<HTML
><HEAD
><TITLE
>Iterated least squares</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><LINK
REL="HOME"
TITLE="Gretl Manual"
HREF="index.html"><LINK
REL="UP"
TITLE="Loop constructs"
HREF="c1320.html"><LINK
REL="PREVIOUS"
TITLE="Loop constructs"
HREF="c1320.html"><LINK
REL="NEXT"
TITLE="Indexed loop"
HREF="x1405.html"></HEAD
><BODY
CLASS="sect1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Gretl Manual: Gnu Regression, Econometrics and Time-series
      Library</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="c1320.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 8. Loop constructs</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x1405.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="ils"
></A
>Iterated least squares</H1
><P
>A second form of loop structure is designed primarily for
      carrying out iterated least squares.  Greene (2000, ch. 11)
      shows how this method can be used to estimate nonlinear
      models.</P
><P
>To open this sort of loop you need to specify a
      <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>condition</I
></SPAN
> rather than an unconditional
      number of times to iterate.  This should take the form of the
      keyword <TT
CLASS="command"
>while</TT
> followed by an inequality: the
      left-hand term should be the name of a variable that is already
      defined; the right-hand side may be either a numerical constant
      or the name of another predefined variable.  For example,</P
><P
>&#13;      <TT
CLASS="command"
> loop while essdiff &#62; .00001 
      </TT
>
    </P
><P
>Execution of the commands within the loop (i.e. until
      <TT
CLASS="command"
>endloop</TT
> is encountered) will continue so long
      as the specified condition evaluates as true.</P
><P
>I assume that if you specify a <SPAN
CLASS="QUOTE"
>"number of
	times"</SPAN
> loop you are probably doing a Monte Carlo
      analysis, and hence you're not interested in the results from
      each individual iteration but rather the moments of certain
      variables over the ensemble of iterations.  On the other hand,
      if you specify a <SPAN
CLASS="QUOTE"
>"while"</SPAN
> loop you're probably doing
      something like iterated least squares, and so you'd like to see
      the final result &#8212; as well, perhaps, as the value of some
      variable(s) (e.g. the error sum of squares from a regression)
      from each time round the loop. The behavior of the
      <TT
CLASS="command"
>print</TT
> and <TT
CLASS="command"
>ols</TT
> commands are
      tailored to this assumption.  In a <SPAN
CLASS="QUOTE"
>"while"</SPAN
> loop
      <TT
CLASS="command"
>print</TT
> behaves as usual; thus you get a
      printout of the specified variable(s) from each iteration.  The
      <TT
CLASS="command"
>ols</TT
> command prints out the results from the
      final estimation.
    </P
><P
><A
HREF="x1364.html#greene-consump"
>Example 8-2</A
> uses a <SPAN
CLASS="QUOTE"
>"while"</SPAN
>
      loop to replicate the estimation of a nonlinear consumption
      function of the form 
	<SPAN
CLASS="inlinemediaobject"
><IMG
SRC="figures/greeneC.png"
ALIGN="center"></SPAN
>
	as presented in Greene (2000, Example 11.3).  This
      script is included in the <TT
CLASS="application"
>gretl</TT
>
      distribution under the name <TT
CLASS="filename"
>greene11_3.inp</TT
>;
      you can find it in <TT
CLASS="application"
>gretl</TT
> under the
      menu item <SPAN
CLASS="QUOTE"
>"File, Open command file, practice file,
	Greene..."</SPAN
>.</P
><DIV
CLASS="example"
><A
NAME="greene-consump"
></A
><P
><B
>Example 8-2. Nonlinear consumption function</B
></P
><PRE
CLASS="programlisting"
>&#13;	open greene11_3.gdt 
	# run initial OLS
	ols C 0 Y 
	genr essbak = $ess 
	genr essdiff = 1
	genr b0 = coeff(Y) 
	genr gamma0 = 1 
	# form the linearized variables 
	genr C0 = C + gamma0 * b0 * Y^gamma0 * log(Y) 
	genr x1 = Y^gamma0 
	genr x2 = b0 * Y^gamma0 * log(Y) 
	# iterate OLS till the error sum of squares converges 
	loop while essdiff &#62; .00001 
	   ols C0 0 x1 x2 -o 
	   genr b0 = coeff(x1) 
	   genr gamma0 = coeff(x2) 
	   genr C0 = C + gamma0 * b0 * Y^gamma0 * log(Y) 
	   genr x1 = Y^gamma0 genr x2 = b0 * Y^gamma0 * log(Y) 
	   genr ess = $ess genr
	   essdiff = abs(ess - essbak)/essbak 
	   genr essbak = ess 
	endloop 
	# print parameter estimates using their "proper names"
	noecho
	printf "alpha = %g\n", coeff(0)
	printf "beta  = %g\n", coeff(x1)
	printf "gamma = %g\n", coeff(x2)</PRE
></DIV
><P
><A
HREF="x1364.html#jack-arma"
>Example 8-3</A
> (kindly contributed by Riccardo
      <SPAN
CLASS="QUOTE"
>"Jack"</SPAN
> Lucchetti of Ancona University) shows how a
      loop can be used to estimate an ARMA model, exploiting the
      <SPAN
CLASS="QUOTE"
>"outer product of the gradient"</SPAN
> (OPG) regression
      discussed by Davidson and MacKinnon in their
      <I
CLASS="citetitle"
>Estimation and Inference in
	Econometrics</I
>.</P
><DIV
CLASS="example"
><A
NAME="jack-arma"
></A
><P
><B
>Example 8-3. ARMA 1, 1</B
></P
><PRE
CLASS="programlisting"
>&#13;	open arma.gdt

	genr c = 0
	genr a = 0.1
	genr m = 0.1

	genr e = const * 0.0
	genr de_c = e
	genr de_a = e
	genr de_m = e

	genr crit = 1
	loop while crit &#62; 1.0e-9

	   # one-step forecast errors
	   genr e = y - c - a*y(-1) - m*e(-1)  

	   # log-likelihood 
	   genr loglik = -0.5 * sum(e^2)
	   print loglik

	   # partials of forecast errors wrt c, a, and m
	   genr de_c = -1 - m * de_c(-1) 
	   genr de_a = -y(-1) -m * de_a(-1)
	   genr de_m = -e(-1) -m * de_m(-1)
   
	   # partials of l wrt c, a and m
	   genr sc_c = -de_c * e
	   genr sc_a = -de_a * e
	   genr sc_m = -de_m * e
   
	   # OPG regression
	   ols const sc_c sc_a sc_m

	   # Update the parameters
	   genr dc = coeff(sc_c) 
	   genr c = c + dc
	   genr da = coeff(sc_a) 
	   genr a = a + da
	   genr dm = coeff(sc_m) 
	   genr m = m + dm

	   printf "  constant        = %.8g (gradient = %#.6g)\n", c, dc
	   printf "  ar1 coefficient = %.8g (gradient = %#.6g)\n", a, da
	   printf "  ma1 coefficient = %.8g (gradient = %#.6g)\n", m, dm

	   genr crit = $T - $ess
	   print crit
	endloop

	genr se_c = stderr(sc_c)
	genr se_a = stderr(sc_a)
	genr se_m = stderr(sc_m)

	noecho
	print "
	printf "constant = %.8g (se = %#.6g, t = %.4f)\n", c, se_c, c/se_c
	printf "ar1 term = %.8g (se = %#.6g, t = %.4f)\n", a, se_a, a/se_a
	printf "ma1 term = %.8g (se = %#.6g, t = %.4f)\n", m, se_m, m/se_m
      </PRE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="c1320.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x1405.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Loop constructs</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c1320.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Indexed loop</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>