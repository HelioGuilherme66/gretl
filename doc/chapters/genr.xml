<?PSGML NOFILL programlisting example inlineequation informalequation?>


  <chapter id="chap-genr">
  <title>Special functions in genr</title>

  <sect1 id="genr-intro"><title>Introduction</title>

    <para>The <literal>genr</literal> command provides a flexible means of
      defining new variables.  It is documented in the <citetitle>Gretl Command
	Reference</citetitle>.  This chapter offers a more expansive discussion
      of some of the special functions available via <literal>genr</literal> and
      some of the finer points of the command.
    </para>

  </sect1>

  <sect1 id="genr-filter"><title>Time-series filters</title>

    <para>One sort of specialized function in <literal>genr</literal> is the
      time-series filter.  Two such filters are currently available, the
      Hodrick&ndash;Prescott filter and the Baxter&ndash;King bandpass filter. These
      are accessed using <literal>hpfilt()</literal> and <literal>bkfilt()</literal>
      respectively: in each case the function takes one argument, the name of the
      variable to be processed.
    </para>

    <sect2 id="hodrick-prescott"><title>The Hodrick&ndash;Prescott filter</title>

      <para>To be written.</para>

    </sect2>

    <sect2 id="baxter-king"><title>The Baxter and King filter</title>

      <para>Consider the spectral representation of a time series &yt;:
	<informalequation><alt role="tex">
	    \[ y_t = \int_{-\pi}^{\pi} e^{i\omega} \mathrm{d} Z(\omega) \]
	  </alt><graphic fileref="figures/bk1"/>
	</informalequation> if we wanted to extract only that component of
	&yt; that lies between the
	frequencies 
        <inlineequation>
	  <alt role="tex">$\underline{\omega}$</alt>
	  <inlinemediaobject>
	    <imageobject>
	      <imagedata align="center" fileref="figures/bk1a"/>
	    </imageobject>
	  </inlinemediaobject>
	</inlineequation> and
        <inlineequation>
	  <alt role="tex">$\overline{\omega}$</alt>
	  <inlinemediaobject>
	    <imageobject>
	      <imagedata align="center" fileref="figures/bk1b"/>
	    </imageobject>
	  </inlinemediaobject>
	</inlineequation> one could apply a bandpass filter:
	<informalequation><alt role="tex">
	    \[ c^*_t = \int_{-\pi}^{\pi} F^*(\omega) e^{i\omega} \mathrm{d}
	    Z(\omega) \]
	  </alt><graphic fileref="figures/bk2"/>
	</informalequation> where 
        <inlineequation>
	  <alt role="tex">$F^*(\omega) = 1$</alt>
	  <inlinemediaobject>
	    <imageobject>
	      <imagedata align="center" fileref="figures/bk2a"/>
	    </imageobject>
	  </inlinemediaobject>
	</inlineequation> for
        <inlineequation>
	  <alt role="tex">$\underline{\omega} &lt; |\omega| &lt; \overline{\omega}$</alt>
	  <inlinemediaobject>
	    <imageobject>
	      <imagedata align="center" fileref="figures/bk2b"/>
	    </imageobject>
	  </inlinemediaobject>
	</inlineequation> and 0 elsewhere. This would imply, in the time domain,
	applying to the series a filter with an infinite number of coefficients,
	which is undesirable. The Baxter and King bandpass filter applies to
	<mathvar>y<subscript>t</subscript></mathvar> a finite polynomial in the
	lag operator <mathvar>A</mathvar>(<mathvar>L</mathvar>):
	<informalequation><alt role="tex">
	    \[ c_t = A(L) y_t \]
	  </alt><graphic fileref="figures/bk3"/>
	</informalequation> where <mathvar>A</mathvar>(<mathvar>L</mathvar>) is
	defined as
	<informalequation><alt role="tex">
	    \[ A(L) = \sum_{i=-k}^{k} a_i L^i \]
	  </alt><graphic fileref="figures/bk4"/>
	</informalequation> The coefficients
	<mathvar>a<subscript>i</subscript></mathvar> are chosen such that
        <inlineequation>
	  <alt role="tex">$F(\omega) = A(e^{i\omega})A(e^{-i\omega})$</alt>
	  <inlinemediaobject>
	    <imageobject>
	      <imagedata align="center" fileref="figures/bk4a"/>
	    </imageobject>
	  </inlinemediaobject>
	</inlineequation> is the best approximation to
        <inlineequation>
	  <alt role="tex">$F^*(\omega)$</alt>
	  <inlinemediaobject>
	    <imageobject>
	      <imagedata align="center" fileref="figures/bk4"/>
	    </imageobject>
	  </inlinemediaobject>
	</inlineequation> for a given <mathvar>k</mathvar>. Clearly, the higher
	<mathvar>k</mathvar> the better the approximation is, but since
	2<mathvar>k</mathvar> observations have to be discarded, a compromise is
	usually sought. Moreover, the filter has also other appealing theoretical
	properties, among which the property that <mathvar>A</mathvar>(1) = 0, so
	a series with a single unit root is made stationary by application of the
	filter.</para>

      <para>In practice, the filter is normally used with monthly or quarterly data
	to extract the <quote>business cycle</quote> component, namely the component
	between 6 and 36 quarters. Usual choices for <mathvar>k</mathvar> are 8 or
	12 (maybe higher for monthly series).
      </para>

      <para>The default values for the frequency bounds are 8 and 32, and the
	default value for the approximation order, <mathvar>k</mathvar>, is 8. You
	can adjust these values using the <command>set</command> command. The
	keyword for setting the frequency limits is <literal>bkbp_limits</literal>
	and the keyword for <mathvar>k</mathvar> is <literal>bkbp_k</literal>.
	Thus for example if you were using monthly data and wanted to adjust the
	frequency bounds to 18 and 96, and <mathvar>k</mathvar> to 24, you could
	do</para>

      <programlisting>
	set bkbp_limits 18 96
	set bkbp_k 24</programlisting>

      <para>These values would then remain in force for calls to the
	<literal>bkfilt</literal> function until changed by a further use of
	<literal>set</literal>. 
      </para>

    </sect2>

  </sect1>

  <sect1 id="genr-resample"><title>Resampling and bootstrapping</title>

    <para>Another specialized function is the resampling, with replacement, of a
      series.  To be written.
    </para>

  </sect1>

  <sect1 id="genr-missing"><title>Handling missing values</title>

    <para>Four special functions are available for the handling of missing values.
      The boolean function <literal>missing()</literal> takes the name of a variable
      as its single argument; it returns a series with value 1 for each observation
      at which the given variable has a missing value, and value 0 otherwise (that
      is, if the given variable has a valid value at that observation).  The
      function <literal>ok()</literal> is complementary to
      <literal>missing</literal>; it is just a shorthand for
      <literal>!missing</literal> (where <literal>!</literal> is the boolean NOT
      operator).
    </para>

    <para>For example, one can count the missing values for variable
      <literal>x</literal> using</para>

      <programlisting>
      genr nmiss_x = sum(missing(x))</programlisting>

    <para>The function <literal>zeromiss()</literal>, which again takes a single
      series as its argument, returns a series where all zero values are set to the
      missing code.  This should be used with caution &mdash; one does not want to
      confuse missing values and zeros &mdash; but it can be useful in some
      contexts.  For example, one can determine the first valid observation for a
      variable <literal>x</literal> using</para>

      <programlisting>
      genr time
      genr x0 = min(zeromiss(time * ok(x)))</programlisting>

    <para>
      The function <literal>misszero()</literal> does the opposite of
      <literal>zeromiss</literal>, that is, it converts all missing values to zero.
    </para>

    <para>It may be worth commenting on the propagation of missing values within
      <literal>genr</literal> formulae.  The general rule is that in arithmetical
      operations involving two variables, if either of the variables has a missing
      value at observation <mathvar>t</mathvar> then the resulting series will
      also have a missing value at <mathvar>t</mathvar>.  The one exception to
      this rule is multiplication by zero: zero times a missing value produces zero
      (since this is mathematically valid regardless of the unknown value).
    </para>

  </sect1>

  <sect1 id="genr-internal"><title>Retrieving internal variables</title>
    
    <para>The <literal>genr</literal> command provides a means of retrieving
      various values calculated by the program in the course of estimating
      models or testing hypotheses.  The variables that can be retrieved in this
      way are listed in the <citetitle>Gretl Command Reference</citetitle>
      reference; here we say a bit more about the special variables
      <literal>$test</literal> and <literal>$pvalue</literal>.</para>

    <para>These variables hold, respectively, the value of the last test statistic
      calculated using an explicit testing command and the p-value for that test
      statistic.  If no such test has been performed at the time when these
      variables are referenced, they will produce the missing value code.  The
      <quote>explicit testing commands</quote> that work in this way are as follows:
      <command>add</command> (joint test for the significance of variables added
      to a model); 
      <command>adf</command> (Augmented Dickey&ndash;Fuller test, see below);
      <command>arch</command> (test for ARCH);
      <command>chow</command> (Chow test for a structural break);
      <command>coeffsum</command> (test for the sum of specified coefficients);
      <command>cusum</command> (the Harvey&ndash;Collier
      <mathvar>t</mathvar>-statistic);
      <command>kpss</command> (KPSS stationarity test, no p-value available);
      <command>lmtest</command> (see below);
      <command>meantest</command> (test for difference of means);
      <command>omit</command> (joint test for the significance of variables
      omitted from a model);
      <command>reset</command> (Ramsey's RESET);
      <command>restrict</command> (general linear restriction);
      <command>runs</command> (runs test for randomness); 
      <command>testuhat</command> (test for normality of residual); and
      <command>vartest</command> (test for difference of variances). In most
      cases both a <literal>$test</literal> and a <literal>$pvalue</literal> are
      stored; the exception is the KPSS test, for which a p-value is not currently
      available.  
    </para>

    <para>
      An important point to notice about this mechanism is that the internal
      variables <literal>$test</literal> and <literal>$pvalue</literal> are
      over-written each time one of the tests listed above is performed.  If you
      want to reference these values, you must do so at the correct point in the
      sequence of <application>gretl</application> commands.</para>

    <para>
      A related point is that some of the test commands generate, by default, more
      than one test statistic and p-value; in these cases only the last values are
      stored. To get proper control over the retrieval of values via
      <literal>$test</literal> and <literal>$pvalue</literal> you should formulate
      the test command in such a way that the result is unambiguous.  This comment
      applies in particular to the <literal>adf</literal> and
      <literal>lmtest</literal> commands.</para>

    <itemizedlist>
      <listitem>
	<para>By default, the <command>adf</command> command generates three
	  variants of the Dickey&ndash;Fuller test: one based on a regression
	  including a constant, one using a constant and linear trend, and one using
	  a constant and a quadratic trend.  When you wish to reference
	  <literal>$test</literal> or <literal>$pvalue</literal> in connection with
	  this command, you can control the variant that is recorded by using one of
	  the flags <literal>--nc</literal>, <literal>--c</literal>,
	  <literal>--ct</literal> or <literal>--ctt</literal> with
	  <literal>adf</literal>.
	</para>
      </listitem>
      <listitem>
	<para>By default, the <command>lmtest</command> command (which must
	  follow an OLS regression) performs several diagnostic tests on the
	  regression in question.  To control what is recorded in
	  <literal>$test</literal> and <literal>$pvalue</literal> you should limit
	  the test using one of the flags <literal>--logs</literal>,
	  <literal>--autocorr</literal>, <literal>--squares</literal> or
	  <literal>--white</literal>.
	</para>
      </listitem>
    </itemizedlist>

    <para>As an aid in working with values retrieved using <literal>$test</literal>
      and <literal>$pvalue</literal>, the nature of the test to which these values
      relate is written into the descriptive label for the generated variable.  You
      can read the label for the variable using the <command>label</command>
      command (with just one argument, the name of the variable), to check that you
      have retrieved the right value.  The following interactive session illustrates
      this point.</para>

    <programlisting>
      ? adf 4 x1 --c

      Augmented Dickey-Fuller tests, order 4, for x1
      sample size 59
      unit-root null hypothesis: a = 1

        test with constant
        model: (1 - L)y = b0 + (a-1)*y(-1) + ... + e
        estimated value of (a - 1): -0.216889
        test statistic: t = -1.83491
        asymptotic p-value 0.3638

      P-values based on MacKinnon (JAE, 1996)
      ? genr pv = $pvalue
      Generated scalar pv (ID 13) = 0.363844
      ? label pv    
      pv=Dickey-Fuller pvalue (scalar)</programlisting>
    

  </sect1>

  </chapter>


<!-- Keep this comment at the end of the file
Local variables:
sgml-default-dtd-file:"../manual.ced"
mode: xml
sgml-parent-document:("../manual.xml" "book" "chapter")
End:
-->

