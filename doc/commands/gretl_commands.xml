<?xml version="1.0"?>
<!DOCTYPE commandlist SYSTEM "gretl_commands.dtd">

<commandlist language="english">

<?PSGML NOFILL label code altforms altform menu-path equation other-access?>

  <command name="add" section="Tests" label="Add variables to model">

    <usage>
      <arguments>
        <argument>varlist</argument>
      </arguments>
      <options>
	<option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>don't print estimates for augmented model</effect>
	</option>
	<option>
	  <flag>--silent</flag>
	  <effect>don't print anything</effect>
	</option>
	<option>
	  <flag>--inst</flag>
	  <effect>add as instrument, TSLS only</effect>
	</option>
	<option>
	  <flag>--both</flag>
	  <effect>add as both regressor and instrument, TSLS only</effect>
	</option>
      </options>
      <examples>
        <example>add 5 7 9</example>
        <example>add xx yy zz --quiet</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
	Must be invoked after an estimation command.  The variables in
	<repl>varlist</repl> are added to the previous model and the
	new model is estimated. A test statistic for the joint
	significance of the added variables is printed, along with its
	p-value. The test statistic is <math>F</math> in the
	case of OLS estimation, an asymptotic Wald chi-square value
	otherwise. A p-value below 0.05 means that the coefficients
	are jointly significant at the 5 percent level.
      </para>
      <para context="cli">
	If the <lit>--quiet</lit> option is given the printed results
	are confined to the test for the joint significance of the
	added variables, otherwise the estimates for the augmented
	model are also printed.  In the latter case, the
	<lit>--vcv</lit> flag causes the covariance matrix for the
	coefficients to be printed also.  If the <lit>--silent</lit>
	option is given, nothing is printed; nonetheless, the results
	of the test can be retrieved using the special variables
        <lit>$test</lit> and <lit>$pvalue</lit>.
      </para>
      <para context="cli">
	If the original model was estimated using two-stage least squares, an
	ambiguity arises: should the new variables be added as regressors, as
	instruments, or as both?  This is resolved as follows: by default the
	new variables are added as endogenous regressors, but if the
	<lit>--inst</lit> flag is given they are added as instruments, or
	if the <lit>--both</lit> flag is given they are added as exogenous
	regressors.
      </para>
      <para context="gui">
	The selected variables are added to the previous model and the
	new model estimated. A test statistic for the joint
	significance of the added variables is printed, along with its
	p-value. The test statistic is <math>F</math> in the
	case of OLS estimation, an asymptotic Wald chi-square value
	otherwise. A p-value below 0.05 means that the coefficients
	are jointly significant at the 5 percent level.
      </para>
    </description>

    <gui-access>
      <menu-path>Model window, /Tests/Add variables</menu-path>
    </gui-access>

  </command>

  <command name="adf" section="Tests" label="Augmented Dickey-Fuller test">

    <usage>
      <arguments>
        <argument>order</argument>
        <argument>varlist</argument>
      </arguments>
      <options>
	<option>
	  <flag>--nc</flag>
	  <effect>test without a constant</effect>
	</option>
	<option>
	  <flag>--c</flag>
	  <effect>with constant only</effect>
	</option>
	<option>
	  <flag>--ct</flag>
	  <effect>with constant and trend</effect>
	</option>
	<option>
	  <flag>--ctt</flag>
	  <effect>with constant, trend and trend squared</effect>
	</option>
	<option>
	  <flag>--seasonals</flag>
	  <effect>include seasonal dummy variables</effect>
	</option>
	<option>
	  <flag>--gls</flag>
	  <effect>de-mean or de-trend using GLS</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>print regression results</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>suppress printing of results</effect>
	</option>
	<option>
	  <flag>--difference</flag>
	  <effect>use first difference of variable</effect>
	</option>
	<option>
	  <flag>--test-down</flag>
	  <effect>automatic lag order</effect>
	</option>
      </options>
      <examples>
	<example>adf 0 y</example>
        <example>adf 2 y --nc --c --ct</example>
        <example>adf 12 y --c --test-down</example>
	<demos>
	  <demo>jgm-1996.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para context="gui">
	This command needs an integer lag order; if the order is zero a
	standard (not augmented) Dickey&ndash;Fuller test is run. Computes
	a set of Dickey&ndash;Fuller tests on the selected variable, the
	null hypothesis being that the variable has a unit root.  (But if
	the differencing option is selected, the first difference of the
	variable is taken prior to testing, and the discussion below must
	be taken as referring to the transformed variable.)	
      </para>

      <para context="cli">
	Computes a set of Dickey&ndash;Fuller tests on each of the the
	listed variables, the null hypothesis being that the variable in
	question has a unit root.  (But if the <lit>--difference</lit>
	flag is given, the first difference of the variable is taken prior
	to testing, and the discussion below must be taken as referring to
	the transformed variable.)
      </para>

      <para context="cli">
	By default, two variants of the test are shown: one based on a
	regression containing a constant and one using a constant and
	linear trend.  You can control the variants that are presented by
	specifying one or more of the option flags.
      </para>

      <para>In all cases the dependent variable is the first
	difference of the specified variable, <math>y</math>,
	and the key independent variable is the first lag of
	<math>y</math>.  The model is constructed so that the
	coefficient on lagged <math>y</math> equals 1 minus the
	root in question.  For example, the model with a constant may
	be written as <equation status="display"
	tex="\[(1-L)y_t=\beta_0+(\alpha-1)y_{t-1}+\epsilon_t\]"
	ascii="(1 - L)y(t) = b0 + (a-1)y(t-1) + e(t)"
	  graphic="adf1"/></para>

      <para context="cli">
	If the lag order, <math>k</math>, is greater than 0, then
	<math>k</math> lags of the dependent variable are included
	on the right-hand side of the test regressions, subject to the
	following qualification.  If the <lit>--test-down</lit> option is
	given, <math>k</math> is taken as the maximum lag
	and the actual lag order used is obtained by testing down, using
	this algorithm:
      </para>

      <para context="gui">
	If the lag order, <math>k</math>, is greater than 0, then
	<math>k</math> lags of the dependent variable are included
	on the right-hand side of the test regressions, subject to the
	following qualification. If the box labeled <quote>test down from
	  maximum lag</quote> is checked, the selected lag order is taken
	as a maximum and the actual lag order used is obtained by testing
	down, using this algorithm:
      </para>

      <nlist>
	<li><para>Estimate the Dickey&ndash;Fuller regression with
	    <math>k</math> lags of the dependent variable.
	  </para>
	</li>
	<li><para>Is the last lag significant?  If so, execute the
	    test with lag order <math>k</math>.  Otherwise, let
	    <math>k</math> = <math>k</math> &minus; 1; if
	    <math>k</math> equals 0, execute the test with lag order
	    0, else go to step 1.
	  </para>
	</li>
      </nlist>

      <para>In the context of step 2 above, <quote>significant</quote>
	means that the <math>t</math>-statistic for the last lag
	has an asymptotic two-sided <emphasis>p</emphasis>-value,
	against the normal distribution, of 0.10 or less.</para> 

      <para context="cli">
	The <lit>--gls</lit> option can be used in conjunction with one
	or other of the flags <lit>--c</lit> and <lit>--ct</lit> (the model
	with constant, or model with constant and trend).  The effect of
	this option is that the de-meaning or de-trending of the variable
	to be tested is done using the GLS procedure suggested by Elliott,
	Rothenberg and Stock (1996), which gives a test of greater
	power than the standard Dickey&ndash;Fuller approach.  This option
	is not compatible with <lit>--nc</lit>, <lit>--ctt</lit> or
	<lit>--seasonals</lit>.
      </para>

      <para><emphasis>P</emphasis>-values for the Dickey&ndash;Fuller
	tests are based on MacKinnon (1996).  The relevant code is
	included by kind permission of the author.  In the case of the
	test with linear trend using GLS these
	<emphasis>P</emphasis>-values are not applicable; critical values
	from Table 1 in Elliott, Rothenberg and Stock (1996) are shown
	instead.
      </para>

    </description>

    <gui-access>
      <menu-path>/Variable/Augmented Dickey-Fuller test</menu-path>
    </gui-access>

  </command>

  <command name="append" section="Dataset" 
    label="Append data" context="cli">

    <usage>
      <arguments>
        <argument>datafile</argument>
      </arguments>
      <options>
	<option>
	  <flag>--time-series</flag>
	  <effect>see below</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Opens a data file and appends the content to the current
	dataset, if the new data are compatible.  The program will try
	to detect the format of the data file (native, plain text, CSV,
	Gnumeric, Excel, etc.). 
      </para>
      <para>
	The appended data may take the form of either additional observations
	on variables already present in the dataset, or new variables.
	in the case of adding variables, compatibility requires either
	(a) that the number of observations for the new data equals that
	for the current data, or (b) that the new data carries clear
	observation information so that gretl can work out how to place the
	values.  
      </para>
      <para>
	A special feature is supported for appending to a panel dataset. Let
	<math>n</math> denote the number of cross-sectional units in the panel,
	<math>T</math> denote the number of time periods, and <math>m</math>
	denote the number of observations for the new data. If <math>m =
	  n</math> the new data are taken to be time-invariant, and are copied
	into place for each time period. On the other hand, if <math>m =
	  T</math> the data are treated as non-varying across the panel units,
	and are copied into place for each unit. If the panel is
	<quote>square</quote>, and <math>m</math> equals both <math>n</math>
	and <math>T</math>, an ambiguity arises. The default in this case is
	to treat the new data as time-invariant, but you can force gretl to
	treat the new data as time series via the <lit>--time-series</lit>
	option.  (This option is ignored in all other cases.)
      </para>

    </description>

    <gui-access>
      <menu-path>/File/Append data</menu-path>
    </gui-access>

  </command>

  <command name="ar" section="Estimation" label="Autoregressive estimation">

    <usage>
      <arguments>
        <argument>lags</argument>
	<argument separated="true">depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
	</option>
      </options>
      <examples>
        <example>ar 1 3 4 ; y 0 x1 x2 x3</example>
      </examples>
    </usage>

    <description>
      <para>
	Computes parameter estimates using the generalized
	Cochrane&ndash;Orcutt iterative procedure (see Section 9.5 of
	Ramanathan, 2002). Iteration is terminated when successive error
	sums of squares do not differ by more than 0.005 percent or
	after 20 iterations.</para>

      <para context="gui">
	The <quote>list of AR lags</quote> specifies the structure of
	the error process.  For example, the entry <quote>1 3
	  4</quote> corresponds to the process: 
	<equation status="display" 
	  tex="\[u_t = \rho_1u_{t-1} + \rho_3 u_{t-3} +
	    \rho_4 u_{t-4} + e_t\]"
	  ascii="u(t) = rho1*u(t-1) + rho3*u(t-3) + rho4*u(t-4)"
	  graphic="arlags"/>
      </para>

      <para context="cli">
	<repl quote="true">lags</repl> is a list of lags in the
	residuals, terminated by a semicolon. In the above example,
	the error term is specified as 
	<equation status="display" 
	  tex="\[u_t = \rho_1u_{t-1} + \rho_3 u_{t-3} +
	    \rho_4 u_{t-4} + e_t\]"
	  ascii="u(t) = rho(1)*u(t-1) + rho(3)*u(t-3) + rho(4)*u(t-4)"
	  graphic="arlags"/>
      </para>

    </description>

    <gui-access>
      <menu-path>/Model/Time series/Autoregressive estimation</menu-path>
    </gui-access>

  </command>

  <command name="ar1" section="Estimation" label="AR(1) estimation">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--hilu</flag>
	  <effect>use Hildreth&ndash;Lu procedure</effect>
	</option>
	<option>
	  <flag>--pwe</flag>
	  <effect>use Prais&ndash;Winsten estimator</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
	</option>
	<option>
	  <flag>--no-corc</flag>
	  <effect>do not fine-tune results with Cochrane-Orcutt</effect>
	</option>
      </options>
      <examples>
        <example>ar1 1 0 2 4 6 7</example>
	<example>ar1 y 0 xlist --hilu --no-corc</example>
	<example>ar1 y 0 xlist --pwe</example>
      </examples>
    </usage>

    <description>
      <para>
	Computes feasible GLS estimates for a model in which the error term is
	assumed to follow a first-order autoregressive process.
      </para>
      <para>
	The default method is the Cochrane&ndash;Orcutt iterative procedure
	(see, for example, Section 9.4 of Ramanathan, 2002). Iteration is
	terminated when successive estimates of the autocorrelation
	coefficient do not differ by more than 0.001 or after 20 iterations.
      </para>
      <para>
	If the <lit>--hilu</lit> option is given, the Hildreth&ndash;Lu search
	procedure is used.  The results are then fine-tuned using the
	Cochrane&ndash;Orcutt method, unless the <lit>--no-corc</lit> flag is
	specified.  (The latter option is ignored if <lit>--hilu</lit>
	is not specified.)
      </para>
      <para>
	If the <lit>--pwe</lit> option is given, the Prais&ndash;Winsten
	estimator is used.  This involves an an iteration similar to
	Cochrane&ndash;Orcutt; the difference is that while
	Cochrane&ndash;Orcutt discards the first observation,
	Prais&ndash;Winsten makes use of it. See, for example, Chapter 13 of
	Greene's <book>Econometric Analysis</book> (2000) for details.
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Time series/Cochrane-Orcutt</menu-path>
      <menu-path>/Model/Time series/Hildreth-Lu</menu-path>
      <menu-path>/Model/Time series/Prais-Winsten</menu-path>
    </gui-access>

  </command>

  <command name="arbond" section="Estimation" label="Dynamic panel models">

    <usage>
      <arguments>
	<argblock>
	  <argument>p</argument>
	  <argument optional="true">q</argument>
	</argblock>
	<argblock separated="true">
	  <argument>depvar</argument>
	  <argument>indepvars</argument>
	</argblock>
	<argblock optional="true" separated="true">
	  <argument>instruments</argument>
	</argblock>
      </arguments>
      <options>
	<option>
	  <flag>--quiet</flag>
	  <effect>don't show estimated model</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
	</option>
        <option>
	  <flag>--two-step</flag>
	  <effect>perform 2-step GMM estimation</effect>
        </option>
        <option>
	  <flag>--time-dummies</flag>
	  <effect>add time dummy variables</effect>
        </option>
        <option>
	  <flag>--asymptotic</flag>
	  <effect>uncorrected asymptotic standard errors</effect>
        </option>
      </options>
      <examples>
        <example>arbond 2 ; y Dx1 Dx2</example>
        <example>arbond 2 5 ; y Dx1 Dx2 ; Dx1</example>
	<example>arbond 1 ; y Dx1 Dx2 ; Dx1 GMM(x2,2,3)</example>
	<demos>
	  <demo>arbond91.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para>
	Carries out estimation of dynamic panel data models (that is,
	panel models including one or more lags of the dependent variable)
	using the GMM method set out by Arellano and Bond (1991).  
      </para>
      <para context="cli">
	The parameter <repl>p</repl> represents the order of the
	autoregression for the dependent variable.  The optional parameter
	<repl>q</repl> indicates the maximum lag of the level of the
	dependent variable to be used as an instrument.  If this argument
	is omitted, or given as 0, all available lags are used.
      </para>
      <para>
	The dependent variable should be given in levels form; it will be
	automatically differenced (since this estimator uses differencing
	to cancel out the individual effects).  The independent variables
	are not automatically differenced; if you want to use differences
	(which will generally be the case for ordinary quantitative
	variables, though perhaps not for, say, time dummy variables) you
	should create the differences first then specify these as the
	regressors. 
      </para>
      <para context="cli">
	The last (optional) field in the command is for specifying
	instruments.  If no instruments are given, it is assumed that all
	the independent variables are strictly exogenous.  If you specify
	any instruments, you should include in the list any strictly
	exogenous independent variables.  For predetermined regressors,
	you can use the <lit>GMM</lit> function to include a specified
	range of lags in block-diagonal fashion.  This is illustrated in
	the third example above.  The first argument to <lit>GMM</lit> is
	the name of the variable in question, the second is the minimum
	lag to be used as an instrument, and the third is the maximum lag.
	If the third argument is given as 0, all available lags are used.
      </para>
      <para context="gui">
	As regards the handling of instruments, please see the
	documentation for the script version of this command.  Currently
	you cannot specify instruments explicitly in the GUI: all the
	independent variables are taken to be strictly exogenous.
      </para>
      <para>
	By default the results of 1-step estimation are reported (with
	robust standard errors).  You may select 2-step estimation as an
	option.  In both cases tests for autocorrelation of orders 1 and 2
	are provided, as well as the Sargan overidentification test and a
	Wald test for the joint significance of the regressors.  Note that
	in this differenced model first-order autocorrelation is not a
	threat to the validity of the model, but second-order
	autocorrelation violates the maintained statistical assumptions.
      </para>
      <para context="cli">
	In the case of 2-step estimation, standard errors are by default
	computed using the finite-sample correction suggested by
	Windmeijer (2005).  The standard asymptotic standard errors
	associated with the 2-step estimator are generally reckoned to be
	an unreliable guide to inference, but if for some reason you want
	to see them you can use the <lit>--asymptotic</lit> option to turn
	off the Windmeijer correction.
      </para>
      <para context="cli">
	If the <lit>--time-dummies</lit> option is given, a set of
	time dummy variables is added to the specified regressors.  
	The number of dummies is one less than the maximum number of
	periods used in estimation, to avoid perfect collinearity with
	the constant.  The dummies are entered in levels; if you wish
	to use time dummies in first-differenced form, you will have
	to define and add these variables manually.
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Panel</menu-path>
    </gui-access>

  </command>

  <command name="arch" section="Estimation" label="ARCH model">

    <usage>
      <arguments>
        <argument>order</argument>
        <argument>depvar</argument>
	<argument>indepvars</argument>
      </arguments>
      <examples>
        <example>arch 4 y 0 x1 x2 x3</example>
      </examples>
    </usage>

    <description>
      <para>
	Estimates the given model specification allowing for ARCH
	(Autoregressive Conditional Heteroskedasticity). The model is
	first estimated via OLS, then an auxiliary regression is run, in
	which the squared residual from the first stage is regressed on
	its own lagged values. The final step is weighted least squares
	estimation, using as weights the reciprocals of the fitted error
	variances from the auxiliary regression.  (If the predicted
	variance of any observation in the auxiliary regression is not
	positive, then the corresponding squared residual is used
	instead).
      </para>
      <para>
	The <lit>alpha</lit> values displayed below the coefficients
	are the estimated parameters of the ARCH process from the
	auxiliary regression.
      </para>
      <para>
	See also <cmdref targ="garch"/> and <cmdref targ="lmtest"/> (the
	<lit>--arch</lit> option).  
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Time series/ARCH</menu-path>
    </gui-access>

  </command>

  <command name="arima" section="Estimation" label="ARMA model">

    <usage>
      <arguments>
	<argblock>
	  <argument>p</argument>
	  <argument>d</argument>
	  <argument>q</argument>
	</argblock>
	<argblock separated="true" optional="true">
	  <argument>P</argument>
	  <argument>D</argument>
	  <argument>Q</argument>
	</argblock>
	<argument separated="true">depvar</argument>
	<argument optional="true">indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--verbose</flag>
	  <effect>print details of iterations</effect>
        </option>
        <option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
        </option>
        <option>
	  <flag>--opg</flag>
	  <effect>see below</effect>
        </option>
        <option>
	  <flag>--nc</flag>
	  <effect>do not include a constant</effect>
        </option>
        <option>
	  <flag>--conditional</flag>
	  <effect>use conditional maximum likelihood</effect>
        </option>
        <option>
	  <flag>--x-12-arima</flag>
	  <effect>use X-12-ARIMA for estimation</effect>
        </option>
      </options>
      <examples>
        <example>arima 1 0 2 ; y</example>
	<example>arima 2 0 2 ; y 0 x1 x2 --verbose</example>
	<example>arima 0 1 1 ; 0 1 1 ; y --nc</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
	If no <repl>indepvars</repl> list is given, estimates a univariate
	ARIMA (Autoregressive, Integrated, Moving Average) model.  The
	values <repl>p</repl>, <repl>d</repl> and <repl>q</repl>
	represent the autoregressive (AR) order, the differencing order,
	and the moving average (MA) order respectively.  These values may be
	given in numerical form, or as the names of pre-existing scalar
	variables.  A <repl>d</repl> value of 1, for instance, means that
	the first difference of the dependent variable should be taken before
	estimating the ARMA parameters.
      </para>

      <para context="cli">
	If you wish to include only specific AR or MA lags in the model
	(as opposed to all lags up to a given order) you can substitute
	for <repl>p</repl> and/or <repl>q</repl> either (a) the name of a
	pre-defined matrix containing a set of integer values or (b) an
	expression such as <lit>{1 4}</lit>; that is, a set of lags
	separated by spaces and enclosed in braces.
      </para>

      <para context="cli">
	The optional integer values <repl>P</repl>, <repl>D</repl> and
	<repl>Q</repl> represent the seasonal AR, order for seasonal
	differencing and seasonal MA order respectively.  These are
	applicable only if the data have a frequency greater than 1 (for
	example, quarterly or monthly data).  These orders must be
	given in numerical form or as scalar variables.
      </para>

      <para context="cli">
	In the univariate case the default is to include an intercept
	in the model but this can be suppressed with the
	<lit>--nc</lit> flag.  If <repl>indepvars</repl> are added,
	the model becomes ARMAX; in this case the constant should be
	included explicitly if you want an intercept (as in the second
	example above).
      </para>

      <para context="cli">
	An alternative form of syntax is available for this command: if
	you do not want to apply differencing (either seasonal or
	non-seasonal), you may omit the <repl>d</repl> and <repl>D</repl>
	fields altogether, rather than explicitly entering 0.  In
	addition, <lit>arma</lit> is a synonym or alias for
	<lit>arima</lit>.  Thus for example the following command is a
	valid way to specify an ARMA(2, 1) model:
      </para>
      <code context="cli">
	arma 2 1 ; y
      </code>

      <para context="gui">
	Estimates an ARMA model, with or without exogenous regressors. If
	the order of differencing is greater than zero the model becomes
	ARIMA.  If the data have a frequency greater than 1 the option of
	including a seasonal component is presented.
      </para>

      <para context="gui">
	If you wish to include only specified AR or MA lags in the model
	(as opposed to all lags up to a given order) check the box to the
	right of the spinner and type a list of lags, separated by
	spaces, into the entry field.  Alternatively, if you have defined
	a matrix containing the desired set of lags you can type its name
	into the entry field.
      </para>

      <para>
	The default is to use the <quote>native</quote> gretl ARMA
	functionality, with estimation by exact ML using the Kalman
	filter; estimation via conditional ML is available as an option.
	(If <program>X-12-ARIMA</program> is installed you have the option
	of using it instead of native code.)  For details regarding these
	options, please see <guideref
	targ="arma-estimation"/>.
      </para>

      <para context="cli">
	When the native ARMA code is used, estimated standard errors are by
	default based on a numerical approximation to the (negative inverse
	of) the Hessian.  But if the <lit>--opg</lit> option is given they are
	instead based on the Outer Product of the Gradient.  This option is
	ignored if estimation via <program>X-12-ARIMA</program> is selected. 
      </para>

      <para>The AIC value given in connection with ARIMA models is
	calculated according to the definition used in
	<program>X-12-ARIMA</program>, namely
	  <equation status="display" 
	  tex="\[\mbox{AIC}=-2\ell + 2k\]"
	  ascii="AIC = -2L + 2k"
	  graphic="aic"/> where 
	<equation status="inline" 
	  tex="$\ell$" ascii="L"
	  graphic="ell"/> is the
	log-likelihood and <math>k</math> is the total number of
	parameters estimated.  Note that <program>X-12-ARIMA</program>
	does not produce information criteria such as AIC when estimation
	is by conditional ML.
      </para>

      <para>
	The <quote>frequency</quote> figure
	printed in connection with AR and MA roots is the &lgr; value
	that solves
	  <equation status="display" 
	  tex="\[z=re^{i2\pi\lambda}\]"
	  ascii="z = r * exp(i*2*pi*lambda)"
	  graphic="lambda"/> where <math>z</math> is the root in
	question and <math>r</math> is its modulus.
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Time series/ARIMA</menu-path>
      <other-access>Main window pop-up menu (single selection)</other-access>
    </gui-access>

  </command>

  <command name="bootstrap" section="Tests" label="Bootstrap options"
    context="gui">

    <description>

      <para>In this dialog you get to choose:</para>

      <ilist>
	<li>
	  <para>
	    The variable/coefficient to examine.  (You can test only one
	    coefficient at a time using this method.)
	  </para>
	</li>
	<li>
	  <para>
	    The sort of analysis to perform.  The default (95 percent)
	    confidence interval is based directly on the quantiles of the
	    bootstrap coefficient estimates.  The
	    <quote>studentized</quote> version is as per Davidson and
	    MacKinnon's <book>Economic Theory and Methods</book> (ETM),
	    chapter 5: at each bootstrap replication a
	    <math>t</math>-ratio is formed as (a) the difference
	    between the current and the baseline coefficient estimate,
	    divided by (b) the baseline estimated standard error. Then the
	    confidence interval is formed based on the quantiles of this
	    t-ratio, as explained in ETM.  The P-value option is based on
	    the distribution of the bootstrap <math>t</math>-ratio:
	    it is the proportion of the replications where the absolute
	    value of this statistic exceeds the absolute value of the
	    baseline <math>t</math>-ratio. 
	  </para>
	</li>
	<li>
	  <para>Resampled residuals versus simulate normal errors. In the
	    first case the original residuals (rescaled as suggested in
	    ETM) are resampled with replacement.  In the second case
	    pseudo-random normal values are generated with the original
	    residual variance.
	  </para>
	</li>
	<li>
	  <para>The number of replications to perform. Note that when
	    you're constructing a 95 percent confidence interval it is
	    desirable that 0.05(<math>B</math> + 1)/2 is an integer
	    (where <math>B</math> is the number of replications).
	    So gretl may adjust the chosen number of replications to
	    ensure this is the case.
	  </para>
	</li>
	<li>
	  <para>Whether or not to produce a graph of the bootstrap
	    distribution. This option employs gretl's kernel density
	    estimation facility.
	  </para>
	</li>
      </ilist>

    </description>
  </command>

  <command name="boxplot" section="Graphs" label="Boxplots">

    <usage>
      <arguments>
        <argument>varlist</argument>
      </arguments>
      <options>
	<option>
	  <flag>--notches</flag>
	  <effect>show 90 percent interval for median</effect>
	</option>
      </options>
    </usage>

    <description>

      <para>These plots (after Tukey and Chambers) display the
	distribution of a variable. The central box encloses the middle 50
	percent of the data, &ie; it is bounded by the first and third
	quartiles.  The <quote>whiskers</quote> extend to the minimum and
	maximum values.  A line is drawn across the box at the median.  A
	<quote>+</quote> sign indicates the mean.</para>

      <para>In the case of notched boxes, the notch shows the limits
	of an approximate 90 percent confidence interval for the
	median.  This is obtained by the bootstrap method.</para>

      <para context="gui">After each variable specified in the boxplot
	command, a parenthesized Boolean expression may be added, to
	limit the sample for the variable in question.  A space must
	be inserted between the variable name or number and the
	expression. Suppose you have salary figures for men and women,
	and you have a dummy variable <lit>GENDER</lit> with value 1
	for men and 0 for women.  In that case you could draw
	comparative boxplots with the following line in the boxplots
	dialog:</para>

      <para context="cli">After each variable specified in the boxplot
	command, a parenthesized Boolean expression may be added, to
	limit the sample for the variable in question.  A space must
	be inserted between the variable name or number and the
	expression. Suppose you have salary figures for men and women,
	and you have a dummy variable <lit>GENDER</lit> with value 1
	for men and 0 for women.  In that case you could draw
	comparative boxplots with the following <repl
	  quote="true">varlist</repl>:</para>
      <code>
	salary (GENDER=1) salary (GENDER=0)
      </code>

      <para>Some details of gretl's boxplots can be controlled via a
	(plain text) file named <filename>.boxplotrc</filename>.  For
	details on this see <guideref targ="sect-boxplots"/>.</para>

    </description>

    <gui-access>
      <menu-path>/View/Graph specified vars/Boxplots</menu-path>
    </gui-access>

  </command>

  <command name="break" section="Programming" 
    label="Break from loop" context="cli">

    <description>

      <para>Break out of a loop.  This command can be used only within
	a loop; it causes command execution to break out of the
	current (innermost) loop.  See also <cmdref targ="loop"/>.
      </para> 

    </description>

  </command>

  <command name="chow" section="Tests" label="Chow test">

    <usage>
      <arguments>
        <argument>obs</argument>
      </arguments>
      <examples>
        <example>chow 25</example>
        <example>chow 1988:1</example>
      </examples>
    </usage>

    <description>
      <para context="gui">
	This command needs an observation number (or date, with dated
	data).
      </para>

      <para>
	Must follow an OLS regression.  Creates a dummy variable which
	equals 1 from the split point specified by <repl>obs</repl> to
	the end of the sample, 0 otherwise, and also creates
	interaction terms between this dummy and the original
	independent variables.  An augmented regression is run
	including these terms and an <math>F</math> statistic is
	calculated, taking the augmented regression as the
	unrestricted and the original as restricted.  This statistic
	is appropriate for testing the null hypothesis of no
	structural break at the given split point.
      </para>
    </description>

    <gui-access>
      <menu-path>Model window, /Tests/Chow test</menu-path>
    </gui-access>

  </command>

  <command name="coeffsum" section="Tests" label="Sum of coefficients">

    <usage>
      <arguments>
        <argument>varlist</argument>
      </arguments>
      <examples>
        <example>coeffsum xt xt_1 xr_2</example>
	<demos>
	  <demo>restrict.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para context="gui">This command needs a list of variables,
	selected from the set of independent variables in a given
	model.</para>
      <para context="gui">
	Calculates the sum of the coefficients on the variables in the
	specified list.  Prints this sum along with its standard error
	and the p-value for the null hypothesis that the sum is zero.
      </para>
      <para context="cli">
	Must follow a regression.  Calculates the sum of the
	coefficients on the variables in <repl>varlist</repl>.  Prints
	this sum along with its standard error and the p-value for the
	null hypothesis that the sum is zero.  
      </para>
      <para>Note the difference between this and <cmdref
	  targ="omit"/>, which tests the null
	hypothesis that the coefficients on a specified subset of
	independent variables are <emphasis>all</emphasis> equal to
	zero.</para>
    </description>

    <gui-access>
      <menu-path>Model window, /Tests/Sum of coefficients</menu-path>
    </gui-access>

  </command>

  <command name="coint" section="Tests" 
    label="Engle-Granger cointegration test">

    <usage>
      <arguments>
        <argument>order</argument>
        <argument>depvar</argument>
	<argument>indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--nc</flag>
	  <effect>do not include a constant</effect>
	</option>
	<option>
	  <flag>--ct</flag>
	  <effect>include constant and trend</effect>
	</option>
	<option>
	  <flag>--ctt</flag>
	  <effect>include constant and quadratic trend</effect>
	</option>
	<option>
	  <flag>--skip-df</flag>
	  <effect>no DF tests on individual variables</effect>
	</option>
      </options>
      <examples>
	<example>coint 4 y x1 x2</example>
	<example>coint 0 y x1 x2 --ct --skip-df</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
	The Engle&ndash;Granger cointegration test.  The default procedure
	is: (1) carry out Dickey&ndash;Fuller tests on the null
	hypothesis that each of the variables listed has a unit root; (2)
	estimate the cointegrating regression; and (3) run a DF test
	on the residuals from the cointegrating regression.  If the
	<lit>--skip-df</lit> flag is given, step (1) is omitted.
      </para>
      <para context="cli">
	If the specified lag order is positive, all the
	Dickey&ndash;Fuller tests use that order.  If the order is
	prefaced with a minus sign, it is taken as the maximum lag and the
	actual lag order used in each case is obtained by testing down:
	see the <cmdref targ="adf"/> command for details.
      </para>
      <para context="cli">
	By default, the cointegrating regression contains a constant. If
	you wish to suppress the constant, add the <lit>--nc</lit> flag.
	If you wish to augment the list of deterministic terms in the
	cointegrating regression with a linear or quadratic trend, add
	the <lit>--ct</lit> or <lit>--ctt</lit> flag.  These option
	flags are mutually exclusive.
      </para>

      <para context="gui">
	The Engle&ndash;Granger cointegration test.  The default procedure
	is: (1) carry out Dickey&ndash;Fuller tests on the null
	hypothesis that each of the variables listed has a unit root; (2)
	estimate the cointegrating regression; and (3) run a DF test on
	the residuals from the cointegrating regression.  If the box
	labeled <quote>skip initial DF tests</quote> is checked, however,
	the first of these steps is omitted.
      </para>
      <para context="gui">
	If the lag order, <math>k</math>, is greater than 0, then
	<math>k</math> lags of the dependent variable are included
	on the right-hand side of each test regression, unless the box
	labeled <quote>test down from maximum lag</quote> is checked: in
	that case the selected lag order is taken as a maximum and the
	actual lag order used is obtained by testing down.  See the
	<cmdref targ="adf"/> command for details of this procedure.
      </para>
      <para context="gui">
	By default, the cointegrating regression contains a constant. If
	you wish to suppress the constant, or to add a linear or quadratic
	trend, select the appropriate option from the set of radio buttons
	in the Cointegration dialog box.
      </para>

      <para><emphasis>P-</emphasis>values for this test are based on
	MacKinnon (1996).  The relevant code is included by kind
	permission of the author.
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Time series/Cointegration test/Engle-Granger</menu-path>
    </gui-access>

  </command>

  <command name="coint2" section="Tests" label="Johansen cointegration test">

    <usage>
      <arguments>
        <argument>order</argument>
        <argument>ylist</argument>
	<argblock optional="true" separated="true">
	  <argument>xlist</argument>
	</argblock>
	<argblock optional="true" separated="true">
	  <argument>rxlist</argument>
	</argblock>
      </arguments>
      <options>
        <option>
	  <flag>--nc</flag>
	  <effect>no constant</effect>
        </option>
        <option>
	  <flag>--rc</flag>
	  <effect>restricted constant</effect>
        </option>
        <option>
	  <flag>--crt</flag>
	  <effect>constant and restricted trend</effect>
        </option>
        <option>
	  <flag>--ct</flag>
	  <effect>constant and unrestricted trend</effect>
        </option>
        <option>
	  <flag>--seasonals</flag>
	  <effect>include centered seasonal dummies</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>print just the tests</effect>
        </option>
        <option>
	  <flag>--verbose</flag>
	  <effect>print details of auxiliary regressions</effect>
        </option>
      </options>
      <examples>
        <example>coint2 2 y x</example>
	<example>coint2 4 y x1 x2 --verbose</example>
	<example>coint2 3 y x1 x2 --rc</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
	Carries out the Johansen test for cointegration among the
	variables in <repl>ylist</repl> for the given lag order. Critical
	values are computed via J. Doornik's gamma approximation (Doornik,
	1998). For details of this test see Hamilton, <book>Time Series
	  Analysis</book> (1994), Chapter 20.
      </para>

      <para context="gui">
	Carries out the Johansen test for cointegration among the listed
	variables for the selected lag order. Critical values are computed
	via J. Doornik's gamma approximation (Doornik, 1998). For details
	of this test see Hamilton, <book>Time Series Analysis</book>
	(1994), Chapter 20.
      </para>

      <para context="cli">
	The inclusion of deterministic terms in the model is controlled by
	the option flags.  The default if no option is specified is to
	include an <quote>unrestricted constant</quote>, which allows for
	the presence of a non-zero intercept in the cointegrating
	relations as well as a trend in the levels of the endogenous
	variables.  In the literature stemming from the work of Johansen
	(see for example his 1995 book) this is often referred to as
	<quote>case 3</quote>.  The first four options given above, which
	are mutually exclusive, produce cases 1, 2, 4 and 5 respectively.
	The meaning of these cases and the criteria for selecting a case
	are explained in <guideref targ="chap:vecm"/>.
      </para>

      <para context="gui">
	The inclusion of deterministic terms in the model is controlled by
	the drop-down option list.  The default is to include an
	<quote>unrestricted constant</quote>, which allows for the
	presence of a non-zero intercept in the cointegrating relations as
	well as a trend in the levels of the endogenous variables.  In the
	literature stemming from the work of Johansen (see for example his
	1995 book) this is often referred to as <quote>case 3</quote>. The
	other four options produce cases 1, 2, 4 and 5 respectively. The
	meaning of these cases and the criteria for selecting a case are
	explained in <guideref targ="chap:vecm"/>.
      </para>

      <para context="cli">
	The optional lists <repl>xlist</repl> and <repl>rxlist</repl>
	allow you to control for specified exogenous variables: these
	enter the system either unrestrictedly (<repl>xlist</repl>) or
	restricted to the cointegration space (<repl>rxlist</repl>). These
	lists are separated from <repl>ylist</repl> and from each other by
	semicolons.
      </para>

      <para context="gui">
	You may control for exogenous variables by adding them to the
	lower list box.  By default these enter the model in unrestricted
	form (indicated by a <lit>U</lit> next to the name of the
	variable).  If you want a certain exogenous variable to be
	restricted to the cointegrating space, right-click on it and
	select <quote>Restricted</quote> from the pop-up menu.  The symbol
	next to the variable will change to R.
      </para>

      <para context="cli">
	The <lit>--seasonals</lit> option, which may be combined with any of the
	other options, specifies the inclusion of a set of centered seasonal
	dummy variables.  This option is available only for quarterly or monthly
	data.
      </para>

      <para context="gui">
	If the data are quarterly or monthly, a check box is shown that allows
	you to include a set of centered seasonal dummy variables.  In all
	cases, an additional check box (<quote>Show details</quote>) allows
	for the printing of the auxiliary regressions that form the starting
	point of the Johansen maximum likelihood estimation procedure.
      </para>

      <para context="notex">
	The following table is offered as a guide to the
	interpretation of the results shown for the test, for the
	3-variable case.  <lit>H0</lit> denotes the null hypothesis,
	<lit>H1</lit> the alternative hypothesis, and <lit>c</lit> the
	number of cointegrating relations.
      </para>
      <code context="notex">
                 Rank     Trace test         Lmax test
                          H0     H1          H0     H1
                 ---------------------------------------
                  0      c = 0  c = 3       c = 0  c = 1
                  1      c = 1  c = 3       c = 1  c = 2
                  2      c = 2  c = 3       c = 2  c = 3
                 ---------------------------------------
      </code>
      <para context="tex">
	The following table is offered as a guide to the
	interpretation of the results shown for the test, for the
	3-variable case.  $H_0$ denotes the null hypothesis,
	$H_1$ the alternative hypothesis, and $c$ the
	number of cointegrating relations.	

	\begin{center}
	\begin{tabular}{cllll}
	&amp; \multicolumn{2}{c}{Trace test} &amp;
	   \multicolumn{2}{c}{$\lambda$-max test} \\
	Rank &amp;  \multicolumn{1}{c}{$H_0$} &amp; 
	       \multicolumn{1}{c}{$H_1$} &amp; 
	       \multicolumn{1}{c}{$H_0$} &amp; 
	       \multicolumn{1}{c}{$H_1$} \\ [4pt]
 	0 &amp; $c$ = 0 &amp; $c$ = 3 &amp; $c$ = 0 &amp; $c$ = 1 \\
	1 &amp; $c$ = 1 &amp; $c$ = 3 &amp; $c$ = 1 &amp; $c$ = 2 \\
	2 &amp; $c$ = 2 &amp; $c$ = 3 &amp; $c$ = 2 &amp; $c$ = 3 
	\end{tabular}
	\end{center}
      </para>

      <para>
	See also the <cmdref targ="vecm"/> command.
      </para>

    </description>

    <gui-access>
      <menu-path>/Model/Time series/Cointegration test/Johansen</menu-path>
    </gui-access>

  </command>

  <command name="compact" section="Dataset" context="gui"
    label="Compact data">

    <description>

      <para>When you add to a dataset a series that is of higher
	frequency, it is necessary to <quote>compact</quote> the new
	series.  For instance, a monthly series will have to be
	compacted to fit into a quarterly dataset.</para>  

      <para>In addition, you may sometimes want to compact an entire
	dataset to a lower frequency (perhaps, prior to adding a
	lower-frequency variable to the dataset).</para>

      <para>Gretl offers four options for compacting:</para>

      <ilist>
	<li><para>Averaging: The value written to the dataset will be
	    the arithmetic mean of the relevant series values.  For
	    instance the value written for the first quarter of 1990
	    will be the average of the values for January, February
	    and March of 1990.</para>
	</li>

	<li><para>Summing: The value written to the dataset will be
	    the sum of the relevant higher-frequency values.  For
	    example, the first-quarter value will be the sum of the
	    January, February and March values.</para>
	</li>

	<li><para>End-of-period values: The value written to the
	    dataset is the last relevant value from the
	    higher-frequency data.  For example, the first quarter of
	    1990 will get the March 1990 value.</para>
	</li>

	<li><para>Start-of-period values: The value written to the
	    dataset is the first relevant value from the
	    higher-frequency data.  For example, the first quarter of
	    1990 will get the January 1990 value.</para>
	</li>
      </ilist>

      <para>In the case of compacting an entire dataset, the choice
	you make in this dialog box sets the default method.  But if
	you have set a compaction method for an individual variable
	(menu item <quote>Variable/Edit attributes</quote>) that
	method is used rather than the default.  If the compaction
	method is already set for all variables, the choice of a
	default compaction method is not presented.</para>

    </description>
  </command>

  <command name="controlled" section="Graphs" context="gui"
    label="Scatterplot with control">

    <description>
      <para>
	This command requires the selection of three variables, one for the X
	axis, one for the Y axis, and one for which you wish to control (call
	it Z).  The plot shows adjusted Y against adjusted X, where the
	adjusted version of the variable is the residual from an OLS
	regression on Z.  
      </para>
      <para>
	Example: You have data on wages, experience and education level
	for a sample of people.  You wish to plot wages against education,
	controlling for experience.  In that case you select wages for
	the Y axis, education for the X axis, and experience as the control.
	The plot shows wages against education, with both variables
	<quote>purged</quote> of the effect of experience.
      </para>
    </description>

  </command>

  <command name="copy-formats" section="Utilities" context="gui"
    label="Copy formats">

    <description>
      <para>
	Besides plain text, you have two options for copying data
	from this window.  
      </para>

      <para>
	Tab separated: The data are copied as plain text, using tabs to
	separate the columns.  This is a good choice for pasting data into
	a word processor.  In MS Word or OpenOffice.org Writer, for
	example, you can select the copied material and covert it to a
	properly formatted table, using a menu item such as <quote>Table
	  autoformat</quote> or <quote>Convert text to table</quote>.
      </para>

      <para>
	Comma separated: The data are placed onto the clipboard as
	comma-separated values (CSV).  Use this format if you want to
	paste the data into a spreadsheet.
      </para>

    </description>

  </command>

  <command name="corr" section="Statistics" 
    label="Correlation coefficients">

    <usage>
      <arguments>
        <argument optional="true">varlist</argument>
      </arguments>
      <options>
	<option>
	  <flag>--uniform</flag>
	  <effect>ensure uniform sample</effect>
	</option>
	<option>
	  <flag>--spearman</flag>
	  <effect>Spearman's rho</effect>
	</option>
	<option>
	  <flag>--kendall</flag>
	  <effect>Kendall's tau</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>print rankings</effect>
	</option>
      </options>
      <examples>
        <example>corr y x1 x2 x3</example>
	<example>corr ylist --uniform</example>
	<example>corr x y --spearman</example>
      </examples>
    </usage>

    <description context="gui">
      <para>
	Prints the pairwise correlation coefficients (Pearson's product-moment
	correlation) for the selected variables. The default behavior is to
	use all available observations for computing each pairwise
	coefficient, but if the option box is checked the sample is limited (if
	necessary) so that the same set of observations is used for all the
	coefficients.  This option has an effect only if there are differing
	numbers of missing values for the variables used.
      </para>
    </description>

    <description context="cli">
      <para>
	By default, prints the pairwise correlation coefficients (Pearson's
	product-moment correlation) for the variables in <repl>varlist</repl>,
	or for all variables in the data set if <repl>varlist</repl> is not
	given.  The standard behavior is to use all available observations for
	computing each pairwise coefficient, but if the <flag>--uniform</flag>
	option is given the sample is limited (if necessary) so that the same
	set of observations is used for all the coefficients.  This option
	has an effect only if there are differing numbers of missing values
	for the variables used.
      </para>
      <para>
	The (mutually exclusive) options <lit>--spearman</lit> and
	<lit>--kendall</lit> produce, respectively, Spearman's rank
	correlation rho and Kendall's rank correlation tau in place of the
	default Pearson coefficient.  When either of these options is given,
	<repl>varlist</repl> should contain just two variables.
      </para>
      <para>
	When a rank correlation is computed, the <lit>verbose</lit> option can
	be used to print the original and ranked data (otherwise this option
	is ignored).
      </para>
    </description>

    <gui-access>
      <menu-path>/View/Correlation matrix</menu-path>
      <other-access>Main window pop-up menu (multiple selection)</other-access>
    </gui-access>

  </command>

  <command name="corrgm" section="Statistics" label="Correlogram">

    <usage>
      <arguments>
        <argument>variable</argument>
        <argument optional="true">maxlag</argument>
      </arguments>
      <examples>
        <example>corrgm x 12</example>
      </examples>
    </usage>

    <description>
      <para>
	Prints the values of the autocorrelation function for
	<repl>variable</repl>, which may be specified by name or number.  The
	values are defined as 
	<equation status="inline" 
	  tex="$\hat{\rho}(u_t, u_{t-s})$" 
	  ascii="rho(u(t), u(t-s))" 
	  graphic="autocorr"/> where
	<math>u</math><sub>t</sub> is the <math>t</math>th
	observation of the variable <math>u</math> and
	<math>s</math> is the number of lags.
      </para>

      <para>
	The partial autocorrelations (calculated using the Durbin&ndash;Levinson
	algorithm) are also shown: these are net of the effects of intervening
	lags.  The command also graphs the correlogram and prints the
	Box&ndash;Pierce <math>Q</math> statistic for testing the null
	hypothesis that the series is <quote>white noise</quote>: this is
	asymptotically distributed as chi-square with degrees of freedom equal
	to the number of lags used.
      </para>

      <para>
	If a <repl>maxlag</repl> value is specified the length of the
	correlogram is limited to at most that number of lags, otherwise the
	length is determined automatically, as a function of the frequency of
	the data and the number of observations.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Correlogram</menu-path>
      <other-access>Main window pop-up menu (single selection)</other-access>
    </gui-access>

  </command>

  <command name="criteria" section="Utilities" 
    label="Model selection criteria" context="cli">

    <usage>
      <arguments>
        <argument>ess</argument>
        <argument>T</argument>
        <argument>k</argument>
      </arguments>
      <examples>
        <example>criteria 23.45 45 8</example>
      </examples>
    </usage>

    <description>
      <para>
	Computes the Akaike Information Criterion (AIC) and Schwarz's
	Bayesian Information Criterion (BIC), given <repl>ess</repl>
	(error sum of squares), the number of observations
	(<math>T</math>), and the number of coefficients
	(<math>k</math>). <math>T</math>,
	<math>k</math>, and <repl>ess</repl> may be numerical
	values or names of previously defined variables.
      </para>
      <para>
	The AIC is computed as in Akaike's original (1974)
	formulation, namely
	<equation status="display"
	  tex="\[{\rm AIC} = -2 \ell + 2k\]"
	  ascii="AIC = -2L + 2k"
          graphic="aic"/>
	where <equation status="inline" 
	  tex="$\ell$" ascii="L"
	  graphic="ell"/> denotes the maximized log-likelihood.
	The BIC is computed as
	<equation status="display"
	  tex="\[{\rm BIC} = -2 \ell + k \log T\]"
	  ascii="BIC = -2L + k log T"
          graphic="bic_orig"/>
	Please see <guideref targ="select-criteria"/> for further 
	details.
      </para>
    </description>

  </command>

  <command name="cusum" section="Tests" label="CUSUM test">

    <usage>
      <options>
	<option>
	  <flag>--squares</flag>
	  <effect>perform the CUSUMSQ test</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>just print the Harvey&ndash;Collier test</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Must follow the estimation of a model via OLS.  Performs the
	CUSUM test&mdash;or if the <lit>--squares</lit> option is
	given, the CUSUMSQ test&mdash;for parameter stability.  A
	series of one-step ahead forecast errors is obtained by
	running a series of regressions: the first regression uses the
	first <math>k</math> observations and is used to
	generate a prediction of the dependent variable at observation
	<math>k</math> + 1; the second uses the first
	<math>k</math> + 1 observations and generates a
	prediction for observation <math>k</math> + 2, and so on
	(where <math>k</math> is the number of parameters in the
	original model).
      </para>
      <para>
	The cumulated sum of the scaled forecast errors, or the
	squares of these errors, is printed and graphed.  The null
	hypothesis of parameter stability is rejected at the 5 percent
	significance level if the cumulated sum strays outside of the
	95 percent confidence band.
      </para>
      <para>
	In the case of the CUSUM test, the Harvey&ndash;Collier
	<math>t</math>-statistic for testing the null hypothesis
	of parameter stability is also printed.  See Greene's
	<book>Econometric Analysis</book> for details.  For the
	CUSUMSQ test, the 95 percent confidence band is calculated
	using the algorithm given in Edgerton and Wells (1994).
      </para>
    </description>

    <gui-access>
      <menu-path>Model window, /Tests/CUSUM(SQ)</menu-path>
    </gui-access>

  </command>

  <command name="data" section="Dataset" 
    label="Import from database" context="cli">

    <usage>
      <arguments>
        <argument>varlist</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Reads the variables in <repl>varlist</repl> from a database
	(gretl, RATS 4.0 or PcGive), which must have been opened
	previously using the <cmdref targ="open"/> command.  The
	data frequency and sample range may be established via the
	<cmdref targ="setobs"/> and <cmdref targ="smpl"/> commands prior
	to using this command. Here is a full example:</para>
      <code>
	open macrodat.rat
	setobs 4 1959:1
	smpl ; 1999:4
	data GDP_JP GDP_UK
      </code>
      <para>
	The commands above open a database named
	<filename>macrodat.rat</filename>, establish a quarterly data set
	starting in the first quarter of 1959 and ending in the fourth
	quarter of 1999, and then import the series named
	<lit>GDP_JP</lit> and <lit>GDP_UK</lit>.</para>
      <para>
	If <lit>setobs</lit> and <lit>smpl</lit> are not specified in this
	way, the data frequency and sample range are set using the first
	variable read from the database.
      </para>
      <para>
	If the series to be read are of higher frequency than the working
	data set, you may specify a compaction method as below:</para>
      <code>
	data (compact=average) LHUR PUNEW
      </code>
      <para>
	The four available compaction methods are <quote>average</quote>
	(takes the mean of the high frequency observations),
	<quote>last</quote> (uses the last observation),
	<quote>first</quote> and <quote>sum</quote>.  If no method is
	specified, the default is to use the average.
      </para>

    </description>

    <gui-access>
      <menu-path>/File/Databases</menu-path>
    </gui-access>

  </command>

  <command name="dataset" section="Dataset" 
    label="Manipulate the dataset" context="cli">

    <usage>
      <arguments>
        <argument>keyword</argument>
	<argument>parameters</argument>
      </arguments>
      <examples>
        <example>dataset addobs 24</example>
        <example>dataset compact 1</example>
        <example>dataset compact 4 last</example>
        <example>dataset expand 12</example>
        <example>dataset transpose</example>
	<example>dataset sortby x1</example>
	<example>dataset resample 500</example>
      </examples>
    </usage>

    <description>
      <para>
	Performs various operations on the data set as a whole, depending on
	the given <repl>keyword</repl>, which must be <lit>addobs</lit>,
	<lit>compact</lit>, <lit>expand</lit>, <lit>transpose</lit>,
	<lit>sortby</lit>, <lit>dsortby</lit> or <lit>resample</lit>.  Note:
	these actions are not available when the dataset is currently
	subsampled by selection of cases on some Boolean criterion.
      </para>
      <para>
	<lit>addobs</lit>: Must be followed by a positive integer.  Adds
	the specified number of extra observations to the end of the
	working dataset.  This is primarily intended for forecasting
	purposes.  The values of most variables over the additional range
	will be set to missing, but certain deterministic variables are
	recognized and extended, namely, a simple linear trend and
	periodic dummy variables. 
      </para>
      <para>
	<lit>compact</lit>: Must be followed by a positive integer
	representing a new data frequency, which should be lower than the
	current frequency (for example, a value of 4 when the current
	frequency is 12 indicates compaction from monthly to quarterly).
	This command is available for time series data only; it compacts
	all the series in the data set to the new frequency.  A second
	parameter may be given, namely one of <lit>sum</lit>,
	<lit>first</lit> or <lit>last</lit>, to specify, respectively,
	compaction using the sum of the higher-frequency values,
	start-of-period values or end-of-period values.  The default
	is to compact by averaging.
      </para>
      <para>
	<lit>expand</lit>: Must be followed by a positive integer
	representing a new data frequency, which should be higher than the
	current frequency.  This command is only available for annual or
	quarterly time series data.  Annual data can be expanded to
	quarterly or monthly; quarterly data can be expanded to monthly.
	All the series in the data set are padded out to the new
	frequency by repeating the existing values.
      </para>
      <para>
	<lit>transpose</lit>: No additional parameter required.
	Transposes the current data set.  That is, each observation (row)
	in the current data set will be treated as a variable (column),
	and each variable as an observation.  This command may be useful
	if data have been read from some external source in which the rows
	of the data table represent variables.
      </para>
      <para>
	<lit>sortby</lit>: One variable name is required; this variable is
	used as a sort key.  The observations on all variables in the
	dataset are re-ordered by increasing value of the key variable.
	This command is available only for undated data.
      </para>
      <para>
	<lit>dsortby</lit>: Works as <lit>sortby</lit> except that
	the re-ordering is by decreasing value of the key variable.
      </para>
      <para>
	<lit>resample</lit>: Constructs a new dataset by random
	sampling, with replacement, of the rows of the current dataset.
	One argument is required, namely the number of rows to
	include.  This may be less than, equal to, or greater than
	the number of observations in the original data.  The
	original dataset can be retrieved via the command
	<lit>smpl full</lit>.  
      </para>

    </description>

    <gui-access>
      <menu-path>/Data</menu-path>
    </gui-access>

  </command>

  <command name="datasort" section="Dataset" context="gui"
    label="Sorting data">

    <description>
      <para>
	The selected variable is used as a sort key for the entire
	data set.  The observations on all variables are
	re-ordered by increasing value of the key variable, or by
	decreasing value if you select the <quote>Descending</quote>
	option.
      </para>
    </description>
  </command>

  <command name="delete" section="Dataset" 
    label="Delete variables" context="cli">

    <usage>
      <arguments>
        <argument optional="true">varlist</argument>
      </arguments>
      <options>
	<option>
	  <flag>--db</flag>
	  <effect>delete from opened database</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	By default, removes the listed variables (given by name or
	number) from the current dataset. <emphasis>Use with
	caution</emphasis>: no confirmation is asked, and any variables
	with higher ID numbers will be re-numbered.
      </para>
      <para>If no <repl>varlist</repl> is given with this command, it
	deletes the last (highest numbered) variable from the
	dataset.
      </para>
      <para>
	If the <lit>--db</lit> option is given, this command deletes the
	listed variables not from the current dataset but from a gretl
	database, assuming that a database has been opened, and the user
	has write permission for file in question.  See also the
	<cmdref targ="open"/> command.
      </para>
    </description>

    <gui-access>
      <menu-path>Main window pop-up (single selection)</menu-path>
    </gui-access>

  </command>

  <command name="density" section="Statistics" context="gui"
    label="Kernel density estimation">

    <description>

      <para>Kernel density estimation proceeds by defining a set of
	evenly spaced reference points, over a suitable range in
	relation to the range of the data, and attributing a density
	to each reference point based on the actual observations in
	the vicinity.</para>
      
      <para>The formula used to compute the estimated density at each
	reference point, <math>x</math>, is
      <equation status="display"
	tex="\[f(x)=(1/nh) \sum_{t-1}^{n} k\left((x-x_t)/h\right)\]"
	ascii="f(x) = (1/nh) sum(t=1 to n) k((x - x(t)) / h)"
	graphic="kernel1"/>
	where <math>n</math> denotes the number of data
	points, <math>h</math> is a <quote>bandwidth</quote>
	parameter, and <math>k</math>() is the kernel function.
	The larger the value of the bandwidth parameter, the smoother
	the estimated density.</para>

      <para>You are given the choice of using a Gaussian kernel (the
	standard normal density) or the Epanechnikov kernel.  By
	default, the bandwidth is that suggested as a rule of thumb by
	Silverman (1986), namely
	<equation status="display"
	  tex="\[h=0.9 {\rm min}(s, {\rm IQR}/1.349) n^{1/5}\]"
	  ascii="h = 0.9 min(s, IQR/1.349) n^{1/5}"
	  graphic="kernel2"/>
	where <math>s</math> denotes the standard deviation
	of the data and IQR denotes the inter-quartile range.  You can
	widen or shrink the bandwidth via the <quote>bandwidth
	  adjustment factor</quote>: the actual bandwidth used is
	obtained by multiplying the Silverman value by the adjustment
	factor.
      </para>

      <para>For a good introductory discussion of kernel density
	estimation see Chapter 15 of Davidson and MacKinnon's
	<book>Econometric Theory and Methods</book>.
      </para>

    </description>

  </command>  

  <command name="dfgls" section="Tests" context="gui"
    label="The ADF-GLS test">

    <description>
      <para>
	The ADF-GLS test is a variant of the Dickey&ndash;Fuller
	test for a unit root, for the case where the variable
	to be tested is assumed to have a non-zero mean or to
	exhibit a linear trend.  The difference is that 
	the de-meaning or de-trending of the variable is done
	using the GLS procedure suggested by Elliott, Rothenberg
	and Stock (1996).  This gives a test of greater power than
	the standard Dickey&ndash;Fuller approach.
      </para>
      <para>
	See also the <cmdref targ="adf"/> command and the <lit>--gls</lit>
	option.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/ADF-GLS test</menu-path>
    </gui-access>

  </command>

  <command name="dialog" section="Estimation" context="gui"
    label="Model dialog box">

    <description>
      <para>To select the dependent variable, highlight a variable in
	the list on the left and press the <quote>Choose</quote>
	button pointing to the Dependent variable slot.  If you check
	the <quote>Set as default</quote> box, the selected variable
	will be pre-selected as dependent when the model dialog is
	next opened.  Short-cut: double-click on a variable on the
	left to select it as the dependent variable and also set it as
	the default.</para>

      <para>To select independent variables, highlight them on the
	left and press the <quote>Add</quote> button (or click the
	right mouse button).  You can highlight several contiguous
	variables by dragging with the mouse.  You can highlight a
	group of non-contiguous variables by clicking on them with the
	<lit>Ctrl</lit> key pressed.</para>

    </description>

  </command>

  <command name="diff" section="Transformations" 
    label="First differences" context="cli">

    <usage>
      <arguments>
        <argument>varlist</argument>
      </arguments>
    </usage>

    <description>
      <para>
	The first difference of each variable in <repl>varlist</repl>
	is obtained and the result stored in a new variable with the
	prefix <lit>d_</lit>.  Thus <cmd>diff x y</cmd> creates the
	new variables
      </para>
      <code>
	d_x = x(t) - x(t-1)
	d_y = y(t) - y(t-1)
      </code>
    </description>

    <gui-access>
      <menu-path>/Add/First differences of selected variables</menu-path>
    </gui-access>

  </command>

  <command name="difftest" section="Tests" 
    label="Nonparametric tests for differences" context="cli">

    <usage>
      <arguments>
        <argument>var1</argument>
	<argument>var2</argument>
      </arguments>
      <options>
	<option>
	  <flag>--sign</flag>
	  <effect>Sign test, the default</effect>
	</option>
	<option>
	  <flag>--rank-sum</flag>
	  <effect>Wilcoxon rank-sum test</effect>
	</option>
	<option>
	  <flag>--signed-rank</flag>
	  <effect>Wilcoxon signed-rank test</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>print extra output</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Carries out a nonparametric test for a difference between two
	populations or groups, the specific test depending on the option
	selected.
      </para>
      <para>
	With the <lit>--sign</lit> option, the Sign test is performed.
	This test is based on the fact that if two samples,
	<math>x</math> and <math>y</math>, are drawn randomly
	from the same distribution, the probability that
	<math>x</math><sub>i</sub> &gt;
	<math>y</math><sub>i</sub>, for each observation
	<math>i</math>, should equal 0.5.  The test statistic is
	<math>w</math>, the number of observations for which
	<math>x</math><sub>i</sub> &gt;
	<math>y</math><sub>i</sub>. Under the null hypothesis this
	follows the Binomial distribution with parameters
	(<math>n</math>, 0.5), where <math>n</math> is the
	number of observations.
      </para>
      <para>
	With the <lit>--rank-sum</lit> option, the Wilcoxon rank-sum test
	is performed.  This test proceeds by ranking the observations from
	both samples jointly, from smallest to largest, then finding the
	sum of the ranks of the observations from one of the samples.  The
	two samples do not have to be of the same size, and if they differ
	the smaller sample is used in calculating the rank-sum.  Under the
	null hypothesis that the samples are drawn from populations with
	the same median, the probability distribution of the rank-sum can
	be computed for any given sample sizes; and for reasonably large
	samples a close Normal approximation exists.
      </para>
      <para>
	With the <lit>--signed-rank</lit> option, the Wilcoxon signed-rank
	test is performed.  This is designed for matched data pairs such
	as, for example, the values of a variable for a sample of
	individuals before and after some treatment.  The test proceeds by
	finding the differences between the paired observations,
	<math>x</math><sub>i</sub> &minus;
	<math>y</math><sub>i</sub>, ranking these differences by
	absolute value, then assigning to each pair a signed rank, the
	sign agreeing with the sign of the difference.  One then
	calculates <math>W</math><sub>+</sub>, the sum of the
	positive signed ranks.  As with the rank-sum test, this statistic
	has a well-defined distribution under the null that the median
	difference is zero, which converges to the Normal for samples
	of reasonable size.
      </para>
      <para>
	For the Wilcoxon tests, if the <lit>--verbose</lit> option is
	given then the ranking is printed.  (This option has no effect if
	the Sign test is selected.)
      </para>
    </description>

  </command>

  <command name="discrete" section="Transformations" 
    label="Mark variables as discrete" context="cli">

    <usage>
      <arguments>
        <argument>varlist</argument>
      </arguments>
      <options>
	<option>
	  <flag>--reverse</flag>
	  <effect>mark variables as continuous</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Marks each variable in <repl>varlist</repl> as being discrete. By
	default all variables are treated as continuous; marking a
	variable as discrete affects the way the variable is handled in
	frequency plots, and also allows you to select the variable for
	the command <cmdref targ="dummify"/>.
      </para>
      <para>
	If the <lit>--reverse</lit> flag is given, the operation is reversed;
	that is, the variables in <repl>varlist</repl> are marked as
	being continuous.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Edit attributes</menu-path>
    </gui-access>

  </command>

  <command name="dummify" section="Transformations" 
    label="Create sets of dummies" context="cli">

    <usage>
      <arguments>
        <argument>varlist</argument>
      </arguments>
      <options>
	<option>
	  <flag>--drop-first</flag>
	  <effect>omit lowest value from encoding</effect>
	</option>
	<option>
	  <flag>--drop-last</flag>
	  <effect>omit highest value from encoding</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	For any suitable variables in <repl>varlist</repl>, creates a set
	of dummy variables coding for the distinct values of that
	variable.   Suitable variables are those that have been explicitly
	marked as discrete, or those that take on a fairly small number of
	values all of which are <quote>fairly round</quote> (multiples of
	0.25).
      </para>
      <para>
	By default a dummy variable is added for each distinct value of
	the variable in question.  For example if a discrete variable
	<lit>x</lit> has 5 distinct values, 5 dummy variables will be
	added to the data set, with names <lit>Dx_1</lit>, <lit>Dx_2</lit>
	and so on.  The first dummy variable will have value 1 for
	observations where <lit>x</lit> takes on its smallest value, 0
	otherwise; the next dummy will have value 1 when <lit>x</lit>
	takes on its second-smallest value, and so on.  If one of the
	option flags <lit>--drop-first</lit> or <lit>--drop-last</lit>
	is added, then either the lowest or the highest value of each
	variable is omitted from the encoding (which may be useful for
	avoiding the <quote>dummy variable trap</quote>).
      </para>
      <para>
	This command can also be embedded in the context of a regression
	specification.  For example, the following line specifies a model
	where <lit>y</lit> is regressed on the set of dummy variables
	coding for <lit>x</lit>.  (Option flags cannot be passed to
	<cmd>dummify</cmd> in this context.)
      </para>
      <code>
	ols y dummify(x)
      </code>
    </description>

  </command>

  <command name="elif" section="Programming" label="Flow control" context="cli">

    <description><para>See <cmdref targ="if"/>.</para>
    </description>

  </command>

  <command name="else" section="Programming" context="cli">

    <description><para>See <cmdref targ="if"/>.</para>
    </description>

  </command>

  <command name="end" section="Programming" 
    label="End block of commands" context="cli">

    <description>
      <para>
	Ends a block of commands of some sort.  For example, <cmd>end
	  system</cmd> terminates an equation <cmdref targ="system"/>.
      </para>
    </description>

  </command>

  <command name="endif" section="Programming" label="Flow control" context="cli">

    <description><para>See <cmdref targ="if"/>.</para>
    </description>

  </command>

  <command name="endloop" section="Programming" 
    label="End a command loop" context="cli">

    <description>
      <para>
	Marks the end of a command loop.  See <cmdref targ="loop"/>.
      </para>
    </description>

  </command>

  <command name="eqnprint" section="Printing" 
    label="Print model as equation" context="cli">

    <usage>
      <arguments>
        <argument optional="true">-f filename</argument>
      </arguments>
      <options>
        <option>
	  <flag>--complete</flag>
	  <effect>Create a complete document</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Must follow the estimation of a model.  Prints the estimated
	model in the form of a &latex; equation.  If a filename is
	specified using the <lit>-f</lit> flag output goes to that
	file, otherwise it goes to a file with a name of the form
	<filename>equation_N.tex</filename>, where <lit>N</lit> is the
	number of models estimated to date in the current session.
	See also <cmdref targ="tabprint"/>.
      </para>

      <para>
	If the <lit>--complete</lit> flag is given, the &latex; file is
	a complete document, ready for processing; otherwise it must
	be included in a document.
      </para>
    </description>

    <gui-access>
      <menu-path>Model window, /LaTeX</menu-path>
    </gui-access>

  </command>

  <command name="equation" section="Estimation" 
    label="Define equation within a system" context="cli">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <examples>
        <example>equation y x1 x2 x3 const</example>
      </examples>
    </usage>

    <description>
      <para>
	Specifies an equation within a system of equations (see 
	<cmdref targ="system"/>).  The syntax for specifying an
	equation within an SUR system is the same as that for, &eg;, 
	<cmdref targ="ols"/>.  For an equation within a Three-Stage Least
	Squares system you may either (a) give an OLS-type equation
	specification and provide a common list of instruments using the
	<cmd>instr</cmd> keyword (again, see <cmdref targ="system"/>),
	or (b) use the same equation syntax as for <cmdref targ="tsls"/>.
      </para>
    </description>

  </command>

  <command name="estimate" section="Estimation" 
    label="Estimate system of equations" context="cli">

    <usage>
      <arguments>
        <argument>systemname</argument>
        <argument>estimator</argument>
      </arguments>
      <options>
	<option>
	  <flag>--iterate</flag>
	  <effect>iterate to convergence</effect>
	</option>
	<option>
	  <flag>--no-df-corr</flag>
	  <effect>no degrees of freedom correction</effect>
	</option>
	<option>
	  <flag>--geomean</flag>
	  <effect>see below</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>print details of iterations</effect>
	</option>
      </options>
      <examples>
        <example>estimate "Klein Model 1" method=fiml</example>
	<example>estimate Sys1 method=sur</example>
	<example>estimate Sys1 method=sur --iterate</example>
      </examples>
    </usage>

    <description>
      <para>
	Calls for estimation of a system of equations, which must have
	been previously defined using the <cmdref targ="system"/>
	command.  The name of the system should be given first,
	surrounded by double quotes if the name contains spaces.  The
	estimator, which must be one of <cmd>ols</cmd>,
	<cmd>tsls</cmd>, <cmd>sur</cmd>, <cmd>3sls</cmd>,
	<cmd>fiml</cmd> or <cmd>liml</cmd>, is preceded by the string
	<lit>method=</lit>.
      </para>
      <para>If the system in question has had a set of restrictions
	applied (see the <cmdref targ="restrict"/> command),
	estimation will be subject to the specified restrictions.
      </para>
      <para>
	If the estimation method is <cmd>sur</cmd> or <cmd>3sls</cmd>
	and the <lit>--iterate</lit> flag is given, the estimator will
	be iterated.  In the case of SUR, if the procedure converges
	the results are maximum likelihood estimates.  Iteration of
	three-stage least squares, however, does not in general
	converge on the full-information maximum likelihood results.
	The <lit>--iterate</lit> flag is ignored for other methods of
	estimation.  
      </para>
      <para>If the equation-by-equation estimators <cmd>ols</cmd> or
	<cmd>tsls</cmd> are chosen, the default is to apply a degrees
	of freedom correction when calculating standard errors. This
	can be suppressed using the <lit>--no-df-corr</lit> flag. This
	flag has no effect with the other estimators; no degrees of
	freedom correction is applied in any case.
      </para>
      <para>By default, the formula used in calculating the
	elements of the cross-equation covariance matrix is
	<equation status="display"
	tex="\[\hat{\sigma}_{i,j}=\frac{\hat{u}_i' \hat{u}_j}{T}\]"
	ascii="sigma(i,j) = u(i)' * u(j) / T"
	graphic="syssigma1"/>
	If the <lit>--geomean</lit> flag is
	given, a degrees of freedom correction is applied: the
	formula is
	<equation status="display"
	tex="\[\hat{\sigma}_{i,j}=\frac{\hat{u}_i' \hat{u}_j}{\sqrt{(T-k_i)(T-k_j)}}\]"
	ascii="sigma(i,j) = u(i)' * u(j) / sqrt((T - ki) * (T - kj))"
	graphic="syssigma2"/>
	where the <math>k</math>s denote the number of
	independent parameters in each equation.
      </para>
      <para>
	If the <lit>verbose</lit> option is given and an iterative
	method is specified, details of the iterations are printed.
      </para>
    </description>

  </command>

  <command name="expand" section="Dataset" context="gui"
    label="Expand data">

    <description>

      <para>
	If you wish to add to a dataset a series that is of lower frequency, it
	is necessary to <quote>expand</quote> the new series.  For instance, a
	quarterly series will have to be expanded to fit into a monthly dataset.
	In addition, you may sometimes want to expand an entire dataset to a
	higher frequency (perhaps, prior to adding a higher-frequency variable
	to the dataset).
      </para>

      <para>
	Expansion of data should be considered an <quote>expert</quote> option:
	you need to know what you are doing.  What gretl does is simply
	replicate the values of the lower-frequency series as many times as
	required.  For example, suppose we have a quarterly series with the
	value 35.5 in 1990:1, the first quarter of 1990.  On expansion to
	monthly, the value 35.5 will be assigned to the observations for
	January, February and March of 1990.  The expanded variable is 
	therefore useless for fine-grained time-series analysis, outside
	of the special case where you know that the variable in question 
	does in fact remain constant over the sub-periods.  
      </para>

      <para>
	Two related commands should be mentioned here.  First, when you are
	combining series of differing original frequencies within one dataset,
	you should consider the option of compacting the higher-frequency data
	rather than expanding the lower-frequency series.  This option can be
	found under gretl's Sample menu.  Second, if you choose to expand
	a series, you may wish to consider smoothing the result.  Various
	options are available using the <cmd>genr</cmd> command.
      </para>

    </description>
  </command>

  <command name="export" section="Dataset" context="gui"
    label="Export data">

    <description>
      <para>You may export data in Comma-Separated Values (CSV)
	format: such data may be opened in spreadsheets and many other
	application programs.</para>

      <para>You may also export data in the native formats of GNU R or
	GNU octave.  For further information on these programs (both
	of which support advanced statistical analysis) please see
	their respective websites, http://www.r-project.org/ and
	http://www.octave.org/</para>
    </description>
  </command>

  <command name="factorized" section="Graphs" context="gui"
    label="Factorized plot">

    <description>
      <para>This command requires the selection of three variables,
	the last of which must be a dummy variable (values 1 or 0).
	The Y variable is plotted against the X variable, with the
	data points colored differently depending on the value of the
	third.
      </para>
      <para>Example: You have data on wages and educational attainment
	for a sample of people; you also have a dummy variable with
	value 1 for men and 0 for women (as in Ramanathan's
	<filename>data7-2</filename>).  A <quote>factorized
	  plot</quote> of <lit>WAGE</lit> against <lit>EDUC</lit>
	using the <lit>GENDER</lit> dummy as factor will show the data
	points for men in one color and those for women in another
	(with a legend to identify them).
      </para>
    </description>

  </command>

  <command name="fcast" section="Prediction" 
    label="Generate forecasts">

    <usage>
      <arguments>
        <argument optional="true">startobs endobs</argument>
	<argument optional="true">varname</argument>
      </arguments>
      <options>
        <option>
	  <flag>--dynamic</flag>
	  <effect>create dynamic forecast</effect>
        </option>
        <option>
	  <flag>--static</flag>
	  <effect>create static forecast</effect>
        </option>
        <option>
	  <flag>--out-of-sample</flag>
	  <effect>generate post-sample forecast</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>don't print the forecast</effect>
        </option>
      </options>
      <examples>
        <example>fcast 1997:1 2001:4 f1</example>
	<example>fcast fit2</example>
      </examples>
    </usage>

    <description>

      <para context="gui">
	Must follow an estimation command.  Forecasts are generated for
	the specified range of observations. Depending on the nature of
	the model, standard errors may also be generated (see below).
      </para>

      <para context="cli">
	Must follow an estimation command.  Forecasts are generated for a
	certain range of observations: if <repl>startobs</repl> and
	<repl>endobs</repl> are given, for that range (if possible);
	otherwise if the <lit>--out-of-sample</lit> option is given, for
	observations following the range over which the model was
	estimated; otherwise over the currently defined sample range.  If
	an out-of-sample forecast is requested but no relevant
	observations are available, an error is flagged. Depending on the
	nature of the model, standard errors may also be generated (see
	below).
      </para>

      <para context="cli">
	If the last model estimated is a single equation, then the
	optional <repl>varname</repl> argument has the following effect:
	the forecast values are not printed, but are saved to the dataset
	under the given name.  If the last model is a system of equations,
	<repl>varname</repl> has a different effect, namely selecting a
	particular endogenous variable for forecasting (the default being
	to produce forecasts for all the endogenous variables). In the
	system case, or if <repl>varname</repl> is not given, the forecast
	values can be retrieved using the accessor <lit>$fcast</lit>, and
	the standard errors, if available, via <lit>$fcerr</lit>.
      </para>

      <para>
	The choice between a static and a dynamic forecast applies
	only in the case of dynamic models, with an autoregressive
	error process or including one or more lagged values of the
	dependent variable as regressors.  Static forecasts are one
	step ahead, based on realized values from the previous period,
	while dynamic forecasts employ the chain rule of forecasting.
	For example, if a forecast for <math>y</math> in 2008
	requires as input a value of <math>y</math> for 2007, a
	static forecast is impossible without actual data for 2007.  A
	dynamic forecast for 2008 is possible if a prior forecast can
	be substituted for <math>y</math> in 2007.
      </para>

      <para>
	The default is to give a static forecast for any portion of
	the forecast range that lies within the sample range over which
	the model was estimated, and a dynamic forecast (if relevant)
	out of sample.  The <lit>dynamic</lit> option requests a
	dynamic forecast from the earliest possible date, and the
	<lit>static</lit> option requests a static forecast even out
	of sample.  
      </para>

      <para>
	The nature of the forecast standard errors (if available)
	depends on the nature of the model and the forecast.  For
	static linear models standard errors are computed using
	the method outlined by Davidson and MacKinnon (2004); they
	incorporate both uncertainty due to the error process and
	parameter uncertainty (summarized in the covariance matrix of
	the parameter estimates).  For dynamic models, forecast
	standard errors are computed only in the case of a dynamic
	forecast, and they do not incorporate parameter uncertainty.
	For nonlinear models, forecast standard errors are not
	presently available.
      </para>	

    </description>

    <gui-access>
      <menu-path>Model window, /Analysis/Forecasts</menu-path>
    </gui-access>

  </command>

  <command name="freq" section="Statistics" label="Frequency distribution">

    <usage>
      <arguments>
        <argument>var</argument>
      </arguments>
      <options>
        <option>
	  <flag>--quiet</flag>
	  <effect>suppress printing of graph</effect>
        </option>
        <option>
	  <flag>--normal</flag>
	  <effect>test for the normal distribution</effect>
        </option>
        <option>
	  <flag>--gamma</flag>
	  <effect>test for gamma distribution</effect>
        </option>
        <option>
	  <flag>--silent</flag>
	  <effect>don't print anything</effect>
        </option>
      </options>
    </usage>

    <description context="cli">
      <para>
	With no options given, displays the frequency distribution for
	<repl>var</repl> (given by name or number).
      </para>
      <para>
	If the <lit>--normal</lit> option is given, the
	Doornik&ndash;Hansen chi-square test for normality is computed. If
	the <lit>--gamma</lit> option is given, the test for normality is
	replaced by Locke's nonparametric test for the null hypothesis
	that the variable follows the gamma distribution; see Locke
	(1976), Shapiro and Chen (2001).
      </para>
      <para>
	In interactive mode a graph of the distribution is displayed by
	default.  The <lit>--quiet</lit> flag can be used to suppress
	this.
      </para>
      <para>
	The <lit>--silent</lit> flag suppresses the usual output entirely.
	This makes sense only in conjunction with one or other of the
	distribution test options: the test statistic and its p-value are
	recorded, and can be retrieved using the accessors
	<lit>$test</lit> and <lit>$pvalue</lit>.
      </para>
    </description>

    <description context="gui">
      <para>
	In the frequency plot dialog box you can control the
	characteristics of the plot in either of two ways.
      </para>
      <para>
	First, you may choose the number of bins.  In this case the width
	and placement of the bins are calculated automatically.
      </para>
      <para>
	Alternatively, you may specify the lower limit of the left-most
	bin, and the width of the bins.  In this case the number of bins
	is calculated automatically.
      </para>
      <para>
	If you wish to align the bins on round numbers, here is one way to
	proceed: start by specifying the number of bins you want, and take
	a look at the plot that is produced.  If it's not to your liking,
	take note of the modification that is required (for example, make
	the left-most bin start at 100 and impose a bin width of 200).
	Then make a second pass where you specify the left-hand limit and
	bin width.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Frequency distribution</menu-path>
    </gui-access>

  </command>

  <command name="function" section="Programming" 
    label="Define a function" context="cli">

    <usage>
      <arguments>
        <argument>fnname</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Opens a block of statements in which a function is defined.  This
	block must be closed with <lit>end function</lit>.  Please see
	<guideref targ="chap:functions"/> for details.
      </para>
    </description>

  </command>  

  <command name="garch" section="Estimation" label="GARCH model">

    <usage>
      <arguments>
        <argument>p</argument>
	<argument>q</argument>
	<argument separated="true">depvar</argument>
	<argument optional="true">indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--robust</flag>
	  <effect>robust standard errors</effect>
        </option>
	<option>
	  <flag>--verbose</flag>
	  <effect>print details of iterations</effect>
        </option>
        <option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
        </option>
        <option>
	  <flag>--arma-init</flag>
	  <effect>initial variance parameters from ARMA</effect>
        </option>
      </options>
      <examples>
        <example>garch 1 1 ; y</example>
	<example>garch 1 1 ; y 0 x1 x2 --robust</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
	Estimates a GARCH model (GARCH = Generalized Autoregressive
	Conditional Heteroskedasticity), either a univariate model or,
	if <repl>indepvars</repl> are specified, including the given
	exogenous variables.  The integer values <repl>p</repl> and
	<repl>q</repl> (which may be given in numerical form or as the
	names of pre-existing scalar variables) represent the lag
	orders in the conditional variance equation:
	<equation status="display"
	  tex="\[h_t = \alpha_0 + \sum_{i=1}^q \alpha_i \varepsilon^2_{t-i} +
	  \sum_{j=1}^p \beta_i h_{t-j}\]"
	  ascii="h(t) = a(0) + sum(i=1 to q) a(i)*u(t-i)^2 + sum(j=1 to p) b(j)*h(t-j)"
	  graphic="garch_h"/>
      </para>

      <para context="gui">
	Estimates a GARCH model (GARCH = Generalized Autoregressive
	Conditional Heteroskedasticity), either a univariate model or,
	if independent variables are selected, including the given
	exogenous variables.  The conditional variance equation is
	shown below.
	<equation status="display" tex="\[h_t = \alpha_0 + 
	\sum_{i=1}^q \alpha_i \varepsilon^2_{t-i} + \sum_{j=1}^p
	\beta_i h_{t-j}\]" ascii="h(t) = a(0) + sum(i=1 to q) a(i)*u(t-i) +
	sum(j=1 to p) b(j)*h(t-j)" graphic="garch_h"/>
      </para>

      <para>The gretl GARCH algorithm is basically that of Fiorentini,
	Calzolari and Panattoni (1996), used by kind permission of
	Professor Fiorentini.</para>

      <para context="cli">Several variant estimates of the coefficient
	covariance matrix are available with this command.  By
	default, the Hessian is used unless the <lit>--robust</lit>
	option is given, in which case the QML (White) covariance
	matrix is used.  Other possibilities (&eg; the information
	matrix, or the Bollerslev&ndash;Wooldridge estimator) can be
	specified using the <cmdref targ="set"/> command.
      </para>

      <para context="gui">Several variant estimates of the coefficient
	covariance matrix are available with this command.  By
	default, the Hessian is used unless the <quote>Robust standard
	  errors</quote> box is checked, in which case the QML (White)
	covariance matrix is used.  Other possibilities (&eg; the
	information matrix, or the Bollerslev&ndash;Wooldridge
	estimator) can be specified using the <cmdref targ="set"/>
	command.
      </para>

      <para context="gui">
	The estimated conditional variance, along with the residuals and
	various other model statistics, can be accessed and added to the
	dataset using the <quote>Model data</quote> menu in the window
	where the model is displayed.
      </para>

      <para context="cli">
	By default, the estimates of the variance parameters are
	initialized using the unconditional error variance from
	initial OLS estimation for the constant, and small positive
	values for the coefficients on the past values of the squared
	error and the error variance.  The flag <lit>--arma-init</lit>
	calls for the starting values of these parameters to be
	set using an initial ARMA model, exploiting the relationship
	between GARCH and ARMA set out in Chapter 21 of Hamilton's
	<book>Time Series Analysis</book>.  In some cases this may 
	improve the chances of convergence.
      </para>

      <para context="cli">
	The GARCH residuals and estimated conditional variance can be
	retrieved as <lit>$uhat</lit> and <lit>$h</lit> respectively.  For
	example, to get the conditional variance:  
      </para>
      <code context="cli">
	genr ht = $h
      </code>

    </description>

    <gui-access>
      <menu-path>/Model/Time series/GARCH</menu-path>
    </gui-access>

  </command>

  <command name="genr" section="Dataset"
    label="Generate a new variable">

    <usage>
      <arguments>
        <argument>newvar</argument>
        <argument>= formula</argument>
      </arguments>
    </usage>

    <description>
      <para>
	In the appropriate context, <lit>series</lit>, <lit>scalar</lit>
	and <lit>matrix</lit> are synonyms for this command.
      </para>

      <para>
	Creates new variables, usually through transformations of existing
	variables. See also <cmdref targ="diff"/>, <cmdref targ="logs"/>,
	<cmdref targ="lags"/>, <cmdref targ="ldiff"/>, 
	<cmdref targ="sdiff"/> and <cmdref targ="square"/>
	for shortcuts. In the context of a <lit>genr</lit> formula, existing
	variables must be referenced by name, not ID number.  The formula should
	be a well-formed combination of variable names, constants, operators and
	functions (described below).  Note that further details on some aspects
	of this command can be found in <guideref targ="chap-genr"/>.
      </para>

      <para>
	A <lit>genr</lit> command may yield either a series or a scalar
	result.  For example, the formula <lit>x2 = x * 2</lit> naturally
	yields a series if the variable <lit>x</lit> is a series and a
	scalar if <lit>x</lit> is a scalar.  The formulae <lit>x = 0</lit>
	and <lit>mx = mean(x)</lit> naturally return scalars. Under some
	circumstances you may want to have a scalar result expanded into a
	series or vector.  You can do this by using <lit>series</lit> as
	an <quote>alias</quote> for the <lit>genr</lit> command.  For
	example, <lit>series x = 0</lit> produces a series all of whose
	values are set to 0.  You can also use <lit>scalar</lit> as an
	alias for <lit>genr</lit>.  It is not possible to coerce a vector
	result into a scalar, but use of this keyword indicates that the
	result <emphasis>should be</emphasis> a scalar: if it is not, an
	error occurs.
      </para>

      <para>
	When a formula yields a series or vector result, the range over which
	the result is written to the target variable depends on the current
	sample setting.  It is possible, therefore, to define a series piecewise
	using the <lit>smpl</lit> command in conjunction with <lit>genr</lit>.
      </para>

      <para>
	Supported <emphasis>arithmetical operators</emphasis> are, in
	order of precedence: <lit>^</lit> (exponentiation);
	<lit>*</lit>, <lit>/</lit> and <lit>%</lit> (modulus or
	remainder); <lit>+</lit> and <lit>-</lit>. 
      </para>

      <para>
	The available <emphasis>Boolean operators</emphasis> are (again,
	in order of precedence): <lit>!</lit> (negation),
	<lit>&amp;&amp;</lit> (logical AND), <lit>||</lit> (logical OR),
	<lit>&gt;</lit>, <lit>&lt;</lit>, <lit>=</lit>, <lit>&gt;=</lit>
	(greater than or equal), <lit>&lt;=</lit> (less than or equal) and
	<lit>!=</lit> (not equal).  The Boolean operators can be used in
	constructing dummy variables: for instance <lit>(x > 10)</lit>
	returns 1 if <lit>x</lit> &gt; 10, 0 otherwise.
      </para>

      <para>
	Built-in constants are <lit>pi</lit> and <lit>NA</lit>.  The latter
	is the missing value code: you can initialize a variable to the missing
	value with <lit>scalar x = NA</lit>.
      </para>

      <para>
	The <lit>genr</lit> command supports a wide range of mathematical and
	statistical functions, including all the common ones plus several that
	are special to econometrics.  In addition it offers access to numerous
	internal variables that are defined in the course of running
	regressions, doing hypothesis tests, and so on.
	<refnote xref="false"> 
	  For a listing of functions and accessors, type 
	  <quote>help functions</quote>. 
	</refnote> 
	<refnote xref="true">
	  For a listing of functions and accessors, see 
	  <gfr targ="chap:funcref"/>. 
	</refnote>
      </para>

      <para>
	Besides the operators and functions noted above there are
	some special uses of <cmd>genr</cmd>:
      </para>

      <ilist>
	<li>
	  <para>
	    <cmd>genr time</cmd> creates a time trend variable (1,2,3,&hellip;)
	    called <cmd>time</cmd>. <cmd>genr index</cmd> does the same thing
	    except that the variable is called <lit>index</lit>.
	  </para>
	</li>
	<li>
	  <para>
	    <cmd>genr dummy</cmd> creates dummy variables up to the periodicity
	    of the data.  For example, in the case of quarterly data
	    (periodicity 4), the program creates <lit>dummy_1</lit> = 1 for
	    first quarter and 0 in other quarters, <lit>dummy_2</lit> = 1 for
	    the second quarter and 0 in other quarters, and so on.
	  </para>
	</li>
	<li>
	  <para>
	    <cmd>genr unitdum</cmd> and <cmd>genr timedum</cmd> create 
	    sets of special dummy variables for use with panel data.
	    The first codes for the cross-sectional units and the second
	    for the time period of the observations.
	  </para>
	</li>
      </ilist>

      <para>
	<emphasis>Note</emphasis>: In the command-line program, <cmd>genr</cmd>
	commands that retrieve model-related data always reference the model
	that was estimated most recently. This is also true in the GUI program,
	if one uses <cmd>genr</cmd> in the <quote>gretl console</quote> or
	enters a formula using the <quote>Define new variable</quote> option
	under the Variable menu in the main window.  With the GUI, however, you
	have the option of retrieving data from any model currently displayed in
	a window (whether or not it's the most recent model).  You do this under
	the <quote>Model data</quote> menu in the model's window.
      </para>

      <para>
	The special variable <lit>t</lit> serves as an index of the
	observations (<lit>obs</lit> is a synonym).  For instance <lit>genr
	dum = (t=15)</lit> will generate a dummy variable that has value 1 for
	observation 15, 0 otherwise.  You can also use this variable to pick
	out particular observations by date or name.  For example, 
	<lit>genr d = (obs&gt;1986:4)</lit>, 
	<lit>genr d = (obs&gt;"2008/04/01")</lit>
	<lit>genr d = (obs="CA")</lit>.  If daily dates or observation labels
	are used in this context, they must be enclosed in double quotes.
	Quarterly and monthly dates (with a colon) may be used unquoted.
      </para>

      <para>
	Please note: when using <lit>t</lit> and <lit>obs</lit> with annual
	time-series data, the value always corresponds to the year of the
	observation.  Therefore if you have annual data starting in 1970, the
	observation for 1980 corresponds to <lit>t=1980</lit>, and not
	<lit>t=10</lit>.  With quarterly or monthly data, on the other hand,
	<lit>t=10</lit> would correspond to the 10th observation.
      </para>

      <para>
	Scalar values can be pulled from a series in the context of a
	<lit>genr</lit> formula, using the syntax
	<repl>varname</repl><lit>[</lit><repl>obs</repl><lit>]</lit>. The
	<repl>obs</repl> value can be given by number or date. Examples:
	<lit>x[5]</lit>, <lit>CPI[1996:01]</lit>.  For daily data, the form
	<repl>YYYY/MM/DD</repl> should be used, &eg; <lit>ibm[1970/01/23]</lit>.
      </para>

      <para>
	An individual observation in a series can be modified via
	<lit>genr</lit>.  To do this, a valid observation number or date, in
	square brackets, must be appended to the name of the variable on the
	left-hand side of the formula.  For example, <lit>genr x[3] = 30</lit>
	or <lit>genr x[1950:04] = 303.7</lit>.
      </para>

      <para>
	A tip regarding dummy variables: Suppose <lit>x</lit> is coded
	with values 1, 2, or 3 and you want three dummy variables,
	<lit>d1</lit> = 1 if <lit>x</lit> = 1, 0 otherwise, <lit>d2</lit>
	= 1 if <lit>x</lit> = 2, and so on.  To create these you can use
	the commands:
      </para>
      <code>
	    genr d1 = (x=1)
	    genr d2 = (x=2)
	    genr d3 = (x=3)
      </code>

      <table id="tab-genr" title="Examples of use of genr command"
	lhead="Formula" rhead="Comment" lwidth="100pt" rwidth="300pt" 
	style="rpara">
	<row>
	  <cell><lit>y = x1^3</lit></cell>
	  <cell><lit>x1</lit> cubed</cell>
	</row>          
	<row>
	  <cell><lit>y = ln((x1+x2)/x3)</lit></cell>
	  <cell></cell>
	</row>
	<row>
	  <cell><lit>z = x&gt;y</lit></cell>
	  <cell><lit>z(t)</lit> = 1 if <lit>x(t) &gt; y(t)</lit>,
	    otherwise 0</cell>
	</row> 
	<row>
	  <cell><lit>y = x(-2)</lit></cell>
	  <cell><lit>x</lit> lagged 2 periods</cell>
	</row>     
	<row>
	  <cell><lit>y = x(+2)</lit></cell>
	  <cell><lit>x</lit> led 2 periods</cell>
	</row>
	<row>
	  <cell><lit>y = diff(x)</lit></cell>
	  <cell><lit>y(t) = x(t) - x(t-1)</lit></cell>
	</row>
	<row>
	  <cell><lit>y = ldiff(x)</lit></cell>
	  <cell><lit>y(t) = log x(t) - log x(t-1)</lit>, the
	    instantaneous rate of growth of <lit>x</lit></cell>
	</row>
	<row>
	  <cell><lit>y = sort(x)</lit></cell>
	  <cell>sorts <lit>x</lit> in increasing order and stores in
	    <lit>y</lit></cell>
	</row>
	<row>
	  <cell><lit>y = dsort(x)</lit></cell>
	  <cell>sort <lit>x</lit> in decreasing order</cell>
	</row>
	<row>
	  <cell><lit>y = int(x)</lit></cell>
	  <cell>truncate <lit>x</lit> and store its integer value as
	    <lit>y</lit></cell>
	</row>
	<row>
	  <cell><lit>y = abs(x)</lit></cell>
	  <cell>store the absolute values of <lit>x</lit></cell>
	</row>
	<row>
	  <cell><lit>y = sum(x)</lit></cell>
	  <cell>sum <lit>x</lit> values excluding missing <lit>NA</lit>
	    entries</cell>
	</row>
	<row>
	  <cell><lit>y = cum(x)</lit></cell>
	  <cell>cumulation: 
		<equation status="inline"
		  tex="$y_t = \sum_{\tau=1}^t x_{\tau}$"
		  ascii="y(t) = the sum from s=1 to s=t of x(s)"
		  graphic="cumulate"/>
	  </cell>
	</row>
	<row>
	  <cell><lit>aa = $ess</lit></cell>
	  <cell>set <lit>aa</lit> equal to the Error Sum of Squares
	    from last regression</cell>
	</row>
	<row>
	  <cell><lit>x = $coeff(sqft)</lit></cell>
	  <cell>grab the estimated coefficient on the variable
	    <lit>sqft</lit> from the last regression</cell>
	</row>
	<row>
	  <cell><lit>rho4 = $rho(4)</lit></cell>
	  <cell>grab the 4th-order autoregressive coefficient from the
	    last model (presumes an <lit>ar</lit> model)</cell>
	</row>
	<row>
	  <cell><lit>cvx1x2 = $vcv(x1, x2)</lit></cell>
	  <cell>grab the estimated coefficient covariance of vars
	    <lit>x1</lit> and <lit>x2</lit> from the last model</cell>
	</row>
	<row>
	  <cell><lit>foo = uniform()</lit></cell>
	  <cell>uniform pseudo-random variable in range
	    0&ndash;1</cell>
	</row>
	<row>
	  <cell><lit>bar = 3 * normal()</lit></cell>
	  <cell>normal pseudo-random variable, &mu; = 0, &sigma; =
	    3</cell>
	</row>
	<row>
	  <cell><lit>samp = ok(x)</lit></cell>
	  <cell>= 1 for observations where <lit>x</lit> is not
	    missing.</cell>
	</row>
      </table>

    </description>

    <gui-access>
      <menu-path>/Variable/Define new variable</menu-path>
      <other-access>Main window pop-up menu</other-access>
    </gui-access>

  </command>

  <command name="genrand" section="Programming" context="gui"
    label="Generating random variables">

    <description>
      <para>
	In this dialog you must give a name for the variable to be
	created, plus some additional information depending on the
	distribution.
      </para>

      <ilist>
	<li>
	  <para>
	    Uniform: the lower and upper bounds for the distribution.
	  </para>
	</li>
	<li>
	  <para>
	    Normal: the mean and (positive) standard deviation.
	  </para>
	</li>
	<li>
	  <para>
	    Chi-square and Student's t: the degrees of freedom, which must
	    be positive.
	  </para>
	</li>
	<li>
	  <para>
	    F: both numerator and denominator degrees of freedom.
	  </para>
	</li>
	<li>
	  <para>
	    gamma: shape and scale parameters (both positive).
	  </para>
	</li>
	<li>
	  <para>
	    Binomial: the <quote>success</quote> probability and the
	    integer number of trials.
	  </para>
	</li>
	<li>
	  <para>
	    Poisson: the positive mean (which also equals the variance).
	  </para>
	</li>
      </ilist>

      <para>
	If you want to generate repeatable sequences of pseudo-random
	numbers, you can set the seed, under the Tools menu.
      </para>

    </description>
  </command>

  <command name="genseed" section="Programming" context="gui"
    label="Setting the seed for random numbers">

    <description>
      <para>
	The "seed" controls the starting point for the sequence of
	pseudo-random numbers generated in a given gretl session. By
	default the seed is set when the program is started, using the
	system time.  This ensures that you get a different
	sequence of random numbers each time you run the program.  If
	you want to obtain repeatable sequences, you need to set the
	seed manually (and take note of the value you used).
      </para>
      <para>
	Note that whenever you click "OK" in this dialog box, the
	generator is re-started, using the given seed.  So, for
	example, if you (a) set the seed to (say) 147; (b) generate a
	series from the standard normal distribution; (c) revisit
	this dialog and click "OK" again with the seed still at 147;
	then (d) generate a second series from the standard normal
	distribution, the two generated series will be identical.
      </para>
    </description>
  </command>

  <command name="gmm" section="Estimation" label="GMM estimation">

    <usage>
      <options>
	<option>
	  <flag>--two-step</flag>
	  <effect>two step estimation</effect>
	</option>
	<option>
	  <flag>--iterate</flag>
	  <effect>iterated GMM</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>print details of iterations</effect>
	</option>
      </options>
    </usage>

    <description>

      <para>
	Performs Generalized Method of Moments (GMM) estimation using the
	BFGS (Broyden, Fletcher, Goldfarb, Shanno) algorithm. You must
	specify one or more commands for updating the relevant quantities
	(tyically, GMM residuals), one or more sets of orthogonality
	conditions, an initial matrix of weights, and a listing of the
	parameters to be estimated, all enclosed between the tags
	<lit>gmm</lit> and <lit>end gmm</lit>.
      </para>
      <para>
	Please see <guideref targ="chap:gmm"/> for details on this command.
	Here we just illustrate with a simple example.
      </para>
      <code>
	gmm e = y - X*b
	  orthog e ; W
	  weights V
	  params b
	end gmm
      </code>
      <para>
	In the example above we assume that <lit>y</lit> and <lit>X</lit>
	are data matrices, <lit>b</lit> is an appropriately sized vector
	of parameter values, <lit>W</lit> is a matrix of instruments, and
	<lit>V</lit> is a suitable matrix of weights.  The statement
      </para>
      <code>
	orthog e ; W
      </code>
      <para>
	indicates that the residual vector <lit>e</lit> is in principle
	orthogonal to each of the instruments composing the columns of
	<lit>W</lit>.
      </para>

    </description>

    <gui-access>
      <menu-path>/Model/GMM</menu-path>
    </gui-access>

  </command>

  <command name="gnuplot" section="Graphs" 
    label="Create a gnuplot graph" context="cli">

    <usage>
      <arguments>
        <argument>yvars</argument>
        <argument>xvar</argument>
	<argument optional="true">dumvar</argument>
      </arguments>
      <options>
        <option>
	  <flag>--with-lines</flag>
	  <effect>use lines, not points</effect>
        </option>
        <option>
	  <flag>--with-impulses</flag>
	  <effect>use vertical lines</effect>
        </option>
        <option>
	  <flag>--time-series</flag>
	  <effect>plot against time</effect>
        </option>
        <option>
	  <flag>--suppress-fit</flag>
	  <effect>don't show fitted line</effect>
        </option>
        <option>
	  <flag>--linear-fit</flag>
	  <effect>show least squares fit</effect>
        </option>
        <option>
	  <flag>--inverse-fit</flag>
	  <effect>show inverse fit</effect>
        </option>
        <option>
	  <flag>--quadratic-fit</flag>
	  <effect>show quadratic fit</effect>
        </option>
        <option>
	  <flag>--loess-fit</flag>
	  <effect>show loess fit</effect>
        </option>
        <option>
	  <flag>--dummy</flag>
	  <effect>see below</effect>
        </option>
      </options>
      <examples>
        <example>gnuplot y1 y2 x</example>
        <example>gnuplot x --time-series --with-lines</example>
	<example>gnuplot wages educ gender --dummy</example>
      </examples>
    </usage>

    <description>
      <para>
	The variables in the list <repl>yvars</repl> are graphed against
	<repl>xvar</repl>.  For a time series plot you may either
	give <lit>time</lit> as <repl>xvar</repl> or use the option
	flag <lit>--time-series</lit>.
      </para>

      <para>
	If the <lit>--dummy</lit> option is selected, exactly three variables
	should be given: a single <math>y</math> variable, an <math>x</math>
	variable, and <repl>dumvar</repl>, a dummy variable.  The effect is to
	plot <repl>yvar</repl> against <repl>xvar</repl> with the points shown
	in different colors depending on whether the value of
	<repl>dumvar</repl> is 1 or 0 at the given observation.
      </para>

      <para>
	In interactive mode the result is displayed immediately. In
	batch mode a gnuplot command file is written, with a name on
	the pattern <filename>gpttmpN.plt</filename>, starting with N
	= <lit>01</lit>. The actual plots may be generated later using
	<program>gnuplot</program> (under MS Windows,
	<program>wgnuplot</program>).
      </para>

      <para>
	The various <quote>fit</quote> options are applicable only in
	the case of a bivariate scatterplot.  The default behavior
	is to show the OLS fitted line if and only if the slope
	coefficient is significant at the 10 percent level. If the
	<lit>suppress</lit> option is given, no fitted line is shown.
	If the <lit>linear</lit> option is given, the OLS line is
	shown regardless of whether or not it is significant.  The other
	options&mdash;<lit>inverse</lit>, <lit>quadratic</lit> and
	<lit>loess</lit>&mdash;produce respectively an inverse fit
	(regression of <math>y</math> on 1/<math>x</math>), a
	quadratic fit, or a loess fit.  Loess (also sometimes called
	<quote>lowess</quote>) is a robust locally weighted regression.  
      </para>

      <para>
	A further option to this command is available: following
	the specification of the variables to be plotted and the
	option flag (if any), you may add literal gnuplot commands to
	control the appearance of the plot (for example, setting the
	plot title and/or the axis ranges).  These commands should be
	enclosed in braces, and each gnuplot command must be
	terminated with a semi-colon.  A backslash may be used to
	continue a set of gnuplot commands over more than one line.
	Here is an example of the syntax:
      </para>

      <para>
	<lit>{ set title 'My Title'; set yrange [0:1000]; }</lit>
      </para>

    </description>

    <gui-access>
      <menu-path>/View/Graph specified vars</menu-path>
      <other-access>Main window pop-up menu, graph button on toolbar</other-access>
    </gui-access>

  </command>

  <command name="graph" section="Graphs" 
    label="Create ASCII graph" context="cli">

    <usage>
      <arguments>
        <argument>yvars</argument>
        <argument>xvar</argument>
      </arguments>
      <options>
        <option>
	  <flag>--tall</flag>
	  <effect>use 40 rows</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	ASCII graphics.  The <repl>yvars</repl> (which may be given by
	name or number) are  graphed against <repl>xvar</repl> using
	ASCII symbols. The <lit>--tall</lit> flag will produce a graph
	with 40 rows and 60 columns. Without it, the graph will be 20
	by 60 (for screen output).  See also <cmdref targ="gnuplot"/>.
      </para>
    </description>

  </command>

  <command name="graphing" section="Graphs" context="gui"
    label="Graphing">

    <description>

      <para>Gretl calls a separate program, namely gnuplot, to
	generate graphs.  Gnuplot is a very full-featured graphing
	program with myriad options.  Gretl gives you direct access,
	via a graphical interface, to a subset of these options and it
	tries to choose sensible values for you; it also allows you to
	take complete control over graph details if you wish.</para>

      <para>With a graph displayed, you can click on the graph window
	for a pop-up menu with the following options:</para>

      <ilist>
	<li><para>Save as postscript: save the graph in encapsulated
	    postscript (EPS) format</para>
	</li>
	<li><para>Save as PNG: save in Portable Network Graphics
	    format</para>
	</li>
	<li><para>Save to session as icon: the graph will appear in
	    iconic form when you select <quote>Icon view</quote> from
	    the Session menu</para>
	</li>
	<li><para>Zoom: lets you select an area within the graph for
	    closer inspection</para>
	</li>
	<li><para>Print: (on the Gnome desktop and MS Windows only)
	    lets you print the graph directly</para>
	</li>
	<li><para>Copy to clipboard: (MS Windows only) lets you paste
	    the graph into Windows applications such as MS
	    Word</para>
	</li>
	<li><para>Edit: opens a controller for the plot which lets you
	    adjust various aspects of its appearance</para>
	</li>
	<li><para>Close: closes the graph window</para>
	</li>
      </ilist>

      <para>
	If you know something about gnuplot and wish to get finer
	control over the appearance of a graph than is available via
	the graphical controller (<quote>Edit</quote> option), you
	have two further options:
      </para>

      <ilist>
	<li>
	  <para>
	    Once the graph is saved as a session icon, you can
	    right-click on its icon for a further pop-up menu.  One of the
	    options here is <quote>Edit plot commands</quote>, which opens
	    an editing window with the actual gnuplot commands displayed.
	    You can edit these commands and either save them for future
	    processing or send them to gnuplot (with the execute toolbar
	    icon in the plot commands editing window).
	  </para>
	</li>
	<li>
	  <para>
	    Another way to save the plot commands (or to save
	    the displayed plot in formats other than EPS or PNG) is to
	    use <quote>Edit</quote> item on a graph's pop-up menu to
	    invoke the graphical controller, then click on the
	    <quote>Output to file</quote> tab in the controller.  You
	    are then presented with a drop-down menu of formats in
	    which to save the graph.
	  </para>
	</li>
      </ilist>

      <para>
	To find out more about gnuplot, see http://www.gnuplot.info
      </para>

    </description>

  </command>

  <command name="graphpag" section="Graphs" context="gui"
    label="Gretl graph page">

    <description>

      <para>
	The session <quote>graph page</quote> will work only if you have
	the &latex; typesetting system installed, and are able to generate
	and view PDF or PostScript output.
      </para>

      <para>
	In the session icon window, you can drag up to eight graphs onto
	the graph page icon.  When you double-click on the graph page (or
	right-click and select <quote>Display</quote>), a page containing
	the selected graphs will be composed and opened in a suitable
	viewer.  From there you should be able to print the page.
      </para>

      <para>
	To clear the graph page, right-click on its icon and select
	<quote>Clear</quote>.
      </para> 

      <para>
	On systems other than MS Windows, you may have to adjust the
	setting for the program used to view PDF or PostScript files. Find
	that under the <quote>Programs</quote> tab in the gretl
	Preferences dialog box (under the Tools menu in the main window).
      </para>

    </description>

  </command>

  <command name="3-D" section="Graphs" context="gui"
    label="3-dimensional plots">

    <description>
      <para>This feature works best if you have gnuplot 3.8 or higher
	installed.  In that case you can manipulate the 3-D plot with
	the mouse (rotate it, and expand or shrink the axes).</para>

      <para>In composing a 3-D plot, note that the Z-axis will be
	shown as the vertical axis.  Thus if you have some dependent
	variable that you think may be influenced by two independent
	variables, you should put the dependent variable on the
	Z-axis, and the independent variables on the X and Y
	axes.</para>  

      <para>Unlike most other gretl graphs, 3-D plots are controlled
	by gnuplot rather than gretl itself.  The gretl graph-editing
	menu is not available.</para>

    </description>
  </command>

  <command name="gui-htest" section="Tests" context="gui"
    label="Test statistic calculator">

    <description>
      <para>
	Gretl's test calculator computes test statistics and p-values for
	various common hypothesis tests concerning one or two populations.  The
	required input takes the form of sample statistics derived from one or
	two samples, depending on the test chosen.  These statistics can be
	typed in as numerical values.  Alternatively, if you have a data file
	open, you can get gretl to calculate sample statistics for a selected
	variable or variables (in the case of means and variances, but not in
	the case of proportions).
      </para>

      <para>
	If you want to base your test on a variable in the data set, first
	activate this option by checking the box titled "Use variable from
	dataset".  Then the drop-down list of variables will become active and
	you can select a variable.  When you select a variable from the list,
	the relevant statistics are automatically entered in the boxes below.
      </para>

      <para>
	In addition to the simple selection of a variable, you have the option
	of specifying a restriction on the selected variable (that is, defining
	a sub-sample).   For example, suppose you have wage data in a variable
	called "wage" and you also have a dummy variable called "gender" that
	equals 1 for males and 0 for females (or vice versa). Then, in the test
	for the difference of two means, you could select "wage" in both slots,
	but add to the top slot "(gender=0)" and to the bottom "(gender=1)".
	This would then give you a test for the difference between mean male
	income and mean female income.  Note that when you type a restriction in
	this way, you must then press the Enter key to have the sample statistics
	calculated.  
      </para>

      <para>
	The sub-sampling restriction must be placed in parentheses following the
	selected variable, and in general the restriction takes the form "var2
	op value," where var2 is the name of a variable in the current data set,
	val is a numerical value, and op is a comparison operator chosen from =,
	!=, &lt;, &gt;, &lt;= or &gt;= (respectively equality, inequality, less
	than, greater than, less than or equal, and greater than or equal).  The
	spaces around the operator are optional.
      </para>

    </description>
  </command>

  <command name="gui-htest-np" section="Tests" context="gui"
    label="Nonparametric tests">

    <description>
      <para>
	Under the <quote>Difference test</quote> tab you can carry out a
	nonparametric test for a difference between two populations or
	groups, the specific test depending on the option selected.
      </para>
      <para>
	Sign test: This test is based on the fact that if two samples,
	<math>x</math> and <math>y</math>, are drawn randomly
	from the same distribution, the probability that
	<math>x</math><sub>i</sub> &gt;
	<math>y</math><sub>i</sub>, for each observation
	<math>i</math>, should equal 0.5.  The test statistic is
	<math>w</math>, the number of observations for which
	<math>x</math><sub>i</sub> &gt;
	<math>y</math><sub>i</sub>. Under the null hypothesis this
	follows the Binomial distribution with parameters
	(<math>n</math>, 0.5), where <math>n</math> is the
	number of observations.
      </para>
      <para>
	Rank sum test: The Wilcoxon rank-sum test is performed.  This test
	proceeds by ranking the observations from both samples jointly,
	from smallest to largest, then finding the sum of the ranks of the
	observations from one of the samples.  The two samples do not have
	to be of the same size, and if they differ the smaller sample is
	used in calculating the rank-sum.  Under the null hypothesis that
	the samples are drawn from populations with the same median, the
	probability distribution of the rank-sum can be computed for any
	given sample sizes; and for reasonably large samples a close
	Normal approximation exists.
      </para>
      <para>
	Signed rank test: The Wilcoxon signed-rank test is performed.
	This is designed for matched data pairs such as, for example, the
	values of a variable for a sample of individuals before and after
	some treatment.  The test proceeds by finding the differences
	between the paired observations, <math>x</math><sub>i</sub>
	&minus; <math>y</math><sub>i</sub>, ranking these
	differences by absolute value, then assigning to each pair a
	signed rank, the sign agreeing with the sign of the difference.
	One then calculates <math>W</math><sub>+</sub>, the sum of
	the positive signed ranks.  As with the rank-sum test, this
	statistic has a well-defined distribution under the null that the
	median difference is zero, which converges to the Normal for
	samples of reasonable size.
      </para>
      <para>
	Under the <quote>Runs test</quote> tab you can carry out a test
	for the randomness of a given variable, based on the number of
	runs of consecutive positive or negative values.  If you select
	the option <quote>Use first difference</quote>, the variable is
	differenced prior to the analysis and hence the runs are
	interpreted as runs of increasing or decreasing values of the
	original variable.  The test statistic is based on a normal
	approximation to the distribution of the number of runs under
	the null of randomness.
      </para>

    </description>
  </command>   
 
  <command name="hausman" section="Tests"
    label="Panel diagnostics">

    <description>
      <para>
	This test is available only after estimating an OLS model
	using panel data (see also <cmd>setobs</cmd>).  It tests the
	simple pooled model against the principal alternatives, the fixed
	effects and random effects models.
      </para>

      <para>
	The fixed effects model allows the intercept of the regression to
	vary across the cross-sectional units.  An
	<math>F</math>-test is reported for the null hypotheses that
	the intercepts do not differ. The random effects model decomposes
	the residual variance into two parts, one part specific to the
	cross-sectional unit and the other specific to the particular
	observation.  (This estimator can be computed only if the number
	of cross-sectional units in the data set exceeds the number of
	parameters to be estimated.) The Breusch&ndash;Pagan LM statistic
	tests the null hypothesis that the pooled OLS estimator is
	adequate against the random effects alternative.
      </para>

      <para>
	The pooled OLS model may be rejected against both of the
	alternatives, fixed effects and random effects. Provided the
	unit- or group-specific error is uncorrelated with the
	independent variables, the random effects estimator is more
	efficient than the fixed effects estimator; otherwise the
	random effects estimator is inconsistent and the fixed effects
	estimator is to be preferred. The null hypothesis for the
	Hausman test is that the group-specific error is not so
	correlated (and therefore the random effects model is
	preferable).  A low p-value for this test counts against the
	random effects model and in favor of fixed effects.
      </para>
    </description>

    <gui-access>
      <menu-path>Model window, /Tests/Panel diagnostics</menu-path>
    </gui-access>

  </command>

  <command name="hccm" section="Estimation" context="cli"
    label="HCCM estimation">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Heteroskedasticity-Consistent Covariance Matrix: this command
	runs a regression where the coefficients are estimated via the
	standard OLS procedure, but the standard errors of the
	coefficient estimates are computed in a manner that is robust
	in the face of heteroskedasticity, namely using the
	MacKinnon&ndash;White <quote>jackknife</quote> procedure.
      </para>
    </description>

  </command>

  <command name="hccme" section="Estimation" context="gui"
    label="Robust standard errors">

    <description>
      <para>
	You are offered several variant calculations for standard
	errors that are robust in the presence of heteroskedasticity
	(and, in the case of the HAC estimator, autocorrelation).
      </para>

      <para>HC0 produces the original <quote>White's standard
	errors</quote>; HC1, HC2, HC3 and HC3a are subsequent
	variations that are generally reckoned to produce superior
	(more reliable) results.  For details of the estimators, see
	MacKinnon and White (Journal of Econometrics, 1985) or
	Davidson and MacKinnon, Econometric Theory and Methods
	(Oxford, 2004).  The labels given here are those used by
	Davidson and MacKinnon.  Variant <quote>HC3a</quote> is the
	jackknife, as described in MacKinnon and White (1985); HC3 is
	a close approximation to the jackknife.  
      </para>

      <para>If you use the HAC estimator for time-series data, you are
	able to fine-tune the lag-length using the <cmd>set</cmd>
	command.  Please see the gretl manual or the script commands
	help file for details.</para>

      <para>When estimating a model via OLS using panel data, the default
	robust estimator of the covariance matrix is that given by
	Arellano.  The alternative is Beck and Katz's Panel Corrected
	Standard Errors (PCSE).  The latter take into account
	heteroskedastcity but not autocorrelation.  
      </para>

      <para>Two robust estimators of the covariance matrix are
	offered for GARCH models: QML is the Quasi-Maximum Likelihood
	Estimator, and BW is the Bollerslev-Wooldridge estimator.
      </para>

    </description>

  </command>

  <command name="heckit" section="Estimation" context="cli"
    label="Heckman selection model">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
	<argument separated="true">selection equation</argument>
      </arguments>
      <options>
        <option>
	  <flag>--two-step</flag>
	  <effect>perform two-step estimation</effect>
        </option>
        <option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
        </option>
	<option>
	  <flag>--verbose</flag>
	  <effect>print extra output</effect>
        </option>
      </options>      
      <examples>
        <example>heckit y 0 x1 x2 ; ys 0 x3 x4</example>
	<demos>
	  <demo>heckit.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para>
	Heckman-type selection model.  In the specification, the list
	before the semicolon represents the outcome equation, and the
	second list represents the selection equation.  The dependent
	variable in the selection equation (<lit>ys</lit> in the
	example above) must be a binary variable.  </para>

      <para>
	By default, the parameters are estimated by maximum
	likelihood. The covariance matrix of the parameters is
	computed using the negative inverse of the Hessian. If
	two-step estimation is desired, use the <lit>--two-step</lit>
	option. In this case, the covariance matrix of the parameters
	of the outcome equation is appropriately adjusted as per
	Heckman (1979).
      </para>

      <para>
	Please note that in ML estimation a numerical approximation of
	the Hessian is used; this may lead to inaccuracies in the
	estimated covariance matrix if the scale of the explanatory
	variables is such that some of the estimated coefficients are
	very small in absolute value. This problem will be addressed
	in future versions; in the meantime, rescaling the offending
	explanatory variable(s) can be used as a workaround.
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Nonlinear models/Heckit</menu-path>
    </gui-access>

  </command>

  <command name="help" section="Utilities" 
    label="Help on commands" context="cli">

    <usage>
      <altforms>
        <altform><lit>help</lit></altform>
	<altform><lit>help functions</lit></altform>
        <altform><lit>help</lit> <repl>command</repl></altform>
        <altform><lit>help</lit> <repl>function</repl></altform>
      </altforms>
      <options>
	<option>
	  <flag>--func</flag>
	  <effect>select functions help</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	If no arguments are given, prints a list of available commands. If the
	single argument <lit quote="true">functions</lit> is given, prints a
	list of available functions (see <cmdref targ="genr"/>).
      </para>
      <para>
	<lit>help</lit> <repl>command</repl> describes <repl>command</repl>
	(&eg; <lit>help smpl</lit>).  <lit>help</lit> <repl>function</repl> 
	describes <repl>function</repl> (&eg; <lit>help ldet</lit>).
	Some functions have the same names as related commands (&eg;
	<lit>diff</lit>): in that case the default is to print help
	for the command, but you can get help on the function by
	using the <lit>--func</lit> option.
      </para> 
    </description>

    <gui-access>
      <menu-path>/Help</menu-path>
    </gui-access>

  </command>

  <command name="hsk" section="Estimation"
    label="Heteroskedasticity-corrected estimates">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	This command is applicable where heteroskedasticity is present in the
	form of an unknown function of the regressors which can be
	approximated by a quadratic relationship.  In that context it offers
	the possibility of consistent standard errors and more efficient
	parameter estimates as compared with OLS.  
      </para>
      <para>
	The procedure involves (a) OLS estimation of the model of interest,
	followed by (b) an auxiliary regression to generate an estimate of the
	error variance, then finally (c) weighted least squares, using as
	weight the reciprocal of the estimated variance.
      </para>
      <para>
	In the auxiliary regression (b) we regress the log of the squared
	residuals from the first OLS on the original regressors and their
	squares.  The log transformation is performed to ensure that the
	estimated variances are non-negative.  Call the fitted values from
	this regression <math>u</math><sup>*</sup>.  The weight series for the
	final WLS is then formed as 1/exp(<math>u</math><sup>*</sup>).
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Other linear models/Heteroskedasticity corrected</menu-path>
    </gui-access>

  </command>

  <command name="hurst" section="Statistics"
    label="Hurst exponent">

    <usage>
      <arguments>
        <argument>varname</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Calculates the Hurst exponent (a measure of persistence or
	long memory) for a time-series variable having at least 128
	observations.
      </para>

      <para>
	The Hurst exponent is discussed by Mandelbrot.  In theoretical
	terms it is the exponent, <math>H</math>, in the
	relationship 
	<equation status="display" 
	  tex="\[\mathrm{RS}(x) = an^H\]" 
	  ascii="RS(x) = an^H" 
	  graphic="hurst"/>where RS is the <quote>rescaled
	  range</quote> of the variable <math>x</math> in
	samples of size <math>n</math> and <math>a</math>
	is a constant. The rescaled range is the range (maximum minus
	minimum) of the cumulated value or partial sum of
	<math>x</math> over the sample period (after subtraction
	of the sample mean), divided by the sample standard deviation.
      </para>

      <para>
	As a reference point, if <math>x</math> is white noise
	(zero mean, zero persistence) then the range of its cumulated
	<quote>wandering</quote> (which forms a random walk), scaled
	by the standard deviation, grows as the square root of the
	sample size, giving an expected Hurst exponent of 0.5.  Values
	of the exponent significantly in excess of 0.5 indicate
	persistence, and values less than 0.5 indicate
	anti-persistence (negative autocorrelation).  In principle the
	exponent is bounded by 0 and 1, although in finite samples it
	is possible to get an estimated exponent greater than 1.  
      </para>

      <para>
	In gretl, the exponent is estimated using binary sub-sampling:
	we start with the entire data range, then the two halves of
	the range, then the four quarters, and so on.  For sample
	sizes smaller than the data range, the RS value is the mean
	across the available samples.  The exponent is then estimated
	as the slope coefficient in a regression of the log of RS on
	the log of sample size.
      </para>

    </description>

    <gui-access>
      <menu-path>/Variable/Hurst exponent</menu-path>
    </gui-access>

  </command>

  <command name="if" section="Programming" label="Flow control" context="cli">

    <description>
      <para>Flow control for command execution.  Three sorts of
	construction are supported, as follows.
      </para>
      <pre>
	<lit># simple form</lit>&par;
	<lit>if</lit> <repl>condition</repl>&par;
	<lit> </lit><lit> </lit> <repl>commands</repl>&par;
	<lit>endif</lit>
      </pre>

      <pre>
	<lit># two branches</lit>&par;
	<lit>if</lit> <repl>condition</repl>&par;
	<lit> </lit><lit> </lit> <repl>commands1</repl>&par;
	<lit>else</lit>&par;
	<lit> </lit><lit> </lit> <repl>commands2</repl>&par;
	<lit>endif</lit>
      </pre>

      <pre>
	<lit># three or more branches</lit>&par;
	<lit>if</lit> <repl>condition1</repl>&par;
	<lit> </lit><lit> </lit> <repl>commands1</repl>&par;
	<lit>elif</lit> <repl>condition2</repl>&par;
	<lit> </lit><lit> </lit> <repl>commands2</repl>&par;
	<lit>else</lit>&par;
	<lit> </lit><lit> </lit> <repl>commands3</repl>&par;
	<lit>endif</lit>
      </pre>

      <para>
	<repl quote="true">condition</repl> must be a Boolean expression, for
	the syntax of which see <cmdref targ="genr"/>.  More than one
	<cmd>elif</cmd> block may be included.  In addition, <lit>if</lit>
	&hellip; <lit>endif</lit> blocks may be nested.
      </para>
    </description>

  </command>

  <command name="include" section="Programming" 
    label="Include function definitions" context="cli">

    <usage>
      <arguments>
        <argument>inputfile</argument>
      </arguments>
      <examples>
        <example>include myfile.inp</example>
        <example>include sols.gfn</example>
      </examples>
    </usage>

    <description>
      <para>
	Intended for use in a command script, primarily for including definitions of
	functions.  Executes the commands in <repl>inputfile</repl> then returns
	control to the main script. To include a packaged function, be
	sure to include the filename extension.
      </para>
      <para>
	See also <cmdref targ="run"/>.
      </para>
    </description>

  </command>

  <command name="info" section="Dataset" 
    label="Information on data set" context="cli">

    <description>
      <para>
	Prints out any supplementary information stored with the
	current datafile.
      </para>
    </description>

    <gui-access>
      <menu-path>/Data/Read info</menu-path>
      <other-access>Data browser windows</other-access>
    </gui-access>

  </command>

  <command name="irfboot" section="Graphs" context="gui"
    label="Impulse response bootstrap">

    <description>
      <para>If you select the bootstrap confidence interval when plotting
	impulse responses, gretl computes a 95 percent confidence interval for
	the responses using the bootstrap method.  The residuals from the
	original VAR (or VECM) are resampled with replacement; an artificial
	dataset is constructed based on the original parameter estimates and the
	resampled residuals; the system is re-estimated and the impulse
	responses are re-evaluated.  This is repeated 999 times and the 0.025
	and 0.975 quantiles for the responses are found and plotted along with
	the point estimates.
      </para>
      <para>
	The bootstrap option is not currently available for restricted VECMs.
      </para>

    </description>

  </command>

  <command name="kpss" section="Tests" label="KPSS stationarity test">

    <usage>
      <arguments>
        <argument>order</argument>
        <argument>varlist</argument>
      </arguments>
      <options>
	<option>
	  <flag>--trend</flag>
	  <effect>include a trend</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>print regression results</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>suppress printing of results</effect>
	</option>
	<option>
	  <flag>--difference</flag>
	  <effect>use first difference of variable</effect>
	</option>
      </options>
      <examples>
	<example>kpss 8 y</example>
        <example>kpss 4 x1 --trend</example>
      </examples>
    </usage>

    <description>

      <para context="gui">
	Computes the KPSS test (Kwiatkowski, Phillips, Schmidt and Shin,
	1992) for stationarity of the given variable (or its first
	difference, if the differencing option is selected).  The null
	hypothesis is that the variable in question is stationary, either
	around a level or, if the <quote>include a trend</quote> box is
	checked, around a deterministic linear trend.  
      </para>

      <para context="cli">
	Computes the KPSS test (Kwiatkowski, Phillips, Schmidt and Shin,
	1992) for stationarity, for each of the specified variables (or
	their first difference, if the <lit>--difference</lit> option is
	selected). The null hypothesis is that the variable in question is
	stationary, either around a level or, if the <lit>--trend</lit>
	option is given, around a deterministic linear trend.  
      </para>

      <para context="gui">
	The selected lag order determines the size of the window used
	for Bartlett smoothing.  If the <quote>show regression
	  results</quote> box is checked the results of the auxiliary
	regression are printed, along with the estimated variance of
	the random walk component of the variable.
      </para>

      <para context="cli">
	The order argument determines the size of the window used for
	Bartlett smoothing.  If the <lit>--verbose</lit> option is
	chosen the results of the auxiliary regression are printed,
	along with the estimated variance of the random walk component
	of the variable.
      </para>

    </description>

    <gui-access>
      <menu-path>/Variable/KPSS test</menu-path>
    </gui-access>

  </command>

  <command name="labels" section="Dataset" 
    label="Print labels for variables" context="cli">

    <description>
      <para>
	Prints out the informative labels for any variables that have
	been generated using <cmd>genr</cmd>, and any labels added to
	the data set via the GUI.
      </para>
    </description>

  </command>

  <command name="lad" section="Estimation"
    label="Least Absolute Deviation estimation">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
        <option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Calculates a regression that minimizes the sum of the absolute
	deviations of the observed from the fitted values of the
	dependent variable.  Coefficient estimates are derived using
	the Barrodale&ndash;Roberts simplex algorithm; a warning is
	printed if the solution is not unique.
      </para>
      <para>
	Standard errors are derived using the bootstrap procedure with
	500 drawings. The covariance matrix for the parameter
	estimates, printed when the <lit>--vcv</lit> flag is given, is
	based on the same bootstrap.
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Robust estimation/Least Absolute Deviation</menu-path>
    </gui-access>

  </command>

  <command name="lags" section="Transformations" 
    label="Create lags" context="cli">

    <usage>
      <altforms>
        <altform><lit>lags</lit> <repl>varlist</repl></altform>
	<altform><lit>lags</lit> <repl>order</repl> <lit>;</lit> <repl>varlist</repl></altform>
      </altforms>
      <examples>
	<example>lags x y</example>
	<example>lags 12 ; x y</example>
      </examples>
    </usage>

    <description>
      <para>
	Creates new variables which are lagged values of each of the variables in
	<repl>varlist</repl>.  By default the number of lagged variables equals the
	periodicity of the data. For example, if the periodicity is 4 (quarterly),
	the command <cmd>lags x</cmd> creates
      </para>
      <code>
	x_1 = x(t-1)
	x_2 = x(t-2)
	x_3 = x(t-3)
	x_4 = x(t-4)
      </code>
      <para>
	The number of lags created can be controlled by the optional
	first parameter.
      </para>
    </description>

    <gui-access>
      <menu-path>/Add/Lags of selected variables</menu-path>
    </gui-access>

  </command>

  <command name="lags-dialog" section="Estimation" context="gui"
    label="Lag selection box">

    <description>
      <para>
	In this dialog you can select the lag order for the independent
	variables in a time-series model, and in some cases for the dependent
	variable also.  (But note that the common lag order for vector models
	such as VARs and VECMs is handled separately, via a selection spinner in
	the main model dialog box.)
      </para>

      <para>
	The spinners on the left let you select a range of consecutive lags for
	any given variable. To specify non-consecutive lags, click the check box
	next to the entry field titled <quote>specific lags</quote>.  This
	activates the entry box, into which you can type a list of lags,
	separated by spaces.
      </para>

      <para>
	The row marked <quote>default</quote> offers a quick way to set a common
	lag specification for all the independent variables: values set in that
	row are copied to all the others (apart from the dependent variable, if
	present).  
      </para>

      <para>
	The dependent variable is treated specially: the minimum lag must be
	zero, which places the current value of the variable on the left-hand
	side of the model.  Any higher lags appear with the independent
	variables on the right-hand side of the model.
      </para>

      <para>
	Values selected in this dialog are remembered for the duration of your
	session with a given dataset.
      </para>

    </description>

  </command>

  <command name="ldiff" section="Transformations" 
    label="Log-differences" context="cli">

    <usage>
      <arguments>
        <argument>varlist</argument>
      </arguments>
    </usage>

    <description>
      <para>
	The first difference of the natural log of each variable in
	<repl>varlist</repl> is obtained and the result stored in a
	new variable with the prefix <lit>ld_</lit>.  Thus <cmd>ldiff
	  x y</cmd> creates the new variables
      </para>
      <code>
	ld_x = log(x) - log(x(-1))
	ld_y = log(y) - log(y(-1))
      </code>
    </description>

    <gui-access>
      <menu-path>/Add/Log differences of selected variables</menu-path>
    </gui-access>

  </command>

  <command name="leverage" section="Tests"
    label="Influential observations">

    <usage>
      <options>
        <option>
	  <flag>--save</flag>
	  <effect>save variables</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Must immediately follow an <cmd>ols</cmd> command. Calculates
	the leverage (<math>h</math>, which must lie in the
	range 0 to 1) for each data point in the sample on which the
	previous model was estimated.  Displays the residual
	(<math>u</math>) for each observation along with its
	leverage and a measure of its influence on the estimates, 
	  <equation status="inline" 
	  tex="$uh/(1 - h)$"
	  ascii="u*h/(1-h)"
	  graphic="influence"/>. <quote>Leverage points</quote> for
	which the value of <math>h</math> exceeds
	2<math>k</math>/<math>n</math> (where
	<math>k</math> is the number of parameters being
	estimated and <math>n</math> is the sample size) are
	flagged with an asterisk.  For details on the concepts of
	leverage and influence see Davidson and MacKinnon (1993,
	Chapter 2).
      </para>

      <para>
	DFFITS values are also shown: these are <quote>studentized
	  residuals</quote> (predicted residuals divided by their
	standard errors) multiplied by 
	  <equation status="inline" 
	  tex="$\sqrt{h/(1 - h)}$"
	  ascii="sqrt[h/(1 - h)]"
	  graphic="dffit"/>. For a discussion of studentized residuals
	and DFFITS see G. S. Maddala, <book>Introduction to
	  Econometrics</book>, chapter 12; also Belsley, Kuh and
	Welsch (1980).
      </para>
      <para>
	Briefly, a <quote>predicted residual</quote> is the difference
	between the observed value of the dependent variable at
	observation <math>t</math>, and the fitted value for
	observation <math>t</math> obtained from a regression in
	which that observation is omitted (or a dummy variable with
	value 1 for observation <math>t</math> alone has been
	added); the studentized residual is obtained by dividing the
	predicted residual by its standard error.
      </para>

      <para context="cli">If the <lit>--save</lit> flag is given with
	this command, then the leverage, influence and DFFITS values
	are added to the current data set.</para>

      <para context="gui">
	The "+" icon at the top of the leverage test window brings up
	a dialog box that allows you to save one or more of the test
	variables to the current data set.</para>

    </description>

    <gui-access>
      <menu-path>Model window, /Tests/Influential observations</menu-path>
    </gui-access>

  </command>

  <command name="lmtest" section="Tests" label="LM tests">

    <usage>
      <arguments>
        <argument optional="true">order</argument>
      </arguments>
      <options>
        <option>
	  <flag>--logs</flag>
	  <effect>non-linearity, logs</effect>
        </option>
        <option>
	  <flag>--autocorr</flag>
	  <effect>serial correlation</effect>
        </option>
        <option>
	  <flag>--arch</flag>
	  <effect>ARCH</effect>
        </option>
        <option>
	  <flag>--squares</flag>
	  <effect>non-linearity, squares</effect>
        </option>
        <option>
	  <flag>--white</flag>
	  <effect>heteroskedasticity, White's test</effect>
        </option>
        <option>
	  <flag>--breusch-pagan</flag>
	  <effect>heteroskedasticity, Breusch&ndash;Pagan</effect>
        </option>
        <option>
	  <flag>--robust</flag>
	  <effect>robust variance estimate for Breusch&ndash;Pagan</effect>
        </option>
        <option>
	  <flag>--panel</flag>
	  <effect>heteroskedasticity, groupwise</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>don't print auxiliary regression</effect>
        </option>
      </options>
    </usage>

    <description context="gui">
      <para>
	Under this heading fall several hypothesis tests.  What they have in
	common is that the test involves the estimation of an auxiliary
	regression, where the dependent variable is the residual from some
	<quote>original</quote> regression.  The right-hand side variables
	include those from the original regression, along with some additional
	terms.  In most cases the test statistic is calculated as (sample size
	* R-squared) from the auxiliary regression: this is distributed as
	chi-square with degrees of freedom equal to the number of additional
	terms, under the null hypothesis that the additional terms have no
	explanatory power over the residual.  A <quote>large</quote>
	chi-square value (small p-value) suggests that this null hypothesis
	should be rejected.
      </para>
    </description>

    <description context="cli">
      <para>
	Must immediately follow an estimation command. Depending on the option
	given, this command carries out one of the following: a Lagrange
	Multiplier test for nonlinearity (logs or squares); White's test or
	the Breusch&ndash;Pagan test for heteroskedasticity; the LMF test for
	serial correlation (Kiviet, 1986); or a test for ARCH (Autoregressive
	Conditional Heteroskedasticity; see also the <cmd>arch</cmd> command).
	Most of the options are only available for models estimated via OLS,
	but see below for details regarding two-stage least squares.  
      </para>
      <para>
	The optional <lit>order</lit> argument is relevant only in case
	the <lit>--autocorr</lit> or <lit>--arch</lit> options are
	selected.  The default is to run these tests using a lag order
	equal to the periodicity of the data, but this can be adjusted by
	supplying a specific lag order.
      </para>
      <para>
	The <lit>--robust</lit> option applies only when the
	Breusch&ndash;Pagan test is selected; its effect is to use the robust
	variance estimator proposed by Koenker (1981), making the test less
	sensitive to the assumption of normality.
      </para>
      <para>
	The <lit>--panel</lit> option is available only when the model
	is estimated on panel data: in this case a test for groupwise
	heteroskedasticity is performed (that is, for a differing
	error variance across the cross-sectional units).
      </para>
      <para>
	By default, the program prints the auxiliary regression on which
	the test statistic is based.  This may be suppressed by using the
	<lit>--quiet</lit> flag.  The test statistic and its p-value may
	be retrieved using the accessors <lit>$test</lit> and
	<lit>$pvalue</lit> respectively.
      </para>
      <para>
	When a model has been estimated by two-stage least squares (see
	<cmdref targ="tsls"/>), the LM principle breaks down and gretl offers
	some equivalents: the <flag>--autocorr</flag> option computes
	Godfrey's test for autocorrelation (Godfrey, 1994) while the
	<flag>--white</flag> option yields the HET1 heteroskedasticity test
	(Pesaran and Taylor, 1999).
      </para>
    </description>

    <gui-access>
      <menu-path>Model window, /Tests</menu-path>
    </gui-access>

  </command>

  <command name="logistic" section="Estimation"
    label="Logistic regression">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
	<argument optional="true" flag="ymax=">value</argument>
      </arguments>
      <options>
	<option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
	</option>
      </options>
      <examples>
        <example>logistic y const x</example>
        <example>logistic y const x ymax=50</example>
      </examples>
    </usage>

    <description>
      <para>
	Logistic regression: carries out an OLS regression using the
	logistic transformation of the dependent variable,
	<equation status="display" 
	  tex="\[\log\left(\frac{y}{y^*-y}\right)\]"
	  ascii="log(y/(y* - y))"
	  graphic="logistic1"/>
      </para>

      <para context="cli">The dependent variable must be strictly
	positive.  If it is a decimal fraction, between 0 and 1, the
	default is to use a <math>y</math><sup>*</sup> value
	(the asymptotic maximum of the dependent variable) of 1. If
	the dependent variable is a percentage, between 0 and 100, the
	default <math>y</math><sup>*</sup> is 100.
      </para>

      <para context="cli">
	If you wish to set a different maximum, use the optional
	<lit>ymax=</lit><repl>value</repl> syntax following the list of
	regressors.  The supplied value must be greater than all of the observed
	values of the dependent variable.
      </para>

      <para context="gui">
	You are presented with a dialog box that allows you to specify a
	different maximum if you wish.  The supplied
	<math>y</math><sup>*</sup> value must be greater than all of
	the observed values of the dependent variable.
      </para>

      <para>The fitted values and residuals from the regression are
	automatically transformed using 	  
	<equation status="display" 
	  tex="\[y=\frac{y^*}{1+e^{-x}}\]"
	  ascii="y = y* / (1 + exp(-x))"
	  graphic="logistic2"/> where <math>x</math> represents
	either a fitted value or a residual from the OLS regression
	using the transformed dependent variable.  The reported values
	are therefore comparable with the original dependent
	variable.</para>

      <para>
	Note that if the dependent variable is binary, you should
	use the <cmdref targ="logit"/> command instead.
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Nonlinear models/Logistic</menu-path>
    </gui-access>

  </command>

  <command name="logit" section="Estimation"
    label="Logit regression">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--robust</flag>
	  <effect>robust standard errors</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>print details of iterations</effect>
	</option>
	<option>
	  <flag>--p-values</flag>
	  <effect>show p-values instead of slopes</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	If the dependent variable is a binary variable (all values are 0
	or 1) maximum likelihood estimates of the coefficients on
	<repl>indepvars</repl> are obtained via the <quote>binary response
	  model regression</quote> (BRMR) method outlined by Davidson and
	MacKinnon (2004). As the model is nonlinear the slopes depend on
	the values of the independent variables.  By default the slopes
	with respect to each of the independent variables are calculated
	(at the means of those variables) and these slopes replace the
	usual p-values in the regression output.  This behavior can be
	suppressed my giving the <lit>--p-values</lit> option. The
	chi-square statistic tests the null hypothesis that all
	coefficients are zero apart from the constant.
      </para>
      <para context="cli">
	By default, standard errors are computed using the negative
	inverse of the Hessian.  If the <lit>--robust</lit> flag is given,
	then QML or Huber&ndash;White standard errors are calculated
	instead. In this case the estimated covariance matrix is a
	<quote>sandwich</quote> of the inverse of the estimated Hessian
	and the outer product of the gradient. See Davidson and MacKinnon
	(2004, Chapter 10) for details.
      </para>
      <para context="gui">
	By default, standard errors are computed using the negative
	inverse of the Hessian.  If the "Robust standard errors" box is
	checked, then QML or Huber&ndash;White standard errors are
	calculated instead. In this case the estimated covariance matrix
	is a <quote>sandwich</quote> of the inverse of the estimated
	Hessian and the outer product of the gradient.  See Davidson and
	MacKinnon (2004, Chapter 10) for details.
      </para>
      <para>
	If the dependent variable is not binary but is discrete, then Ordered
	Logit estimates are obtained.  (If the variable selected as dependent
	is not discrete, an error is flagged.)
      </para>
      <para>
	If you want to use logit for analysis of proportions (where
	the dependent variable is the proportion of cases having a
	certain characteristic, at each observation, rather than a 1
	or 0 variable indicating whether the characteristic is present
	or not) you should not use the <cmd>logit</cmd> command, but
	rather construct the logit variable, as in
      </para>
      <code>
	genr lgt_p = log(p/(1 - p))
      </code>
      <para>and use this as the dependent variable in an OLS regression.  
	See Ramanathan (2002, Chapter 12).
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Nonlinear models/Logit</menu-path>
    </gui-access>

  </command>

  <command name="logs" section="Transformations" 
    label="Create logs" context="cli">

    <usage>
      <arguments>
        <argument>varlist</argument>
      </arguments>
    </usage>

    <description>
      <para>
	The natural log of each of the variables in <repl>varlist</repl>
	is obtained and the result stored in a new variable with the
	prefix <lit>l_</lit> (<quote>el</quote> underscore).  For example,
	<cmd>logs x y</cmd> creates the new variables <lit>l_x</lit> =
	ln(<lit>x</lit>) and <lit>l_y</lit> = ln(<lit>y</lit>).
      </para>
    </description>

    <gui-access>
      <menu-path>/Add/Logs of selected variables</menu-path>
    </gui-access>

  </command>

  <command name="loop" section="Programming" 
    label="Start a command loop" context="cli">

    <usage>
      <arguments>
        <argument>control</argument>
      </arguments>
      <options>
	<option>
	  <flag>--progressive</flag>
	  <effect>enable special forms of certain commands</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>report details of genr commands</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>do not report number of iterations performed</effect>
	</option>
      </options>
      <examples>
        <example>loop 1000</example>
	<example>loop 1000 --progressive</example>
        <example>loop while essdiff > .00001</example>
        <example>loop for i=1991..2000</example>
        <example>loop for (r=-.99; r&lt;=.99; r+=.01)</example>
      </examples>
    </usage>

    <description>
      <para>The parameter <repl quote="true">control</repl> must take
	one of four forms, as shown in the examples: an integer number
	of times to repeat the commands within the loop;
	<quote><lit>while</lit></quote> plus a numerical condition;
	<quote><lit>for</lit></quote> plus a range of values for the
	internal index variable <lit>i</lit>; or
	<quote><lit>for</lit></quote> plus three expressions in
	parentheses, separated by semicolons.  In the last form the
	left-hand expression initializes a variable, the middle
	expression sets a condition for iteration to continue, and the
	right-hand expression sets an increment or decrement to be
	applied at the start of the second and subsequent iterations.
	(This is a restricted form of the <lit>for</lit> statement in
	the C programming language.)
      </para>

      <para>This command opens a special mode in which the program
	accepts commands to be executed repeatedly.  You exit the mode
	of entering loop commands with <cmd>endloop</cmd>: at this
	point the stacked commands are executed.
      </para>

      <para>See <guideref targ="chap:looping"/> for further details and
	examples.  The effect of the <lit>--progressive</lit> option
	(which is designed for use in Monte Carlo simulations) is
	explained there. Not all gretl commands may be used within
	a loop; the commands available in this context are also
	set out there.
      </para>
    </description>

  </command>

  <command name="mahal" section="Statistics" 
    label="Mahalanobis distances">

    <usage>
      <arguments>
        <argument>varlist</argument>
      </arguments>
      <options>
	<option>
	  <flag>--save</flag>
	  <effect>add distances to the dataset</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	The Mahalanobis distance is the distance between two points in
	an <math>k</math>-dimensional space, scaled by the
	statistical variation in each dimension of the space.  For
	example, if <math>p</math> and <math>q</math> are
	two observations on a set of <math>k</math> variables
	with covariance matrix <math>C</math>, then the
	Mahalanobis distance between the observations is given by
	<equation status="display"
        tex="\[\sqrt{(p-q)^{\prime}C^{-1}(p-q)}\]"
        ascii="sqrt((p - q)' * C-inverse * (p - q))"
          graphic="mahal"/>where 
	<equation status="inline" tex="$(p-q)$" ascii="(p - q)" graphic="mahal2"/> is a
	<math>k</math>-vector. This reduces to Euclidean
	distance if the covariance matrix is the identity
	matrix.</para>

      <para>The space for which distances are computed is defined by
	the selected variables.  For each observation in the current
	sample range, the distance is computed between the observation
	and the centroid of the selected variables.  This distance is
	the multidimensional counterpart of a standard
	<math>z</math>-score, and can be used to judge whether a
	given observation <quote>belongs</quote> with a group of other
	observations.
      </para>

      <para context="cli">If the <lit>--vcv</lit> option is given, the
	covariance matrix and its inverse are printed.  If the
	<lit>--save</lit> option is given, the distances are saved to
	the dataset under the name <lit>mdist</lit> (or
	<lit>mdist1</lit>, <lit>mdist2</lit> and so on if there is
	already a variable of that name).
      </para>

      <para context="gui">If the number of variables selected is 4 or
	less, the covariance matrix and its inverse are printed.
	Clicking the "+" button at the top of the window displaying
	the distances give you the option of adding the distances to
	the dataset as a new variable.
      </para>

    </description>

    <gui-access>
      <menu-path>/View/Mahalanobis distances</menu-path>
    </gui-access>

  </command>  

  <command name="markers" section="Dataset" context="gui"
    label="Add case markers">

    <description>
      <para>
	This command needs the name of a file containing <quote>case
	  markers</quote>, that is, short identifying strings for the
	individual observations in the data set (for example, country
	or city names or codes).  These marker strings should be no
	more than 8 characters long.  The file should contain one
	marker per line, and there should be just as many markers as
	observations in the current dataset. If these conditions are
	met and the specified file is found, the case markers will be
	added; they will be visible when you choose <quote>Display
	  values</quote> under gretl's Data menu.</para>
    </description>
  </command>

  <command name="meantest" section="Tests"
    label="Difference of means">

    <usage>
      <arguments>
        <argument>var1</argument>
        <argument>var2</argument>
      </arguments>
      <options>
        <option>
	  <flag>--unequal-vars</flag>
	  <effect>assume variances are unequal</effect>
        </option>
      </options>
    </usage>

    <description>
      <para context="cli">
	Calculates the <math>t</math> statistic for the null
	hypothesis that the population means are equal for the
	variables <repl>var1</repl> and <repl>var2</repl>, and shows
	its p-value.
      </para>
      <para>
	By default the test statistic is calculated on the assumption
	that the variances are equal for the two variables; with the
	<lit>--unequal-vars</lit> option the variances are assumed to
	be different.  This will make a difference to the test
	statistic only if there are different numbers of non-missing
	observations for the two variables.
      </para>
      <para context="gui">
	Calculates the t statistic for the null hypothesis that the
	population means are equal for two selected variables, and
	shows its p-value.  The command may be called with or without
	the assumption that the variances are equal for the two
	variables (although this will make a difference to the test
	statistic only if there are different numbers of non-missing
	observations for the two variables.)</para>
    </description>

    <gui-access>
      <menu-path>/Model/Bivariate tests/Difference of means</menu-path>
    </gui-access>

  </command>

  <command name="missing" section="Dataset" context="gui"
    label="Missing data values">

    <description>
      <para>Set a numerical value that will be interpreted as
	<quote>missing</quote> or <quote>not available</quote>, either
	for a particular data series (under the Variable menu) or
	globally for the entire data set (under the Sample
	menu).</para> 

      <para>Gretl has its own internal coding for missing values, but
	sometimes imported data may employ a different code.  For
	example, if a particular series is coded such that a value of
	-1 indicates <quote>not applicable</quote>, you can select
	<quote>Set missing value code</quote> under the Variable menu
	and type in the value <quote>-1</quote> (without the quotes).
	Gretl will then read the -1s as missing observations.</para>
    </description>
  </command>

  <command name="mle" section="Estimation"
    label="Maximum likelihood estimation">

    <usage>
      <arguments>
        <argument>log-likelihood function</argument>
        <argument>derivatives</argument>
      </arguments>
      <options>
	<option>
	  <flag>--quiet</flag>
	  <effect>don't show estimated model</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
	</option>
	<option>
	  <flag>--hessian</flag>
	  <effect>base covariance matrix on the Hessian</effect>
	</option>
	<option>
	  <flag>--robust</flag>
	  <effect>QML covariance matrix</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>print details of iterations</effect>
	</option>
      </options>
      <examples>
	<demos>
	  <demo>weibull.inp</demo>
	</demos>
      </examples>
    </usage>

    <description context="gui">

      <para>Performs Maximum Likelihood (ML) estimation using the BFGS
	(Broyden, Fletcher, Goldfarb, Shanno) algorithm. You must
	specify the log-likelihood function; it is recommended that you
	also supply expressions for the derivatives of this function
	with respect to each of the parameters if possible.</para>

      <para>Simple example: Suppose we have a series <lit>X</lit> with values 0
	or 1 and we wish to obtain the maximum likelihood estimate of the
	probability, <lit>p</lit>, that <lit>X</lit> = 1.  (In this simple case
	we can guess in advance that the ML estimate of <lit>p</lit> will simply
	equal the proportion of Xs equal to 1 in the sample.)
      </para>

      <para>The parameter <lit>p</lit> must first be added to the dataset and
	given an initial value.  This can be done using the genr command or via
	menu choices.  Appropriate <quote>genr</quote> lines may be typed into
	the MLE specification window prior to the specification of the
	log-likelihood function.</para>

      <para>In the MLE window we type the following
	lines:</para>
      <code>
	loglik = X*log(p) + (1-X)*log(1-p)
	deriv p = X/p - (1-X)/(1-p)
      </code>

      <para>
	The first line specifies the log-likelihood function, and the
	next line supplies the derivative of that function with
	respect to the parameter p.  If no "deriv" lines are given, a
	numerical approximation to the derivatives is computed.
      </para>

      <para>
	If the parameter p was not previously declared we could
	preface the above lines with something like the following:
      </para>
      <code>
	genr p = 0.5
      </code>

      <para>
	By default, standard errors are based on the Outer Product of the
	Gradient.  If the robust standard errors box is checked, a QML
	estimator is used (namely, a sandwich of the negative inverse of
	the Hessian and the covariance matrix of the gradient).  The
	Hessian is approximated numerically.
      </para>

    </description>

    <description context="cli">

      <para>
	Performs Maximum Likelihood (ML) estimation using the BFGS
	(Broyden, Fletcher, Goldfarb, Shanno) algorithm. The user must
	specify the log-likelihood function.  The parameters of this
	function must be declared and given starting values (using the
	<cmd>genr</cmd> command) prior to estimation.  Optionally, the
	user may specify the derivatives of the log-likelihood
	function with respect to each of the parameters; if analytical
	derivatives are not supplied, a numerical approximation is
	computed.
      </para>

      <para>Simple example: Suppose we have a series <lit>X</lit> with values 0
	or 1 and we wish to obtain the maximum likelihood estimate of the
	probability, <lit>p</lit>, that <lit>X</lit> = 1.  (In this simple case
	we can guess in advance that the ML estimate of <lit>p</lit> will simply
	equal the proportion of Xs equal to 1 in the sample.)
      </para>

      <para>The parameter <lit>p</lit> must first be added to the dataset and
	given an initial value.  This can be done using the genr
	command.  For example, <lit>genr p = 0.5</lit>.
      </para>

      <para>We then construct the MLE command block:</para>
      <code>
	mle loglik = X*log(p) + (1-X)*log(1-p)
	  deriv p = X/p - (1-X)/(1-p)
	end mle
      </code>

      <para>
	The first line above specifies the log-likelihood function. It
	starts with the keyword <lit>mle</lit>, then a dependent
	variable is specified and an expression for the log-likelihood
	is given (using the same syntax as in the <cmd>genr</cmd>
	command).  The next line (which is optional) starts with the
	keyword <lit>deriv</lit> and supplies the derivative of
	the log-likelihood function with respect to the parameter
	<lit>p</lit>. If no derivatives are given, you should include
	a statement using the keyword <lit>params</lit> which
	identifies the free parameters: these are listed on one line,
	separated by spaces.  For example, the above could be changed
	to:
      </para>
      <code>
	mle loglik = X*log(p) + (1-X)*log(1-p)
	  params p
	end mle
      </code>
      <para>
	in which case numerical derivatives would be used.
      </para>

      <para>
	Note that any option flags should be appended to the ending line
	of the MLE block.
      </para>

      <para>
	By default, estimated standard errors are based on the Outer
	Product of the Gradient.  If the <lit>--hessian</lit> option is
	given, they are instead based on the negative inverse of the
	Hessian (which is approximated numerically).  If the
	<lit>--robust</lit> option is given, a QML estimator is used
	(namely, a sandwich of the negative inverse of the Hessian and the
	covariance matrix of the gradient). 
      </para>

    </description>

    <gui-access>
      <menu-path>/Model/Maximum likelihood</menu-path>
    </gui-access>

  </command>

  <command name="modeltab" section="Utilities"
    label="The model table">

    <usage>
      <arguments>
        <argument>add</argument>
        <argument alternate="true">show</argument>
        <argument alternate="true">free</argument>
      </arguments>
    </usage>

    <description context="gui"> 
      <para>
	In econometric research it is common to estimate several
	models with a common dependent variable&mdash;the models
	differing in respect of which independent variables are
	included, or perhaps in respect of the estimator used.  In
	this situation it is convenient to present the regression
	results in the form of a table, where each column contains the
	results (coefficient estimates and standard errors) for a
	given model, and each row contains the estimates for a given
	variable across the models.</para>

      <para>Gretl provides a means of constructing such a table (and
	copying it in plain text, &latex; or Rich Text Format).  Here is
	how to do it:</para>

      <nlist>
	<li><para>Estimate a model which you wish to include in the
	    table, and in the model display window, under the File
	    menu, select <quote>Save to session as icon</quote> or
	    <quote>Save as icon and close</quote>.</para>
	</li>

	<li><para>Repeat step 1 for the other models to be included in
	    the table (up to a total of six models).</para>
	</li>

	<li><para>When you are done estimating the models, open the
	    icon view of your gretl session (by selecting <quote>icon
	      view</quote> under the Session menu in the main gretl
	    window, or by clicking the <quote>session icon
	      view</quote> icon on the gretl toolbar).</para>
	</li>

	<li><para>In session icon view, there is an icon labeled
	    <quote>Model table</quote>. Decide which model you wish to
	    appear in the left-most column of the model table and add
	    it to the table, either by dragging its icon onto the
	    Model table icon, or by right-clicking on the model icon
	    and selecting <quote>Add to model table</quote> from the
	    pop-up menu.</para>
	</li>

	<li><para>Repeat step 4 for the other models you wish to
	    include in the table.  The second model selected will
	    appear in the second column from the left, and so
	    on.</para>
	</li>

	<li><para>When you are finished composing the model table,
	    display it by double-clicking on its icon.  Under the Edit
	    menu in the window which appears, you have the option of
	    copying the table to the clipboard in various
	    formats.</para>
	</li>

	<li><para>If the ordering of the models in the table is not
	    what you wanted, right-click on the model table icon and
	    select <quote>Clear table</quote>.  Then go back to step 4
	    above and try again.</para>
	</li>
      </nlist>
    </description>

    <description context="cli">
      <para>Manipulates the gretl <quote>model table</quote>. See 
	<guideref targ="modes"/> for details. The sub-commands have
	the following effects: <cmd>add</cmd> adds the last model
	estimated to the model table, if possible; <cmd>show</cmd>
	displays the model table in a window; and <cmd>free</cmd>
	clears the table.</para>
    </description>

    <gui-access>
      <menu-path>Session window, Model table icon</menu-path>
    </gui-access>

  </command>

  <command name="mpols" section="Estimation"
    label="Multiple-precision OLS">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
        </option>
	<option>
	  <flag>--simple-print</flag>
	  <effect>do not print auxiliary statistics</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>suppress printing of results</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Computes OLS estimates for the specified model using multiple
	precision floating-point arithmetic.  This command is available
	only if <program>gretl</program> is compiled with support for the
	Gnu Multiple Precision (GMP) library.  By default 256 bits of
	precision are used for the calculations, but this can be increased
	via the environment variable <lit>GRETL_MP_BITS</lit>.  For
	example, when using the bash shell one could issue the following
	command, before starting gretl, to set a precision of 1024 bits.
      </para>
      <code>
	export GRETL_MP_BITS=1024
      </code>

      <para context="cli">
	A rather arcane option is available for this command (primarily
	for testing purposes): if the <repl>indepvars</repl> list is
	followed by a semicolon and a further list of numbers, those
	numbers are taken as powers of <repl>x</repl> to be added to the
	regression, where <repl>x</repl> is the last variable in
	<repl>indepvars</repl>.  These additional terms are computed and
	stored in multiple precision.  In the following example
	<lit>y</lit> is regressed on <lit>x</lit> and the second, third
	and fourth powers of <lit>x</lit>:
      </para>
      <code context="cli">
	mpols y 0 x ; 2 3 4
      </code>

    </description>

    <gui-access>
      <menu-path>/Model/Other linear models/High precision OLS</menu-path>
    </gui-access>

  </command>

  <command name="nls" section="Estimation"
    label="Nonlinear Least Squares">

    <usage>
      <arguments>
        <argument>function</argument>
        <argument optional="true">derivatives</argument>
      </arguments>
      <options>
	<option>
	  <flag>--quiet</flag>
	  <effect>don't show estimated model</effect>
	</option>
	<option>
	  <flag>--robust</flag>
	  <effect>robust standard errors</effect>
        </option>
	<option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>print details of iterations</effect>
	</option>
      </options>
      <examples>
	<demos>
	  <demo>wg_nls.inp</demo>
	</demos>
      </examples>
    </usage>

    <description context="gui">

      <para>Performs Nonlinear Least Squares (NLS) estimation using a
	modified version of the Levenberg&ndash;Marquandt algorithm. You
	must supply a function specification; it is recommended but not
	required that you also supply expressions for the derivatives of
	this function with respect to each of the parameters if possible.
	If you do not supply derivatives you should instead give a list of
	the parameters to be estimated (separated by spaces or commas),
	preceded by the keyword <lit>params</lit>.
      </para>

      <para>
	Example: Suppose we have a data set with variables
	<math>C</math> and <math>Y</math> (&eg;
	<lit>greene11_3.gdt</lit>) and we wish to estimate a nonlinear
	consumption function of the form
	<equation status="display"
	  tex="\[C = \alpha + \beta Y^{\gamma}\]"
	  ascii="C = alpha + beta * Y^gamma"
	  graphic="greene_Cfunc"/></para>

      <para>The parameters alpha, beta and gamma must
	first be added to the dataset and given initial values.  This
	can be done using the genr command or via menu choices.
	Appropriate <quote>genr</quote> lines may be typed into the
	NLS specification window prior to the function
	specification.</para>

      <para>In the NLS window we type the following
	lines:</para>
      <code>
	C = alpha + beta * Y^gamma
	deriv alpha = 1
	deriv beta = Y^gamma
	deriv gamma = beta * Y^gamma * log(Y)
      </code>

      <para>The first line specifies the regression
	function, and the next three lines supply the derivatives of
	that function with respect to each of the parameters in turn.
	If the "deriv" lines are not given, a numerical approximation
	to the Jacobian is computed.</para>

      <para>If the parameters alpha, beta and gamma were
	not previously declared we could preface the above lines with
	something like the following:</para>
      <code>
	genr alpha = 1
	genr beta = 1
	genr gamma = 1
      </code>

      <para>For further details on NLS estimation please see 
	<guideref targ="chap-nls"/>.</para>

    </description>

    <description context="cli">

      <para>
	Performs Nonlinear Least Squares (NLS) estimation using a modified
	version of the Levenberg&ndash;Marquandt algorithm.  You must
	supply a function specification.  The parameters of this function
	must be declared and given starting values (using the
	<cmd>genr</cmd> command) prior to estimation.  Optionally, you may
	specify the derivatives of the regression function with respect to
	each of the parameters.  If you do not supply derivatives you
	should instead give a list of the parameters to be estimated
	(separated by spaces or commas), preceded by the keyword
	<lit>params</lit>.  In the latter case a numerical approximation
	to the Jacobian is computed.
      </para>

      <para>
	It is easiest to show what is required by example.  The
	following is a complete script to estimate the nonlinear
	consumption function set out in William Greene's
	<book>Econometric Analysis</book> (Chapter 11 of the 4th
	edition, or Chapter 9 of the 5th).  The numbers to the left of
	the lines are for reference and are not part of the commands.
	Note that any option flags, such as <lit>--vcv</lit> for
	printing the covariance matrix of the parameter estimates,
	should be appended to the final command, <lit>end nls</lit>.
      </para>
      <code>
	1   open greene11_3.gdt
	2   ols C 0 Y
	3   genr a = $coeff(0)
	4   genr b = $coeff(Y)
	5   genr g = 1.0
	6   nls C = a + b * Y^g
	7    deriv a = 1
	8    deriv b = Y^g
	9    deriv g = b * Y^g * log(Y)
	10  end nls --vcv
      </code>

      <para>
	It is often convenient to initialize the parameters by
	reference to a related linear model; that is accomplished here
	on lines 2 to 5.  The parameters alpha, beta and gamma could
	be set to any initial values (not necessarily based on a model
	estimated with OLS), although convergence of the NLS procedure
	is not guaranteed for an arbitrary starting point.
      </para>

      <para>
	The actual NLS commands occupy lines 6 to 10. On line 6 the
	<cmd>nls</cmd> command is given: a dependent variable is
	specified, followed by an equals sign, followed by a function
	specification.  The syntax for the expression on the right is
	the same as that for the <cmd>genr</cmd> command.  The next
	three lines specify the derivatives of the regression function
	with respect to each of the parameters in turn.  Each line
	begins with the keyword <cmd>deriv</cmd>, gives the name of a
	parameter, an equals sign, and an expression whereby the
	derivative can be calculated (again, the syntax here is the
	same as for <cmd>genr</cmd>). As an alternative to supplying
	numerical derivatives, you could substitute the following for
	lines 7 to 9:
      </para>
      <code>
	params a b g
      </code>
      <para>
	Line 10, <cmd>end nls</cmd>, completes the command and calls for
	estimation.
      </para>

      <para>For further details on NLS estimation please see
	<guideref targ="chap-nls"/>.</para>

    </description>

    <gui-access>
      <menu-path>/Model/Nonlinear models/Nonlinear Least Squares</menu-path>
    </gui-access>

  </command>

  <command name="normtest" section="Tests"
    label="Normality test">

    <usage>
      <arguments>
        <argument>series</argument>
      </arguments>
      <options>
	<option>
	  <flag>--dhansen</flag>
	  <effect>Doornik&ndash;Hansen test</effect>
        </option>
	<option>
	  <flag>--swilk</flag>
	  <effect>Shapiro&ndash;Wilk test</effect>
        </option>
	<option>
	  <flag>--jbera</flag>
	  <effect>Jarque&ndash;Bera test</effect>
        </option>
	<option>
	  <flag>--quiet</flag>
	  <effect>suppress printed output</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Carries out a test for normality for the given
	<repl>series</repl>.  The specific test is controlled by the
	option flags (but if no flag is given, the Doornik&ndash;Hansen
	test is performed).  Note: the Jarque&ndash;Bera test, while it is
	easy to compute, has relatively poor small-sample properties and
	is not recommended for purposes other than comparison.
      </para>
      <para>
	The test statistic and its p-value may be retrieved
	using the accessors <lit>$test</lit> and <lit>$pvalue</lit>.
      </para>
    </description>

  </command>

  <command name="nulldata" section="Dataset"
    label="Creating a blank dataset">

    <usage>
      <arguments>
        <argument>series_length</argument>
      </arguments>
      <options>
	<option>
	  <flag>--preserve</flag>
	  <effect>preserve matrices</effect>
        </option>
      </options>
      <examples>
        <example>nulldata 500</example>
      </examples>
    </usage>

    <description>
      <para>
	Establishes a <quote>blank</quote> data set, containing only a
	constant and an index variable, with periodicity 1 and the
	specified number of observations. This may be used for
	simulation purposes: some of the <cmd>genr</cmd> commands
	(&eg; <cmd>genr uniform()</cmd>, <cmd>genr normal()</cmd>)
	will generate dummy data from scratch to fill out the data
	set. This command may be useful in conjunction with
	<cmd>loop</cmd>.  See also the <quote>seed</quote> option to
	the <cmdref targ="set"/> command.
      </para>
      <para>
	By default, this command cleans out all data in gretl's current
	workspace.  If you give the <lit>--preserve</lit> option, however,
	any currently defined matrices are retained.
      </para>
    </description>

    <gui-access>
      <menu-path>/File/New data set</menu-path>
    </gui-access>

  </command>

  <command name="ols" section="Estimation"
    label="Ordinary Least Squares">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
        <option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
        </option>
        <option>
	  <flag>--robust</flag>
	  <effect>robust standard errors</effect>
        </option>
        <option>
	  <flag>--simple-print</flag>
	  <effect>do not print auxiliary statistics</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>suppress printing of results</effect>
        </option>
        <option>
	  <flag>--no-df-corr</flag>
	  <effect>suppress degrees of freedom correction</effect>
        </option>
        <option>
	  <flag>--print-final</flag>
	  <effect>see below</effect>
        </option>
      </options>
      <examples>
        <example>ols 1 0 2 4 6 7</example>
	<example>ols y 0 x1 x2 x3 --vcv</example>
	<example>ols y 0 x1 x2 x3 --quiet</example>
      </examples>
    </usage>

    <description>
      <para context="gui">
        Computes ordinary least squares (OLS) estimates for the
	specified model.
      </para>

      <para context="cli">
        Computes ordinary least squares (OLS) estimates with
	<repl>depvar</repl> as the dependent variable and
	<repl>indepvars</repl> as the list of independent variables.
	Variables may be specified by name or number; use the number
	zero for a constant term. 
      </para>

      <para>Besides coefficient estimates and standard errors, the
	program also prints p-values for <math>t</math>
	(two-tailed) and <math>F</math>-statistics.  A p-value
	below 0.01 indicates statistical significance at the 1 percent
	level and is marked with <lit>***</lit>. <lit>**</lit>
	indicates significance between 1 and 5 percent and
	<lit>*</lit> indicates significance between the 5 and 10
	percent levels. Model selection statistics (the Akaike
	Information Criterion or AIC and Schwarz's Bayesian Information
	Criterion) are also printed.  The formula used for the AIC is
	that given by Akaike (1974), namely minus two times the
	maximized log-likelihood plus two times the number of
	parameters estimated.</para>

      <para context="cli">If the option <lit>--no-df-corr</lit> is
	given, the usual degrees of freedom correction is not applied
	when calculating the estimated error variance (and hence also
	the standard errors of the parameter estimates).</para>

      <para context="cli">
	The option <lit>--print-final</lit> is applicable only in the
	context of a <cmdref targ="loop"/>.  It arranges for the
	regression to be run silently on all but the final iteration
	of the loop. See <guideref targ="loop-examples"/> for details.
      </para>

      <para context="cli">Various internal variables may be retrieved
	using the <cmdref targ="genr"/> command, provided
	<cmd>genr</cmd> is invoked immediately after this command.
      </para>

      <para context="cli">The specific formula used for generating
	robust standard errors (when the <lit>--robust</lit> option is
	given) can be adjusted via the <cmdref targ="set"/> command.
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Ordinary Least Squares</menu-path>
      <other-access>Beta-hat button on toolbar</other-access>
    </gui-access>

  </command>

  <command name="omit" section="Tests" label="Omit variables">

    <usage>
      <arguments>
        <argument>varlist</argument>
      </arguments>
      <options>
	<option>
	  <flag>--wald</flag>
	  <effect>do a Wald test rather than an F-test</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>don't print estimates for reduced model</effect>
	</option>
	<option>
	  <flag>--silent</flag>
	  <effect>don't print anything</effect>
	</option>
	<option>
	  <flag>--auto</flag>
	  <optparm>alpha</optparm>
	  <effect>sequential elimination, see below</effect>
	</option>
	<option>
	  <flag>--inst</flag>
	  <effect>omit as instrument, TSLS only</effect>
	</option>
	<option>
	  <flag>--both</flag>
	  <effect>omit as both regressor and instrument, TSLS only</effect>
	</option>
      </options>
      <examples>
        <example>omit 5 7 9</example>
        <example>omit seasonals --quiet</example>
        <example>omit --auto</example>
        <example>omit --auto=0.05</example>
      </examples>
    </usage>

    <description>
      <para context="gui">
	This command re-estimates the given model after omitting the specified
	variables, or after sequentially omitting insignificant variables if
	the relevant box is available and is checked.  Besides the usual model
	output, it prints a test for the joint significance of the omitted
	variables. The null hypothesis is that the true coefficients on all
	the omitted variables equal zero.
      </para>
      <para context="gui">
	When the original model was estimated by OLS, the default test
	statistic is an <math>F</math>-value, based on the sums of
	squared residuals for the restricted and unrestricted models. For
	estimators other than OLS, or if the Wald option is selected, the
	statistic is an asymptotic Wald chi-square value based on the
	covariance matrix of the original model.
      </para>
      <para context="gui">
	Sequential elimination works as follows: at each step the
	variable with the highest p-value is omitted, until all remaining
	variables have a p-value no greater than some cutoff.  The default
	cutoff is 10 percent (two-sided); this can be adjusted via the
	spin button.
      </para>
      <para context="cli">
	This command must follow an estimation command.  It calculates a
	test for the joint significance of the variables in
	<repl>varlist</repl>, which should be a subset of the independent
	variables in the model previously estimated. Alternatively, if the
	<lit>--auto</lit> flag is given, sequential elimination is
	performed: at each step the variable with the highest p-value is
	omitted, until all remaining variables have a p-value no greater
	than some cutoff.  The default cutoff is 10 percent (two-sided);
	this can be adjusted by appending <quote><lit>=</lit></quote> and
	a value between 0 and 1 (with no spaces), as in the fourth example
	above.
      </para>
      <para context="cli">
	If the original model was estimated by OLS, the test statistic is
	by default an <math>F</math>-value.  This is based on the
	sums of squared residuals for the restricted and unrestricted
	models, unless the original model was estimated with robust
	standard errors.  In the latter case <math>F</math> is
	computed from the robust estimate of the covariance matrix for the
	original model.  (It is the <math>F</math>-form of a Wald
	test).
      </para>
      <para context="cli">
	For estimators other than OLS, or if the <lit>--wald</lit> option
	is given, the statistic is an asymptotic Wald chi-square value
	based on the covariance matrix of the original model.
      </para>
      <para context="cli">
	By default, the restricted model is estimated, the estimates
	are printed, and the restricted model replaces the original as
	the <quote>current model</quote> for the purposes of, for
	example, retrieving the residuals as <lit>$uhat</lit> (or
	doing further tests such as <cmd>add</cmd> or
	<cmd>omit</cmd>).  
      </para>
      <para context="cli">
	If the Wald option is selected, the restricted model is not
	estimated (and so the current model is not replaced). The
	<lit>--quiet</lit> option suppresses the printout of the
	restricted model (if applicable): only the result of the test is
	printed.  If the restricted model is both estimated and printed,
	the <lit>--vcv</lit> option has the effect of printing the
	covariance matrix for the coefficients in the restricted model,
	otherwise this option is ignored.
      </para>
      <para context="cli">
	If the <lit>--silent</lit> option is given, nothing is printed;
	nonetheless, the results of the test can be retrieved using the
	special variables <lit>$test</lit> and <lit>$pvalue</lit>.
      </para>
      <para context="cli">
	If the original model was estimated using two-stage least
	squares, an ambiguity arises: should the selected variables be
	omitted as regressors, as instruments, or as both?  This is
	resolved as follows: by default the variables are dropped from
	the list of regressors, but if the <lit>--inst</lit> flag is
	given they are dropped as instruments, or if the
	<lit>--both</lit> flag is given they are dropped from the
	model altogether.  These two options are incompatible with the
	<lit>--wald</lit> option; if one or more instruments are
	omitted the model must be re-estimated.
      </para>
    </description>

    <gui-access>
      <menu-path>Model window, /Tests/Omit variables</menu-path>
    </gui-access>

  </command>

  <command name="online" section="Dataset" context="gui"
    label="Access online databases">

    <description>
      <para>
	Gretl is able to access databases at Wake Forest University
	(your computer must be connected to the internet for this to
	work).</para>

      <para>Under the <quote>File, Browse databases</quote> menu,
	select the item <quote>on database server</quote>. A window
	should appear, showing a listing of the gretl databases
	available at Wake Forest. (Depending on your location and the
	speed of your internet connection, this may take a few
	seconds.)  Along with the name of the database and a short
	description, there will appear a <quote>Local status</quote>
	entry: this shows whether you have the database installed
	locally (on the hard drive of your computer) and if so,
	whether or not it is up to date with the version on the
	server.</para>

      <para>If you have a given database installed locally, and it is
	up to date, there is no advantage in accessing it via the
	server.  But for a database that is not already installed and
	up to date, you may wish to get a listing of the data series:
	click on <quote>Get series listing</quote>.  This brings up a
	further window, from which you can display the values of a
	chosen data series, graph those values, or import them into
	gretl's workspace.  These tasks can be accomplished using the
	<quote>Series</quote> menu, or via the popup menu that appears
	when you click the right mouse button on a given series.  You
	can also search the listing for a variable of interest (the
	<quote>Find</quote> menu item).</para>

      <para>If you want faster access to the data, or wish to access
	the database offline, then select the line showing the
	database you want, in the initial database window, and press
	the <quote>Install</quote> button.  This will download the
	database in compressed format, then uncompress it and install
	it on your hard drive. Thereafter you should be able to find
	it under the <quote>File, Browse databases, gretl
	  native</quote> menu.</para>

    </description>
  </command>

  <command name="open" section="Dataset" 
    label="Open a data file" context="cli">

    <usage>
      <arguments>
        <argument>datafile</argument>
      </arguments>
      <options>
	<option>
	  <flag>--www</flag>
	  <effect>use a database on the gretl server</effect>
	</option>
	<option>
	  <note>See below for spreadsheet-specific options</note>
	</option>
      </options>
      <examples>
        <example>open data4-1</example>
        <example>open voter.dta</example>
	<example>open fedbog --www</example>
      </examples>
    </usage>

    <description>
      <para>
	Opens a data file.  If a data file is already open, it is replaced
	by the newly opened one.  If a full path is not given, the program
	will search some relevant paths to try to find the file.  If no
	filename suffix is given (as in the first example above), gretl
	assumes a native datafile with suffix <lit>.gdt</lit>.  Based on
	the name of the file and various heuristics, gretl will try to
	detect the format of the data file (native, plain text, CSV, MS
	Excel, Stata, etc.).
      </para>

      <para>
	When opening a spreadsheet file (Gnumeric, Open Document or XLS), you
	may give up to three additional parameters following the filename.
	First, you can select a particular worksheet within the file.  This is
	done either by giving its (1-based) number, using the syntax, &eg;,
	<lit>--sheet=2</lit>, or, if you know the name of the sheet, by giving
	the name in double quotes, as in <lit>--sheet="MacroData"</lit>. The
	default is to read the first worksheet. You can also specify a column
	and/or row offset into the worksheet via, &eg;,
      </para>
      <code>
	--coloffset=3 --rowoffset=2
      </code>
      <para>
	which would cause gretl to ignore the first 3 columns and the first 2
	rows.  The default is an offset of 0 in both dimensions, that is, to
	start reading at the top-left cell.
      </para>

      <para>
	This command can also be used to open a database (gretl, RATS 4.0
	or PcGive) for reading.  In that case it should be followed by the
	<cmdref targ="data"/> command to extract particular series from
	the database.  If the <lit>www</lit> option is given, the program
	will try to access a database of the given name on the gretl
	server &mdash; for instance the Federal Reserve interest rates
	database in the third example above.
      </para>
    </description>

    <gui-access>
      <menu-path>/File/Open data</menu-path>
      <other-access>Drag a data file into gretl (MS Windows or Gnome)</other-access>
    </gui-access>

  </command>

  <command name="orthdev" section="Transformations" 
    label="Orthogonal deviations" context="cli">

    <usage>
      <arguments>
        <argument>varlist</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Applicable with panel data only. A series of forward orthogonal
	deviations is obtained for each variable in <repl>varlist</repl> and
	stored in a new variable with the prefix <lit>o_</lit>. Thus
	<cmd>orthdev x y</cmd> creates the new variables <lit>o_x</lit> and
	<lit>o_y</lit>.
      </para>
      <para>
	The values are stored one step ahead of their true temporal location
	(that is, <lit>o_x</lit> at observation <math>t</math> holds the
	deviation that, strictly speaking, belongs at <math>t</math> &minus;
	1).  This is for compatibility with first differences: one loses the
	first observation in each time series, not the last.
      </para>
    </description>

  </command>

  <command name="outfile" section="Printing" 
    label="Direct printing to file" context="cli">

    <usage>
      <arguments>
        <argument>filename</argument>
        <argument>option</argument>
      </arguments>
      <options>
        <option>
	  <flag>--append</flag>
	  <effect>append to file</effect>
        </option>
        <option>
	  <flag>--close</flag>
	  <effect>close file</effect>
        </option>
        <option>
	  <flag>--write</flag>
	  <effect>overwrite file</effect>
        </option>
      </options>
      <examples>
        <example>outfile --write regress.txt</example>
        <example>outfile --close</example>
      </examples>
    </usage>

    <description>
      <para>Diverts output to <repl>filename</repl>, until further
	notice.  Use the flag <lit>--append</lit> to append output to
	an existing file or <lit>--write</lit> to start a new file
	(or overwrite an existing one).  Only one file can be opened
	in this way at any given time.</para>

      <para>The <lit>--close</lit> flag is used to close an output
	file that was previously opened as above.  Output will then
	revert to the default stream.</para>

      <para>In the first example command above, the file
	<filename>regress.txt</filename> is opened for writing, and in
	the second it is closed.  This would make sense as a sequence
	only if some commands were issued before the
	<lit>--close</lit>.  For example if an <cmd>ols</cmd> command
	intervened, its output would go to
	<filename>regress.txt</filename> rather than the
	screen.
      </para>

      <para>
	In a variant on the above, if you give the keyword <lit>null</lit>
	in place of a real filename along with the <lit>--write</lit>
	option, the effect is to suppress all printed output until
	the next <lit>outfile --close</lit>.
      </para>

    </description>

  </command>

  <command name="panel" section="Estimation" label="Panel models">

    <usage>
      <options>
	<option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
	</option>
        <option>
	  <flag>--fixed-effects</flag>
	  <effect>estimate with group fixed effects</effect>
        </option>
        <option>
	  <flag>--random-effects</flag>
	  <effect>random effects or GLS model</effect>
        </option>
        <option>
	  <flag>--between</flag>
	  <effect>estimate the between-groups model</effect>
        </option>
        <option>
	  <flag>--time-dummies</flag>
	  <effect>include time dummy variables</effect>
        </option>
        <option>
	  <flag>--unit-weights</flag>
	  <effect>weighted least squares</effect>
        </option>
        <option>
	  <flag>--iterate</flag>
	  <effect>iterative estimation</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>less verbose output</effect>
        </option>
        <option>
	  <flag>--verbose</flag>
	  <effect>more verbose output</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Estimates a panel model.  By default the fixed effects estimator is
	used; this is implemented by subtracting the group or unit means from
	the original data.
      </para>
      <para context="cli">
	If the <lit>--random-effects</lit> flag is given, random effects
	estimates are computed, using the method of Swamy and Arora.
      </para>
      <para context="cli">
	Alternatively, if the <lit>--unit-weights</lit> flag is given, the
	model is estimated via weighted least squares, with the weights
	based on the residual variance for the respective cross-sectional
	units in the sample.  In this case (only) the <lit>--iterate</lit>
	flag may be added to produce iterative estimates: if the
	iteration converges, the resulting estimates are Maximum
	Likelihood.
      </para>
      <para context="cli">
	As a further alternative, if the <lit>--between</lit> flag is
	given, the between-groups model is estimated (that is, an OLS
	regression using the group means).
      </para>
      <para context="gui">
	If the "Random effects" button is checked, random effects
	GLS estimates are computed, using the method of Swamy and Arora.
      </para>
      <para>
	For more details on panel estimation, please see <guideref
	  targ="chap-panel"/>.
      </para>
      
    </description>

    <gui-access>
      <menu-path>/Model/Panel</menu-path>
    </gui-access>

  </command>

  <command name="panel-between" section="Estimation" context="gui"
    label="Between groups model">

    <description>
      <para>
	This dialog allows you to enter a specification for the
	<quote>between model</quote> in the context of panel data.  This
	regression uses the group-means of the data, thereby ignoring the
	variation within the groups.  This model is rarely of great
	interest in its own right, but may be useful for purposes of
	comparison (for example, with the fixed effects model).
      </para>
    </description>

  </command>    

  <command name="panel-mode" section="Dataset" context="gui"
    label="Panel data organization">

    <description>
      <para>
	This dialog offers three options with regard to defining a data
	set as a panel.  The first two options require that the data set
	is already organized in a panel format (although this may not yet
	be recognized by gretl).  The third option requires that the data
	set contains variables that represent the panel structure.
      </para>
      <para>
	Stacked time series: Let there be N cross-sectional
	units in the data set, and let T = the number of time-series
	observations per unit.  By selecting this option you are
	telling gretl that the data set is currently composed of N
	consecutive blocks of T time-series observations, one for each
	cross-sectional unit.  The next step will be to specify the value
	of N.
      </para>
      <para>
	Stacked cross sections: You are telling gretl that the data set is
	currently composed of T consecutive blocks of N cross-sectional
	observations, one for each time period.  The next step, again,
	will be to specify the value of N.
      </para>
      <para>
	Use index variables: You are saying that the data set is currently
	organized any old way (it doesn't matter how), but that it
	contains two variables that index the cross-sectional units and
	the time periods respectively.  The next step will be to select
	those two variables.  Note that these index variables must be
	strictly positive.
      </para>
    </description>

  </command>

  <command name="panel-wls" section="Estimation" context="gui"
    label="Groupwise weighted least squares">

    <description>
      <para>
	Groupwise weighted least squares for panel data.  Computes
	weighted least squares (WLS) estimates, with the weights based on
	the estimated error variances for the respective cross-sectional
	units in the sample.
      </para>
      <para>
	If the iteration option is selected, the procedure is iterated: at
	each round the residuals are re-computed using the current WLS
	parameter estimates, which gives rise to a new set of estimates of
	the error variances, and a hence a new set of weights. Iteration
	stops when the maximum difference in the parameter estimates from
	one round to the next falls below 0.0001 or the number of
	iterations reaches 20.  If the iteration converges, the resulting
	estimates are Maximum Likelihood.
      </para>
    </description>

  </command>

  <command name="pca" section="Statistics"
    label="Principal Components Analysis">

    <usage>
      <arguments>
        <argument>varlist</argument>
      </arguments>
      <options>
        <option>
	  <flag>--covariance</flag>
	  <effect>use the covariance matrix</effect>
        </option>	
        <option>
	  <flag>--save</flag>
	  <effect>save major components</effect>
        </option>	
        <option>
	  <flag>--save-all</flag>
	  <effect>save all components</effect>
        </option>
      </options>
    </usage>

    <description context="gui">
      <para>
	Principal Components Analysis.  Prints the eigenvalues of the
	correlation matrix (or the covariance matrix if the option box is
	checked) for the variables in <repl>varlist</repl>, along with the
	proportion of the joint variance accounted for by each component.
	Also prints the corresponding eigenvectors (or <quote>component
	  loadings</quote>).
      </para>
      <para>
	In the window displaying the results, you have the option of
	saving the principal components to the dataset as series.
      </para> 
    </description>

    <description context="cli">
      <para>
	Principal Components Analysis.  Prints the eigenvalues of the
	correlation matrix (or the covariance matrix if the
	<flag>--covariance</flag> option is given) for the variables in
	<repl>varlist</repl>, along with the proportion of the joint variance
	accounted for by each component.  Also prints the corresponding
	eigenvectors (or <quote>component loadings</quote>).
      </para>
      <para>
	If the <lit>--save</lit> flag is given, components with eigenvalues
	greater than the mean (which means greater than 1.0 if the analysis is
	based on the correlation matrix) are saved to the dataset as
	series, with names <lit>PC1</lit>, <lit>PC2</lit> and so on.  These
	artificial variables are formed as the sum of (component loading)
	times (standardized <lit>Xi</lit>), where <lit>Xi</lit> denotes the
	<math>i</math>th variable in <repl>varlist</repl>.
      </para>
      <para>
	If the <lit>--save-all</lit> flag is given, all of the components are
	saved as described above.
      </para> 
    </description>

    <gui-access>
      <menu-path>/View/Principal components</menu-path>
      <other-access>Main window pop-up (multiple selection)</other-access>
    </gui-access>

  </command>

  <command name="pergm" section="Statistics"
    label="Periodogram">

    <usage>
      <arguments>
        <argument>varname</argument>
        <argument optional="true">bandwidth</argument>
      </arguments>
      <options>
        <option>
	  <flag>--bartlett</flag>
	  <effect>use Bartlett lag window</effect>
        </option>
        <option>
	  <flag>--log</flag>
	  <effect>use log scale</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Computes and displays (and if not in batch mode, graphs) the
	spectrum of the specified variable.  By default the sample
	periodogram is given; with the <lit>--bartlett</lit> flag a
	Bartlett lag window is used in estimating the spectrum (see, for
	example, Greene's <book>Econometric Analysis</book> for a
	discussion of this).  The default width of the Bartlett window is
	twice the square root of the sample size but this can be set
	manually using the <repl>bandwidth</repl> parameter, up to a
	maximum of half the sample size.  If the <lit>--log</lit> option
	is given the spectrum is represented on a logarithmic scale.
      </para>
      <para>
	When the sample periodogram is printed, two tests for fractional
	integration of the series (<quote>long memory</quote>) are given,
	namely the Geweke and Porter-Hudak (GPH) test and the Local
	Whittle Estimator.  The null hypothesis in both cases is that the
	integration order is zero.  By default the order for these tests
	is the lesser of <math>T</math>/2 and
	<math>T</math><sup>0.6</sup>.  Again, this value can be
	adjusted using the bandwidth parameter.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Spectrum</menu-path>
      <other-access>Main window pop-up menu (single selection)</other-access>
    </gui-access>

  </command>

  <command name="poisson" section="Estimation" 
    label="Poisson estimation">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
        <argument separated="true" optional="true">offset</argument>
      </arguments>
      <options>
        <option>
          <flag>--vcv</flag>
          <effect>print covariance matrix</effect>
        </option>
        <option>
          <flag>--verbose</flag>
          <effect>print details of iterations</effect>
        </option>
      </options>      
      <examples>
        <example>poisson y 0 x1 x2</example>
	<example>poisson y 0 x1 x2 ; S</example>
      </examples>
    </usage>

    <description>
      <para>Estimates a poisson regression.  The dependent variable is
	taken to represent the occurrence of events of some sort, and
	must take on only non-negative integer values.
      </para>

      <para>If a discrete random variable <math>Y</math> follows
      the Poisson distribution, then
        <equation status="display" 
          tex="\[\mathrm{Pr}(Y = y) = \frac{e^{-v} v^y}{y!}\]"
          ascii="Pr(Y = y) = exp(-v) * v^y / y!"
          graphic="poisson1"/>
	for <math>y</math> = 0, 1,
      2,&hellip;.  The mean and variance of the distribution are both
      equal to <math>v</math>.  In the Poisson regression model,
      the parameter <math>v</math> is represented as a function
      of one or more independent variables.  The most common version
      (and the only one supported by gretl) has
        <equation status="display" 
          tex="\[v = \mathrm{exp}(\beta_0+\beta_1 x_1+\beta_2 x_2 + \cdots)\]"
          ascii="v = exp(b0 + b1*x1 + b2*x2 + ...)"
          graphic="poisson2"/>
	or in other words the log of
      <math>v</math> is a linear function of the independent
      variables.</para>

      <para>Optionally, you may add an <quote>offset</quote> variable
	to the specification.  This is a scale variable, the log of
	which is added to the linear regression function (implicitly,
	with a coefficient of 1.0).  This makes sense if you expect
	the number of occurrences of the event in question to be
	proportional, other things equal, to some known factor.  For
	example, the number of traffic accidents might be supposed to
	be proportional to traffic volume, other things equal, and in
	that case traffic volume could be specified as an
	<quote>offset</quote> in a Poisson model of the accident rate.
	The offset variable must be strictly positive.  
      </para>

    </description>

    <gui-access>
      <menu-path>/Model/Nonlinear models/Poisson</menu-path>
    </gui-access>

  </command>

  <command name="plot" section="Graphs" 
    label="ASCII plot" context="cli">

    <usage>
      <arguments>
        <argument>varlist</argument>
      </arguments>
      <options>
        <option>
	  <flag>--one-scale</flag>
	  <effect>force a single scale</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Plots the values for specified variables, for the range of
	observations currently in effect, using ASCII symbols.  Each
	line stands for an observation and the values are plotted
	horizontally.  By default the variables are scaled
	appropriately.  See also <cmdref targ="gnuplot"/>.
      </para>
    </description>

  </command>

  <command name="print" section="Printing" 
    label="Print data or strings" context="cli">

    <usage>
      <arguments>
	<argument>varlist</argument>
	<argument alternate="true">string_literal</argument>
      </arguments>
      <options>
	<option>
	  <flag>--byobs</flag>
	  <effect>by observations</effect>
	</option>
	<option>
	  <flag>--long</flag>
	  <effect>use 10 significant digits or more</effect>
	</option>
	<option>
	  <flag>--no-dates</flag>
	  <effect>use simple observation numbers</effect>
	</option>
      </options>
      <examples>
	<example>print x1 x2 --byobs</example>
	<example>print "This is a string"</example>
      </examples>
    </usage>

    <description>
      <para>
	If <repl>varlist</repl> is given, prints the values of the
	specified variables; if no list is given, prints the values of
	all variables in the current data file. If the
	<lit>--byobs</lit> flag is given the data are printed by
	observation, otherwise they are printed by variable.
      </para>

      <para>
	If the <lit>--long</lit> flag is given the data are printed, by
	variable, to greater than usual precision.  The default in this
	case is to show 10 significant digits but you can adjust that
	figure using the <cmdref targ="set"/> command.
      </para>

      <para>
	If the <lit>--byobs</lit> flag is given and the data are
	printed by observation, the default is to show the date (with
	time-series data) or the observation marker string (if any) at
	the start of each line.  The <lit>--no-dates</lit> option
	suppresses the printing of dates or markers; a simple
	observation number is shown instead.
      </para>

      <para>
	If the argument to <cmd>print</cmd> is a literal string (which
	must start with a double-quote, <lit>"</lit>), the string is
	printed as is.  See also <cmdref
	  targ="printf"/>.
      </para>

      <para>
	Note: a special <quote>hack</quote> is available with this
	command, in conjunction with the <lit>--byobs</lit> flag, which
	can be useful when working with missing values in a data set.  If
	you give a list of variables followed by a semi-colon, followed by
	one final variable, then the final variable is not printed but is
	used to screen the observations to print.  Any observations for
	which the screening variable has value 0 are not printed.  As an
	example of use, suppose you have a daily time series
	<lit>x</lit>, and you want a list of the dates for which
	<lit>x</lit> is missing.  You can do
      </para>
      <code>
	genr filt = missing(x)
	print x ; filt --byobs
      </code>

    </description>

    <gui-access>
      <menu-path>/Data/Display values</menu-path>
    </gui-access>

  </command>

  <command name="printf" section="Printing" 
    label="Formatted printing" context="cli">

    <usage>
      <arguments>
        <argument>format</argument>
	<argpunct>, </argpunct>
        <argument>args</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Prints scalar values, matrices, or strings under the control of a
	format string (providing a subset of the <lit>printf()</lit>
	statement in the C programming language).  Recognized numeric formats
	are <lit>%e</lit>, <lit>%E</lit>, <lit>%f</lit>, <lit>%g</lit>,
	<lit>%G</lit> and <lit>%d</lit>, in each case with the various
	modifiers available in C.  Examples: the format <lit>%.10g</lit>
	prints a value to 10 significant figures; <lit>%12.6f</lit> prints a
	value to 6 decimal places, with a width of 12 characters.  The format
	<lit>%s</lit> should be used for strings.
      </para>
      <para>
	The format string itself must be enclosed in double quotes.  The
	values to be printed must follow the format string, separated by
	commas.  These values should take the form of either (a) the names of
	scalar variables or matrices, (b) expressions that are valid for the
	<cmd>genr</cmd> command, or (c) the special functions
	<lit>varname()</lit> or <lit>date()</lit>.  The following example
	prints the values of two variables plus that of a calculated
	expression:
      </para>
      <code>
	ols 1 0 2 3
	genr b = $coeff(2)
	genr se_b = $stderr(2)
	printf "b = %.8g, standard error %.8g, t = %.4f\n", b, se_b, b/se_b
      </code>

      <para>
	The next lines illustrate the use of the varname and date functions,
	which respectively print the name of a variable, given its ID number,
	and a date string, given a 1-based observation number.
      </para>
      <code>
	printf "The name of variable %d is %s\n", i, varname(i)
	printf "The date of observation %d is %s\n", j, date(j)
      </code>

      <para>
	If a matrix argument is given in association with a numeric
	format, the entire matrix is printed using the specified format
	for each element.
      </para>
      <para>
	The maximum length of a format string is 127 characters.  The
	escape sequences <lit>\n</lit> (newline), <lit>\t</lit> (tab),
	<lit>\v</lit> (vertical tab) and <lit>\\</lit> (literal
	backslash) are recognized.  To print a literal percent sign,
	use <lit>%%</lit>.
      </para>
      <para>
	As in C, numerical values that form part of the format (width and or
	precision) may be given directly as numbers, as in <lit>%10.4f</lit>,
	or they may be given as variables.  In the latter case, one puts
	asterisks into the format string and supplies corresponding arguments
	in order.  For example,
      </para>
      <code>
	scalar width = 12
	scalar precision = 6
	printf "x = %*.*f\n", width, precision, x
      </code>
 
    </description>

  </command>

  <command name="probit" section="Estimation"
    label="Probit model">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--robust</flag>
	  <effect>robust standard errors</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>print details of iterations</effect>
	</option>
	<option>
	  <flag>--p-values</flag>
	  <effect>show p-values instead of slopes</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	If the dependent variable is a binary variable (all values are 0
	or 1) maximum likelihood estimates of the coefficients on
	<repl>indepvars</repl> are obtained via the <quote>binary response
	  model regression</quote> (BRMR) method outlined by Davidson and
	MacKinnon (2004). As the model is nonlinear the slopes depend on
	the values of the independent variables.  By default the slopes
	with respect to each of the independent variables are calculated
	(at the means of those variables) and these slopes replace the
	usual p-values in the regression output.  This behavior can be
	suppressed my giving the <lit>--p-values</lit> option. The
	chi-square statistic tests the null hypothesis that all
	coefficients are zero apart from the constant.
      </para>
      <para context="cli">
	By default, standard errors are computed using the negative
	inverse of the Hessian.  If the <lit>--robust</lit> flag is given,
	then QML or Huber&ndash;White standard errors are calculated
	instead. In this case the estimated covariance matrix is a
	<quote>sandwich</quote> of the inverse of the estimated Hessian
	and the outer product of the gradient. See Davidson and MacKinnon
	(2004, Chapter 10) for details.
      </para>
      <para context="gui">
	By default, standard errors are computed using the negative
	inverse of the Hessian.  If the "Robust standard errors" box is
	checked, then QML or Huber&ndash;White standard errors are
	calculated instead. In this case the estimated covariance matrix
	is a <quote>sandwich</quote> of the inverse of the estimated
	Hessian and the outer product of the gradient.  See Davidson and
	MacKinnon (2004, Chapter 10) for details.
      </para>
      <para>
	If the dependent variable is not binary but is discrete, then Ordered
	Probit estimates are obtained.  (If the variable selected as dependent
	is not discrete, an error is flagged.)
      </para>
      <para>
	Probit for analysis of proportions is not implemented in
	<program>gretl</program> at this point.
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Nonlinear models/Probit</menu-path>
    </gui-access>

  </command>

  <command name="pvalue" section="Utilities" 
    label="Compute p-values" context="cli">

    <usage>
      <arguments>
        <argument>dist</argument>
        <argument optional="true">params</argument>
	<argument>xval</argument>
      </arguments>
      <examples>
        <example>pvalue z zscore</example>
	<example>pvalue t 25 3.0</example>
	<example>pvalue X 3 5.6</example>
	<example>pvalue F 4 58 fval</example>
	<example>pvalue G shape scale x</example>
	<example>pvalue B bprob 10 6</example>
	<example>pvalue P lambda x</example>
	<example>pvalue W shape scale x</example>
      </examples>
    </usage>

    <description>
      <para>
	Computes the area to the right of <repl>xval</repl> in the
	specified distribution (<lit>z</lit> for Gaussian, <lit>t</lit>
	for Student's <math>t</math>, <lit>X</lit> for chi-square,
	<lit>F</lit> for <math>F</math>, <lit>G</lit> for gamma,
	<lit>B</lit> for binomial, <lit>P</lit> for Poisson, or
	<lit>W</lit> for Weibull).  
      </para>
      <para>
	Depending on the distribution, the following information must be
	given, before the <repl>xval</repl>: for the <math>t</math>
	and chi-square distributions, the degrees of freedom; for
	<math>F</math>, the numerator and denominator degrees of
	freedom; for gamma, the shape and scale parameters; for the
	binomial distribution, the <quote>success</quote> probability and
	the number of trials; for the Poisson distribution, the
	parameter &lgr; (which is both the mean and the variance); and
	for the Weibull distribution, shape and scale parameters. As
	shown in the examples above, the numerical parameters may be given
	in numeric form or as the names of variables.
      </para>
      <para>
	The parameters for the gamma distribution are sometimes given as
	mean and variance rather than shape and scale. The mean is the
	product of the shape and the scale; the variance is the product of
	the shape and the square of the scale.  So the scale may be found
	as the variance divided by the mean, and the shape as the mean
	divided by the scale.  
      </para>
    </description>

    <gui-access>
      <menu-path>/Tools/P-value finder</menu-path>
    </gui-access>

  </command>

  <command name="qlrtest" section="Tests" 
    label="Quandt likelihood ratio test">

    <description>
      <para>
	For a model estimated on time-series data via OLS, performs the
	Quandt likelihood ratio (QLR) test for a structural break at an
	unknown point in time, with 15 percent trimming at the beginning
	and end of the sample period.
      </para>
      <para>
	For each potential break point within the central 70 percent of
	the observations, a Chow test is performed (see <cmdref
	  targ="chow"/>). The QLR test statistic is the maximum of the
	<math>F</math> values from these tests.  It follows a
	non-standard distribution, the critical values of which are taken
	from Stock and Watson's <book>Introduction to Econometrics</book>
	(2003). If the QLR statistic exceeds the critical value at the
	chosen level of significance, one can infer that the parameters of
	the model are not constant.  This statistic can be used to detect
	forms of instability other than a single discrete break (such as
	multiple breaks or a slow drifting of the parameters). 
      </para>
    </description>

    <gui-access>
      <menu-path>Model window, /Tests/QLR test</menu-path>
    </gui-access>

  </command>

  <command name="quantreg" section="Estimation" 
    label="Quantile regression">

    <usage>
      <arguments>
	<argument>tau</argument>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--robust</flag>
	  <effect>robust standard errors</effect>
        </option>
        <option>
	  <flag>--intervals</flag>
	  <optparm>level</optparm>
	  <effect>compute confidence intervals</effect>
        </option>
        <option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
        </option>
      </options>
      <examples>
	<example>quantreg 0.25 y 0 xlist</example>
	<example>quantreg 0.5 y 0 xlist --intervals</example>
	<example>quantreg 0.5 y 0 xlist --intervals=.95</example>
	<example>quantreg tauvec y 0 xlist --robust</example>
      </examples>
	<demos>
	  <demo>mrw_qr.inp</demo>
	</demos>
    </usage>

    <description context="gui">
      <para>
	Quantile regression.  By default standard errors are computed
	according to the asymptotic formula given by Koenker and Bassett
	(<book>Econometrica</book>, 1978), but if the <quote>robust</quote>
	box is checked we use the heteroskedasticity-robust variant from
	Koenker and Zhao (<book>Journal of Nonparametric Statistics</book>,
	1994).
      </para>
      <para>
	If the <quote>Compute confidence intervals</quote> option is checked
	gretl will calculate confidence intervals for the coefficients, in
	place of standard errors. The <quote>robust</quote> check-box still
	has an effect: if it is not checked, the intervals are computed on the
	assumption of IID errors; with it, gretl uses the robust estimator
	developed by Koenker and Machado (<book>Journal of the American
	  Statistical Association</book>, 1999).  Note that these intervals
	are not just <quote>plus or minus so many standard errors</quote>; in
	general, they are asymmetrical about the point estimates of the
	coefficients.  
      </para>	
      <para>
	You may give a list of quantiles (see the drop-down list for some
	pre-defined possibilities).  In that case gretl will calculate
	quantile estimates and either standard errors or confidence intervals
	for each of the specified values.
      </para>
      <para>
	To Follow up on the references given above, please see
	<guideref targ="chap:quantreg"/>.
      </para>
    </description>

    <description context="cli">
      <para>
	Quantile regression.  The first argument, <repl>tau</repl>, is the
	conditional quantile for which estimates are wanted.  It may be given
	either as a numerical value or as the name of a pre-defined scalar
	variable; the value must be in the range 0.01 to 0.99. (Alternatively,
	a vector of values may be given for <repl>tau</repl>; see below for
	details.) The second and subsequent arguments compose a regression
	list on the same pattern as <cmdref targ="ols"/>.
      </para>
      <para>
	Without the <lit>--intervals</lit> option, standard errors are printed
	for the quantile estimates.  By default, these are computed according
	to the asymptotic formula given by Koenker and Bassett (1978), but if
	the <lit>--robust</lit> option is given, standard errors that are
	robust with respect to heteroskedasticity are calculated using the
	method of Koenker and Zhao (1994).
      </para>
      <para>
	When the <lit>--intervals</lit> option is chosen, confidence intervals
	are given for the parameter estimates instead of standard errors.
	These intervals are computed using the rank inversion method, and in
	general they are asymmetrical about the point estimates.  The specifics
	of the calculation are inflected by the <lit>--robust</lit> option:
	without this, the intervals are computed on the assumption of IID
	errors (Koenker, 1994); with it, they use the robust estimator
	developed by Koenker and Machado (1999).
      </para>
      <para>
	By default, 90 percent confidence intervals are produced.  You can
	change this by appending a confidence level (expressed as a decimal
	fraction) to the intervals option, as in <lit>--intervals=0.95</lit>.
      </para>
      <para>
	Vector-valued <repl>tau</repl>:  instead of supplying a scalar, you
	may give the name of a pre-defined matrix.  In this case estimates are
	computed for all the given <repl>tau</repl> values and the results are
	printed in a special format, showing the sequence of quantile
	estimates for each regressor in turn.
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Robust estimation/Quantile regression</menu-path>
    </gui-access>

  </command>

  <command name="quit" section="Utilities" 
    label="Exit the program" context="cli">

    <description>
      <para>
	Exits from the program, giving you the option of saving the
	output from the session on the way out.  
      </para>
    </description>

    <gui-access>
      <menu-path>/File/Exit</menu-path>
    </gui-access>

  </command>

  <command name="rename" section="Dataset" 
    label="Rename variables" context="cli">

    <usage>
      <altforms>
	<altform><lit>rename</lit> <repl>varnumber</repl> <repl>newname</repl></altform>
	<altform><lit>rename</lit> <repl>varname</repl> <repl>newname</repl></altform>
      </altforms>
    </usage>

    <description>
      <para>Changes the name of the variable with identification number
	<repl>varnumber</repl> or current name <repl>varname</repl> to
	<repl>newname</repl>.  The new name must be of 15 characters maximum,
	must start with a letter, and must be composed of only letters, digits,
	and the underscore character.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Edit attributes</menu-path>
      <other-access>Main window pop-up menu (single selection)</other-access>
    </gui-access>

  </command>

  <command name="reset" section="Tests" label="Ramsey's RESET">

    <usage>
      <options>
	<option>
	  <flag>--quiet</flag>
	  <effect>don't print the auxiliary regression</effect>
	</option>
	<option>
	  <flag>--squares-only</flag>
	  <effect>compute the test using only the squares</effect>
	</option>
	<option>
	  <flag>--cubes-only</flag>
	  <effect>compute the test using only the cubes</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Must follow the estimation of a model via OLS. Carries out
	Ramsey's RESET test for model specification (non-linearity) by
	adding the square and/or the cube of the fitted values to the
	regression and calculating the <math>F</math> statistic for the
	null hypothesis that the parameters on the added terms are zero.
      </para>
      <para context="cli">
	Both the square and the cube are added, unless one of the options
	<lit>--squares-only</lit> or <lit>--cubes-only</lit> is given.
      </para>
    </description>

    <gui-access>
      <menu-path>Model window, /Tests/Ramsey's RESET</menu-path>
    </gui-access>

  </command>

  <command name="restrict" section="Tests" context="cli"
    label="Linear restrictions">

    <description>
      <para>
	Imposes a set of linear restrictions on either (a) the model
	last estimated or (b) a system of equations previously defined
	and named.  The syntax and effects of the command differ
	slightly in the two cases.
      </para>

      <para>
	In both cases the set of restrictions should be started with
	the keyword <quote>restrict</quote> and terminated with
	<quote>end restrict</quote>.  In the single equation case the
	restrictions are implicitly to be applied to the last model,
	and they are evaluated as soon as the <lit>restrict</lit>
	command is terminated.  In the system case the initial
	<quote>restrict</quote> must be followed by the name of a
	previously defined system of equations (see <cmdref
	  targ="system"/>).  The restrictions are evaluated when
	the system is next estimated, using the <cmdref
	targ="estimate"/> command.
      </para>

      <para>
	Each restriction in the set should be expressed as an equation,
	with a linear combination of parameters on the left and a numeric
	value to the right of the equals sign. In the single-equation
	case, parameters may be referenced in the form
	<lit>b[</lit><repl>i</repl><lit>]</lit>, where <repl>i</repl>
	represents the position in the list of regressors (starting at 1),
	or <lit>b[</lit><repl>varname</repl><lit>]</lit>, where
	<repl>varname</repl> is the name of the regressor in question. In
	the system case, parameters are referenced using <lit>b</lit> plus
	two numbers in square brackets. The leading number represents the
	position of the equation within the system and the second number
	indicates position in the list of regressors.  For example
	<lit>b[2,1]</lit> denotes the first parameter in the second
	equation, and <lit>b[3,2]</lit> the second parameter in the third
	equation.
      </para>

      <para>The <lit>b</lit> terms in the equation representing a
	restriction equation may be prefixed with a numeric
	multiplier, using <lit>*</lit> to represent multiplication,
	for example <lit>3.5*b[4]</lit>.
      </para>

      <para>Here is an example of a set of restrictions for a
	previously estimated model:
      </para>
      <code>
	restrict
	 b[1] = 0
	 b[2] - b[3] = 0
	 b[4] + 2*b[5] = 1
	end restrict
      </code>

      <para>And here is an example of a set of restrictions to be
	applied to a named system.  (If the name of the system does
	not contain spaces, the surrounding quotes are not required.)
      </para>
      <code>
	restrict "System 1"
	 b[1,1] = 0
	 b[1,2] - b[2,2] = 0
	 b[3,4] + 2*b[3,5] = 1
	end restrict
      </code>

      <para>
	In the single-equation case the restrictions are evaluated via
	a Wald <math>F</math>-test, using the coefficient covariance
	matrix of the model in question.  By default, the restricted
	coefficient estimates are printed; if you just want the test
	statistic, you can append the <lit>--quiet</lit> option flag
	to the initial <lit>restrict</lit> command.
      </para>

      <para>
	In the system case, the test statistic depends on the estimator
	chosen: a Likelihood Ratio test if the system is estimated using a
	Maximum Likelihood method, or an asymptotic
	<math>F</math>-test otherwise.
      </para>

    </description>

    <gui-access>
      <menu-path>Model window, /Tests/Linear restrictions</menu-path>
    </gui-access>

  </command>

  <command name="restrict-model" section="Tests" context="gui"
    label="Restrictions on a model">

    <description>

      <para>Each restriction in the set should be expressed as an
	equation, with a linear combination of parameters on the left and
	a numeric value to the right of the equals sign. Parameters may be
	referenced in the form <lit>b[</lit><repl>i</repl><lit>]</lit>,
	where <repl>i</repl> represents the position in the list of
	regressors (starting at 1), or
	<lit>b[</lit><repl>varname</repl><lit>]</lit>, where
	<repl>varname</repl> is the name of the regressor in question.
      </para>

      <para>The <lit>b</lit> terms in the equation representing a restriction
	may be prefixed with a numeric multiplier, using <lit>*</lit>
	to represent multiplication, for example <lit>3.5*b[4]</lit>.
      </para>

      <para>Here is an example of a set of restrictions:
      </para>
      <code>
	b[1] = 0
	b[2] - b[3] = 0
	b[4] + 2*b[5] = 1
      </code>

    </description>

  </command>

  <command name="restrict-system" section="Tests" context="gui"
    label="Restrictions on a system of equations">

    <description>

      <para>Each restriction in the set should be expressed as an
	equation, with a linear combination of parameters on the left and
	a numeric value to the right of the equals sign.  Parameters are
	referenced using <lit>b</lit> plus two numbers in square brackets.
	The leading number represents the position of the equation within
	the system and the second number indicates position in the list of
	regressors, starting at 1 in both cases.  For example
	<lit>b[2,1]</lit> denotes the first parameter in the second
	equation, and <lit>b[3,2]</lit> the second parameter in the third
	equation.
      </para>

      <para>The <lit>b</lit> terms in the equation representing a restriction
	may be prefixed with a numeric multiplier, using <lit>*</lit>
	to represent multiplication, for example <lit>3.5*b[1,4]</lit>.
      </para>

      <para>Here is an example of a set of restrictions:
      </para>
      <code>
	b[1,1] = 0
	b[1,2] - b[2,2] = 0
	b[3,4] + 2*b[3,5] = 1
      </code>

    </description>

  </command>

  <command name="restrict-vecm" section="Tests" context="gui"
    label="Restrictions on a VECM">

    <description>

      <para>
	Use this command to place linear restrictions on the cointegrating
	relations (beta) and/or adjustment coefficients (alpha) in a
	vector error-correction model (VECM).
      </para>

      <para>
	Each restriction should be expressed as an equation, with a linear
	combination of parameters to the left of the equals sign and a
	numerical value on the right.  Restrictions on beta may be
	non-homogeneous (non-zero on the right), but alpha restrictions
	must be homogeneous (zero on the right).  
      </para>

      <para>
	If the VECM is of rank 1, the elements of beta are referenced in
	the form <lit>b[</lit><repl>i</repl><lit>]</lit>, where
	<repl>i</repl> represents position in the cointegrating vector,
	starting at 1. For example, <lit>b[2]</lit> denotes the second
	element in beta. If the rank is greater than 1, use <lit>b</lit>
	plus two numbers in square brackets.  For example,
	<lit>b[2,1]</lit> denotes the first element in the second
	cointegrating vector.
      </para>

      <para>
	To reference elements of alpha, use <lit>a</lit> instead of
	<lit>b</lit>.
      </para>

      <para>
	The parameter identifiers in the equation representing a
	restriction may be prefixed with a numeric multiplier, using
	<lit>*</lit> to represent multiplication, for example
	<lit>3.5*b[4]</lit>.
      </para>

      <para>Here is an example of a set of restrictions on a VECM of rank 1.
      </para>
      <code>
	b[1] + b[2] = 0
	b[1] + b[3] = 0
      </code>

      <para>
	See also <guideref targ="chap:vecm"/>.
      </para>

    </description>

  </command>

  <command name="rhodiff" section="Transformations" 
    label="Quasi-differencing" context="cli">

    <usage>
      <arguments>
        <argument>rholist</argument>
        <argument separated="true">varlist</argument>
      </arguments>
      <examples>
        <example>rhodiff .65 ; 2 3 4</example>
        <example>rhodiff r1 r2 ; x1 x2 x3</example>	
      </examples>
    </usage>

    <description>
      <para>
	Creates rho-differenced counterparts of the variables (given
	by number or by name) in <repl>varlist</repl> and adds them to
	the data set, using the suffix <lit>#</lit> for the new
	variables. Given variable <lit>v1</lit> in
	<repl>varlist</repl>, and entries <lit>r1</lit> and
	<lit>r2</lit> in <repl>rholist</repl>, the new variable
      </para>
      <code>
	v1# = v1 - r1*v1(-1) - r2*v1(-2)
      </code>
      <para>
	is created. The <repl>rholist</repl> entries can be given as numerical
	values or as the names of variables previously defined.
      </para>
    </description>

  </command>

  <command name="rmplot" section="Graphs"
    label="Range-mean plot">

    <usage>
      <arguments>
        <argument>varname</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Range&ndash;mean plot: this command creates a simple graph to
	help in deciding whether a time series,
	<math>y</math>(t), has constant variance or not.  We
	take the full sample t=1,...,T and divide it into small
	subsamples of arbitrary size <math>k</math>. The first
	subsample is formed by
	<math>y</math>(1),...,<math>y</math>(k), the
	second is <math>y</math>(k+1), ...,
	<math>y</math>(2k), and so on.  For each subsample we
	calculate the sample mean and range (= maximum minus minimum),
	and we construct a graph with the means on the horizontal axis
	and the ranges on the vertical. So each subsample is
	represented by a point in this plane.  If the variance of the
	series is constant we would expect the subsample range to be
	independent of the subsample mean; if we see the points
	approximate an upward-sloping line this suggests the variance
	of the series is increasing in its mean; and if the points
	approximate a downward sloping line this suggests the variance
	is decreasing in the mean.
      </para>

      <para>Besides the graph, gretl displays the means and ranges for
	each subsample, along with the slope coefficient for an OLS
	regression of the range on the mean and the p-value for the
	null hypothesis that this slope is zero.  If the slope
	coefficient is significant at the 10 percent significance
	level then the fitted line from the regression of range on
	mean is shown on the graph.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/Range-mean graph</menu-path>
    </gui-access>

  </command>

  <command name="run" section="Programming" 
    label="Execute a script" context="cli">

    <usage>
      <arguments>
        <argument>inputfile</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Execute the commands in <repl>inputfile</repl> then return
	control to the interactive prompt.  This command is intended
	for use with the command-line program gretlcli, or at the
	<quote>gretl console</quote> in the GUI program.
      </para>
      <para>
	See also <cmdref targ="include"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>Run icon in script window</menu-path>
    </gui-access>

  </command>

  <command name="runs" section="Tests" label="Runs test">

    <usage>
      <arguments>
        <argument>varname</argument>
      </arguments>
      <options>
	<option>
	  <flag>--difference</flag>
	  <effect>use first difference of variable</effect>
	</option>
	<option>
	  <flag>--equal</flag>
	  <effect>positive and negative values are equiprobable</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Carries out the nonparametric <quote>runs</quote> test for
	randomness of the specified variable, where runs are defined as
	sequences of consecutive positive or negative values.  If you want
	to test for randomness of deviations from the median, for a
	variable named <lit>x1</lit> with a non-zero median, you can do
	the following:
      </para>
      <code>
	genr signx1 = x1 - median(x1)
	runs signx1
      </code>
      <para>
	If the <lit>--difference</lit> option is given, the variable is
	differenced prior to the analysis, hence the runs are interpreted
	as sequences of consecutive increases or decreases in the
	value of the variable.
      </para>
      <para>
	If the <lit>--equal</lit> option is given, the null hypothesis
	incorporates the assumption that positive and negative values
	are equiprobable, otherwise the test statistic is invariant
	with respect to the <quote>fairness</quote> of the process
	generating the sequence, and the test focuses on independence
	alone.  
      </para>
    </description>

    <gui-access>
      <menu-path>/Tools/Nonparametric tests</menu-path>
    </gui-access>

  </command>

  <command name="sampling" section="Dataset" context="gui"
    label="Setting the sample">

    <description>
      <para>The Sample menu offers several ways of selecting a
      sub-sample from the current dataset.</para>

      <para>
	If you choose <quote>Sample/Define based on dummy...</quote>
	you are prompted to select a dummy (indicator) variable, which
	must have the values 0 or 1 at each observation.  The sample
	will be restricted to observations for which the dummy's value
	is 1.</para>

      <para>If you choose <quote>Sample/Restrict based on
	  criterion...</quote> you need to supply a Boolean (logical)
	expression, of the same sort that you would use to define a dummy
	variable.  For example the expression <quote>sqft > 1400</quote>
	will select only cases for which the variable sqft has a value
	greater than 1400. Conditions may be concatenated using the
	logical operators <quote>&amp;&amp;</quote> (AND) and
	<quote>||</quote> (OR), and may be negated using <quote>!</quote>
	(NOT).
      </para>

      <para>The menu item <quote>Sample/Drop all obs with missing
	  values</quote> redefines the sample to exclude all
	observations for which values of one or more variables are
	missing (leaving only complete cases).</para>  

      <para>To select observations for which a particular variable has
	no missing values, use <quote>Sample/Restrict based on
	  criterion...</quote> and supply the Boolean condition
	<quote>!missing(varname)</quote> (replace
	<quote>varname</quote> with the name of the variable you want
	to use).</para>  

      <para>If the observations are named, you can re-sample to
	exclude a particular observation using, say, obs!="France" as
	the Boolean criterion.  The observation name must be enclosed
	in double quotes.</para>

      <para>One point should be noted about defining a sample based on
	a dummy variable, a Boolean expression, or on the missing
	values criterion: Any <quote>structural</quote> information in
	the data header file (regarding the time series or panel
	nature of the data) is lost.  You may reimpose structure with
	<quote>Sample/Set frequency, startobs...</quote>.</para>

      <para>Please see <guideref targ="sampling"/> for further details.
      </para>

    </description>
  </command>


  <command name="scatters" section="Graphs"
    label="Multiple pairwise graphs">

    <usage>
      <arguments>
        <argument>yvar</argument>
        <argument separated="true">xvarlist</argument>
	<argument alternate="true">yvarlist ; xvar</argument>
      </arguments>
      <options>
	<option>
	  <flag>--with-lines</flag>
	  <effect>create line graphs</effect>
	</option>
      </options>
      <examples>
        <example>scatters 1 ; 2 3 4 5</example>
        <example>scatters 1 2 3 4 5 6 ; 7</example>
	<example>scatters y1 y2 y3 ; x --with-lines</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
	Generates pairwise graphs of <repl>yvar</repl> against all the
	variables in <repl>xvarlist</repl>, or of all the variables in
	<repl>yvarlist</repl> against <repl>xvar</repl>.  The first
	example above puts variable 1 on the <math>y</math>-axis
	and draws four graphs, the first having variable 2 on the
	<math>x</math>-axis, the second variable 3 on the
	<math>x</math>-axis, and so on.  The second example
	plots each of variables 1 through 6 against variable 7 on the
	<math>x</math>-axis. Scanning a set of such plots can be
	a useful step in exploratory data analysis.  The maximum
	number of plots is six; any extra variable in the list will be
	ignored.
      </para>
      <para context="cli">
	By default the graphs are scatterplots, but if you give the
	<lit>--with-lines</lit> flag they will be line graphs.
      </para>
      <para context="gui">
	Generates pairwise graphs of the selected <quote>Y-axis
	  variable</quote> against each of the selected <quote>X-axis
	  variables</quote> in turn.  (Or you can select several variables
	for the Y-axis and one for the X-axis.)  Scanning a set of such
	plots can be a useful step in exploratory data analysis.  The
	maximum number of plots is six; any extra variables will be
	ignored.
      </para>
    </description>

    <gui-access>
      <menu-path>/View/Multiple graphs</menu-path>
    </gui-access>

  </command>

  <command name="sdiff" section="Transformations" 
    label="Seasonal differencing" context="cli">

    <usage>
      <arguments>
        <argument>varlist</argument>
      </arguments>
    </usage>

    <description>
      <para>
	The seasonal difference of each variable in <repl>varlist</repl> is
	obtained and the result stored in a new variable with the prefix
	<lit>sd_</lit>.  This command is available only for seasonal time
	series.  
      </para>
    </description>

    <gui-access>
      <menu-path>/Add/Seasonal differences of selected variables</menu-path>
    </gui-access>

  </command>

  <command name="set" section="Programming" 
    label="Set program parameters" context="cli">

    <usage>
      <arguments>
        <argument>variable</argument>
        <argument>value</argument>
      </arguments>
      <examples>
        <example>set qr on</example>
        <example>set csv_delim tab</example>
	<example>set horizon 10</example>
      </examples>    
    </usage>

    <description>
      <para>
	Set the values of various program parameters.  The given value
	remains in force for the duration of the gretl session unless it
	is changed by a further call to <cmd>set</cmd>.  The parameters
	that can be set in this way are enumerated below. Note that the
	settings of <lit>hc_version</lit>, <lit>hac_lag</lit> and
	<lit>hac_kernel</lit> are used when the <lit>--robust</lit> option
	is given to an estimation command. 
      </para>
      <para>
	A special usage of the command is <cmd>set
	stopwatch</cmd>. This activates the measurement of CPU time,
	which stops the first time the accessor <lit>$stopwatch</lit>
	is used, either in assigning it to a variable or simply by
	printing it. The accessor <lit>$stopwatch</lit> will yield the
	seconds of CPU time that have elapsed since the last <lit>set
	stopwatch</lit> statement.
      </para>
      <para>
	If the <cmd>set</cmd> command is given without any parameters, the
	current settings for all the relevant variables are printed.
      </para>
      <para>
	The available settings are grouped under six categories:
	program interaction and behavior, numerical methods, random
	number generation, robust estimation, filtering and time series
	models estimation.
      </para>

      <para>
	<emphasis>Program interaction and behavior</emphasis>
      </para>
      <para>
	These settings are used for controlling various aspects of the way
	gretl interacts with the user.
      </para>
      <ilist>
	<li>
	  <para><lit>csv_delim</lit>: either <lit>comma</lit> (the
	  default), <lit>space</lit> or <lit>tab</lit>.  Sets the column
	  delimiter used when saving data to file in CSV format.
	  </para>
	</li>
	<li>
	  <para><lit>echo</lit>: <lit>off</lit> or <lit>on</lit> (the
	  default). Suppress or resume the echoing of commands in gretl's
	    output.</para>
	</li>
	<li>
	  <para><lit>force_decpoint</lit>: <lit>on</lit> or <lit>off</lit>
	    (the default).  Force gretl to use the decimal point
	    character, in a locale where another character (most likely
	    the comma) is the standard decimal separator.
	  </para>
	</li>
	<li>
	  <para><lit>halt_on_error</lit>: <lit>off</lit> or
	  <lit>on</lit> (the default). When active, if an error occurs
	  within a command loop, the loop will break. This also forces
	  the command-line client to exit.
	  </para>
	</li>
	<li>	  
	  <para><lit>longdigits</lit>: one positive integer value, less
	    than or equal to 20.  Determines the number of digits of
	    precision used when printing the values of variables using the
	    <lit>--long</lit> option (see <cmdref targ="print"/>).
	  </para>
	</li>
	<li>	  
	  <para><lit>loop_maxiter</lit>: one positive integer value.
	  Sets the maximum number of iterations that a
	  <lit>while</lit> loop is allowed before halting (see <cmdref
	  targ="loop"/>). Note that this setting only affects the
	  <lit>while</lit> variant, as its purpose is to forcibly
	  break potentially infinite loops.
	  </para>
	</li>
	<li>
	  <para><lit>max_verbose</lit>: <lit>on</lit> or
	  <lit>off</lit> (the default). Toggles verbose output for the
	  <lit>BFGSmax</lit> function (see the User's Guide for
	  details).
	</para>
	</li>
	<li>
	  <para><lit>messages</lit>: <lit>off</lit> or <lit>on</lit> (the
	  default). Suppress or resume the printing of non-error messages
	  associated with various commands, for example when a new variable is
	  generated or when the sample range is changed.
         </para>
	</li>
	<li>
	  <para><lit>debug</lit>: <lit>1</lit>, <lit>2</lit> or <lit>0</lit>
	    (the default).  This is for use with user-defined functions.
	    Setting <lit>debug</lit> to 1 is equivalent to turning
	    <lit>messages</lit> on within all such functions; setting this
	    variable to <lit>2</lit> has the additional effect of turning on
	    <lit>max_verbose</lit> within all functions.
	  </para>
	</li>
	<li>
	  <para><lit>shell_ok</lit>: <lit>on</lit> or <lit>off</lit>
	  (the default). Enable launching external programs from
	  gretl via the system shell. This is disabled by default for
	  security reasons, and can only be enabled via the graphical
	  user interface (Tools/Preferences/General). However, once
	  set to on, this setting will remain active for future
	  sessions until explicitly disabled.
	  </para>
	</li>
	<li>
	  <para><lit>shelldir</lit>: <repl>path</repl>.  Sets the current
	  working directory for shell commands.
	  </para>
	</li>
	<li>
	  <para><lit>use_cwd</lit>: <lit>on</lit> or <lit>off</lit>
	  (the default). This setting affects the behavior of the
	  <cmdref targ="outfile"/> and <cmdref targ="store"/>
	  commands, which write external files. Normally, the file
	  will be written in the user's default data directory; if
	  <lit>use_cwd</lit> is <lit>on</lit>, on the contrary, the
	  file will be created in the working directory when gretl was
	  started.
	  </para>
	</li>
      </ilist>

      <para>
	<emphasis>Numerical methods</emphasis>
      </para>
      <para>
	These settings are used for controlling
	the numerical algorithms that gretl uses for estimation.
      </para>
      <ilist>
	<li>	
	  <para><lit>bhhh_maxiter</lit>: one integer, the maximum number of
	    iterations for gretl's internal BHHH routine, which is used in
	    the <cmd>arma</cmd> command for conditional ML estimation. If
	    convergence is not achieved after <lit>bhhh_maxiter</lit>, the
	    program returns an error. The default is set at 500.
	  </para>
	</li>	  
	<li>	  
	  <para><lit>bhhh_toler</lit>: one floating point value, or the
	    string <lit>default</lit>.  This is used in gretl's internal
	    BHHH routine to check if convergence has occurred. The
	    algorithm stops iterating as soon as the increment in the
	    log-likelihood between iterations is smaller than
	    <lit>bhhh_toler</lit>.  The default value is 1.0E&minus;06;
	    this value may be re-established by typing <lit>default</lit>
	    in place of a numeric value.
	  </para>
	</li>
	<li>
	  <para><lit>bfgs_maxiter</lit>: one integer, the maximum number of
	    iterations for gretl's BFGS routine, which is used for
	    <cmd>mle</cmd>, <cmd>gmm</cmd> and several specific
	    estimators. If convergence is not achieved in the specified
	    number of iterations, the program returns an error. The
	    default is 500.
	  </para>
	</li>	  
	<li>	  
	  <para><lit>bfgs_toler</lit>: one floating point value, or the
	    string <lit>default</lit>.  This is used in gretl's BFGS
	    routine to check if convergence has occurred. The algorithm
	    stops as soon as the relative improvement in the objective
	    function between iterations is smaller than
	    <lit>bfgs_toler</lit>.  The default value is the machine
	    precision to the power 3/4; this value may be re-established
	    by typing <lit>default</lit> in place of a numeric value.
	  </para>
	</li>
	<li>	  
	  <para><lit>initvals</lit>: a pre-specified matrix. Allows manual
	    setting of the initial parameter estimates for ARMA
	    estimation. For details see <guideref
	      targ="arma-estimation"/>.
	  </para>
	</li>
	<li>
	  <para><lit>lbfgs</lit>: <lit>on</lit> or <lit>off</lit> (the
	  default). Use the limited-memory version of BFGS instead of
	  the ordinary algorithm. This may be advantageous when the
	  function to maximize is not globally concave.
	  </para>
	</li>
	<li>
	<para>
	  <lit>nls_toler</lit>: a floating-point value (the default is the
	  machine precision to the power 3/4).  Sets the tolerance used in
	  judging whether or not convergence has occurred in nonlinear least
	  squares estimation using the <cmdref targ="nls"/> command.
	</para>
	</li>
	<li>
	  <para><lit>qr</lit>: <lit>on</lit> or <lit>off</lit> (the
	    default). Use QR rather than Cholesky decomposition in calculating
	    OLS estimates.</para>
	</li>
	<li>
	  <para><lit>fcp</lit>: <lit>on</lit> or <lit>off</lit> (the
	    default). Use the algorithm of Fiorentini, Calzolari and
	    Panattoni rather than native gretl code when computing
	    GARCH estimates.</para>
	</li>
      </ilist>

      <para>
	<emphasis>Random number generation</emphasis>
      </para>

      <ilist>
	<li>
	  <para><lit>seed</lit>: an unsigned integer.  Sets the seed for
	    the pseudo-random number generator.  By default this is set from the
	    system time; if you want to generate repeatable sequences of random
	    numbers you must set the seed manually.
	  </para>
	</li>
      </ilist>

      <para>
	<emphasis>Robust estimation</emphasis>
      </para>

      <ilist>
	<li>
	  <para><lit>bootrep</lit>: an integer. Sets the number of
	  replications for the <cmdref targ="restrict"/> command with
	  the <lit>--bootstrap</lit> option.</para>
	</li>
	<li>
	  <para><lit>garch_vcv</lit>: <lit>unset</lit>,
	    <lit>hessian</lit>, <lit>im</lit> (information matrix) ,
	    <lit>op</lit> (outer product matrix), <lit>qml</lit> (QML
	    estimator), <lit>bw</lit> (Bollerslev&ndash;Wooldridge). Specifies
	    the variant that will be used for estimating the coefficient
	    covariance matrix, for GARCH models.  If <lit>unset</lit> is given
	    (the default) then the Hessian is used unless the
	    <quote>robust</quote> option is given for the garch command, in
	    which case QML is used.
	  </para>
	</li>
	<li>
	  <para><lit>arma_vcv</lit>: <lit>hessian</lit> (the default) or
	    <lit>op</lit> (outer product matrix). Specifies the variant
	    to be used when computing the covariance matrix for ARIMA
	    models.
	  </para>
	</li>
	<li>
	  <para><lit>force_hc</lit>: <lit>off</lit> (the default) or
	    <lit>on</lit>.  By default, with time-series data and when the
	    <lit>--robust</lit> option is given with <lit>ols</lit>, the
	    HAC estimator is used.  If you set <lit>force_hc</lit> to
	    <quote>on</quote>, this forces calculation of the regular
	    Heteroskedasticity Consistent Covariance Matrix (which does
	    not take autocorrelation into account).
	  </para>
	</li>
	<li>
	  <para><lit>hac_lag</lit>: <lit>nw1</lit> (the default),
	    <lit>nw2</lit>, <lit>nw3</lit> or an integer.  Sets the
	    maximum lag value or bandwidth, <math>p</math>, used when
	    calculating HAC (Heteroskedasticity and Autocorrelation
	    Consistent) standard errors using the Newey-West approach, for
	    time series data.  <lit>nw1</lit> and <lit>nw2</lit> represent
	    two variant automatic calculations based on the sample size,
	    <math>T</math>: for nw1, 
	    <equation status="inline"
	      tex="$p = 0.75 \times T^{1/3}$" 
	      ascii="p = 0.75 * T^(1/3)"
	      graphic="nw1"/>, and for nw2, 
	    <equation status="inline"
	      tex="$p = 4 \times (T/100)^{2/9}$" 
	      ascii="p = 4 * (T/100)^(2/9)" 
	      graphic="nw2"/>. <lit>nw3</lit> calls for data-based
	    bandwidth selection.  See also <lit>qs_bandwidth</lit> and
	    <lit>hac_prewhiten</lit> below.
	  </para>
	</li>
	<li>
	  <para><lit>hac_kernel</lit>: <lit>bartlett</lit> (the default),
	    <lit>parzen</lit>, or <lit>qs</lit> (Quadratic Spectral). Sets
	    the kernel, or pattern of weights, used when calculating HAC
	    standard errors.
	  </para>
	</li>
	<li>
	  <para><lit>hac_prewhiten</lit>: <lit>on</lit> or <lit>off</lit>
	    (the default). Use Andrews-Monahan prewhitening and
	    re-coloring when computing HAC standard errors.  This also
	    implies use of data-based bandwidth selection.
	  </para>
	</li>
	<li>
	  <para>
	    <lit>hc_version</lit>: 0 (the default), 1, 2 or 3. Sets the
	    variant used when calculating Heteroskedasticity Consistent
	    standard errors with cross-sectional data.  The options
	    correspond to the HC0, HC1, HC2 and HC3 discussed by Davidson
	    and MacKinnon in <book>Econometric Theory and Methods</book>,
	    chapter 5.  HC0 produces what are usually called
	    <quote>White's standard errors</quote>.
	  </para>
	</li>
	<li>
	  <para><lit>pcse</lit>: <lit>off</lit> (the default) or
	    <lit>on</lit>.  By default, when estimating a model using
	    pooled OLS on panel data with the <lit>--robust</lit> option,
	    the Arellano estimator is used for the covariance matrix.  If
	    you set <lit>pcse</lit> to <quote>on</quote>, this forces use
	    of the Beck and Katz Panel Corrected Standard Errors (which do
	    not take autocorrelation into account).
	  </para>
	</li>
	<li>
	  <para><lit>qs_bandwidth</lit>: Bandwidth for HAC estimation in
	    the case where the Quadratic Spectral kernel is selected.
	    (Unlike the Bartlett and Parzen kernels, the QS bandwidth need
	    not be an integer.)
	  </para>
	</li> </ilist>

      <para>
	<emphasis>Filtering</emphasis>
      </para>

      <ilist>
	<li>
	  <para><lit>hp_lambda</lit>: <lit>auto</lit> (the default), or a
	    numerical value.  Sets the smoothing parameter for the
	    Hodrick&ndash;Prescott filter (see the <lit>hpfilt</lit> function
	    under the <lit>genr</lit> command).  The default is to use 100 times
	    the square of the periodicity, which gives 100 for annual data, 1600
	    for quarterly data, and so on.</para>
	</li>
	<li>
	  <para><lit>bkbp_limits</lit>: two integers, the second greater
	    than the first (the defaults are 8 and 32).  Sets the
	    frequency bounds for the Baxter&ndash;King bandpass filter
	    (see the <lit>bkfilt</lit> function under the <lit>genr</lit>
	    command).
	  </para>
	</li>
	<li>
	  <para><lit>bkbp_k</lit>: one integer (the default is 8).  Sets
	    the approximation order for the Baxter&ndash;King bandpass
	    filter.
	  </para>
	</li>
      </ilist>

      <para>
	<emphasis>Time series</emphasis>
      </para>

      <ilist>
	<li>
	  <para><lit>horizon</lit>: one integer (the default is based on
	    the frequency of the data).  Sets the horizon for impulse
	    responses and forecast variance decompositions in the context
	    of vector autoregressions.
	  </para>
	  <para><lit>vecm_norm</lit>: <lit>phillips</lit> (the
	  default), <lit>diag</lit>, <lit>first</lit> or
	  <lit>none</lit>. Used in the context of VECM estimation via
	  the <cmdref targ="vecm"/> command for identifying the
	  cointegration vectors. See the User's Guide for details.
	  </para>
	</li>
      </ilist>

    </description>
  </command>

  <command name="setinfo" section="Dataset" label="Edit attributes of variable">

    <usage>
      <arguments>
        <argument>varname</argument>
        <argument flag="-d ">description</argument>
        <argument flag="-n ">displayname</argument>
      </arguments>
      <options>
	<option>
	  <flag>--discrete</flag>
	  <effect>mark variable as discrete</effect>
	</option>
	<option>
	  <flag>--continuous</flag>
	  <effect>mark variable as continuous</effect>
	</option>
      </options>
      <examples>
        <example>setinfo x1 -d "Description of x1" -n "Graph name"</example>
	<example>setinfo z --discrete</example>
      </examples>
    </usage>

    <description context="cli">
      <para>
	Sets up to three attributes of the named variable, as follows.
      </para>

      <para>
	If the <lit>-d</lit> flag is given followed by a string in double
	quotes, that string is used to set the variable's descriptive
	label. This label is shown in response to the <cmdref
	  targ="labels"/> command, and is also shown in the main window of
	the GUI program.
      </para>

      <para>
	If the <lit>-n</lit> flag is given followed by a quoted string,
	that string is used to set the variable's <quote>display
	  name</quote>, which is then used in place of the variable's name
	in graphs.
      </para>

      <para>
	If one or other of the <lit>--discrete</lit> or
	<lit>--continuous</lit> option flags is given, the variable's
	numerical character is set accordingly.  The default is to treat
	all variables as continuous; setting a variable as discrete
	affects the way the variable is handled in frequency plots.
      </para>

    </description>

    <description context="gui">

      <para>
	In this dialog box you can:</para>

      <para>* Rename a variable.</para>

      <para>* Add or edit a description of the variable: this appears
	next to the variable name in the gretl main window.</para>

      <para>* Add or edit the "display name" for the variable (if the
	variable is a series, not a scalar).  This string (maximum 19
	characters) is shown in place of the variable name when the
	variable is displayed in a graph.  Thus for instance you can
	associate a more comprehensible string such as "T-bill rate" with
	a cryptically named variable such as "tb3".</para>

      <para>* (For time-series data) set the compaction method for the
	variable.  This method will be used if you decide to reduce the
	frequency of the dataset, or if you update the variable by
	importing from a database where the variable is at a higher
	frequency than in the working dataset.
      </para>

      <para>* Mark a variable as discrete (for series with integer values
	only).  This affects the way the variable is handled when you ask
	for a frequency plot.
      </para>

      <para>* (For a scalar variable) set the value of the variable.
      </para>

    </description>

    <gui-access>
      <menu-path>/Variable/Edit attributes</menu-path>
      <other-access>Main window pop-up menu</other-access>
    </gui-access>

  </command>

  <command name="setobs" section="Dataset" context="cli"
    label="Set frequency and starting observation">

    <usage>
      <altforms>
        <altform>setobs <repl>periodicity</repl> <repl>startobs</repl></altform>
	<altform>setobs <repl>unitvar</repl> <repl>timevar</repl></altform>
      </altforms>
      <options>
        <option>
	  <flag>--cross-section</flag>
	  <effect>interpret as cross section</effect>
        </option>
        <option>
	  <flag>--time-series</flag>
	  <effect>interpret as time series</effect>
        </option>
        <option>
	  <flag>--stacked-cross-section</flag>
	  <effect>interpret as panel data</effect>
        </option>
        <option>
	  <flag>--stacked-time-series</flag>
	  <effect>interpret as panel data</effect>
        </option>
        <option>
	  <flag>--panel-vars</flag>
	  <effect>use index variables (see below)</effect>
        </option>
      </options>
      <examples>
        <example>setobs 4 1990:1 --time-series</example>
        <example>setobs 12 1978:03</example>
	<example>setobs 1 1 --cross-section</example>
        <example>setobs 20 1:1 --stacked-time-series</example>
	<example>setobs unit year --panel-vars</example>
      </examples>
    </usage>

    <description>
      <para>
	Force the program to interpret the current data set as having
	a specified structure.  
      </para>
      <para>
	In the first form of the command the <repl>periodicity</repl>,
	which must be an integer, represents frequency in the case of
	time-series data (1 = annual; 4 = quarterly; 12 = monthly; 52 =
	weekly; 5, 6, or 7 = daily; 24 = hourly).  In the case of panel
	data the periodicity means the number of lines per data block:
	this corresponds to the number of cross-sectional units in the
	case of stacked cross-sections, or the number of time periods in
	the case of stacked time series.  In the case of simple
	cross-sectional data the periodicity should be set to 1.
      </para>
      <para>
	The starting observation represents the starting date in the
	case of time series data.  Years may be given with two or four
	digits; subperiods (for example, quarters or months) should be
	separated from the year with a colon.  In the case of panel
	data the starting observation should be given as 1:1; and in
	the case of cross-sectional data, as 1.  Starting observations
	for daily or weekly data should be given in the form YY/MM/DD
	or YYYY/MM/DD (or simply as 1 for undated data).  
      </para>
      <para>
	The second form of the command (which requires the
	<lit>--panel-vars</lit> flag) may be used to impose a panel
	interpretation when the data set contains variables that uniquely
	identify the cross-sectional units and the time periods.  The data
	set will be sorted as stacked time series, by ascending values of
	the units variable, <repl>unitvar</repl>.
      </para>
      <para>
	If no explicit option flag is given to indicate the structure
	of the data the program will attempt to guess the structure
	from the information given.
      </para>
    </description> 

    <gui-access>
      <menu-path>/Data/Dataset structure</menu-path>
    </gui-access>
      
  </command>

  <command name="setmiss" section="Dataset"
    label="Missing value code">

    <usage>
      <arguments>
        <argument>value</argument>
        <argument optional="true">varlist</argument>
      </arguments>
      <examples>
        <example>setmiss -1</example>
        <example>setmiss 100 x2</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
	Get the program to interpret some specific numerical data
	value (the first parameter to the command) as a code for
	<quote>missing</quote>, in the case of imported data.  If this
	value is the only parameter, as in the first example above,
	the interpretation will be applied to all series in the data
	set.  If <repl quote="true">value</repl> is followed by a list
	of variables, by name or number, the interpretation is
	confined to the specified variable(s). Thus in the second
	example the data value 100 is interpreted as a code for
	<quote>missing</quote>, but only for the variable
	<lit>x2</lit>.
      </para>
      
      <para context="gui">
	Set a numerical value that will be interpreted as "missing" or
	"not applicable", either for a particular data series (under
	the Variable menu) or globally for the entire data set (under
	the Sample menu).</para> 
      
      <para context="gui">
	Gretl has its own internal coding for missing values, but
	sometimes imported data may employ a different code.  For
	example, if a particular series is coded such that a value of
	-1 indicates "not applicable", you can select "Set missing
	value code" under the Variable menu and type in the value "-1"
	(without the quotes).  Gretl will then read the -1s as missing
	observations.</para>

    </description>

    <gui-access>
      <menu-path>/Sample/Set missing value code</menu-path>
    </gui-access>

  </command>

  <command name="shell" section="Utilities" 
    label="Execute shell commands" context="cli">

    <usage>
      <arguments>
        <argument>shellcommand</argument>
      </arguments>
      <examples>
        <example>! ls -al</example>
	<example>! notepad</example>
	<example>launch notepad</example>
      </examples>
    </usage>

    <description>
      <para>
	A <cmd>!</cmd>, or the keyword <cmd>launch</cmd>, at the beginning
	of a command line is interpreted as an escape to the user's shell.
	Thus arbitrary shell commands can be executed from within
	<program>gretl</program>.  When <cmd>!</cmd> is used, the external
	command is executed synchronously.  That is,
	<program>gretl</program> waits for it to complete before
	proceeding.  If you want to start another program from within
	<program>gretl</program> and not wait for its completion
	(asynchronous operation), use <cmd>launch</cmd> instead.
      </para>
      <para>
	For reasons of security this facility is not enabled by default.
	To activate it, check the box titled <quote>Allow shell
	commands</quote> under the File, Preferences menu in the GUI
	program.  This also makes shell commands available in the
	command-line program (and is the only way to do so).  </para>
    </description>

  </command>

  <command name="smpl" section="Dataset" 
    label="Set the sample range" context="cli">

    <!-- don't break the lines below or the text version will get messed
    up -->

    <usage>
      <altforms>
	<altform><lit>smpl</lit> <repl>startobs endobs</repl></altform>
	<altform><lit>smpl</lit> <repl>+i -j</repl></altform>
	<altform><lit>smpl</lit> <repl>dumvar</repl> <lit>--dummy</lit></altform>
	<altform><lit>smpl</lit> <repl>condition</repl> <lit>--restrict</lit></altform>
	<altform><lit>smpl</lit> <lit>--no-missing [ </lit><repl>varlist</repl> <lit>]</lit></altform>
	<altform><lit>smpl</lit> <repl>n</repl> <lit>--random</lit></altform>
	<altform><lit>smpl full</lit></altform>
      </altforms>
      <examples>
        <example>smpl 3 10</example>
	<example>smpl 1960:2 1982:4</example>
	<example>smpl +1 -1</example>
	<example>smpl x > 3000 --restrict</example>
	<example>smpl y > 3000 --restrict --replace</example>
	<example>smpl 100 --random</example>
      </examples>
    </usage>

    <description>
      <para>
	Resets the sample range.  The new range can be defined in
	several ways.  In the first alternate form (and the first two
	examples) above, <repl>startobs</repl> and <repl>endobs</repl>
	must be consistent with the periodicity of the data.  Either
	one may be replaced by a semicolon to leave the value
	unchanged.  In the second form, the integers <repl>i</repl>
	and <repl>j</repl> (which may be positive or negative, and
	should be signed) are taken as offsets relative to the
	existing sample range. In the third form <repl>dummyvar</repl>
	must be an indicator variable with values 0 or 1 at each
	observation; the sample will be restricted to observations
	where the value is 1. The fourth form, using
	<lit>--restrict</lit>, restricts the sample to observations
	that satisfy the given Boolean condition (which is specified
	according to the syntax of the <cmdref targ="genr"/>
	command).</para>

      <para>With the <lit>--no-missing</lit> form, if
	<repl>varlist</repl> is specified observations are selected on
	condition that all variables in <repl>varlist</repl> have
	valid values at that observation; otherwise, if no
	<repl>varlist</repl> is given, observations are selected on
	condition that <emphasis>all</emphasis> variables have valid
	(non-missing) values.</para>

      <para>With the <lit>--random</lit> flag, the specified number of
	cases are selected from the full dataset at random.  If you
	wish to be able to replicate this selection you should 
	set the seed for the random number generator first (see the
	<cmdref targ="set"/> command).</para>

      <para>The final form, <lit>smpl full</lit>, restores the full
	data range.
      </para>

      <para>Note that sample restrictions are, by default, cumulative:
	the baseline for any <lit>smpl</lit> command is the current
	sample. If you wish the command to act so as to replace any
	existing restriction you can add the option flag
	<lit>--replace</lit> to the end of the command.</para>

      <para>The internal variable <lit>obs</lit> may be used with the
	<lit>--restrict</lit> form of <lit>smpl</lit> to exclude
	particular observations from the sample.  For example</para>

      <code>
	smpl obs!=4 --restrict
      </code> 

      <para>will drop just the fourth observation. If the data points
	are identified by labels,</para>

      <code>
	smpl obs!="USA" --restrict
      </code>
	  
      <para>will drop the observation with label <quote>USA</quote>.
      </para>

      <para>
	One point should be noted about the <lit>--dummy</lit>,
	<lit>--restrict</lit> and <lit>--no-missing</lit> forms of
	<lit>smpl</lit>: Any <quote>structural</quote> information in
	the data file (regarding the time series or panel nature of
	the data) is lost when this command is issued.  You may
	reimpose structure with the <cmdref targ="setobs"/> command.
      </para>

      <para>Please see <guideref targ="sampling"/> for further details.</para>

    </description>

    <gui-access>
      <menu-path>/Sample</menu-path>
    </gui-access>

  </command>

  <command name="spearman" section="Statistics"
    label="Spearmans's rank correlation">

    <usage>
      <arguments>
        <argument>x</argument>
        <argument>y</argument>
      </arguments>
      <options>
        <option>
	  <flag>--verbose</flag>
	  <effect>print ranked data</effect>
        </option>
      </options>
    </usage>

    <description>
      <para context="cli">
	Prints Spearman's rank correlation coefficient for the two
	variables <math>x</math> and <math>y</math>. The
	variables do not have to be ranked manually in advance; the
	function takes care of this.
      </para>

      <para context="gui">
	Prints Spearman's rank correlation coefficient for a specified
	pair of variables.  The variables do not have to be ranked
	manually in advance; the function takes care of this.</para>

      <para>
	The automatic ranking is from largest to smallest (&ie; the
	largest data value gets rank 1).  If you need to invert this
	ranking, create a new variable which is the negative of the
	original first.  For example:
      </para>

      <code>
	genr altx = -x
	spearman altx y
      </code>
    </description>

    <gui-access>
      <menu-path>/Model/Robust estimation/Rank correlation</menu-path>
    </gui-access>

  </command>

  <command name="sprintf" section="Printing" 
    label="Printing to a string" context="cli">

    <usage>
      <arguments>
	<argument>stringvar</argument>
        <argument>format</argument>
	<argpunct>, </argpunct>
        <argument>args</argument>
      </arguments>
    </usage>

    <description>
      <para>
	This command works exactly like the <cmdref targ="printf"/>
	command, printing the given arguments under the control of the
	format string, except that the result is written into the named
	string, <repl>stringvar</repl>.
      </para>
      <para>
	To print the string variable, give its name preceded by
	<lit>@</lit>, as in
      </para>
      <code>
	sprintf myvar "%g", x
	print "myvar has value @myvar"
      </code>
    </description>

  </command>

  <command name="square" section="Transformations" 
    label="Create squares of variables" context="cli">

    <usage>
      <arguments>
        <argument>varlist</argument>
      </arguments>
      <options>
        <option>
	  <flag>--cross</flag>
	  <effect>generate cross-products as well as squares</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Generates new variables which are squares of the variables in
	<repl>varlist</repl> (plus cross-products if the
	<lit>--cross</lit> option is given).  For example, <cmd>square
	  x y</cmd> will generate <lit>sq_x</lit> = <lit>x</lit>
	squared, <lit>sq_y</lit> = <lit>y</lit> squared and
	(optionally) <lit>x_y</lit> = <lit>x</lit> times <lit>y</lit>.
	If a particular variable is a dummy variable it is not squared
	because we will get the same variable.  
      </para>
    </description>

    <gui-access>
      <menu-path>/Add/Squares of selected variables</menu-path>
    </gui-access>

  </command>

  <command name="sscanf" section="Programming" 
    label="Scanning a string" context="cli">

    <usage>
      <arguments>
	<argument>source</argument>
	<argpunct>, </argpunct>
        <argument>format</argument>
	<argpunct>, </argpunct>
        <argument>args</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Scans the string <repl>source</repl> under the control of
	<repl>format</repl>, assigning zero or more values to the
	given <repl>args</repl>. This is a simplifed version of the
	<lit>sscanf</lit> function in the C programming language.
      </para>
      <para>
	<repl>source</repl> may be either a literal string, enclosed in double
	quotes, or the name of a predefined string variable.
	<repl>format</repl> is defined similarly to the format string in
	<cmdref targ="printf"/> (more on this below). <repl>args</repl> should
	be a comma-separated list containing the names of pre-defined
	variables: these are the targets of conversion from
	<repl>source</repl>.  (For those used to C: one can prefix the names
	of numerical variables with <lit>&amp;</lit> but this is not
	required.)
      </para>
      <para>
	Literal	text in <repl>format</repl> is matched against
	<repl>source</repl>.  Conversion specifiers start with
	<lit>%</lit>, and recognized conversions include <lit>%f</lit>,
	<lit>%g</lit> or <lit>%lf</lit> for floating-point numbers;
	<lit>%d</lit> for integers; <lit>%s</lit> for strings; and
	<lit>%m</lit> for matrices.  You may insert a positive integer
	after the percent sign: this sets the maximum number of characters
	to read for the given conversion (or the maximum number of rows in
	the case of matrix conversion). Alternatively, you can insert a
	literal <lit>*</lit> after the percent to suppress the conversion
	(thereby skipping any characters that would otherwise have been
	converted for the given type).  For example, <lit>%3d</lit>
	converts the next 3 characters in <repl>source</repl> to an
	integer, if possible; <lit>%*g</lit> skips as many characters in
	<repl>source</repl> as could be converted to a single
	floating-point number.
      </para>
      <para>
	Matrix conversion works thus: the scanner reads a line of input
	and counts the (space- or tab-separated) number of numeric fields.
	This defines the number of columns in the matrix.  By default,
	reading then proceeds for as many lines (rows) as contain the same
	number of numeric columns, but the maximum number of rows to read
	can be limited as described above.
      </para>
      <para>
	In addition to <lit>%s</lit> conversion for strings, a simplified
	version of the C format
	<lit>%</lit><repl>N</repl><lit>[</lit><repl>chars</repl><lit>]</lit> 
	is available.  In this format <repl>N</repl> is the maximum number
	of characters to read and <repl>chars</repl> is a set of
	acceptable characters, enclosed in square brackets: reading stops
	if <repl>N</repl> is reached or if a character not in
	<repl>chars</repl> is encountered. The function of
	<repl>chars</repl> can be reversed by giving a circumflex,
	<lit>^</lit>, as the first character; in that case reading stops
	if a character in the given set is found.  (Unlike C, the hyphen
	does not play a special role in the <repl>chars</repl> set.)
      </para>
      <para>
	If the source string does not (fully) match the format, the number
	of conversions may fall short of the number of arguments given.
	This is not in itself an error so far as gretl is concerned.
	However, you may wish to check the number of conversions
	performed; this is given by the built-in scalar variable
	<lit>$nscan</lit>, whose value is refreshed every time
	<lit>sscanf</lit> is called.  The number of conversions is also
	printed, in interactive use.
      </para>
      <para>
	Some examples follow:
      </para>
      <code>
	scalar x
	scalar y
	sscanf "123456", "%3d%3d", x, y

	sprintf S "1 2 3 4\n5 6 7 8"
	S
	matrix m
	sscanf S, "%m", m
	print m
      </code>

    </description>

  </command>


  <command name="store" section="Dataset" label="Save data">

    <usage>
      <arguments>
        <argument>datafile</argument>
        <argument optional="true">varlist</argument>
      </arguments>
      <options>
        <option>
	  <flag>--csv</flag>
	  <effect>use CSV format</effect>
        </option>
        <option>
	  <flag>--omit-obs</flag>
	  <effect>see below, on CSV format</effect>
        </option>
        <option>
	  <flag>--gnu-octave</flag>
	  <effect>use GNU Octave format</effect>
        </option>
        <option>
	  <flag>--gnu-R</flag>
	  <effect>use GNU R format</effect>
        </option>
        <option>
	  <flag>--traditional</flag>
	  <effect>use traditional ESL format</effect>
        </option>
        <option>
	  <flag>--gzipped</flag>
	  <effect>apply gzip compression</effect>
        </option>
        <option>
	  <flag>--jmulti</flag>
	  <effect>use JMulti ASCII format</effect>
        </option>
        <option>
	  <flag>--dat</flag>
	  <effect>use PcGive ASCII format</effect>
        </option>
        <option>
	  <flag>--database</flag>
	  <effect>use gretl database format</effect>
        </option>
        <option>
	  <flag>--overwrite</flag>
	  <effect>see below, on database format</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Saves either the entire dataset or, if a <repl>varlist</repl>
	is supplied, a specified subset of the variables in the
	current dataset, to the file given by
	<repl>datafile</repl>.</para>

      <para>
	By default the data are saved in <quote>native</quote> gretl
	format, but the option flags permit saving in several
	alternative formats.  CSV (Comma-Separated Values) data may be
	read into spreadsheet programs, and can also be manipulated
	using a text editor.  The formats of
	<program>Octave</program>, <program>R</program> and
	<program>PcGive</program> are designed for use with the
	respective programs.  Gzip compression may be useful for large
	datasets.  See <guideref targ="datafiles"/> for details on the
	various formats.</para>

      <para>
	The option flag <lit>--omit-obs</lit> is applicable only when saving
	data in CSV format.  By default, if the data are time series or panel or
	if the dataset includes specific observation markers, the CSV file
	includes a first column identifying the observations (&eg; by date).  If
	the <lit>--omit-obs</lit> flag is given this column is omitted; only the
	actual data are printed.
      </para>

      <para>
	Note that any scalar variables will not be saved
	automatically: if you wish to save scalars you must explicitly
	list them in <repl>varlist</repl>.
      </para>  

      <para>
	The option of saving in gretl database format is intended to help with the
	construction of large sets of series, possibly having mixed frequencies and
	ranges of observations.  At present this option is available only for
	annual, quarterly or monthly time-series data. If you save to a file that
	already exists, the default action is to append the newly saved series to
	the existing content of the database.  In this context it is an error if one
	or more of the variables to be saved has the same name as a variable that is
	already present in the database. The <lit>--overwrite</lit> flag has the
	effect that, if there are variable names in common, the newly saved variable
	replaces the variable of the same name in the original dataset.
      </para>
	
    </description>

    <gui-access>
      <menu-path>/File/Save data; /File/Export data</menu-path>
    </gui-access>

  </command>

  <command name="summary" section="Statistics" 
    label="Descriptive statistics" context="cli">

    <usage>
      <arguments>
        <argument optional="true">varlist</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Print summary statistics for the variables in
	<repl>varlist</repl>, or for all the variables in the data set
	if <repl>varlist</repl> is omitted. Output consists of the
	mean, standard deviation (sd), coefficient of variation (=
	sd/mean), median, minimum, maximum, skewness coefficient, and
	excess kurtosis.
      </para>
    </description>

    <gui-access>
      <menu-path>/View/Summary statistics</menu-path>
      <other-access>Main window pop-up menu</other-access>
    </gui-access>

  </command>

  <command name="system" section="Estimation" label="Systems of equations">

    <usage>
      <altforms>
	<altform><lit>system method=</lit><repl>estimator</repl></altform>
	<altform><repl>sysname</repl><lit> &lt;- system</lit></altform>
      </altforms>
      <examples>
	<example>"Klein Model 1" &lt;- system</example>
        <example>system method=sur</example>
	<example>system method=3sls</example>
	<demos>
	  <demo>klein.inp</demo>
	  <demo>kmenta.inp</demo>
	  <demo>greene14_2.inp</demo>
	</demos>	  
      </examples>
    </usage>

    <description>

      <para context="gui">
	In this window you can define a system of equations and choose an
	estimator for the system.  Four sorts of statement may be given here, as
	follows:
      </para>

      <para context="cli">
	Starts a system of equations.  Either of two forms of the
	command may be given, depending on whether you wish to save
	the system for estimation in more than one way or just
	estimate the system once.</para>

      <para context="cli">
	To save the system you should assign it a name, as in the first
	example (if the name contains spaces it must be surrounded by
	double quotes).  In this case you estimate the system using
	the <cmdref targ="estimate"/> command.  With a saved system of
	equations, you are able to impose restrictions (including
	cross-equation restrictions) using the <cmdref
	targ="restrict"/> command.
      </para>

      <para context="cli">
	Alternatively you can specify an estimator for the system
	using <lit>method=</lit> followed by a string identifying one
	of the supported estimators: <cmd>ols</cmd> (Ordinary Least
	Squares), <cmd>tsls</cmd> (Two-Stage Least Squares)
	<cmd>sur</cmd> (Seemingly Unrelated Regressions),
	<cmd>3sls</cmd> (Three-Stage Least Squares), <cmd>fiml</cmd>
	(Full Information Maximum Likelihood) or <cmd>liml</cmd>
	(Limited Information Maximum Likelihood).  In this case the
	system is estimated once its definition is complete.  
      </para>

      <para context="cli">
	An equation system is terminated by the line <cmd>end system</cmd>.
	Within the system four sorts of statement may be given, as follows.
      </para>

      <ilist>
	<li><para><cmdref targ="equation"/>: specify an equation
	    within the system.  At least two such statements must be
	    provided.</para>
	</li>
	<li><para><cmd>instr</cmd>: for a system to be estimated via
	    Three-Stage Least Squares, a list of instruments (by
	    variable name or number). Alternatively, you can put this
	    information into the <cmd>equation</cmd> line using the
	    same syntax as in the <cmdref targ="tsls"/>
	    command.</para>
	</li>
	<li><para><cmd>endog</cmd>: for a system of simultaneous
	    equations, a list of endogenous variables.  This is
	    primarily intended for use with FIML estimation, but with
	    Three-Stage Least Squares this approach may be used
	    instead of giving an <cmd>instr</cmd> list; then all the
	    variables not identified as endogenous will be used as
	    instruments.</para>
	</li>
	<li><para><cmd>identity</cmd>: for use with FIML, an identity
	    linking two or more of the variables in the system.  This
	    sort of statement is ignored when an estimator other than
	    FIML is used.
	  </para>
	</li>
      </ilist>
	
      <para context="cli">
	After estimation using the <cmd>system</cmd> or
	<cmd>estimate</cmd> commands the following accessors can be used to
	retrieve additional information:
      </para>

      <ilist context="cli">
	<li><para><lit>$uhat</lit>: the matrix of residuals, one column
	    per equation.
	  </para>
	</li>
	<li><para><lit>$yhat</lit>: matrix of fitted values, one column
	    per equation.
	  </para>
	</li>
	<li><para><lit>$coeff</lit>: column vector of coefficients (all
	    the coefficients from the first equation, followed by those
	    from the second equation, and so on).
	  </para>
	</li>
	<li><para><lit>$vcv</lit>: covariance matrix of the coefficients.
	    If there are <math>k</math> elements in the
	    <lit>$coeff</lit> vector, this matrix is <math>k</math>
	    by <math>k</math>.
	  </para>
	</li>
	<li><para><lit>$sigma</lit>: cross-equation residual covariance
	    matrix.
	  </para>
	</li>
	<li><para><lit>$sysGamma</lit>, <lit>$sysA</lit> and <lit>$sysB</lit>: 
	    structural-form coefficient matrices (see below).
	  </para>
	</li>
      </ilist>

      <para context="cli">
	If you want to retrieve the residuals or fitted values for a
	specific equation as a data series, select a column from the
	<lit>$uhat</lit> or <lit>$yhat</lit> matrix and assign it to
	a series, as in
      </para>
      <code context="cli">
	series uh1 = $uhat[,1]
      </code>

      <para>
	The structural-form matrices correspond to the following
	representation of a simultaneous equations model:
	<equation status="display"
	  tex="\[\Gamma y_t=Ay_{t-1}+Bx_t+\epsilon_t\]"
	  ascii="Gamma y(t) = A y(t-1) + B x(t) + e(t)"
	  graphic="structural"/> If there are <math>n</math> endogenous
	variables and <math>k</math> exogenous variables, 
	<equation status="inline"
	  tex="$\Gamma$"
	  ascii="Gamma"
	  graphic="Gamma"/> is an <by r="n" c="n"/> matrix and <math>B</math>
	is <by r="n" c="k"/>. If the system contains no lags of the endogenous
	variables then the <math>A</math> matrix is not present.  If the
	maximum lag of an endogenous regressor is <math>p</math>,
	the <math>A</math> matrix is <by r="n" c="np"/>.
      </para>

    </description>

    <gui-access>
      <menu-path>/Model/Simultaneous equations</menu-path>
    </gui-access>

  </command>

  <command name="tabprint" section="Printing" 
    label="Print model in tabular form" context="cli">

    <usage>
      <arguments>
        <argument optional="true">-f filename</argument>
      </arguments>
      <options>
        <option>
	  <flag>--rtf</flag>
	  <effect>Produce RTF instead of &latex;</effect>
        </option>
        <option>
	  <flag>--complete</flag>
	  <effect>Create a complete document</effect>
        </option>
        <option>
	  <flag>--format="f1|f2|f3|f4"</flag>
	  <effect>Specify a custom format</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Must follow the estimation of a model.  Prints the estimated model in
	tabular form &mdash; by default as &latex;, but as RTF if the
	<lit>--rtf</lit> flag is given.  If a filename is specified using the
	<lit>-f</lit> flag output goes to that file, otherwise it goes to a
	file with a name of the form <filename>model_N.tex</filename> (or
	<filename>model_N.rtf</filename>), where <lit>N</lit> is the number of
	models estimated to date in the current session.
      </para>
      <para>
	The further options discussed below are available only when printing
	the model as &latex;.
      </para>
      <para>
	If the <lit>--complete</lit> flag is given the &latex; file is
	a complete document, ready for processing; otherwise it must
	be included in a document.
      </para>
      <para>
	If you wish alter the appearance of the tabular output, you can
	specify a custom row format using the <lit>--format</lit> flag.
	The format string must be enclosed in double quotes and must be
	tied to the flag with an equals sign.  The pattern for the format
	string is as follows.  There are four fields, representing the
	coefficient, standard error, <math>t</math>-ratio and
	p-value respectively.  These fields should be separated by
	vertical bars; they may contain a <lit>printf</lit>-type
	specification for the formatting of the numeric value in question,
	or may be left blank to suppress the printing of that column
	(subject to the constraint that you can't leave all the columns
	blank).  Here are a few examples:
      </para>
      <code>
	--format="%.4f|%.4f|%.4f|%.4f"
	--format="%.4f|%.4f|%.3f|"
	--format="%.5f|%.4f||%.4f"
	--format="%.8g|%.8g||%.4f"
      </code>
      <para>
	The first of these specifications prints the values in all columns
	using 4 decimal places.  The second suppresses the p-value and
	prints the <math>t</math>-ratio to 3 places.  The third
	omits the <math>t</math>-ratio.  The last one again omits
	the <math>t</math>, and prints both coefficient and standard
	error to 8 significant figures.
      </para>
      <para>
	Once you set a custom format in this way, it is remembered and
	used for the duration of the gretl session.  To revert to
	the default format you can use the special variant
	<lit>--format=default</lit>.
      </para>
    </description>

    <gui-access>
      <menu-path>Model window, /LaTeX</menu-path>
    </gui-access>

  </command>

  <command name="testuhat" section="Tests" context="cli"
    label="Normality of residual">

    <description>
      <para>
	Must follow a model estimation command.  Gives the frequency
	distribution for the residual from the model along with a
	chi-square test for normality, based on the procedure
	suggested by Doornik and Hansen (1994).
      </para>
    </description>

    <gui-access>
      <menu-path>Model window, /Tests/Normality of residual</menu-path>
    </gui-access>

  </command>

  <command name="tobit" section="Estimation" label="Tobit model">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
        <option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
        </option>
        <option>
	  <flag>--verbose</flag>
	  <effect>print details of iterations</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>Estimates a Tobit model.  This model may be appropriate
	when the dependent variable is <quote>censored</quote>.  For
	example, positive and zero values of purchases of durable
	goods on the part of individual households are observed, and
	no negative values, yet decisions on such purchases may be
	thought of as outcomes of an underlying, unobserved
	disposition to purchase that may be negative in some cases.
	For details see Greene's <book>Econometric Analysis</book>,
	Chapter 20.</para>
    </description>

    <gui-access>
      <menu-path>/Model/Nonlinear models/Tobit</menu-path>
    </gui-access>

  </command>

  <command name="transpos" section="Dataset" label="Transpose data"
    context="gui">

    <description>
      <para>
	Transposes the current data set.  That is, each observation
	(row) in the current data set will be treated as a variable
	(column), and each variable as an observation.  This command
	may be useful if data have been read from some external source 
	in which the rows of the data table represent variables.
      </para>
      <para>
	See also <cmdref targ="dataset"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Data/Transpose data</menu-path>
    </gui-access>

  </command>

  <command name="tsls" section="Estimation"
    label="Two-Stage Least Squares">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
	<argument separated="true">instruments</argument>
      </arguments>
      <options>
        <option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
        </option>
	<option>
	  <flag>--robust</flag>
	  <effect>robust standard errors</effect>
        </option>
      </options>      
      <examples>
        <example>tsls y1 0 y2 y3 x1 x2 ; 0 x1 x2 x3 x4 x5 x6</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
	Computes two-stage least squares (TSLS or IV) estimates:
	<repl>depvar</repl> is the dependent variable,
	<repl>indepvars</repl> is the list of independent variables
	(including right-hand side endogenous variables) in the
	structural equation for which TSLS estimates are needed; and
	<repl>instruments</repl> is the combined list of exogenous and
	predetermined variables in all the equations. If the
	<repl>instruments</repl> list is not at least as long as
	<repl>indepvars</repl>, the model is not identified.</para>

      <para context="cli">
	In the above example, the <lit>y</lit>s are the endogenous
	variables and the <lit>x</lit>s are the exogenous and
	predetermined variables.  
      </para>

      <para context="gui">
	This command requires the selection of two lists of variables:
	the independent variables to appear in the given model and a
	set of "instruments".  The latter comprises the exogenous
	and/or predetermined variables that may be used as regressors
	to derive fitted values for the right-hand side endogenous
	variables.
      </para>

      <para context="gui">If some of the right-hand side variables for
	the model are exogenous, they should be referenced in both
	lists.
      </para>

      <para>
	Output includes the Hausman test and, if the model is
	over-identified, the Sargan over-identification test.  In the
	Hausman test, the null hypothesis is that OLS estimates are
	consistent, or in other words estimation by means of
	instrumental variables is not required.  A model of this sort
	is over-identified if there are more instruments than are
	strictly required.  The Sargan test is based on an auxiliary
	regression of the residuals from the two-stage least squares
	model on the full list of instruments.  The null hypothesis is
	that all the instruments are valid, and suspicion is thrown on
	this hypothesis if the auxiliary regression has a significant
	degree of explanatory power.  Davidson and MacKinnon (2004,
	chapter 8) give a good explanation of both tests.
      </para>

    </description>

    <gui-access>
      <menu-path>/Model/Other linear models/Two-Stage least Squares</menu-path>
    </gui-access>

  </command>

  <command name="var" section="Estimation"
    label="Vector Autoregression">

    <usage>
      <arguments>
        <argument>order</argument>
        <argument>varlist</argument>
	<argument separated="true" optional="true">exolist</argument>
      </arguments>
      <options>
        <option>
	  <flag>--nc</flag>
	  <effect>do not include a constant</effect>
        </option>
        <option>
	  <flag>--trend</flag>
	  <effect>include a linear trend</effect>
        </option>
        <option>
	  <flag>--seasonals</flag>
	  <effect>include seasonal dummy variables</effect>
        </option>
        <option>
	  <flag>--robust</flag>
	  <effect>robust standard errors</effect>
        </option>
        <option>
	  <flag>--impulse-responses</flag>
	  <effect>print impulse responses</effect>
        </option>
        <option>
	  <flag>--variance-decomp</flag>
	  <effect>print forecast variance decompositions</effect>
        </option>
        <option>
	  <flag>--lagselect</flag>
	  <effect>show information criteria for lag selection</effect>
        </option>
      </options>
      <examples>
        <example>var 4 x1 x2 x3 ; time mydum</example>
	<example>var 4 x1 x2 x3 --seasonals</example>
	<example>var 12 x1 x2 x3 --lagselect</example>
      </examples>
    </usage>

    <description>

      <para context="gui">
	This command requires specification of:</para>

      <ilist context="gui">
	<li><para context="gui">- the lag order, that is, the number of
	    lags of each variable that should be included in the
	    system;</para>
	</li>

	<li><para context="gui">- any exogenous variables (but note that a
	    constant is included automatically unless you specify otherwise, a
	    trend can be added using the trend checkbox, and seasonal dummy
	    variables can be added using the seasonals checkbox); and
	  </para>
	</li>

	<li><para context="gui">- a list of endogenous variables, lags
	    of which will be included on the right-hand side of each
	    equation (note: do not include lagged variables in this
	    list -- they will be added automatically).</para>
	</li>
      </ilist>

      <para context="gui">A separate regression will be run for
	variable in the system.  Output for each equation includes
	F-tests for zero restrictions on all lags of each of the
	variables and an F-test for the maximum lag, along with
	(optionally) forecast variance decompositions and impulse
	response functions.</para>

      <para context="cli">
	Sets up and estimates (using OLS) a vector autoregression (VAR).
	The first argument specifies the lag order &mdash; or the maximum
	lag order in case the <lit>--lagselect</lit> option is given (see
	below).  The order may be given numerically, or as the name of a
	pre-existing scalar variable. Then follows the setup for the first
	equation.  Don't include lags among the elements of
	<repl>varlist</repl> &mdash; they will be added automatically.
	The semi-colon separates the stochastic variables, for which
	<repl>order</repl> lags will be included, from any exogenous
	variables in <repl>exolist</repl>.  Note that a constant is
	included automatically unless you give the <lit>--nc</lit> flag, a
	trend can be added with the <lit>--trend</lit> flag, and seasonal
	dummy variables may be added using the <lit>--seasonals</lit>
	flag.
      </para>

      <para context="cli">
	A separate regression is run for each variable in <repl>varlist</repl>.
	Output for each equation includes <math>F</math>-tests for zero
	restrictions on all lags of each of the variables, an
	<math>F</math>-test for the significance of the maximum lag, and,
	if the <lit>--impulse-responses</lit> flag is given, forecast variance
	decompositions and impulse responses.
      </para>

      <para>
	Forecast variance decompositions and impulse responses are based on the
	Cholesky decomposition of the contemporaneous covariance matrix, and in
	this context the order in which the (stochastic) variables are given
	matters.  The first variable in the list is assumed to be <quote>most
	  exogenous</quote> within-period. The horizon for variance
	decompositions and impulse responses can be set using the <cmdref
	  targ="set"/> command.
      </para>

      <para context="cli">
	If the <lit>--lagselect</lit> option is given, the first parameter to
	the <lit>var</lit> command is taken as the maximum lag order.  Output
	consists of a table showing the values of the Akaike (AIC), Schwartz
	(BIC) and Hannan&ndash;Quinn (HQC) information criteria computed from
	VARs of order 1 to the given maximum.  This is intended to help
	with the selection of the optimal lag order.  The usual VAR output is
	not presented.
      </para>

    </description>

    <gui-access>
      <menu-path>/Model/Time series/Vector autoregression</menu-path>
    </gui-access>

  </command>

  <command name="VAR-lagselect" section="Tests" context="gui"
    label="VAR lag-length selection">

    <description>
      <para>
	In this dialog box you specify a VAR as usual, but use the lag order
	spin button to set the maximum number of lags to test.
      </para>

      <para>
	Output will consist of a table showing the values of the Akaike (AIC),
	Schwartz (BIC) and Hannan&ndash;Quinn (HQC) information criteria computed
	from VARs of order 1 to the chosen maximum.  This is intended to help with
	the selection of the optimal lag order.  
      </para>
    </description>

  </command>

  <command name="VAR-omit" section="Tests" context="gui"
    label="Test exogenous variables in VAR">

    <description>
      <para>
	Use this dialog box to specify a subset of exogenous variables in a VAR.
	These variables will be omitted from the original VAR, and the system
	re-estimated.
      </para>
      <para>
	A Likelihood Ratio test is reported, where the null hypothesis is that
	the true parameter values are zero, in all equations of the VAR, for the
	omitted variables.  The test is based on the difference between the
	log-determinant of the variance matrix for the unrestricted system, and
	that for the restricted system with the selected variables omitted.
      </para>
    </description>

  </command>

  <command name="varlist" section="Dataset" 
    label="Listing of variables" context="cli">

    <description>
      <para>
	Prints a listing of variables currently available.
	<cmd>list</cmd> and <cmd>ls</cmd> are synonyms.  
      </para>
    </description>

  </command>

  <command name="vartest" section="Tests"
    label="Difference of variances">

    <usage>
      <arguments>
        <argument>var1</argument>
        <argument>var2</argument>
      </arguments>
    </usage>

    <description>
      <para context="cli">
	Calculates the <math>F</math> statistic for the null
	hypothesis that the population variances for the variables
	<repl>var1</repl> and <repl>var2</repl> are equal, and shows
	its p-value.
      </para>
      <para context="gui">
	Calculates the <math>F</math> statistic for the null
	hypothesis that the population variances are equal for the
	two selected variables, and shows its p-value.
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Bivariate tests/Difference of variances</menu-path>
    </gui-access>

  </command>

  <command name="vecm" section="Estimation"
    label="Vector Error Correction Model">

    <usage>
      <arguments>
        <argument>order</argument>
	<argument>rank</argument>
        <argument>ylist</argument>
	<argblock optional="true" separated="true">
	  <argument>xlist</argument>
	</argblock>
	<argblock optional="true" separated="true">
	  <argument>rxlist</argument>
	</argblock>
      </arguments>
      <options>
        <option>
	  <flag>--nc</flag>
	  <effect>no constant</effect>
        </option>
        <option>
	  <flag>--rc</flag>
	  <effect>restricted constant</effect>
        </option>
        <option>
	  <flag>--crt</flag>
	  <effect>constant and restricted trend</effect>
        </option>
        <option>
	  <flag>--ct</flag>
	  <effect>constant and unrestricted trend</effect>
        </option>
        <option>
	  <flag>--seasonals</flag>
	  <effect>include centered seasonal dummies</effect>
        </option>
        <option>
	  <flag>--impulse-responses</flag>
	  <effect>print impulse responses</effect>
        </option>
        <option>
	  <flag>--variance-decomp</flag>
	  <effect>print forecast variance decompositions</effect>
        </option>
      </options>
      <examples>
        <example>vecm 4 1 Y1 Y2 Y3</example>
        <example>vecm 3 2 Y1 Y2 Y3 --rc</example>
	<example>vecm 3 2 Y1 Y2 Y3 ; X1 --rc</example>
	<demos>
	  <demo>denmark.inp</demo>
	  <demo>hamilton.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para>
	A VECM is a form of vector autoregression or VAR (see <cmdref
	  targ="var"/>), applicable where the variables in the model are
	individually integrated of order 1 (that is, are random walks, with or
	without drift), but exhibit cointegration.  This command is closely
	related to the Johansen test for cointegration (see <cmdref
	  targ="coint2"/>).
      </para>

      <para context="cli">
	The <repl>order</repl> parameter to this command represents the lag
	order of the VAR system.  The number of lags in the VECM itself (where
	the dependent variable is given as a first difference) is one less than
	<repl>order</repl>.
      </para>

      <para context="gui">
	The lag order selected in the VECM dialog box is that of the VAR system.
	The number of lags in the VECM itself (where the dependent variable is
	given as a first difference) is one less than this number.
      </para>

      <para context="cli">
	The <repl>rank</repl> parameter represents the cointegration rank, or in
	other words the number of cointegrating vectors.  This must be greater
	than zero and less than or equal to (generally, less than) the number of
	endogenous variables given in <repl>ylist</repl>.
      </para>

      <para context="gui">
	The <quote>cointegration rank</quote> represents the number of
	cointegrating vectors.  This must be greater than zero and less than or
	equal to (generally, less than) the number of endogenous variables 
	selected.
      </para>

      <para context="cli">
	<repl>ylist</repl> supplies the list of endogenous variables, in
	levels. The inclusion of deterministic terms in the model is controlled
	by the option flags.  The default if no option is specified is to
	include an <quote>unrestricted constant</quote>, which allows for the
	presence of a non-zero intercept in the cointegrating relations as well
	as a trend in the levels of the endogenous variables.  In the literature
	stemming from the work of Johensen (see for example his 1995 book) this
	is often referred to as <quote>case 3</quote>.  The first four options
	given above, which are mutually exclusive, produce cases 1, 2, 4 and 5
	respectively.  The meaning of these cases and the criteria for selecting
	a case are explained in <guideref targ="chap:vecm"/>.
      </para>

      <para context="cli">
	The optional lists <repl>xlist</repl> and <repl>rxlist</repl>
	allow you to specify sets of exogenous variables which enter the
	model either unrestrictedly (<repl>xlist</repl>) or restricted to
	the cointegration space (<repl>rxlist</repl>). These lists are
	separated from <repl>ylist</repl> and from each other by
	semicolons.
      </para>

      <para context="gui">
	In the <quote>Endogenous variables</quote> box you select the
	vector of endogenous variables, in levels. The inclusion of
	deterministic terms in the model is controlled by the option
	buttons.  The default is to include an <quote>unrestricted
	constant</quote>, which allows for the presence of a non-zero
	intercept in the cointegrating relations as well as a trend in the
	levels of the endogenous variables.  In the literature stemming
	from the work of Johensen (see for example his 1995 book) this is
	often referred to as <quote>case 3</quote>.  The other four
	options produce cases 1, 2, 4 and 5 respectively.  The meaning of
	these cases and the criteria for selecting a case are explained in
	<guideref targ="chap:vecm"/>.
      </para>

      <para context="gui">
	In the <quote>Exogenous variables</quote> box you may add specific
	exogenous variables.  By default these enter the model in
	unrestricted form (indicated by a <lit>U</lit> next to the name of
	the variable).  If you want a certain exogenous variable to be
	restricted to the cointegrating space, right-click on it and
	select <quote>Restricted</quote> from the pop-up menu.  The symbol
	next to the variable will change to R.
      </para>

      <para context="cli">
	The <lit>--seasonals</lit> option, which may be combined with any of the
	other options, specifies the inclusion of a set of centered seasonal
	dummy variables.  This option is available only for quarterly or monthly
	data.
      </para>

      <para context="gui">
	If the data are quarterly or monthly, a check box is shown that allows
	you to include a set of centered seasonal dummy variables.  In all
	cases, an additional check box (<quote>Show details</quote>) allows
	for the printing of the auxiliary regressions that form the starting
	point of the Johansen maximum likelihood estimation procedure.
      </para>

      <para context="cli">
	The first example above specifies a VECM with lag order 4 and a single
	cointegrating vector.  The endogenous variables are <lit>Y1</lit>,
	<lit>Y2</lit> and <lit>Y3</lit>.  The second example uses the same
	variables but specifies a lag order of 3 and two cointegrating vectors;
	it also specifies a <quote>restricted constant</quote>, which is
	appropriate if the cointegrating vectors may have a non-zero intercept
	but the <lit>Y</lit> variables have no trend.
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Time series/VECM</menu-path>
    </gui-access>

  </command>

  <command name="vif" section="Tests" context="cli"
    label="Variance Inflation Factors">

    <description>
      <para>
	Must follow the estimation of a model which includes at least
	two independent variables. Calculates and displays the
	Variance Inflation Factors (VIFs) for the regressors.  The VIF
	for regressor <math>j</math> is defined as
	<equation status="display" 
	  tex="\[\frac{1}{1-R_j^2}\]"
	  ascii="1/(1 - Rj^2)"
	  graphic="vif"/> where <math>R</math><sub>j</sub> is
	the coefficient of multiple correlation between regressor
	<math>j</math> and the other regressors. The factor has
	a minimum value of 1.0 when the variable in question is
	orthogonal to the other independent variables.  Neter,
	Wasserman, and Kutner (1990) suggest inspecting the largest
	VIF as a diagnostic for collinearity; a value greater than 10
	is sometimes taken as indicating a problematic degree of
	collinearity.
      </para>
    </description>

    <gui-access>
      <menu-path>Model window, /Tests/Collinearity</menu-path>
    </gui-access>

  </command>

  <command name="wls" section="Estimation"
    label="Weighted Least Squares">

    <usage>
      <arguments>
        <argument>wtvar</argument>
        <argument>depvar</argument>
	<argument>indepvars</argument>
      </arguments>
      <options>
        <option>
	  <flag>--vcv</flag>
	  <effect>print covariance matrix</effect>
        </option>
	<option>
	  <flag>--robust</flag>
	  <effect>robust standard errors</effect>
        </option>
	<option>
	  <flag>--quiet</flag>
	  <effect>suppress printing of results</effect>
        </option>
      </options> 
    </usage>

    <description>
      <para context="cli">
	Computes weighted least squares (WLS) estimates using
	<repl>wtvar</repl> as the weight, <repl>depvar</repl> as the
	dependent variable, and <repl>indepvars</repl> as the list of
	independent variables.  Let <repl>w</repl> denote the positive
	square root of <lit>wtvar</lit>; then WLS is basically equivalent
	to an OLS regression of <repl>w</repl> <lit>*</lit>
	<repl>depvar</repl> on <repl>w</repl> <lit>*</lit>
	<repl>indepvars</repl>.  The <emphasis>R</emphasis>-squared,
	however, is calculated in a special manner, namely as
	<equation status="display"
	  tex="\[R^2 = 1 - \frac{\rm ESS}{\rm WTSS}\]"
	  ascii="R^2 = 1 - ESS / WTSS"
	  graphic="wlsr2"/> where ESS is the error sum of squares (sum of
	squared residuals) from the weighted regression and WTSS denotes
	the <quote>weighted total sum of squares</quote>, which equals the
	sum of squared residuals from a regression of the weighted
	dependent variable on the weighted constant alone.
      </para>

      <para>
	If <repl>wtvar</repl> is a dummy variable, WLS estimation is
	equivalent to eliminating all observations with value zero for
	<repl>wtvar</repl>.
      </para>

      <para context="gui">
	Let "wtvar" denote the variable selected in the "Weight variable"
	box.  An OLS regression is run, where the dependent variable is
	the product of the positive square root of wtvar and the selected
	dependent variable, and the independent variables are also
	multiplied by the square root of wtvar. Statistics such as
	<emphasis>R</emphasis>-squared are based on the weighted
	data.  If wtvar is a dummy variable, weighted least squares
	estimation is equivalent to eliminating all observations with
	value zero for wtvar.
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Other linear models/Weighted Least Squares</menu-path>
    </gui-access>

  </command>

  <command name="working-dir" section="Utilities" label="Working directory"
    context="gui">

    <description>
      <para>
	The <quote>working directory</quote> is where gretl looks
	by default when reading or writing data files or scripts
	via the file Open and Save dialogs.
      </para>
      <para>
	In addition the working directory is the default location for
      </para>
      <ilist>
	<li>
	  <para>
	    reading files via the script commands <lit>append</lit>,
	    <lit>open</lit>, <lit>run</lit> and <lit>include</lit>; and
	  </para>
	</li>
	<li>
	  <para>
	    writing files via the commands <lit>eqnprint</lit>,
	    <lit>tabprint</lit>, <lit>gnuplot</lit>, <lit>outfile</lit>
	    and <lit>store</lit>.
	  </para>
	</li>
      </ilist>
      <para>
	The option of having gretl use the current directory (as
	determined via the shell) at start-up may be useful to people who
	are in the habit of launching gretl from a command prompt rather
	than a menu or icon.
      </para>
    </description>

    <gui-access>
      <menu-path>/File/Working directory</menu-path>
    </gui-access>

  </command>

  <command name="xcorrgm" section="Statistics" label="Cross-correlogram">

    <usage>
      <arguments>
        <argument>var1</argument>
        <argument>var2</argument>
        <argument optional="true">maxlag</argument>
      </arguments>
      <examples>
        <example>xcorrgm x y 12</example>
      </examples>
    </usage>

    <description>
      <para>
	Prints and graphs the cross-correlogram for variables
	<repl>var1</repl> and <repl>var2</repl>, which may be specified by
	name or number.  The values are the sample correlation coefficients
	between the current value of <repl>var1</repl> and successive leads
	and lags of <repl>var2</repl>.
      </para>
      <para>
	If a <repl>maxlag</repl> value is specified the length of the
	cross-correlogram is limited to at most that number of leads and
	lags, otherwise the length is determined automatically, as a
	function of the frequency of the data and the number of
	observations.
      </para>
    </description>

    <gui-access>
      <menu-path>/View/Cross-correlogram</menu-path>
      <other-access>Main window pop-up menu (multiple selection)</other-access>
    </gui-access>

  </command>

  <command name="xtab" section="Statistics" 
    label="Cross-tabulate variables">

    <usage>
      <arguments>
        <argument>ylist</argument>
	<argument optional="true" separated="true">xlist</argument>
      </arguments>
      <options>
        <option>
	  <flag>--row</flag>
	  <effect>display row percentages</effect>
        </option>
        <option>
	  <flag>--column</flag>
	  <effect>display column percentages</effect>
        </option>
        <option>
	  <flag>--zeros</flag>
	  <effect>display zero entries</effect>
        </option>
      </options>
    </usage>

    <description context="cli">
      <para>
        Displays a contingency table or cross-tabulation for each
	combination of the variables included in <repl>ylist</repl>; if a
	second list <repl>xlist</repl> is given, each variable in
	<repl>ylist</repl> is cross-tabulated by row against each variable
	in <repl>xlist</repl> (by column).  Variables in these lists can
	be referenced by name or by number.  Note that all the variables
	must have been marked as discrete.
      </para>
      <para>
	By default the cell entries are given as frequency counts. The
	<lit>--row</lit> and <lit>--column</lit> options (which are
	mutually exclusive), replace the counts with the percentages for
	each row or column, respectively.  By default, cells with a zero
	count are left blank; the <lit>--zeros</lit> option, which has the
	effect of showing zero counts explicitly, may be useful for
	importing the table into another program, such as a spreadsheet.
      </para>
      <para>
        Pearson's chi-square test for independence is displayed if the
        expected frequency under independence is at least 1.0e-7 for all
        cells.  A common rule of thumb for the validity of this statistic is
        that at least 80 percent of cells should have expected frequencies
        of 5 or greater; if this criterion is not met a warning is printed.
      </para>
      <para>
	If the contingency table is 2 by 2, Fisher's Exact Test for
	independence is computed.  Note that this test is based on the
	assumption that the row and column totals are fixed, which may or
	may not be appropriate depending on how the data were generated.
	The left p-value should be used when the alternative to
	independence is negative association (values tend to cluster
	in the lower left and upper right cells); the right p-value should
	be used if the alternative is positive association.  The two-tailed
	p-value for this test is calculated by method (b) in Agresti
	(1992, section 2.1): it is the sum of the probabilities of all
	possible tables having the given row and column totals and having
	a probability less than or equal to that of the observed table.
      </para>
    </description>

    <description context="gui">
      <para>
        Displays a contingency table or cross-tabulation for each
	combination of the selected variables.  Note that all the
	variables must be discrete.
      </para>
      <para>
	By default, frequency count values are shown in the cells and on
	the margins of the table.  However, you can choose to display
	either row or column percentages instead.
      </para>
      <para>
	By default, cells with a zero count are shown as empty, but you
	can choose to show zero values explicitly.
      </para>
      <para>
        Pearson's chi-square test for independence is displayed if the
        expected frequency under independence is at least 1.0e-7 for all
        cells.  A common rule of thumb for the validity of this statistic is
        that at least 80 percent of cells should have expected frequencies
        of 5 or greater; if this criterion is not met a warning is printed.
      </para>
      <para>
	If the contingency table is 2 by 2, Fisher's Exact Test for
	independence is computed.  Note that this test is based on the
	assumption that the row and column totals are fixed, which may or
	may not be approriate depending on how the data were generated.
	The left p-value should be used when the alternative to
	independence is negative association (values tend to cluster
	in the lower left and upper right cells); the right p-value should
	be used if the alternative is positive association.  The two-tailed
	p-value for this test is calculated by method (b) in Agresti
	(1992, section 2.1): it is the sum of the probabilities of all
	possible tables having the given row and column totals and having
	a probability less than or equal to that of the observed table.
      </para>
    </description>

  </command>

</commandlist>

