<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE funcref SYSTEM "gretl_functions.dtd">

<funcref language="portuguese">

  <funclist name="Accessors" ref="accessors">

    <function name="$ahat" section="access" output="series">
      <description>
	<para>
	  Deve seguir a estimação de um modelo de dados em painel com efeitos
	  fixos. Retorna uma série com as estimativas dos efeitos individuais
	  fixos (interceptos por unidade).
	</para>
      </description>
    </function>

    <function name="$aic" section="access" output="scalar">
      <description>
	<para>
	  Retorna o Critério de Informação de Akaike do último modelo
	  estimado, quando disponível. Veja <guideref targ="chap:criteria"/>
	  para detalhes sobre os cálculos.
	</para>
      </description>
    </function>

    <function name="$bic" section="access" output="scalar">
      <description>
	<para>
	  Retorna o Critério de Informação Bayesiano de Schwarz para o
	  último modelo estimado, quando disponível. Veja <guideref
	  targ="chap:criteria"/> para detalhes sobre os cálculos.
	</para>
      </description>
    </function>

    <function name="$chisq" section="access" output="scalar">
      <description>
	<para>
	  Retorna estatística qui-quadrado global do último modelo
	  estimado, quando disponível.
	</para>
      </description>
    </function>

    <function name="$coeff" section="access" output="matrix" altout="scalar">
      <fnargs>
	<fnarg optional="true" type="coeffname">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Quando utilizado sem argumentos, <lit>$coeff</lit> retorna um vetor
	  coluna com os coeficientes estimados do último modelo. Com o argumento
	  opcional de texto (string) a função retorna, na forma
	  de um escalar, o parâmetro estimado <argname>s</argname>.
	  <seelist>
            <fncref targ="$stderr"/>
            <fncref targ="$vcv"/>
	  </seelist>
	</para>
	<para>
	  Exemplo:
	</para>
	<code>
	  open bjg
	  arima 0 1 1 ; 0 1 1 ; lg
	  b = $coeff               # fornece um vetor
	  macoef = $coeff(theta_1) # fornece um escalar
	</code>
	<para>
	  Se o <quote>modelo</quote> em questão for um sistema, o
	  resultado dependerá das características do sistema: para
	  VARs e VECMs o valor retornado será uma matriz com uma
	  coluna por equação, caso contrário será um vetor coluna
	  contendo os coeficientes da primeira equação seguidos pelos
	  coeficientes da segunda equação e assim sucessivamente.
	</para>
      </description>
    </function>

    <function name="$command" section="access" output="string">
      <description>
	<para>
	  Deve ser utilizada após a estimação de um modelo e retorna
	  o seu tipo, por exemplo <lit>ols</lit> ou <lit>probit</lit>.
	</para>
      </description>
    </function>

    <function name="$compan" section="access" output="matrix">
      <description>
	<para>
	  Deve ser utilizada após a estimação de um VAR ou um VECM e
	  retorna a matriz companheira.
	</para>
      </description>
    </function>

    <function name="$datatype" section="access" output="scalar">
      <description>
	<para>
	  Retorna um número representando o tipo dos dados que estão sendo
	  atualmente utilizados: 0 = sem dados, 1 = dados de corte transversal
	  (não datados), 2 = dados de séries temporais, 3 = dados em painel.
	</para>
      </description>
    </function>

    <function name="$depvar" section="access" output="string">
      <description>
	<para>
	  Deve ser utilizada após a estimação de um modelo com equação
	  única e retorna o nome da variável dependente.
	</para>
      </description>
    </function>

    <function name="$df" section="access" output="scalar">
      <description>
	<para>
	  Retorna os graus de liberdade do último modelo estimado. Se o
	  último modelo for um sistema de equações, o valor retornado
	  será o número de graus de liberdade por equação. Se os graus de
	  liberdade das equações forem diferentes então o valor dado será
	  calculado como a diferença entre o número de observações e a
	  média do número de coeficientes por equação (essa média será
	  arredondada para o valor inteiro imediatamente superior).
	</para>
      </description>
    </function>

    <function name="$diagpval" section="access" output="scalar">
      <description>
	<para>
	  Deve ser utilizada após a estimação de um sistema de equações e
	  retorna o <math>P</math>-valor associado com a estatística <fncref
	  targ="$diagtest"/>.
	</para>
      </description>
    </function>

    <function name="$diagtest" section="access" output="scalar">
      <description>
	<para>
	  Deve ser utilizada após a estimação de um sistema de equações.
	  Retorna a estatística de teste para a hipótese nula de que a
	  matriz de covariâncias dos resíduos das equações do sistema é
	  diagonal. Este é o teste de Breusch&ndash;Pagan, exceto quando
	  o estimador for o SUR iterado (irrestrito), nesse caso será um
	  teste de razão de verossimilhança. Veja <guideref targ="chap:system"/>
	  para detalhes e também <fncref targ="$diagpval"/>.
	</para>
      </description>
    </function>

    <function name="$dw" section="access" output="scalar">
      <description>
	<para>
	  Retorna a estatística de Durbin&ndash;Watson para a correlação
	  de primeira ordem do último modelo estimado (quando disponível).
	</para>
      </description>
    </function>

    <function name="$dwpval" section="access" output="scalar">
      <description>
	<para>
	  Retorna o p-valor para a estatística de Durbin&ndash;Watson
	  do último modelo estimado (quando disponível). É calculada
	  via procedimento de Imhof.
	</para>
	<para>
	  Devido à precisão limitada da aritmética computacional,
	  a integral de Imhof pode se tornar negativa quando a
	  estatística de Durbin&ndash;Watson estiver próxima de
	  seu limite inferior. Nesse caso a função de acesso retorna
	  <lit>NA</lit>. Uma vez que qualquer outra falha será sinalizada,
	  é possivelmente seguro assumir que um resultado NA indica
	  que o verdadeiro p-valor é <quote>muito pequeno</quote>,
	  embora não seja possível quantificá-lo.
	</para>
      </description>
    </function>

    <function name="$ec" section="access" output="matrix">
      <description>
	<para>
	  Deve ser utilizada após a estimação de um VECM e retorna uma matriz
	  contendo os termos de correção de erros. O número de linhas é igual
	  ao número de observações utilizadas e o número de colunas é igual à
	  ordem de cointegração do sistema.
	</para>
      </description>
    </function>

    <function name="$error" section="access" output="scalar">
      <description>
	<para>
	  Retorna o código interno de erro do programa. Esse código será
	  um valor não-nulo quando a função <cmdref targ="catch"/> tiver
	  sido utilizada. Note que o código interno de erro irá retornar
	  para zero quando esta função de acesso for utilizada novamente.
	  Para consultar, posteriormente, a mensagem de erro associada a
	  um dado <lit>$error</lit> será necessário armazená-la em uma
	  variável. Isso pode ser feito da seguinte forma:
	</para>
	<code>
	  err = $error
	  if (err)
	      printf "Got error %d (%s)\n", err, errmsg(err);
	  endif
	</code>
	<para>
	  <seelist>
            <cmdref targ="catch"/>
            <fncref targ="errmsg"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$ess" section="access" output="scalar">
      <description>
	<para>
	  Retorna o erro da soma dos quadrados do último modelo
	  estimado, quando disponível.
	</para>
      </description>
    </function>

    <function name="$evals" section="access" output="matrix">
      <description>
	<para>
	  Deve ser utilizada após a estimação de um VECM e retorna
	  um vetor contendo os autovalores que foram utilizados no
	  cálculo do teste traço para verificação da cointegração.
	</para>
      </description>
    </function>

    <function name="$fcast" section="access" output="matrix">
      <description>
	<para>
	  Deve ser utilizada após o comando <cmdref targ="fcast"/> e
	  retorna os valores previstos na forma de uma matriz. Se foi
	  utilizado um sistema de equações para realizar as previsões
	  a matriz será composta por uma coluna para cada equação,
	  caso contrário será um vetor coluna.
	</para>
      </description>
    </function>

    <function name="$fcse" section="access" output="matrix">
      <description>
	<para>
	  Deve ser utilizada após o comando <cmdref targ="fcast"/> e retorna
	  os erros padrão das previsões, quando disponíveis, na forma de uma
	  matriz. Se foi utilizado um sistema de equações para realizar as
	  previsões a matriz será composta por uma coluna para cada equação,
	  caso contrário será um vetor coluna.
	</para>
      </description>
    </function>

    <function name="$fevd" section="access" output="matrix">
      <description>
	<para>
	  Deve ser utilizada após a estimação de um VAR e retorna uma matriz
	  contendo a decomposição da variância dos erros de previsão (FEVD, na
	  sigla em inglês). Essa matriz possui <math>h</math> linhas, onde <math>h</math>
	  indica a quantidade de períodos do horizonte de previsão que, por sua
	  vez, pode ser escolhida via comando <lit>set horizon</lit> ou
	  de forma automática com base na frequência dos dados.
	</para>
	<para>
	  Para um VAR com <math>p</math> variáveis, a matriz possui <math>p</math>
	  <sup>2</sup> colunas: as primeiras <math>p</math> colunas contêm
	  a FEVD para a primeira variável do VAR, as <math>p</math> colunas
	  seguintes contêm a FEVD para a segunda variável do VAR e assim
	  sucessivamente. A fração (em termos decimais) do erro de previsão
	  da variável <math>i</math> causado por uma inovação na variável
	  <math>j</math> é então encontrado na coluna (<math>i</math> &minus; 1)
	  <math>p</math> + <math>j</math>.
	</para>
	<para>
	  Para uma variante mais flexível desta funcionalidade, ver a função
	  <fncref targ="fevd"/>.
	</para>
      </description>
    </function>

    <function name="$Fstat" section="access" output="scalar">
      <description>
	<para>
	  Retorna estatística F global do último modelo estimado, quando
	  disponível.
	</para>
      </description>
    </function>

    <function name="$gmmcrit" section="access" output="scalar">
      <description>
	<para>
	  Deve ser utilizada após um bloco <lit>gmm</lit>. Retorna o valor
	  da função objetivo GMM em seu mínimo.
	</para>
      </description>
    </function>

    <function name="$h" section="access" output="series">
      <description>
	<para>
	  Deve ser utilizada após o comando <lit>garch</lit>. Retorna a
	  série da variância condicional estimada.
	</para>
      </description>
    </function>

    <function name="$hausman" section="access" output="rvec">
      <description>
	<para>
	  Deve ser utilizada após a estimação de um modelo via <lit>tsls</lit>
	  ou <lit>panel</lit> com a opção de efeitos aleatórios. Retorna um
	  vetor <by r="1" c="3"/> contendo o valor da estatística do teste de
	  Hausman, os graus de liberdade correspondentes e o p-valor para o
	  teste, respectivamente.
	</para>
     </description>
    </function>

    <function name="$hqc" section="access" output="scalar">
      <description>
	<para>
	  Retorna o Critério de Informação de Hannan-Quinn para o último
	  modelo estimado, quando disponível. Veja <guideref
	  targ="chap:criteria"/> para detalhes sobre os cálculos.
	</para>
      </description>
    </function>

    <function name="$huge" section="access" output="scalar">
      <description>
	<para>
	  Retorna um número positivo com valor bastante elevado. Por padrão é igual
	  a 1.0E100, mas pode ser alterado via comando <cmdref targ="set"/>.
	</para>
      </description>
    </function>

    <function name="$jalpha" section="access" output="matrix">
      <description>
	<para>
	  Deve ser utilizada após a estimação de um VECM e retorna a matriz de
	  cargas. O número de linhas dessa matriz é igual ao número de variáveis
	  do VECM e o número de colunas é igual a ordem de cointegração.
	</para>
      </description>
    </function>

    <function name="$jbeta" section="access" output="matrix">
      <description>
	<para>
	  Deve ser utilizada após a estimação de um VECM e retorna a matriz
	  de cointegração. O número de linhas dessa matriz é igual ao número
	  de variáveis no VECM (se existirem variáveis exógenas restritas ao
	  espaço de cointegração adiciona-se mais uma linha) e o número de
	  colunas é igual a ordem de cointegração.
	</para>
      </description>
    </function>

    <function name="$jvbeta" section="access" output="smatrix">
      <description>
	<para>
	  Deve ser utilizada após a estimação de um VECM e retorna a matriz de
	  covariâncias estimada para os elementos dos vetores de cointegração.
	</para>
	<para>
	  No caso de uma estimação sem restrições, o número de linhas dessa
	  matriz é igual ao número de elementos irrestritos do espaço de
	  cointegração após a normalização de Phillips. Entretanto, se for
	  estimado um sistema restrito via comando <lit>restrict</lit> com
	  a opção <lit>--full</lit>, uma matriz singular com <math>(n+m)r
	  </math> linhas será retornada (sendo <math>n</math> o número de
	  variáveis endógenas, <math>m</math> o número de variáveis exógenas
	  restritas ao espaço de cointegração e <math>r</math> a ordem de
	  cointegração).
	</para>
	<para>
	  Exemplo: o código
	</para>
	<code>
	  open denmark.gdt
	  vecm 2 1 LRM LRY IBO IDE --rc --seasonals -q
	  s0 = $jvbeta

	  restrict --full
	    b[1,1] = 1
	    b[1,2] = -1
	    b[1,3] + b[1,4] = 0
	  end restrict
	  s1 = $jvbeta

	  print s0
	  print s1
	</code>
	<para>
	  produz a seguinte saída.
	</para>
	<code>
	  s0 (4 x 4)

          0.019751     0.029816  -0.00044837     -0.12227
          0.029816      0.31005     -0.45823     -0.18526
	   -0.00044837     -0.45823       1.2169    -0.035437
          -0.12227     -0.18526    -0.035437      0.76062

	  s1 (5 x 5)

	  0.0000       0.0000       0.0000       0.0000       0.0000
	  0.0000       0.0000       0.0000       0.0000       0.0000
	  0.0000       0.0000      0.27398     -0.27398    -0.019059
	  0.0000       0.0000     -0.27398      0.27398     0.019059
	  0.0000       0.0000    -0.019059     0.019059    0.0014180
	</code>
      </description>
    </function>

    <function name="$lang" section="access" output="string">
      <description>
	<para>
	  Retorna o texto (string) com o código do idioma que
	  está sendo utilizado no momento, desde que este possa ser determinado.
	  O texto é composto pelo código ISO 639-1 com duas letras (por exemplo,
	  <lit>en</lit> para inglês, <lit>jp</lit> para japonês, <lit>el</lit>
	  para grego) seguido de um sublinhado e o código do país de acordo com
	  o ISO 3166-1. Assim, por exemplo, o português de Portugal é
	  representado por <lit>pt_PT</lit> enquanto o português do Brasil
	  é representado por <lit>pt_BR</lit>.
	</para>
	<para>
	  Se o idioma não puder ser determinado será retornado o texto
	  <quote><lit>unknown</lit></quote>.
	</para>
      </description>
    </function>

    <function name="$llt" section="access" output="series">
      <description>
	<para>
	  Para determinados modelos estimados via Máxima Verossimilhança a
	  função retorna os valores do log da verossimilhança para cada
	  observação. Atualmente essa função está disponível para logit
	  e probit binários, tobit e heckit.
	</para>
      </description>
    </function>

    <function name="$lnl" section="access" output="scalar">
      <description>
	<para>
	  Retorna a log-verossimilhança para o último modelo estimado
	  (quando for aplicável).
	</para>
      </description>
    </function>

    <function name="$macheps" section="access" output="scalar">
      <description>
	<para>
	  Retorna o valor do <quote>épsilon da máquina</quote> que, por sua vez,
	  fornece um limite superior para o erro relativo devido ao arredondamento
	  na aritmética de ponto flutuante com precisão dupla.
	</para>
      </description>
    </function>

    <function name="$mnlprobs" section="access" output="matrix">
      <description>
	<para>
	  Deve seguir a estimação de um modelo logit multinomial (apenas)
	  e retorna uma matriz com as probabilidades estimadas para cada
	  resultado possível em cada observação dentro da amostra utilizada
	  na estimação do modelo. Cada linha representa uma observação e
	  cada coluna representa um resultado.
	</para>
      </description>
    </function>

    <function name="$model" section="access" output="bundle">
      <description>
	<para>
	  Deve seguir a estimação de modelos de equação única e retorna um
	  pacote (bundle) contendo vários itens pertencentes ao modelo.
	  Todas as funções de acesso de modelos regulares são incluídas
	  e são referenciados por chaves iguais aos nomes das funções de acesso
	  regulares menos o cifrão inicial. Assim, por exemplo, os resíduos
	  aparecem sob a chave <lit>uhat</lit> e o quadrado da soma dos
	  erros sob <lit>ess</lit>.
	</para>
	<para>
	  Dependendo do estimador, informações adicionais podem ser
	  disponibilizadas. As chaves para tais informações são normalmente
	  auto-explicativas. Para ver o que está disponível basta salvar o
	  pacote e imprimir seu conteúdo. Isso é mostrado no exemplo a seguir:
	</para>
	<code>
	  ols y 0 x
	  bundle b = $model
	  print b
	</code>
      </description>
    </function>    
    
    <function name="$mpirank" section="access" output="int">
      <description>
	<para>
	  Se gretl foi compilado con suporte MPI, e o programa foi iniciado
	  em modo MPI, retorna o
	  <quote>posto</quote> de base 0 o ID do processo
	  actual. Caso contrário retorna &minus;1.
	</para>
      </description>
    </function>
    
    <function name="$mpisize" section="access" output="int">
      <description>
	<para>
	  Se gretl foi compilado con suporte MPI, e o programa foi iniciado
	  em modo MPI, retorna o número do processo MPi actualmente em execução. Caso contrário retorna 
	  0.
	</para>
      </description>
    </function>
    
    <function name="$ncoeff" section="access" output="int">
      <description>
	<para>
	  Retorna o número total de coeficientes estimados no último
	  modelo.
	</para>
      </description>
    </function>

    <function name="$nobs" section="access" output="int">
      <description>
	<para>
	  Retorna o número de observações na amostra atualmente
	  selecionada. Veja também: <fncref targ="$tmax"/>.
	</para>
      </description>
    </function>
    
    <function name="$now" section="access" output="vector">
      <description>
	<para>
	  Produz um vector de dois elementos: o primeiro elemento é
          o número de segundos decorridos desde1970-01-01 00:00:00 +0000
	  (UTC), que é uma medida utilizada muito frequentemente no mundo da
          informatica para representar a hora. O segundo é a data actual no
          formato <quote>básico</quote> ISO 8601, que é
	  <lit>YYYYMMDD</lit>; para processar o segundo elemento pode-se usar
          a função <fncref targ="epochday"/>.
	</para>
      </description>
    </function>
    
    <function name="$nvars" section="access" output="int">
      <description>
	<para>
	  Retorna o número de variáveis no conjunto de dados (incluindo a
	  constante).
	</para>
      </description>
    </function>

    <function name="$obsdate" section="access" output="series">
      <description>
	<para>
	  Deve ser utilizada quando o conjunto de dados corrente for composto por
	  séries temporais com frequência decenal, anual, trimestral, mensal,
	  semanal (datada) ou diária (datada). Pode ser utilizada também com dados
	  em painel quando a informação temporal estiver ajustada corretamente
	  (veja o comando <cmdref targ="setobs"/>). A série que será retornada é
	  composta por números com 8 dígitos seguindo o padrão <lit>YYYYMMDD</lit>
	  (formato de dados <quote>básico</quote> do ISO 8601), que correspondem
	  ao dia da observação ou ao primeiro dia da observação no caso de
	  frequências de séries temporais menores que a diária.
	</para>
	<para>
	  Esta série pode ser útil na utilização do comando <cmdref
	  targ="join"/>.
	</para>
      </description>
    </function>

    <function name="$obsmajor" section="access" output="series">
      <description>
	<para>
	  É aplicável quando as observações no conjunto de dados corrente
	  têm uma estrutura maior:menor, como em séries temporais trimestrais
	  (ano:trimestre), séries temporais mensais (ano:mês), dados de horas
	  (dia:hora) e dados em painel (indivíduo:período). Retorna uma série
	  contendo o componente maior, ou de menor frequência, de cada
	  observação (por exemplo, o ano).
	</para>
	<para>
	  <seelist>
            <fncref targ="$obsminor"/>
            <fncref targ="$obsmicro"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$obsmicro" section="access" output="series">
      <description>
	<para>
	  É aplicável quando as observações no conjunto de dados corrente
	  têm uma estrutura maior:menor:micro, como em séries temporais
	  datadas diárias (ano:mês:dia). Retorna uma série contendo o
	  componente micro, ou de maior frequência, de cada observação
	  (por exemplo, o dia).
	</para>
	<para>
	  <seelist>
            <fncref targ="$obsmajor"/>
            <fncref targ="$obsminor"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$obsminor" section="access" output="series">
      <description>
	<para>
	  É aplicável quando as observações no conjunto de dados corrente
	  têm uma estrutura maior:menor, como em séries temporais trimestrais
	  (ano:trimestre), séries temporais mensais (ano:mês), dados de horas
	  (dia:hora) e dados em painel (indivíduo:período). Retorna uma série
	  contendo o componente menor, ou de maior frequência, de cada
	  observação (por exemplo, o mês).
	</para>
	<para>
	  No caso de dados diários datados, <lit>$obsminor</lit> retorna o
	  mês de cada observação.
	</para>
	<para>
	  <seelist>
            <fncref targ="$obsmajor"/>
            <fncref targ="$obsmicro"/>
	  </seelist>
	</para>
      </description>
    </function>
    
    <function name="$parnames" section="access" output="strings">
      <description>
	<para>
	  Depois da estimação de um modelo de uma só equação, produz
          um vector de texto contendo os nomes dos parâmetros do modelo.
          Os números do nomes correspondem ao número dos elementos no vector
          <fncref targ="$coeff"/> .
	</para>
	<para>
	  Para modelos especificados com uma lista de regressores o resultado será
          o mesmo que
	</para>
	<code>
	  varnames($xlist)
	</code>
	<para>
	  (ver <fncref targ="varnames"/>), mas <lit>$parnames</lit> é
	  mais geral, pois que funciona também com modelos sem lista de regressores
          (<cmdref targ="nls"/>, <cmdref targ="mle"/>, <cmdref targ="gmm"/>).
	</para>
      </description>
    </function>
    
    <function name="$pd" section="access" output="int">
      <description>
	<para>
	  Retorna a frequência ou periodicidade dos dados (por exemplo: 4 para
	  dados trimestrais). No caso de dados em painel o valor retornado será
	  a quantidade de períodos de tempo no conjunto de dados.
	</para>
      </description>
    </function>

    <function name="$pi" section="access" output="scalar">
      <description>
	<para>
	  Retorna o valor de &pi; com dupla precisão.
	</para>
      </description>
    </function>

    <function name="$pvalue" section="access" output="scalar-or-matrix">
      <description>
	<para>
	  Retorna o p-valor da estatística de teste que foi gerada
	  pelo último comando explícito de teste de hipóteses (por
	  exemplo: <lit>chow</lit>). Veja <guideref targ="chap:genr"/>
	  para detalhes.
	</para>
	<para>
	  Geralmente retorna um escalar, mas em alguns casos retorna uma
	  matriz. Isso ocorre, por exemplo, com os p-valores dos testes
	  lambda traço e lambda máximo associadas ao teste de cointegração
	  de Johansen). Nesse caso os valores na matriz estarão dispostos
	  da mesma forma que na saída do teste.
	</para>
	<para>
	  <seelist>
            <fncref targ="$test"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$qlrbreak" section="access" output="scalar">
      <description>
	<para>
	  Deve ser utilizada após o comando <cmdref targ="qlrtest"/>
	  (que realiza o teste QLR para quebra estrutural em um ponto
	  desconhecido. Retorna o número da observação no qual a
	  estatística de teste é maximizada.
	</para>
      </description>
    </function>   
    
    <function name="$result" section="access" output="matrix-or-bundle">
      <description>
	<para>
	  Fornece a informação  armazenada de alguns comandos que não têm acessores
          específicos. Tais comandos incluem <cmdref targ="corr"/>, <cmdref targ="fractint"/>, <cmdref
	  targ="freq"/>, <cmdref targ="summary"/>, <cmdref
	  targ="xtab"/>, <cmdref targ="vif"/> e <cmdref targ="bkw"/>
	  ; neste caso o resultado é uma matriz, e ainda <cmdref
	  targ="pkg"/>, que opcionalmente guarda como um resultado bundle.
	</para>
      </description>
    </function>
    
    <function name="$rho" section="access" output="scalar">
      <fnargs>
	<fnarg optional="true" type="scalar">n</fnarg>
      </fnargs>
      <description>
	<para>
	  Se for utilizada sem argumentos a função retorna o coeficiente
	  autorregressivo de primeira ordem para os resíduos do último
	  modelo. Após a estimação de um modelo via comando <lit>ar</lit>,
	  a sintaxe <lit>$rho(n)</lit> retorna a estimativa correspondente
	  de &rgr;(<math>n</math>).
	</para>
      </description>
    </function>

    <function name="$rsq" section="access" output="scalar">
      <description>
	<para>
	  Retorna o <math>R</math><sup>2</sup> não ajustado do último
	  modelo estimado, quando disponível.
	</para>
      </description>
    </function>

    <function name="$sample" section="access" output="series">
      <description>
	<para>
	  Deve ser utilizada após a estimação de um modelo com equação simples
	  e retorna uma variável dummy com valores iguais a 1 nas observações
	  utilizadas na estimação, 0 nas observações na amostra corrente e que
	  não foram utilizadas na estimação (possivelmente devido a valores
	  ausentes) e NA nas observações fora da amostra selecionada corrente.
	</para>
	<para>
	  Caso se queira calcular estatísticas baseadas na amostra que foi
	  utilizada para um dado modelo, pode-se fazer, por exemplo:
	</para>
	<code>
	  ols y 0 xlist
	  genr sdum = $sample
	  smpl sdum --dummy
	</code>
      </description>
    </function>

    <function name="$sargan" section="access" output="rvec">
      <description>
	<para>
	  Deve ser utilizada após o comando <lit>tsls</lit>. Retorna
	  um vetor <by r="1" c="3"/> contendo a estatística do teste
	  de sobre-identificação de Sargan e os correspondentes graus
	  de liberdade e p-valor, respectivamente. Se o modelo for
	  exatamente identificado a estatística não estará disponível
	  e tentar acessá-la irá provocar um erro.
	</para>
      </description>
    </function>

    <function name="$sigma" section="access" output="scalar-or-matrix">
      <description>
	<para>
	  Se o último modelo estimado foi uma equação simples, retorna
	  o erro padrão da regressão na forma de um escalar (ou, em
	  outras palavras, retorna o desvio padrão dos resíduos com uma
	  correção apropriada de graus de liberdade). Se o último modelo
	  foi um sistema de equações, retorna a matriz de covariâncias
	  dos resíduos das equações do sistema.
	</para>
      </description>
    </function>

    <function name="$stderr" section="access" output="matrix" altout="scalar">
      <fnargs>
	<fnarg optional="true" type="coeffname">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Quando utilizado sem argumentos, <lit>$stderr</lit> retorna um
	  vetor coluna com os erros padrão dos coeficientes do último
	  modelo estimado. Com o argumento opcional de texto (string) a função
	  retorna, na forma de um escalar, o parâmetro estimado
	  <argname>s</argname>.
	</para>
	<para>
	  Se o <quote>modelo</quote> um sistema, o resultado dependerá de
	  suas características: para VARs e VECMs o valor retornado será
	  uma matriz contendo uma coluna para cada equação, caso contrário,
	  será um vetor coluna contendo os coeficientes da primeira equação
	  seguidos pelos coeficientes da segunda equação e assim
	  sucessivamente.
	</para>
	<para>
	  <seelist>
            <fncref targ="$coeff"/>
            <fncref targ="$vcv"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$stopwatch" section="access" output="scalar">
      <description>
	<para>
	  Deve ser precedida pelo comando <lit>set stopwatch</lit> que, por sua
	  vez, ativa a medição de tempo da CPU. Na primeira utilização da função de
	  acesso obtém-se a quantidade de segundos que se passaram desde o comando
	  <lit>set stopwatch</lit>. A cada acesso o relógio será reiniciado de
	  forma que as utilizações subsequentes de <lit>$stopwatch</lit> irão
	  fornecer os segundos da CPU entre as duas utilizações.
	</para>
      </description>
    </function>

    <function name="$sysA" section="access" output="matrix">
      <description>
	<para>
	  Deve ser utilizada após a estimação de um sistema de equações
	  simultâneas. Retorna a matriz com os coeficientes das variáveis
	  endógenas defasadas, caso existam, na forma estrutural do
	  sistema. Veja o comando <cmdref targ="system"/>.
	</para>
      </description>
    </function>

    <function name="$sysB" section="access" output="matrix">
      <description>
	<para>
	  Deve ser utilizada após a estimação de um sistema de
	  equações simultâneas. Retorna a matriz com os coeficientes
	  das variáveis exógenas na forma estrutural do sistema.
	  Veja o comando <cmdref targ="system"/>.
	</para>
      </description>
    </function>

    <function name="$sysGamma" section="access" output="matrix">
      <description>
	<para>
	  Deve ser utilizada após a estimação de um sistema de
	  equações simultâneas. Retorna a matriz com os coeficientes
	  das variáveis endógenas contemporâneas na forma estrutural
	  do sistema. Veja o comando <cmdref targ="system"/>.
	</para>
      </description>
    </function>

    <function name="$sysinfo" section="access" output="bundle">
      <description>
	<para>
	  Retorna um pacote (bundle) contendo informações sobre o
	  Gretl e o sistema operacional onde está sendo executado.
	  O elementos do pacote são especificados a seguir.
	</para>
	<ilist>
	  <li>
            <para>
              <lit>mpi</lit>: inteiro, igual a 1 se o sistema suporta
              MPI (Message Passing Interface), caso contrário 0.
            </para>
	  </li>
	  <li>
            <para>
              <lit>omp</lit>: inteiro, igual a 1 se o Gretl foi compilado
              com suporte a Open MP, caso contrário 0.
            </para>
	  </li>
	  <li>
            <para>
              <lit>nproc</lit>: inteiro, indica o número de processadores
              disponíveis.
            </para>
	  </li>
	  <li>
            <para>
              <lit>mpimax</lit>: inteiro, indica o número máximo de processos
              MPI que podem ser executados em paralelo. É igual a zero se não
              houver suporte para MPI, caso contrário é igual ao valor de
              <lit>nproc</lit> local. Se for especificado um arquivo de hosts
              MPI, <lit>mpimax</lit> será igual a soma do número de
              processadores ou <quote>slots</quote> ao longo de todas a
              máquinas referenciadas no arquivo.
            </para>
	  </li>
	  <li>
            <para>
              <lit>wordlen</lit>: inteiro, igual a 32 ou 64 para sistemas de
              32 bit e 64, respectivamente.
            </para>
	  </li>
	  <li>
            <para>
              <lit>os</lit>: texto representando o sistema operacional e é
              igual a <lit>linux</lit>, <lit>osx</lit>,
              <lit>windows</lit> ou <lit>other</lit>.
            </para>
	  </li>
	  <li>
            <para>
              <lit>hostname</lit>: informa o nome da máquina (ou
              <quote>host</quote>) onde o Gretl está sendo executado
              no momento. Se não for possível determinar o nome,
              será retornado o <lit>localhost</lit>.
            </para>
	  </li>
	</ilist>
	<para>
	  Note que elementos individuais no pacote podem ser acessados via
	  utilização da notação <quote>dot</quote> sem a necessidade de
	  copiar o pacote inteiro. Por exemplo,
	</para>
	<code>
	  if $sysinfo.os == "linux"
	      # faça alguma coisa que seja própria do Linux
	  endif
	</code>
      </description>
    </function>

    <function name="$system" section="access" output="bundle">
      <description>
	<para>
	  Deve seguir a estimação de um sistema de equações via
	  comandos <cmdref targ="system"/>, <cmdref targ="var"/>
	  ou <cmdref targ="vecm"/>. Retorna um pacote (bundle)
	  contendo os ítems que fazem parte do sistema. Todas as funções
	  de acesso regulares são incluídas: estas estão referenciadas
	  de acordo com indicadores que são iguais aos nomes de acesso
	  regular, sem utilizar o símbolo cifrão. Por exemplo, os resíduos
	  aparecem sob o indicador <lit>uhat</lit> e os coeficientes
	  sob <lit>coeff</lit>. Os os indicadores para as informações
	  adicionais deverão ser auto-explicativos. Para verificar quais
	  estão disponíveis pode-se exibir os conteúdos do pacote.
	  Exemplo:
	</para>
	<code>
	  var 4 y1 y2 y2
	  bundle b = $system
	  print b
	</code>
	<para>
	  Um pacote definido dessa forma pode ser utilizado como o argumento
	  final (que é opcional) nas funções <fncref targ="fevd"/>
	  e <fncref targ="irf"/>.
	</para>
      </description>
    </function>

    <function name="$T" section="access" output="int">
      <description>
	<para>
	  Retorna o número de observações utilizadas na estimação do
	  último modelo.
	</para>
      </description>
    </function>

    <function name="$t1" section="access" output="int">
      <description>
	<para>
	  Retorna o número da primeira observação na amostra
	  selecionada corrente.
	</para>
      </description>
    </function>

    <function name="$t2" section="access" output="int">
      <description>
	<para>
	  Retorna o número da última observação na amostra
	  selecionada corrente.
	</para>
      </description>
    </function>

    <function name="$test" section="access" output="scalar-or-matrix">
      <description>
	<para>
	  Retorna o valor da estatística de teste que foi gerada
	  pelo último comando explícito de teste de hipóteses (por
	  exemplo: <lit>chow</lit>). Veja <guideref targ="chap:genr"/>
	  para detalhes.
	</para>
	<para>
	  Geralmente retorna um escalar, mas em alguns casos retorna
	  uma matriz. Isso ocorre, por exemplo, com as estatísticas
	  lambda traço e lambda máximo associadas ao teste de cointegração
	  de Johansen). Nesse caso os valores na matriz estarão dispostos
	  da mesma forma que na saída do teste.
	</para>
	<para>
	  <seelist>
            <fncref targ="$pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$tmax" section="access" output="int">
      <description>
	<para>
	  Devolve o máximo valor possível para indicar o
	  fim do intervalo de uma amostra alterada com o comando <cmdref targ="smpl"/>.
	  Na maior parte das vezes, isto vai ser igual ao número de observações do
	  conjunto de dados, mas numa função em Hansl, o valor <lit>$tmax</lit>
	  pode ser menor, pois em geral o acesso aos dados a partir do interior de
      funções está limitado ao intervalo amostral definido pela função chamadora.
	</para>
	<para>
	  Notar que, em geral, o <lit>$tmax</lit> não é igual a
	  <fncref targ="$nobs"/>, que indica número de observações do
	  intervalo da amostra actual.
	</para>
      </description>
    </function>

    <function name="$trsq" section="access" output="scalar">
      <description>
	<para>
	  Retorna <math>TR</math><sup>2</sup> (tamanho da amostra multiplicado
	  pelo R-quadrado) do último modelo, quando disponível.
	</para>
      </description>
    </function>

    <function name="$uhat" section="access" output="series">
      <description>
	<para>
	  Retorna os resíduos do último modelo. Isto pode ter diferentes
	  significados a depender dos estimadores utilizados. Por exemplo,
	  após a estimação de um ARMA <lit>$uhat</lit> irá conter os erros
	  de previsão de 1 passo à frente, após a estimação de um probit
	  irá conter os resíduos generalizados.
	</para>
	<para>
	  Se o <quote>modelo</quote> em questão for um sistema
	  (um VAR, um VECM ou um sistema de equações simultâneas),
	  o <lit>$uhat</lit> sem parâmetros fornece a matriz de
	  resíduos, uma coluna por equação.
	</para>
      </description>
    </function>

    <function name="$unit" section="access" output="series">
      <description>
	<para>
	  Vale apenas para dados de painel. Retorna uma série com valor igual
	  a 1 em todas as observações na primeira unidade ou grupo, 2 em todas
	  as observações na segunda unidade ou grupo e assim sucessivamente.
	</para>
      </description>
    </function>

    <function name="$vcv" section="access" output="matrix" altout="scalar">
      <fnargs>
	<fnarg optional="true" type="coeffname">s1</fnarg>
	<fnarg optional="true" type="coeffname">s2</fnarg>
      </fnargs>
      <description>
	<para>
	  Quando utilizado sem argumentos, <lit>$vcv</lit> retorna uma matriz
	  contendo a matriz de covariâncias estimadas para os coeficientes do
	  último modelo. Se o último modelo foi uma equação simples, então é
	  possível fornecer os nomes dos dois parâmetros entre parênteses para
	  se obter a covariância estimada entre <argname>s1</argname> e
	  <argname>s2</argname>.
	  <seelist>
            <fncref targ="$coeff"/>
            <fncref targ="$stderr"/>
	  </seelist>
	</para>
	<para>
	  Este acessor não está disponível para VARs ou VECMs. Para modelos
	  desse tipo <fncref targ="$sigma"/> e <fncref targ="$xtxinv"/>.
	</para>
      </description>
    </function>

    <function name="$vecGamma" section="access" output="matrix">
      <description>
	<para>
	  Deve ser utilizada após a estimação de um VECM e retorna uma
	  matriz na qual as matrizes Gama (coeficientes das diferenças
	  defasadas das variáveis cointegradas) são empilhadas lado a
	  lado. Cada linha representa uma equação. Para um VECM de ordem
	  <math>p</math> existem <math>p</math> &minus; 1 sub-matrizes.
	</para>
      </description>
    </function>

    <function name="$version" section="access" output="scalar">
      <description>
	<para>
	  Retorna um valor inteiro que identifica a versão do Gretl.
	  Atualmente a versão do Gretl é composta por um texto com o
	  seguinte formato: ano, com 4 dígitos, seguido de uma letra,
	  de a até j, representando as atualizações dentro desse ano
	  (por exemplo, 2015d). O valor retornado por essa função é
	  igual ao ano multiplicado por 10 e adicionado de um número
	  representando, em ordem léxica, a letra. Assim, 2015d seria
	  representado por 20153.
	</para>
	<para>
	  Em versões anteriores ao Gretl 2015d, o identificador possuia
	  a seguinte forma: x.y.z (três inteiros separados por pontos) e
	  o valor da função era calculado como <lit>10000*x + 100*y + z
	  </lit>. Assim, por exemplo, a versão 1.10.2 era traduzida como
	  11002. Note que dessa forma a ordem numérica de <lit>$version
	  </lit> foi preservada mesmo com a mudança no esquema de versões.
	</para>
      </description>
    </function>

    <function name="$vma" section="access" output="matrix">
      <description>
	<para>
	  Deve ser utilizada após a estimação de um VAR ou um VECM e
	  retorna uma matriz contendo a representação VMA até a ordem
	  especificada via comando <lit>set horizon</lit>. Veja
	  <guideref targ="chap:var"/> para detalhes.
	</para>
      </description>
    </function>

    <function name="$windows" section="access" output="int">
      <description>
	<para>
	  Retorna o valor 1 se o Gretl estiver sendo utilizado no Windows e 0 caso contrário.
	  Através dessa função é possível utilizar comandos <quote>shell</quote>
	  em scripts que possam ser executados em diferentes sistemas operacionais.
	</para>
	<para>
	  Veja também o comando <cmdref targ="shell"/>.
	</para>
      </description>
    </function>

    <function name="$xlist" section="access" output="list">
      <description>
	<para>
	  Se o último modelo estimado foi um equação simples a função retorna
	  uma lista com os regressores. Se o último modelo foi um sistema de
	  equações ela retorna uma lista <quote>global</quote> com as variáveis
	  exógenas e predeterminadas (na mesma ordem que aparecem na função
	  <fncref targ="$sysB"/>). Se o último modelo foi um VAR ela retorna
	  uma lista com os regressores exógenos, caso existam.
	</para>
      </description>
    </function>

    <function name="$xtxinv" section="access" output="matrix">
      <description>
	<para>
	  Após a estimação de um VAR ou VECM (apenas), retorna
	  <math>X'X</math><sup>-1</sup>, onde <math>X</math> é a
	  matriz comum de regressores utilizados em cada equação.
	  Essa função de acesso não está disponível para VECMs estimados
	  com restrições impostas na matriz de cargas(&agr;).
	</para>
      </description>
    </function>

    <function name="$yhat" section="access" output="series">
      <description>
	<para>
	  Retorna os valores ajustados da última regressão.
	</para>
      </description>
    </function>

    <function name="$ylist" section="access" output="list">
      <description>
	<para>
	  Se o último modelo estimado foi um VAR, um VECM ou um sistema de
	  equações simultâneas a função retorna uma lista com as variáveis
	  endógenas. Se o último modelo foi uma equação simples a função de
	  acesso retorna uma lista com apenas um elemento, a variável dependente.
	  No caso especial do modelo biprobit a lista irá conter dois
	  elementos.
	</para>
      </description>
    </function>

  </funclist>

  <funclist name="Functions proper" ref="functions">

    <function name="abs" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o valor absoluto de <argname>x</argname>.
	</para>
      </description>
    </function>

    <function name="acos" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o arco-cosseno de <argname>x</argname>, isto é, o valor
	  cujo cosseno é <argname>x</argname>. Resultado em radianos e o
	  argumento deve estar entre &minus;1 e 1.
	</para>
      </description>
    </function>

    <function name="acosh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o cosseno hiperbólico inverso de <argname>x</argname>
	  (solução positiva). <argname>x</argname> deve ser maior que 1,
	  caso contrário a função retornará NA.
	  <seelist>
            <fncref targ="cosh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="aggregate" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
	<fnarg type="series-or-list">byvar</fnarg>
	<fnarg type="string" optional="true">funcname</fnarg>
      </fnargs>
      <description>
	<para>
	  Na forma mais simples de uso, <argname>x</argname> é igual a
	  <lit>null</lit>, <argname>byvar</argname> é uma séries individual
	  e o terceiro argumento é omitido. Neste caso é retornada uma
	  matriz com duas colunas contendo na primeira coluna os valores
	  distintos de <argname>byvar</argname>, ordenados de forma crescente,
	  e na segunda a quantidade de observações de <argname>byvar</argname>
	  para cada um dos valores distintos.
	  Por exemplo,
	</para>
	<code>
	  open data4-1
	  eval aggregate(null, bedrms)
	</code>
	<para>
	  mostrará que a serie <lit>bedrms</lit> tem valores
	  3 (num total de 5 vezes) e 4 (num total de 9 vezes).
	</para>
	<para>
	  Se <argname>x</argname> e <argname>byvar</argname> são ambas
      séries individuais, e é indicado um terceiro argumento,
      o valor retornado é uma matriz com três colunas contendo,
      respectivamente, os valores distintos de
	  <argname>byvar</argname>, por ordem crescente; a contagem das
      observações em que o <argname>byvar</argname>
	  toma em cada um desses valores; e os valores da
	  estatística especificada por <argname>funcname</argname> calculada na
	  série <argname>x</argname>, usando apenas aquelas observações
	  nas quais <argname>byvar</argname> tem valor igual aos dados
	  na primeira coluna.
	</para>
	<para>
	  Mais geralmente, se <argname>byvar</argname> for uma lista
	  com <math>n</math> membros então as <math>n</math> colunas a
	  esquerda contêm as combinações dos valores distintos de cada
	  uma das <math>n</math> séries e a coluna de contagem contém
	  o número de observações nas quais cada combinação é feita.
	  Se <argname>x</argname> for uma lista com <math>m</math>
	  membros então as <math>m</math> colunas mais a direita contêm
	  os valores da estatística especificada para cada uma das
	  <argname>x</argname> variáveis, novamente calculadas na
	  subamostra indicada na(s) primeira(s) coluna(s).
	</para>
	<para>
	  Os seguintes valores de <argname>funcname</argname> são
	  suportados de forma <quote>nativa</quote>: <fncref targ="sum"/>,
	  <fncref targ="sumall"/>, <fncref targ="mean"/>, <fncref targ=
	  "sd"/>, <fncref targ="var"/>, <fncref targ="sst"/>, <fncref
	  targ="skewness"/>, <fncref targ="kurtosis"/>, <fncref targ=
	  "min"/>, <fncref targ="max"/>, <fncref targ="median"/>, <fncref
	  targ="nobs"/> e <fncref targ="gini"/>. Cada uma dessas funções
	  utiliza uma série como argumento e retorna um valor escalar e,
	  nesse sentido, pode-se dizer que <quote>agregam</quote> a série
	  de alguma forma. É possível utilizar uma função definida pelo
	  usuário como um agregador. Da mesma forma que as funções
	  nativas, tal função deve ter como argumento apenas uma única
	  série e retornar um valor escalar.
	</para>
	<para>
	  Note que apesar de a contagem de casos ser realizada de forma
	  automática pela função <lit>nobs</lit>, a função <lit>aggregate
	  </lit> não é redundante como uma agregadora, uma vez que fornece
	  o número de observações válidas (não ausentes) em <argname>x
	  </argname> em cada combinação <argname>byvar</argname>.
	</para>
	<para>
	  Para exemplificar isso, suponha que <lit>region</lit>
	  representa um código de uma região geográfica usando valores
	  inteiros de 1 até <math>n</math> e <lit>income</lit> representa
	  a renda doméstica. Então o cálculo a seguir deverá produzir uma
	  matriz de ordem <by r="n" c="3"/> contendo os códigos das regiões,
	  a contagem de observações em cada região e a renda média doméstica
	  para cada uma das regiões:
	</para>
	<code>
	  matrix m = aggregate(income, region, mean)
	</code>
	<para>
	  Para um exemplo usando listas, seja <lit>gender</lit> uma variável
	  dummy macho/fêmea, seja <lit>race</lit> uma variável categórica com
	  três valores e considere o seguinte código:
	</para>
	<code>
	  list BY = gender race
	  list X = income age
	  matrix m = aggregate(X, BY, sd)
	</code>
	<para>
	  A utilização de <lit>aggregate</lit> produzirá uma matriz de ordem
	  <by r="6" c="5"/>. As primeiras duas colunas contêm as 6 distintas
	  combinações dos valores de gênero e raça. A coluna do meio contém
	  a contagem para cada uma dessas combinações. As duas colunas mais
	  à direita contêm os desvios padrão amostrais de <lit>income</lit> e
	  <lit>age</lit>.
	</para>
	<para>
	  Note que se <argname>byvar</argname> for uma lista, algumas combinações
	  dos valores de <argname>byvar</argname> podem não estar presentes nos
	  dados (fornecendo uma contagem igual a zero). Nesse caso os valores das
	  estatísticas para <argname>x</argname> são considerados como <lit>NaN</lit>
	  (ou seja, não são números). Caso seja desejado ignorar esses
	  casos é possível utilizar a função <fncref targ="selifr"/> para
	  selecionar apenas aquelas linhas que não possuam uma contagem igual a
	  zero. A coluna a ser testada estará uma posição à direita após o número
	  de variáveis de <argname>byvar</argname>, assim, pode-se utilizar o
	  seguinte código:
	</para>
	<code>
	  matrix m = aggregate(X, BY, sd)
	  scalar c = nelem(BY)
	  m = selifr(m, m[,c+1])
	</code>
      </description>
    </function>

    <function name="argname" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Seja <argname>s</argname> o nome de um parâmetro de uma função definida
	  pelo usuário, retorna o nome do argumento correspondente ou uma variável
	  de texto (string) vazia se o argumento for anônimo.
	</para>
      </description>
    </function>

    <function name="array" section="data-utils" output="seebelow">
      <fnargs>
	<fnarg type="int">n</fnarg>
      </fnargs>
      <description>
	<para>
	  É a função <quote>construtora</quote> básica de uma nova
	  variável do tipo arranjo (array). Ao usar esta função é
	  necessário que se especifique um tipo (na forma plural)
	  para o arranjo: <lit>strings</lit>, <lit>matrices</lit>,
	  <lit>bundles</lit> ou <lit>lists</lit>. O valor de retorno
	  é um arranjo do tipo especificado e com <argname>n</argname>
	  elementos <quote>vazios</quote> (exemplos: variável de texto/string
	  vazia ou matriz nula). Exemplos de utilização:
	</para>
	<code>
	  strings S = array(5)
	  matrices M = array(3)
	</code>
	<para>
	  Veja também <fncref targ="defarray"/>.
	</para>
      </description>
    </function>

    <function name="asin" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o arco-seno de <argname>x</argname>, isto é, o valor
	  cujo seno é <argname>x</argname>. Resultado em radianos e o
	  argumento deve estar entre &minus;1 e 1.
	</para>
      </description>
    </function>

    <function name="asinh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o seno hiperbólico inverso de <argname>x</argname>.
	  <seelist>
            <fncref targ="sinh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="atan" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o arco-tangente de <argname>x</argname>, isto é, o valor
	  cuja tangente é <argname>x</argname>. Resultado em radianos.
      <seelist>
        <fncref targ="cos"/>
        <fncref targ="sin"/>
        <fncref targ="tan"/>
      </seelist>
	</para>
      </description>
    </function>

    <function name="atan2" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">y</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o valor principal do arco-tangente de
	  <argname>y</argname>/<argname>x</argname>, usando os sinais
	  dos dois argumentos para determinar o quadrante do resultado, que é
          expresso em radianos, dentro do intervalo [&minus;&pi;, &pi;].
	</para>
	<para>
	  Se os dois argumentos forem de tipos diferentes, o resultado é do tipo
          <quote>mais alto</quote> dos dois, seguindo a ordem,
          matriz &gt; série &gt; escalar. Por exemlo, se
	  <argname>y</argname> é um escalar e <argname>x</argname> um
	  vector de <math>n</math> elementos (ou viceversa), o
	  resultado é também um vector. Note-se que os argumentos matriciais
          deverem ser vectores, e que se nenhum deles for escalar, devem ter
          a mesma dimensão.
	</para>
	<para>
	  <seelist>
            <fncref targ="tan"/>
            <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>
    
    <function name="atanh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a tangente hiperbólica inversa de <argname>x</argname>.
	  <seelist>
            <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="atof" section="strings" output="scalar">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Função semelhante à existente na linguagem de programação C, retorna
	  o resultado da conversão da variável de texto (string)
	  <argname>s</argname> (ou sua porção inicial, após descartar quaisquer
	  espaços em branco no seu início) em número de ponto flutuante.
	  Diferente do que ocorre na linguagem C, a função <lit>atof</lit> (por
	  questões de portabilidade) sempre assume que o caractere decimal é o
	  <quote><lit>.</lit></quote>. Todos os caracteres que se seguem após a
	  parte de <argname>s</argname> que pode ser convertida para um número
	  de ponto flutuante são ignorados.
	</para>
	<para>
	  Se nenhum dos caracteres de <argname>s</argname> (que se seguem após
	  os espaços em branco que são descartados) puderem ser convertidos a
	  função retornará <lit>NA</lit>.
	</para>
	<code>
	  # Exemplos:
	  x = atof("1.234") # retorna x = 1.234
	  x = atof("1,234") # retorna x = 1
	  x = atof("1.2y")  # retorna x = 1.2
	  x = atof("y")     # retorna x = NA
	  x = atof(",234")  # retorna x = NA
	</code>
	<para>
	  Veja também <fncref targ="sscanf"/> para maior flexibilidade nas
	  conversões de textos em números.
	</para>
      </description>
    </function>

    <function name="bessel" section="math" output="asinput">
      <fnargs>
	<fnarg type="char">type</fnarg>
	<fnarg type="scalar">v</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula uma das variantes da função de Bessel de ordem <argname>v</argname>
	  e argumento <argname>x</argname>. O valor retornado
	  será do mesmo tipo de <argname>x</argname>. A função específica
	  é selecionada pelo primeiro argumento e deve ser <lit>J</lit>,
	  <lit>Y</lit>, <lit>I</lit> ou <lit>K</lit>. Uma boa discussão
	  sobre as funções de Bessel pode ser encontrada na Wikipédia. Aqui
	  serão feitos comentários breves.
	</para>
	<para>
	  caso <lit>J</lit>: função de Bessel de primeiro tipo. Se assemelha
	  a uma onda senoidal amortecida. Definida para <argname>v</argname>
	  real e <argname>x</argname>. Se <argname>x</argname> for negativo
	  então <argname>v</argname> deve ser um inteiro.
	</para>
	<para>
	  caso <lit>Y</lit>: função de Bessel de segundo tipo. Definida
	  para <argname>v</argname> real e <argname>x</argname>, mas com
	  uma singularidade em <argname>x</argname> = 0.
	</para>
	<para>
	  caso <lit>I</lit>: função de Bessel modificada de primeiro tipo.
	  Uma função com crescimento exponencial. Argumentos que podem ser
	  usados são os mesmos do caso <lit>J</lit>.
	</para>
	<para>
	  caso <lit>K</lit>: função de Bessel modificada de segundo tipo. Uma
	  função com decaimento exponencial. Diverge em <argname>x</argname> =
	  0 e não é definida para valores negativos de <argname>x</argname>.
	  É simétrica em torno de <argname>v</argname> = 0.
	</para>
      </description>
    </function>

    <function name="BFGSmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="fncall" optional="true">g</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza a maximização numérica via método de Broyden,
	  Fletcher, Goldfarb e Shanno. O argumento <argname>
	  b</argname> deve conter os valores iniciais de um conjunto
	  de parâmetros e o argumento <argname>f</argname> deve
	  especificar uma chamada à função que calcule o critério
	  (escalar) a ser maximizado, dados os valores correntes
	  dos parâmetros e quaisquer outros dados que sejam
	  relevantes. Se o objetivo for de fato uma minimização,
	  esta função deverá retornar o negativo do critério. Se
	  for completada com sucesso, <lit>BFGSmax</lit> retorna
	  o valor maximizado do critério e <argname>b</argname>
	  armazena os valores dos parâmetros que maximizam a função.
	</para>
	<para>
	  O terceiro argumento, opcional, estabelece uma maneira de
	  fornecer derivadas analíticas (caso contrário o gradiente
	  será computado numericamente). A função gradiente <argname>
	  g</argname> deve ter como primeiro argumento uma matriz
	  pré-definida que tenha o tamanho adequado para armazenar
	  o gradiente, dado na forma de ponteiro. Ela também precisa
	  ter o vetor de parâmetros como um argumento (na forma de
	  ponteiro ou não). Outros argumentos são opcionais.
	</para>
	<para>
	  Para maiores detalhes e exemplos veja o capítulo sobre
	  métodos numéricos em <guideref targ="chap:numerical"/>.
	  <seelist>
	    <fncref targ="BFGScmax"/>
            <fncref targ="NRmax"/>
            <fncref targ="fdjac"/>
            <fncref targ="simann"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="BFGSmin" section="numerical" output="scalar">
      <description>
	<para>
	  É uma forma alternativa da função <fncref targ="BFGSmax"/>. Se invocada
	  com este nome a função comporta-se como minimizadora.
	</para>
      </description>
    </function>

    <function name="BFGScmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="matrix">bounds</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="fncall" optional="true">g</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza a maximização com restrições via L-BFGS-B (BFGS
	  com memória limitada, veja <cite key="byrd-etal95">Byrd,
	  Lu, Nocedal e Zhu, 1995</cite>). O argumento <argname>b
	  </argname> deve conter os valores iniciais de um conjunto
	  de parâmetros, <argname>bounds</argname> deve conter as
	  restrições que aplicadas aos valores dos parâmetros (veja
	  abaixo) e <argname>f</argname> deve especificar uma chamada
	  à função que calcule o critério (escalar) a ser maximizado,
	  dados os valores correntes dos parâmetros e quaisquer outros
	  dados que sejam relevantes. Se o objetivo for de fato uma
	  minimização, esta função deverá retornar o negativo do
	  critério. Se for completada com sucesso, <lit>BFGScmax</lit>
	  retorna o valor maximizado do critério, sujeito às restrições
	  em <argname>bounds</argname> e <argname>b</argname> contém
	  os valores dos parâmetros que maximizam a função.
	</para>
	<para>
	  A matriz <argname>bounds</argname> deve ter 3 colunas e um
	  número de linhas igual ao número de elementos restritos no
	  vetor de parâmetros. O primeiro elemento de uma dada linha
	  é o índice (de base 1) do parâmetro restrito, o segundo e o
	  terceiro são os limites inferiores e superiores, respectivamente.
	  Os valores <lit>-$huge</lit> e <lit>$huge</lit> devem ser
	  usados para indicar que o parâmetro não possui restrições
	  inferiores ou superiores, respectivamente. Por exemplo, a
	  expressão a seguir é a forma de se especificar que o segundo
	  elemento do vetor de parâmetros deve ser não-negativo:
	</para>
	<code>
	  matrix bounds = {2, 0, $huge}
	</code>
	<para>
	  O quarto argumento, opcional, estabelece uma maneira de
	  fornecer derivadas analíticas (caso contrário o gradiente
	  será computado numericamente). A função gradiente <argname>
	  g</argname> deve ter como primeiro argumento uma matriz
	  pré-definida que tenha o tamanho adequado para armazenar
	  o gradiente, dado na forma de ponteiro. Ela também precisa
	  ter o vetor de parâmetros como um argumento (na forma de
	  ponteiro ou não). Outros argumentos são opcionais.
	</para>
	<para>
	  Para maiores detalhes e exemplos veja o capítulo sobre
	  métodos numéricos em <guideref targ="chap:numerical"/>.
	  <seelist>
	    <fncref targ="BFGSmax"/>
            <fncref targ="NRmax"/>
            <fncref targ="fdjac"/>
            <fncref targ="simann"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="BFGScmin" section="numerical" output="scalar">
      <description>
	<para>
	  É uma forma alternativa da função <fncref targ="BFGSmax"/>.Se invocada
	  com este nome a função comporta-se como minimizadora.
	</para>
      </description>
    </function>

    <function name="bincoeff" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">n</fnarg>
	<fnarg type="anyfloat">k</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula o coeficiente binomial, ou seja o número de maneiras
          com que <argname>k</argname> elementos possam ser escolhidos
          a partir dos <argname>n</argname> elementos sem repetições, 
          independentemente da sua ordenação. Este número é também
          igual ao <argname>(k+1)</argname>-esimo coeficiente
	  da expansão polinomial da <equation status="inline"
	  ascii="(1+x)^n" tex="$(1+x)^n$"/>.
	</para>
	<para context="tex">
	  Para argumentos inteiros, o resultado é $n!/k!(n-k)!$, mas a
	  função aceita também aceita argumentos reais, e a fórmula
          generaliza-se com $\frac{\Gamma(n+1)}{\Gamma(k+1)\Gamma(n-k+1)}$.
	</para>
	<para context="notex">
	  Para argumentos inteiros, o resultado é 
	  <math>n!/k!(n-k)!</math>, mas a
	  função aceita também aceita argumentos reais, e a fórmula
          generaliza-se com <math>
	  Γ(n+1)/( Γ(k+1) &times; Γ(n-k+1) )</math>
	</para>
	<para>
	  Quando <argname>k</argname> &gt; <argname>n</argname> ou
	  <argname>k</argname> &lt; 0, a função retorna NA.
	</para>
	<para>
          Se os dois argumentos forem de tipos diferentes, o resultado é do tipo
          <quote>mais alto</quote> dos dois, seguindo a ordem,
          matriz &gt; série &gt; escalar. Por exemlo, se
	  <argname>n</argname> é um escalar e <argname>k</argname> um
	  vector de <math>r</math> elementos (ou viceversa), o
	  resultado é também um vector. Note-se que os argumentos matriciais
          deverem ser vectores, e que se nenhum deles for escalar, devem ter
          a mesma dimensão.
	</para>
	<para>
	  Ver também <fncref targ="gammafun"/> e <fncref targ="lngamma"/>.
	</para>
      </description>
    </function>

    <function name="bkfilt" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int" optional="true">f1</fnarg>
	<fnarg type="int" optional="true">f2</fnarg>
	<fnarg type="int" optional="true">k</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o resultado da aplicação do filtro passa-banda
	  de Baxter&ndash;King para a série <argname>y</argname>. Os parâmetros
	  opcionais <argname>f1</argname> e <argname>f2</argname> representam,
	  respectivamente, os limites inferior e superior da amplitude
	  de frequência a ser extraída, enquanto <argname>k</argname>
	  é a ordem de aproximação a ser utilizada.
	</para>
	<para>
	  Se esses argumentos não forem fornecidos então os valores
	  padrão irão depender da periodicidade do conjunto de dados.
	  Para dados anuais os padrões para <argname>f1</argname>,
	  <argname>f2</argname> e <argname>k</argname> são 2, 8 e
	  3, respectivamente. Para dados trimestrais são 6, 32 e 12.
	  Para dados mensais são 18, 96 e 36. Esses valores são
	  escolhidos para coincidir com a escolha mais comum entre
	  os praticantes, que é a utilização desse filtro para extrair
	  o componente de frequência do <quote>ciclo de negócios</quote>.
	  Isso, por sua vez, é comumente definido como sendo entre 18
	  meses e 8 anos. O filtro, por escolha padrão, abrange 3 anos
	  de dados.
	</para>
	<para>
	  Se <argname>f2</argname> for maior ou igual ao número
	  de observações disponíveis, então a versão
	  <quote>passa-baixa</quote> do filtro será executada
	  e a série resultante deve ser considerada como uma estimativa
	  do componente de tendência, ao invés de ciclo.
	  <seelist>
            <fncref targ="bwfilt"/>
            <fncref targ="hpfilt"/>
	  </seelist>
	</para>
      </description>
    </function>
    
    <function name="bkw" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">V</fnarg>
	<fnarg optional="true" type="strings">parnames</fnarg>
	<fnarg optional="true" type="bool">verbose</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula o test BKW para a colinearidade (ver
	  <cite key="belsley-etal80">Belsley, Kuh and Welsch
	  (1980)</cite>) dada a matriz covariança da estimativa dos
	  parâmetros <argname>V</argname>. O segundo argumento opcional,
          que pode ser um vector de texto ou uma cadeia de texto que contenha
          nomes separados por vírgulas, é usado para etiquetar a coluna que
          mostra a proporção da variância; o número de nomes deve ser igual
          à dimensão de <argname>V</argname>.  Depois de se ter estimado uma modelo
          em gretl, pode-se obter os parâmetros adequados por via dos acessores
          <fncref targ="$vcv"/> e <fncref
	  targ="$parnames"/>.
	</para>
	<para>
	  Por defeito esta função produz apenas a tabela BKW como matriz,
          mas se inserir um valor diferente de 0 como terceiro argumento,
          junto com a tabela é mostrado mais alguma análise.
	</para>
	<para>
	  Esta função também existe como comando que retorna o mesmo cálculo,
	  <cmdref targ="bkw"/>, e que usa automaticamente o último modelo sem
          necessitar argumentos.
	</para>
      </description>
    </function>

    <function name="boxcox" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="scalar">d</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a transformação de Box&ndash;Cox com parâmetro
	  <argname>d</argname> para uma série positiva <argname>y</argname>.
	</para>
	<para context="tex">
	  \[ y_t^{(d)} = \left\{ \begin{array}{ll} \frac{y_t^d - 1}{d} &amp;
	  {\rm if}\quad d\neq 0 \\ \log (y_t) &amp; {\rm if}\quad d=0
	  \end{array} \right. \]
	</para>
	<para context="notex">
	  A série transformada é (<math>y</math><sup>d</sup> -
	  1)/<math>d</math> para <math>d</math> diferente de zero ou
	  log(<math>y</math>) para <math>d</math> = 0.
	</para>
      </description>
    </function>

    <function name="bread" section="data-utils" output="bundle">
      <fnargs>
	<fnarg type="string">fname</fnarg>
	<fnarg optional="true" type="bool">import</fnarg>
      </fnargs>
      <description>
	<para>
	  Lê um pacote (bundle) a partir de um arquivo de texto. A
	  variável de texto (string) <argname>fname</argname> deve
	  conter o nome do arquivo no qual o pacote será lido. Se esse nome tiver
	  a extensão <quote><lit>.gz</lit></quote> será assumido que foi aplicada
	  a compactação do arquivo via gzip.
	</para>
	<para>
	  O arquivo em questão deve ser um XML apropriadamente definido:
	  ele dever conter um elemento <lit>gretl-bundle</lit>, utilizado
	  para armazenar zero ou mais elementos <lit>bundled-item</lit>. Por
	  exemplo:
	</para>
	<code>
	  &lt;?xml version="1.0" encoding="UTF-8"?&gt;
	  &lt;gretl-bundle name="temp"&gt;
          &lt;bundled-item key="s" type="string"&gt;moo&lt;/bundled-item&gt;
          &lt;bundled-item key="x" type="scalar"&gt;3&lt;/bundled-item&gt;
	  &lt;/gretl-bundle&gt;
	</code>
	<para>
	  Como esperado, tais arquivos são gerados automaticamente pela
	  função associada <fncref targ="bwrite"/>.
	</para>
	<para>
	  Se o nome do arquivo não contiver a especificação completa
	  de seu caminho, ele será procurado em vários locais
	  <quote>prováveis</quote>, começando no
	  <cmdref targ="workdir"/> corrente. Entretanto, se for dado
	  um valor não-nulo para o argumento opcional
	  <argname>import</argname>, o arquivo será procurado no diretório
	  <quote>@dotdir</quote>. Nesse caso o argumento
	  <argname>fname</argname> deverá ser um nome simples, sem a
	  inclusão do caminho.
	</para>
	<para>
	  Se ocorrer algum erro (tal como o arquivo ter sido mal
	  formatado ou ser inacessível), um erro será retornado
	  via acessor <fncref targ="$error"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="mread"/>
            <fncref targ="bwrite"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="brename" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="bundle">B</fnarg>
	<fnarg type="string">antiga</fnarg>
	<fnarg type="string">nova</fnarg>
      </fnargs>
      <description>
	<para>
	  Se o argumento bundle <argname>B</argname> contém um elemento com
	  a etiqueta <argname>antiga</argname>, esta é alterada
	  para <argname>nova</argname>; caso contrário, é mostrado um 
          erro. Em caso de sucesso, retorna 0.
	</para>
	<para>
	  Esta não é uma operação muito comum, mas pode ser necessária
          em funções que trabalham com bundles, e
	  <lit>brename</lit> é uma ferramenta eficiente para essa tarefa.
          Exemplo:
	</para>
	<code>
	  # controi um bundle contendo uma matriz grande
	  bundle b
	  b.X = mnormal(1000, 1000)
	  if 0
	      # muda o nome manualmente
	      Xcopy = b.X
	      delete b.X
	      b.Y = Xcopy
	      delete Xcopy
	  else
	      # melhor: mais eficiente
	      brename(b, "X", "Y")
	  endif
	</code>
	<para>
	  O primeiro método obriga a que a matriz seja copiada duas vezes,
          fora do bundle e depois insere com nova etiqueta,
          enquanto o método eficiente altera directamente a etiqueta.
	</para>
      </description>
    </function>

    <function name="bwfilt" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int">n</fnarg>
	<fnarg type="scalar">omega</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o resultado da aplicação de um filtro passa-baixo
	  de Butterworth de ordem <argname>n</argname> e
	  frequência de corte <argname>omega</argname> na série
	  <argname>y</argname>. O corte é expresso em graus e
	  deve ser maior ou igual a 0 e menor que 180. Valores de corte
	  menores restringem o passa-banda a menores frequências e assim
	  produzem uma tendência mais suave. Valores maiores de
	  <argname>n</argname> produzem um corte mais agudo, mas ao custo
	  de possível instabilidade numérica.
	</para>
	<para>
	  A inspeção preliminar do periodograma da série de interesse é útil
	  quando se deseja aplicar esta função.
	  Veja <guideref targ="chap:tsfilter"/> para detalhes.
	  <seelist>
            <fncref targ="bkfilt"/>
            <fncref targ="hpfilt"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="bwrite" section="data-utils" output="int">
      <fnargs>
	<fnarg type="bundle">B</fnarg>
	<fnarg type="string">fname</fnarg>
	<fnarg optional="true" type="bool">export</fnarg>
      </fnargs>
      <description>
	<para>
	  Escreve um pacote (bundle) <argname>B</argname>
	  em um arquivo XML com nome <argname>fname</argname>. Para uma
	  descrição sumária de seu formato, veja <fncref targ="bread"/>.
	  Se já existir um arquivo <argname>fname</argname> ele será
	  sobrescrito. O valor de retorno da função é 0 em caso de
	  sucesso. Se ocorrerem erros, tais como a impossibilidade de
	  sobrescrever o arquivo, a função retorna um valor não-nulo.
	</para>
	<para>
	  O arquivo de saída será salvo no diretório <cmdref targ="workdir"/>,
	  a menos que a variável <argname>fname</argname> contenha um
	  caminho para o diretório onde será armazenado. Entretanto,
	  se for dado um valor não-nulo para o argumento <argname>
	  export</argname>, o arquivo de saída será armazenado no
	  diretório <quote>@dotdir</quote>. Neste caso um nome simples,
	  sem especificação de caminho, deverá ser utilizado como
	  segundo argumento.
	</para>
	<para>
	  Por padrão, o arquivo XML é armazenado sem compressão, mas se
	  <argname>fname</argname> tiver a extensão <lit>.gz</lit>
	  é aplicada a compressão gzip.
	</para>
	<para>
	  <seelist>
            <fncref targ="bread"/>
            <fncref targ="mwrite"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="carg" section="complex" output="matrix">
      <fnargs>
	<fnarg type="cmatrix">C</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma matriz real <by r="m" c="n"/> contendo o 
          <quote>argumento</quote> complexo de cada elemento da
          matriz complexa <by r="m" c="n"/>
	  <argname>C</argname>. O argumento do número complexo
	  <math>z</math> = <math>x</math> + <math>yi</math> também pode
          ser calculado como <lit>atan2(y, x)</lit>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="cmod"/>
	    <fncref targ="atan2"/>
	  </seelist>
	</para>
      </description>
    </function>
    
    <function name="cdemean" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="bool" optional="true">standardize</fnarg>
      </fnargs>
      <description>
	<para>
	  Centraliza as colunas da matriz <argname>X</argname> em torno
	  de suas médias. Se o segundo argumento (opcional) é diferente de zero,
	  a coluna é normalizada, usando o desvio padrão ajustada com os graus
          de liberdade (ou seja <math>n</math>
	  &minus; 1 como divisor, onde <math>n</math> é o número de linhas de 
	  <argname>X</argname>).
	</para>
      </description>
    </function>

    <function name="cdf" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="char">c</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <examples>
	<example>p1 = cdf(N, -2.5)</example>
	<example>p2 = cdf(X, 3, 5.67)</example>
	<example>p3 = cdf(D, 0.25, -1, 1)</example>
      </examples>
      <description>
	<para>
	  Calculadora da função de distribuição acumulada. Retorna
	  <equation status="inline" ascii="P(X &le; x)" tex="$P(X \le
	  x)$"/>, onde a distribuição de <math>X</math> é especificada
	  pela letra <argname>c</argname>. Entre os argumentos <argname>
	  c</argname> e <argname>x</argname>, zero ou mais argumentos
	  adicionais são necessários para que se especifique os parâmetros
	  da distribuição. Isso é feito da seguinte forma (note que a
	  distribuição normal tem, por conveniência, uma função própria,
	  <fncref targ="cnorm"/>):
	</para>
	<ilist context="notex">
	  <li>
            <para>
              Normal padrão (c = z, n ou N): sem argumentos extras
            </para>
	  </li>
	  <li>
            <para>
              Normal bivariada (D): coeficiente de correlação
            </para>
	  </li>
	  <li>
            <para>
              t de Student (t): graus de liberdade
            </para>
	  </li>
	  <li>
            <para>
              Qui-quadrado (c, x ou X): graus de liberdade
            </para>
	  </li>
	  <li>
            <para>
              F de Snedecor F (f ou F): graus de liberdade (num.); graus de liberdade (den.)
            </para>
	  </li>
	  <li>
            <para>
              Gama (g ou G): forma; escala
            </para>
	  </li>
	  <li>
            <para>
              Binomial (b ou B): probabilidade; quantidade de tentativas
            </para>
	  </li>
	  <li>
            <para>
              Poisson (p ou P): média
            </para>
	  </li>
	  <li>
            <para>
              Exponencial (exp): escala
            </para>
	  </li>
	  <li>
            <para>
              Weibull (w ou W): forma; escala
            </para>
	  </li>
	  <li>
            <para>
              Laplace (l ou L): media; escala
            </para>
	  </li>
	  <li>
            <para>
              Erro Generalizado (E): forma
            </para>
	  </li>
	  <li>
	    <para>
	      Qui-quadrado não-central (ncX): graus de liberdade, parâmetro de não-centralidade
	    </para>
	  </li>
	  <li>
	    <para>
	      F não-central (ncF): graus de liberdade (num.), graus de liberdade (den.),
	      parâmetro de não-centralidade
	    </para>
	  </li>
	  <li>
	    <para>
	      t não-central (nct): graus de liberdade, parâmetro de não-centralidade
	    </para>
	  </li>
	</ilist>
	<tabular colspec="lllll">
	  \textit{Distribuição} &amp; \textsl{d} &amp;
	  \textit{Arg} 2 &amp; \textit{Arg} 3 &amp; \textit{Arg} 4 \\[4pt]
	  Normal padrão &amp; \texttt{z}, \texttt{n} ou \texttt{N} &amp;
	  -- &amp; -- &amp; --\\
	  Normal bivariada &amp; \texttt{D} &amp;
	  $\rho$ &amp; -- &amp; --\\
	  $t$ de Student (central) &amp; \texttt{t} &amp;
	  g.l. &amp; -- &amp; --\\
	  Qui-quadrado &amp; \texttt{c}, \texttt{x} ou \texttt{X} &amp;
	  g.l. &amp; -- &amp; --\\
	  $F$ de Snedecor &amp; \texttt{f} ou \texttt{F} &amp;
	  g.l. (num.) &amp; g.l. (den.) &amp; --\\
	  Gama &amp; \texttt{g} ou \texttt{G} &amp;
	  forma &amp; escala &amp; --\\
	  Binomial &amp; \texttt{b} ou \texttt{B} &amp;
	  probabilidade &amp; tentativas &amp; --\\
	  Poisson &amp; \texttt{p} ou \texttt{P} &amp;
	  média &amp; -- &amp; --\\
	  Exponencial &amp; \texttt{exp} &amp;
	  escala &amp; -- &amp; --\\
	  Weibull &amp; \texttt{w} ou \texttt{W} &amp;
	  forma &amp; escala &amp; --\\
	  Laplace &amp; \texttt{l} ou \texttt{L} &amp;
	  media &amp; escala &amp; --\\
	  Erro Generalizado &amp; \texttt{E} &amp;
	  forma &amp; -- &amp; --\\
	  $\chi^2$ não-central &amp; \texttt{ncX} &amp;
	  g.l. &amp; não-centralidade &amp; -- \\
	  $F$ não-central &amp; \texttt{ncF} &amp;
	  g.l. (num.) &amp; g.l. (den.) &amp; não-centralidade \\
	  Non-central $t$ &amp; \texttt{nct} &amp;
	  g.l. &amp; não-centralidade &amp; -- \\
	</tabular>
	<para>
	  Note que na maioria dos casos existem pseudônimos para ajudar na
	  memorização dos códigos. O caso da norma bivariada é especial: a
	  sintaxe é <lit>x = cdf(D, rho, z1, z2)</lit> onde <lit>rho</lit>
	  é a correlação entre as variáveis <lit>z1</lit>
	  e <lit>z2</lit>.
	</para>
	<para context="tex">
	  A parametrização que o \app{Gretl} usa para a a variável aleatória
	  Gama implica que sua função de densidade pode ser escrita como
	  \[
	  f(x; k, \theta) = \frac{x^{k-1}}{\theta^k} \frac{e^{-x/\theta}}{\Gamma(k)}
	  \]
	  onde $k>0$ é o parâmetro de forma e $\theta>0$ é o parâmetro de
	  escala.
	</para>
	<para>
	  <seelist>
            <fncref targ="pdf"/>
            <fncref targ="critical"/>
            <fncref targ="invcdf"/>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cdiv" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">Y</fnarg>
      </fnargs>
      <description>
	<para>
	  Divisão de números complexos. Os dois argumentos devem possuir o mesmo
	  número de linhas, <math>n</math>, e devem possuir uma ou duas colunas.
	  A primeira coluna contém a parte real e a segunda (se estiver presente)
	  contém a parte imaginária. A função retorna uma matriz de ordem
	  <by r="n" c="2"/> ou, caso não exista a parte imaginária, um vetor com
	  <math>n</math> linhas.
	  <seelist>
            <fncref targ="cmult"/>
	  </seelist>
	</para>
      </description>
    </function>

<function name="cdummify" section="transforms" output="list">
      <fnargs>
	<fnarg type="list">L</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta função devolve uma lista em que cada série do argumento
	  <argname>L</argname> que tenha o atributo <quote>codificado</quote>
	  é substituída por un conjunto de variáveis fictícias/dummy que
	  representam cada um dos seus valores codificados, mas omitindo
	  o valor mais pequeno/menor. Se o argumento <argname>L</argname>
	  não contém nenhuma série codificada, o valor retornado vai ser
	  idêntico ao argumento <argname>L</argname>.
	</para>
	<para>
	  As variáveis fictícias/dummy, se geradas, terão os
	  nomes criados de acordo com o padrão <lit>D</lit><repl>
	  nome-da-variável </repl><lit>_</lit><repl>vi</repl>
	  onde <repl>vi</repl> é o <repl>i</repl><i>-ésimo</i>
	  valor representado da variável codificada. Caso alguns
	  valores sejam negativos, será inserido <quote>m</quote>
	  antes do valor (absoluto) de <repl>vi</repl>.
	</para>
	<para>
	  Por exemplo, supondo que <argname>L</argname> contém, uma série
	  codificada chamada <lit>C1</lit> com valores &minus;9, &minus;7,
	  0, 1 e 2. Então, as variáveis dummy/fictícias geradas vão ser
	  <lit>DC1_m7</lit> (que codifica quando C1 = &minus;7),
	  <lit>DC1_0</lit> (que codifica quando C1 = 0), etc.
	</para>
	<para>
	  <seelist>
            <fncref targ="dummify"/>
	    <fncref targ="getinfo"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ceil" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Consiste na função teto. Retorna o menor inteiro que seja maior
	  ou igual a <argname>x</argname>.
	  <seelist>
            <fncref targ="floor"/>
            <fncref targ="int"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cholesky" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="pdmat">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza a decomposição de Cholesky da matriz <argname>A</argname>,
	  assumindo que seja simétrica e definida positiva. O resultado será
	  uma matriz triangular inferior <math>L</math> que satisfaz
	  <equation status="inline" ascii="A = LL'"  tex="$A = LL'$"/>. A
	  função irá falhar se <argname>A</argname> não for simétrica ou não
	  for definida positiva.
	  <seelist>
            <fncref targ="psdroot"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="chowlin" section="transforms" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="int">xfac</fnarg>
	<fnarg type="matrix" optional="true">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Expande os dados de entrada, <argname>Y</argname>, para uma frequência
	  maior utilizando o método de <cite
	  key="chowlin71">Chow e Lin (1971)</cite>. É assumido
	  que as colunas de <argname>Y</argname>
	  representam séries. A matriz retornada tem a mesma quantidade de colunas
	  de <argname>Y</argname> e <argname>xfac</argname> vezes
	  o número de linhas.
	</para>
	<para>
	  O segundo argumento representa o fator de expansão. Deve ser igual
	  a 3 para expandir dados trimestrais em mensais ou igual a 4 para expandir
	  de anual para trimestral (estes são os únicos fatores atualmente suportados).
	  O terceiro argumento, que é opcional, pode ser utilizado para fornecer uma
	  matriz de covariáveis com frequência maior.
	</para>
	<para>
	  Os regressores utilizados por padrão são uma constante e uma tendência
	  quadrática. Se <argname>X</argname> for fornecido, suas colunas devem ser
	  utilizadas como regressores adicionais. A função retornará um erro se o
	  número de linhas em <argname>X</argname> não for igual a
	  <argname>xfac</argname> vezes o número de linhas em
	  <argname>Y</argname>.
	</para>
      </description>
    </function>

    <function name="cmod" section="complex" output="matrix">
      <fnargs>
	<fnarg type="cmatrix">C</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma matriz real <by r="m" c="n"/> contendo o
	  valor absoluto (ou <quote>módulo</quote>) de cada elemento
	  da matriz complexa <by r="m" c="n"/>
	  <argname>C</argname>. O módulo do número complexo
	  <math>z</math> = <math>x</math> + <math>yi</math> é igual
          à raiz quadrada de <math>x</math><sup>2</sup> +
	  <math>y</math><sup>2</sup>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="carg"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cmult" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">Y</fnarg>
      </fnargs>
      <description>
	<para>
	  Multiplicação complexa. Os dois argumentos devem ter o mesmo
	  número de linhas, <math>n</math>, e uma ou duas colunas.
	  A primeira coluna contendo a parte real e a segunda (se existir)
	  a parte imaginária. O valor retornado é uma matriz
	  <by r="n" c="2"/>, ou, se o resultado não contiver parte
	  imaginária, um vetor de tamanho <math>n</math>.
	  <seelist>
            <fncref targ="cdiv"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cnorm" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a função de distribuição acumulada para uma normal
	  padrão.
	  <seelist>
            <fncref targ="dnorm"/>
            <fncref targ="qnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cnumber" section="linalg" output="scalar">
      <fnargs>
    <fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o número condicional da matriz <argname>X</argname> de
	  ordem <by r="n" c="k"/>, conforme definido em <cite
	  key="belsley-etal80">Belsley, Kuh e Welsch
	  (1980)</cite>. Se as colunas de <argname>X</argname> forem
	  mutuamente ortogonais o número condicional de
	  <argname>X</argname> é a unidade. Um número condicional grande
	  é um indicador de multicolinearidade, sendo que é considerado
	  normalmente um valor <quote>grande</quote> algo acima de 50
	  (ou, algumas vezes, de 30).
	</para>
	<para>
	  Os passos para esses cálculos são: (1) construir uma matriz
	  <math>Z</math> onde suas colunas são a divisão das colunas de
	  <argname>X</argname> divididas por suas respectivas normas
	  euclidianas; (2) construir <math>Z'Z</math> e obter seus
	  autovalores e; (3) calcular a raiz quadrada da razão entre
	  o maior e o menor autovalor.
	</para>
	<para>
	  <seelist>
            <fncref targ="rcond"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cnameget" section="strings" output="string-or-strings">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="int" optional="true">col</fnarg>
      </fnargs>
      <description>
	<para>
	  Se o argumento <argname>col</argname> for dado, retorna o nome
	  da coluna <argname>col</argname> da matriz <argname>M</argname>.
	  Se as colunas de <argname>M</argname> não possuírem nomes então
	  será retornada um texto (string) vazio. Se <argname>col</argname>
	  for maior que o número de colunas da matriz será sinalizado um
	  erro.
	</para>
	<para>
	  Se não se indicar o segundo argumento, retornará um vetor de
      texto que contém os nomes das colunas de <argname>M</argname>,
	  ou um vetor de texto vazio se <argname>M</argname> não tiver
      nomes de colunas atribuídos.
	</para>
	<para>
	  Exemplo:
	</para>
	<code>
	  matrix A = { 11, 23, 13 ; 54, 15, 46 }
	  cnameset(A, "Col_A Col_B Col_C")
	  string name = cnameget(A, 3)
	  print name
	</code>
	<para>
	  <seelist>
            <fncref targ="cnameset"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cnameset" section="matbuild" output="scalar">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="strings-or-list">S</fnarg>
      </fnargs>
      <description>
	<para>
	  Adiciona nomes para as colunas da matriz <argname>M</argname>
	  de ordem <by r="T" c="k"/> . Se <argname>S</argname> for uma
	  lista, os nomes serão os das séries listadas. A lista precisa
	  ter <math>k</math> membros. Se <argname>S</argname> for um
	  arranjo (array) de textos (string), ele precisa ter <math>k
	  </math> elementos. Para manter a compatibilidade com versões
	  anteriores do Gretl, uma única variável de texto também pode
	  ser utilizada como segundo argumento. Nesse caso ela precisa
	  ter <math>k</math> textos separados por espaços.
	</para>
	<para>
	  Retorna o valor 0 se as colunas forem nomeadas com sucesso. Caso
	  contrário retorna um valor não-nulo. Veja também <fncref targ="rownames"/>.
	</para>
	<para>
	  Exemplo:
	</para>
	<code>
	  matrix M = {1, 2; 2, 1; 4, 1}
	  variável de textos S = array(2)
	  S[1] = "Col1"
	  S[2] = "Col2"
	  colnames(M, S)
	  print M
	</code>
      </description>
    </function>

    <function name="cols" section="matshape" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o número de colunas da matriz <argname>X</argname>.
	  <seelist>
            <fncref targ="mshape"/>
            <fncref targ="rows"/>
            <fncref targ="unvech"/>
            <fncref targ="vec"/>
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="corr" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y1</fnarg>
	<fnarg type="series-or-vec">y2</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula o coeficiente de correlação entre <argname>y1</argname>
	  e <argname>y2</argname>. Os argumentos devem ser duas séries ou
	  dois vetores com o mesmo tamanho.
	  <seelist>
            <fncref targ="cov"/>
            <fncref targ="mcov"/>
            <fncref targ="mcorr"/>
            <fncref targ="npcorr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="corrgm" section="stats" output="matrix">
      <fnargs>
	<fnarg type="smlist">x</fnarg>
	<fnarg type="int">p</fnarg>
	<fnarg optional="true" type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Se forem fornecidos apenas os dois primeiros argumentos
	  a função calcula o correlograma de <argname>x</argname>
	  para as defasagens de 1 até <argname>p</argname>. Sendo
	  <math>k</math> o número de elementos em <argname>x</argname>
	  (igual a 1 se <argname>x</argname> for uma série, ao número
	  de colunas se <argname>x</argname> for uma matriz ou ao
	  número de membros se <argname>x</argname> for uma lista).
	  O valor retornado será uma matriz com <argname>p</argname>
	  linhas e 2<math>k</math> colunas, onde as <math>k</math>
	  primeiras colunas conterão as respectivas autocorrelações
	  e o restante as respectivas autocorrelações parciais.
	</para>
	<para>
	  Se um terceiro argumento for fornecido a função irá computar
	  o correlograma cruzado para cada um dos <math>k</math> elementos
	  em <argname>x</argname> e <argname>y</argname>, partindo de
	  <math>+</math><argname>p</argname> até <math>-</math><argname>
	  p</argname>. A matriz retornada possui 2<math>p</math> + 1 linhas
	  e <math>k</math> colunas. Se <argname>x</argname> for uma série
	  ou lista e <argname>y</argname> for um vetor, <argname>y</argname>
	  precisa ter linhas na mesma quantidade que o total de observações
	  na amostra selecionada.
	</para>
      </description>
    </function>

    <function name="cos" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o cosseno de <argname>x</argname>.
	<seelist>
          <fncref targ="sin"/>
          <fncref targ="tan"/>
          <fncref targ="atan"/>
	</seelist>
	</para>
      </description>
    </function>

    <function name="cosh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o cosseno hiperbólico de <argname>x</argname>.
	</para>
	<para context="tex">
	  \[ \cosh x = \frac{e^x + e^{-x}}{2}  \]
	</para>
	<para>
	  <seelist>
            <fncref targ="acosh"/>
            <fncref targ="sinh"/>
            <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cov" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y1</fnarg>
	<fnarg type="series-or-vec">y2</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a covariância <argname>y1</argname> e
	  <argname>y2</argname>. Os argumentos devem ser duas séries
	  ou dois vetores (estes devem possuir o mesmo comprimento).
	  <seelist>
            <fncref targ="corr"/>
            <fncref targ="mcov"/>
            <fncref targ="mcorr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="critical" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="char">c</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">p</fnarg>
      </fnargs>
      <examples>
	<example>c1 = critical(t, 20, 0.025)</example>
	<example>c2 = critical(F, 4, 48, 0.05)</example>
      </examples>
      <description>
	<para>
	  Calculadora de valores críticos. Retorna <math>x</math> tal que
	  <equation status="inline" ascii="P(X &gt; x) = p"
		    tex="$P(X &gt; x) = p$"/>, onde a distribuição <math>X</math> é
	  determinada pela letra <argname>c</argname>. Entre os
	  argumentos <argname>c</argname> e <argname>p</argname>, zero ou
	  mais argumentos escalares são necessários para especificar os
	  parâmetros da distribuição, Isso é feito da seguinte forma:
	</para>
	<ilist context="notex">
	  <li>
            <para>
              Normal padrão (c = z, n ou N): sem argumentos extras
            </para>
	  </li>
	  <li>
            <para>
              t de Student (t): graus de liberdade
            </para>
	  </li>
	  <li>
            <para>
              Chi square (c, x ou X): graus de liberdade
            </para>
	  </li>
	  <li>
            <para>
              F de Snedecor (f ou F): g.l. (num.); g.l. (den.)
            </para>
	  </li>
	  <li>
            <para>
              Binomial (b ou B): probabilidade; tentativas
            </para>
	  </li>
	  <li>
            <para>
              Poisson (p ou P): média
            </para>
	  </li>
	  <li>
            <para>
              Laplace (l ou L): média; escala
            </para>
	  </li>
	  <li>
            <para>
              Erro Generalizado (E): forma
            </para>
	  </li>
	</ilist>
	<tabular colspec="llll">
	  \textit{Distribuição} &amp; \textsl{c} &amp;
	  \textit{Arg} 2 &amp; \textit{Arg} 3 \\[4pt]
	  Normal padrão &amp; \texttt{z}, \texttt{n} ou \texttt{N} &amp;
	  -- &amp; -- \\
	  $t$ de Student (central) &amp; \texttt{t} &amp;
	  graus de liberdade &amp; -- \\
	  Qui-quadrado &amp; \texttt{c}, \texttt{x} ou \texttt{X} &amp;
	  graus de liberdade &amp; -- \\
	  $F$ de Snedecor &amp; \texttt{f} ou \texttt{F} &amp;
	  g.l. (num.) &amp; g.l. (den.) \\
	  Binomial &amp; \texttt{b} ou \texttt{B} &amp;
	  $p$ &amp; $n$ \\
	  Poisson &amp; \texttt{p} ou \texttt{P} &amp;
	  $\lambda$ &amp; -- \\
	  Laplace &amp; \texttt{l} ou \texttt{L} &amp;
	  média &amp; escala \\
	  Erro Generalizado &amp; \texttt{E} &amp;
	  forma &amp; -- \\
	</tabular>
	<para>
	  <seelist>
            <fncref targ="cdf"/>
            <fncref targ="invcdf"/>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cum" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Acumula <argname>x</argname> (isto é, cria uma soma móvel).
	  Quando <argname>x</argname> for uma série, produz uma série
	  <math>y</math> onde cada um de seus elementos é igual a soma
	  dos valores de <argname>x</argname> até a observação correspondente.
	  O ponto de partida para a acumulação é a primeira observação
	  não-ausente da amostra selecionada corrente. Quando <argname>x</argname>
	  for uma matriz, seus elementos são acumulados por colunas.
	</para>
	<para context="tex">
	  Acumula <argname>x</argname>. Quando <math>x</math> or uma série,
	  produz uma série $y_t = \sum_{s=m}^t x_s$. O ponto de partida para
	  a acumulação, <math>m</math>, é a primeira observação não-ausente
	  a amostra selecionada corrente. Se forem encontrados valores ausentes
	  em <math>x</math>, os valores subsequentes de <math>y</math> serão
	  definidos como valor ausente. Quando <argname>x</argname>for uma
	  matriz, seus elementos são acumulados por colunas.
	</para>
	<para>
	  <seelist>
            <fncref targ="diff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="curl" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="bundleref">&amp;b</fnarg>
      </fnargs>
      <description>
	<para>
	  Fornece uma maneira relativamente flexível de se obter um buffer
	  de texto contendo dados de um servidor de internet utilizando a
	  biblioteca libcurl. O argumento <argname>b</argname>, do tipo
	  pacote (bundle), deve conter uma variável de texto (string)
	  chamada <lit>URL</lit> que fornece o endereço completo do recurso
	  no host alvo. Outros elementos opcionais são apresentados a seguir.
	</para>
	<ilist>
	  <li>
	    <para>
	      <quote><lit>header</lit></quote>: a variável de texto especificando
	      um header HTTP que será enviado para o host.
	    </para>
	  </li>
	  <li>
	    <para>
	      <quote><lit>postdata</lit></quote>: a variável de texto contendo
	      os dados que serão enviados para o host.
	    </para>
	  </li>
	</ilist>
	<para>
	  Os campos <lit>header</lit> e <lit>postdata</lit> são destinados
	  para o uso com uma requisição HTTP do tipo <lit>POST</lit>. Se
	  <lit>postdata</lit> estiver presente o método <lit>POST</lit> é
	  implícito, caso contrário o método <lit>GET</lit> é
	  implícito. Mas note que para requisições <lit>GET</lit> diretas
	  a função <fncref targ="readfile"/> oferece uma interface
	  mais simples.
	</para>
	<para>
	  Se outro elemento opcional do pacote, um escalar chamado
	  <lit>include</lit> estiver presente e possuir valor não-nulo,
	  a requisição irá incluir o header recebido
	  do host com o corpo de saída.
	</para>
	<para>
	  Ao completar-se a requisição, o texto recebido do
	  servidor é adicionado ao pacote e recebe o nome de
	  <quote><lit>output</lit></quote>.
	</para>
	<para>
	  Se um erro ocorrer na formulação da requisição (por exemplo, não existir
	  a <lit>URL</lit> na entrada) a função irá falhar, caso contrário ela
	  retornará o valor 0 se a requisição for bem sucedida ou um valor não
	  nulo, sendo que neste caso a mensagem de erro da biblioteca curl
	  será adicionado ao pacote e identificado como
	  <quote><lit>errmsg</lit></quote>. Note, entretanto, que
	  <quote>sucesso</quote> neste sentido não significa necessariamente
	  que os dados desejados foram obtidos. Na verdade significa apenas que
	  alguma resposta foi recebida do servidor. Assim, é necessário conferir
	  o conteúdo do buffer de saída (que pode ser de fato uma mensagem tal como
	  <quote>Página não encontrada</quote>).
	</para>
	<para>
	  Um bom exemplo de como utilizar essa função é baixar alguns dados
	  do site do US Bureau of Labor Statistics, que requere o envio de
	  uma consulta (query) JSON. Note o uso de <cmdref targ="sprintf"/> para
	  inserir aspas duplas no dado <lit>POST</lit>.
	</para>
	<code>
	  bundle req
	  req.URL = "http://api.bls.gov/publicAPI/v1/timeseries/data/"
	  req.include = 1
	  req.header = "Content-Type: application/json"
	  string s = sprintf("{\"seriesid\":[\"LEU0254555900\"]}")
	  req.postdata = s
	  err = curl(&amp;req)
	  if err == 0
	      s = req.output
	      string line
	      loop while getline(s, line) --quiet
	          printf "%s\n", line
	      endloop
	  endif
	</code>
	<para>
	  Veja também as funções <fncref targ="jsonget"/> e
	  <fncref targ="xmlget"/> para processamento de dados recebidos
      no formato JSON e XML, respectivamente.
	</para>
      </description>
    </function>

    <function name="dayspan" section="calendar" output="int">
      <fnargs>
	<fnarg type="int">dia1</fnarg>
	<fnarg type="int">dia2</fnarg>
	<fnarg type="int">dias por semana</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o número de dias (relevantes) entre os dias
	  <argname>dia1</argname> e <argname>dia2</argname>,
	  inclusive. Os <argname>dias por semana</argname>, que têm que ser
	  5, 6 ou 7, dão o número de dias na semana que devem contar
	  (um valor de 6, ignora domingos, e um valor de 5
	  ignora sábados e domingos).
	</para>
	<para>
	  Para obter dias de época a partir de formas mais familiares
	  de datas, ver <fncref targ="epochday"/>. Veja também: <fncref
	  targ="smplspan"/>.
	</para>
      </description>
    </function>

    <function name="defarray" section="data-utils" output="seebelow">
      <fnargs>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Permite a definição de uma variável do tipo arranjo (array)
	  <emphasis>de forma direta</emphasis>, através do fornecimento de um ou mais
	  elementos. Ao utilizar essa função é necessário que se especifique um tipo
	  (na forma plural) para o arranjo: <lit>strings</lit>, <lit>matrices</lit>,
	  <lit>bundles</lit> ou <lit>lists</lit>. Cada um dos argumentos dever ser
	  um objeto do mesmo tipo que o especificado na definição do arranjo.
	  Em caso de sucesso na definição, será retornado um arranjo com
	  <math>n</math> elementos, onde <math>n</math> é igual ao número de
	  argumentos.
	</para>
	<code>
	  strings S = defarray("foo", "bar", "baz")
	  matrices M = defarray(I(3), X'X, A*B, P[1:])
	</code>
	<para>
	  Veja também <fncref targ="array"/>.
	</para>
      </description>
    </function>

    <function name="defbundle" section="data-utils" output="bundle">
      <fnargs>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Permite a definição inicial de uma variável pacote (bundle)
	  <emphasis>por extenso</emphasis>, com a indicação de zero ou
      mais pares com o formato <repl>chave</repl>, <repl>membro</repl>.
	  Se contarmos os argumentos a partir de 1, cada argumento numerado
	  ímpar tem de corresponder a uma cadeia de texto (chave) e cada
	  argumento numerado par deve representar um objeto/objecto de
      um tipo que possa ser incluído num pacote.
   	</para>
	<para>
	  Alguns exemplos simples:
	</para>
	<code>
	  bundle b1 = defbundle("s", "Texto exemplo", "m", I(3))
	  bundle b2 = defbundle("yn", normal(), "x", 5)
	</code>
	<para>
	  O primeiro exemplo é um pacote cujos membros são uma cadeia
	  de texto e uma matriz. O segundo, um pacote com um membro que é
	  uma série e outro que é escalar. Notar que não se pode
	  especificar o tipo de cada argumento quando se utiliza esta função,
	  por isso deve-se aceitar o tipo <quote>natural</quote> do argumento
	  em questão. Por exemplo, se se pretendia acrescentar uma série com
      valor constante 5, a um pacote chamado <lit>b1</lit> seria necessário
      escrever algo como o seguinte (depois de declarar <lit>b1</lit>):
	</para>
	<code>
	  series b1.s5 = 5
	</code>
	<para>
	  Se não se fornecer nenhum argumento a esta função,
	  isso equivale a criar um pacote vazio (ou esvaziar
	  o conteúdo um pacote existente), o que também poderia
	  ser feito via:
	</para>
	<code>
	  bundle b = null
	</code>
      </description>
    </function>

    <function name="deflist" section="data-utils" output="list">
      <fnargs>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Gera uma lista (de séries já definidas) dados um ou mais argumentos
	  apropriados. Cada argumento deve ser uma série já definida (indicada
	  pelo seu nome ou número ID), uma lista definida previamente ou por
	  uma expressão cujo resultado seja uma lista (incluindo um vetor que
	  possa ser interpretado como um conjunto de números ID).
	</para>
	<para>
	  Um ponto a ser considerado é que esta função simplesmente concatena
	  seus argumentos para produzir a lista que ela devolve. Quando se
	  pretende que o valor a ser retornado não tenha duplicados (que não
	  se refira a nenhuma série mais que uma vez), fica a cargo do
	  utilizador garantir que esse requisito seja seguido.
	</para>
      </description>
    </function>

    <function name="deseas" section="filters" output="series">
      <fnargs>
	<fnarg type="series">x</fnarg>
	<fnarg optional="true" type="char">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Precisa que o TRAMO/SEATS e/ou X-12-ARIMA estejam instalados. Retorna
	  a série <argname>x</argname> dessazonalizada (ou seja, sazonalmente
	  ajustada). A série a ser dessazonalizada precisa ser mensal ou trimestral.
	  Para utilizar o X-12-ARIMA deve-se fornecer <lit>X</lit> como segundo
	  argumento e para usar o TRAMO/SEATS deve-se fornecer <lit>T</lit>. Se o
	  segundo argumento for omitido o Gretl irá utilizar o X-12-ARIMA.
	</para>
	<para>
	  Note que se a série de entrada não possuir um componente
	  sazonal detectável a execução da função irá falhar. Note
	  também que tanto o TRAMO/SEATS quanto o X-12-ARIMA oferecem
	  um grande número de opções, mas a função <lit>deseas</lit>
	  utilizará apenas os seus valores padrão. Em ambos os programas
	  os fatores sazonais são calculados com base em um modelo ARIMA
	  automaticamente selecionado. Uma das diferenças entre os dois
	  que pode levar a resultados bastante distintos é o ajuste prévio
	  de observações aberrantes que o TRAMO/SEATS realiza e que
	  não é feito pelo X-12-ARIMA.
	</para>
      </description>
    </function>

    <function name="det" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o determinante de <argname>A</argname>, calculado via
	  decomposição LU.
	  <seelist>
            <fncref targ="ldet"/>
            <fncref targ="rcond"/>
            <fncref targ="cnumber"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="diag" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a diagonal principal de <argname>X</argname> em um
	  vetor coluna. Se <argname>X</argname> for uma matriz de ordem
	  <by r="m" c="n"/> o número de elementos do vetor resultante
	  será igual a min(<math>m</math>, <math>n</math>).
	  <seelist>
            <fncref targ="tr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="diagcat" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix">B</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a soma direta de <argname>A</argname> e
	  <argname>B</argname>, isto é, uma matriz contendo
	  <argname>A</argname> no canto superior esquerdo e
	  <argname>B</argname> no canto inferior direito. Se
	  <argname>A</argname> e <argname>B</argname> forem ambas
	  quadradas, a matriz resultante será diagonal em blocos.
	</para>
      </description>
    </function>

    <function name="diff" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="smlist">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula a primeira diferença. Se <argname>y</argname> for
	  uma série ou uma lista de séries, os valores iniciais serão
	  iguais a <lit>NA</lit>. Se <argname>y</argname> for uma
	  matriz, a diferenciação é feita por colunas e os valores
	  iniciais serão iguais a 0.
	</para>
	<para>
	  Quando for retornada uma lista, cada uma das variáveis
	  será automaticamente nomeada conforme o modelo
	  <lit>d_</lit><repl>varname</repl>, onde <repl>varname</repl>
	  é o nome da série original. O nome será truncado caso
	  necessário e pode ser ajustado caso já exista uma variável
	  com o mesmo nome.
	</para>
	<para>
	  <seelist>
            <fncref targ="cum"/>
            <fncref targ="ldiff"/>
            <fncref targ="sdiff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="digamma" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Retorna a função digama (ou Psi) de
	  <argname>x</argname> e consiste na derivada logarítmica
	  da função gama.
	</para>
	<para context="tex">
	  Retorna a função digama (ou Psi) de $x$, isto é,
	  $\frac{d}{dx}\, \mbox{ln } \Gamma(x)$.
	</para>
      </description>
    </function>

    <function name="dnorm" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a densidade da distribuição normal padrão em
	  <argname>x</argname>. Para obter a densidade para uma
	  distribuição normal não-padrão em <math>x</math>, utilize
	  o escore-<math>z</math> de <math>x</math> como argumento
	  da função <lit>dnorm</lit> e multiplique o resultado pela
	  jacobiana da transformação <math>z</math>, ou seja,
	  1/&sigma;, conforme ilustrado a seguir:
	</para>
	<code>
	  mu = 100
	  sigma = 5
	  x = 109
	  fx = (1/sigma) * dnorm((x-mu)/sigma)
	</code>
	<para>
	  <seelist>
            <fncref targ="cnorm"/>
            <fncref targ="qnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="dropcoll" section="transforms" output="list">
      <fnargs>
	<fnarg type="list">X</fnarg>
	<fnarg optional="true" type="scalar">epsilon</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma lista com os mesmo elementos de <argname>X</argname>,
	  mas excluindo as séries colineares. Assim, se todas as séries em
	  <argname>X</argname> forem linearmente independentes, a lista
	  resultante será simplesmente uma cópia de
	  <argname>X</argname>.
	</para>
	<para>
	  O algoritmo utiliza a decomposição QR (transformação de Householder),
	  de forma que está sujeita a erro de precisão finita. Para avaliar
	  a sensibilidade do algoritmo, um segundo parâmetro (opcional)
	  <argname>epsilon</argname> pode ser especificado para tornar o
	  teste de colinearidade mais ou menos estrito, conforme desejado.
	  O valor padrão para <argname>epsilon</argname> é 1.0e-8. Ajustando
	  <argname>epsilon</argname> para um maior valor eleva a probabilidade
	  de uma série ser descartada.
	</para>
	<para>
	  Exemplo:
	</para>
	<code>
	  nulldata 20
	  set seed 9876
	  series foo = normal()
	  series bar = normal()
	  series foobar = foo + bar
	  list X = foo bar foobar
	  list Y = dropcoll(X)
	  list print X
	  list print Y
	  # defina épsilon como sendo um valor bastante pequeno
	  list Y = dropcoll(X, 1.0e-30)
	  list print Y
	</code>
	<para>
	  produz
	</para>
	<code>
	  ? list print X
	  foo bar foobar
	  ? list print Y
	  foo bar
	  ? list Y = dropcoll(X, 1.0e-30)
	  Replaced list Y
	  ? list print Y
	  foo bar foobar
	</code>
      </description>
    </function>

    <function name="dsort" section="matshape" output="asinput">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Ordena <argname>x</argname> de forma decrescente, descartando
	  observações com valores ausentes quando <argname>x</argname> for
	  uma série.
	  <seelist>
            <fncref targ="sort"/>
            <fncref targ="values"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="dummify" section="transforms" output="list">
      <fnargs>
	<fnarg type="series">x</fnarg>
	<fnarg optional="true" type="scalar">omitval</fnarg>
      </fnargs>
      <description>
	<para>
	  O argumento <argname>x</argname> deve ser uma série
	  discreta. Essa função cria um conjunto de variáveis dummy,
	  sendo uma para cada um dos valores distintos na série. Por padrão
	  o menor valor é tratado como a categoria omitida e não é
	  explicitamente representado.
	</para>
	<para>
	  O segundo argumento (opcional) representa o valor de <argname>x</argname>
	  que deve ser tratado como sendo a categoria omitida. O efeito quando o
	  argumento único for dado é equivalente a utilizar o seguinte comando:
	  <lit>dummify(x, min(x))</lit>. Para produzir um conjunto completo de
	  dummies, ou seja, sem a categoria omitida, pode-se usar
	  <lit>dummify(x, NA)</lit>.
	</para>
	<para>
	  As variáveis geradas são automaticamente nomeadas de acordo
	  com o seguinte padrão:
	  <lit>D</lit><repl>varname</repl><lit>_</lit><repl>i</repl>
	  onde <repl>varname</repl> é o nome da séries original
	  e <repl>i</repl> é um índice iniciado em 1. A porção que representa
	  o nome original da série será truncado, caso seja necessário,
	  e ajustado no caso de não ser único no conjunto de nomes assim
	  construído.
	</para>
      </description>
    </function>

    <function name="easterday" section="calendar" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Com o argumento <argname>x</argname> representando um ano, retorna
	  a data da Páscoa no calendário gregoriano no formato <math>mês +
	  dia/100</math>. Note que 10 de abril é, nesta convenção, 4.1.
	  Assim, 4.2 representa 20 de abril e não 2 de abril (que seria
	  representado por 4.02).
	</para>
	<code>
	  scalar e = easterday(2014)
	  scalar m = floor(e)
	  scalar d = 100*(e-m)
	</code>
      </description>
    </function>

    <function name="ecdf" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Calcula a função distribuição acumulada (FDA) empírica de
	  <argname>y</argname>. Esta é retornada em uma matriz com
	  duas colunas: a primeira contém os valores únicos e ordenados
	  de <argname>y</argname> e a segunda a frequência relativa
	  cumulativa, isto é, a quantidade de vezes em que o valor da
	  observação é menor ou igual ao valor na primeira coluna,
	  dividida pelo número total de observações.
	</para>
	<para context="tex">
	  Calcula a função distribuição acumulada (FDA) empírica de <argname>
	  y</argname>. Esta é retornada em uma matriz com duas colunas:
	  a primeira contém os valores únicos e ordenados de <argname>
	  y</argname> e a segunda a frequência relativa acumulada,
	  \[ F(y) =
	  \frac{1}{n} \sum_{i=1}^n I(y_i \leq y)
	  \]
	  onde $n$ é o número total de observações e $I()$ representa
	  a função indicadora.
	</para>
      </description>
    </function>

    <function name="eigengen" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula os autovalores e, opcionalmente, os autovetores, da
	  matriz <argname>A</argname> de ordem <by r="n" c="n"/>. Se todos os
	  autovalores forem reais uma matriz <by r="n" c="1"/> é retornada.
	  Caso contrário, o resultado é uma matriz <by r="n" c="2"/>, com a primeira
	  coluna contendo os componentes reais e a segunda coluna os componentes
	  imaginários. Não é garantido que os autovalores sejam
	  classificados em alguma ordem particular.
	</para>
	<para>
	  Existem duas possibilidades para o segundo argumento. Ele deve ser o nome
	  de uma matriz existente precedida por <lit>&amp;</lit> (para indicar o
	  <quote>endereço</quote> da matriz em questão), sendo que nesse caso
	  um resultado auxiliar é armazenado nesta matriz. A outra possibilidade é a
	  utilização da palavra-chave <lit>null</lit>, sendo que nesse caso o resultado
	  auxiliar não é produzido.
	</para>
	<para>
	  Se o segundo argumento for não-nulo, a matriz especificada será sobrescrita
	  com o resultado auxiliar. Vale salientar que não é necessário que a matriz
	  existente tenha a dimensão adequada para receber o resultado. A matriz
	  <argname>U</argname> é organizada da seguinte forma:
	</para>
	<ilist>
	  <li>
            <para>
              Se o <math>i</math>-ésimo autovalor for real, a
              <math>i</math>-ésima coluna de <math>U</math> irá conter
              o autovetor correspondente;
            </para>
	  </li>
	  <li>
            <para>
              Se o <math>i</math>-ésimo autovalor for complexo, a
              <math>i</math>-ésima coluna de <argname>U</argname> irá conter
              a parte real do autovetor correspondente e a coluna seguinte
              a parte imaginária. O autovetor para o autovalor conjugado
              é a conjugada do autovetor.
            </para>
	  </li>
	</ilist>
	<para>
	  Em outras palavras, os autovetores são armazenados na mesma ordem que os
	  autovalores, mas os autovetores reais ocupam uma coluna, enquanto que os
	  autovetores complexos ocupam duas (sendo que a parte real é armazenada
	  primeiro). O número total de colunas ainda é <math>n</math>, pois o
	  autovetor conjugado é ignorado.
	</para>
	<para>
	  <seelist>
            <fncref targ="eigensym"/>
            <fncref targ="eigsolve"/>
            <fncref targ="qrdecomp"/>
            <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="eigensym" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="symmat">A</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Funciona da mesma forma que <fncref targ="eigengen"/>, mas o
	  argumento <argname>A</argname> deve ser simétrico (sendo que
	  neste caso os cálculos podem ser reduzidos). Diferentemente
	  de <fncref targ="eigengen"/>, autovalores são retornados em
	  ordem ascendente.
	</para>
	<para>
	  Note: se o interesse é na decomposição espectral de uma
	  matriz da forma <math>X'X</math>, onde <math>X</math> é
	  uma matriz grande, é preferível calculá-la via operador
	  <lit>X'X</lit> ao invés de utilizar a sintaxe mais geral
	  <lit>X'*X</lit>. A primeira expressão utiliza um
	  algoritmo especializado que tem a dupla vantagem de ser
	  mais eficiente computacionalmente e de garantir que o
	  resultado seja livre, por construção, dos artefatos de precisão
	  de máquina que podem torná-la numericamente não-simétrico.
	</para>
      </description>
    </function>

    <function name="eigsolve" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="symmat">A</fnarg>
	<fnarg type="symmat">B</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Resolve o problema do autovalor generalizado |<math>A</math>
	  &minus; &lgr;<math>B</math>| = 0, onde <math>A</math> e
	  <math>B</math> são simétricas e <math>B</math> é positiva
	  definida. Os autovalores são retornados diretamente,
	  ordenados de forma ascendente. Se for utilizado o terceiro
	  argumento (opcional) ele deve ser o nome de uma matriz
	  existente precedida por <lit>&amp;</lit>. Neste caso os
	  autovetores generalizados serão escritos nesta matriz.
	</para>
      </description>
    </function>

    <function name="epochday" section="calendar" output="scalar-or-series">
      <fnargs>
	<fnarg type="scalar-or-series">ano</fnarg>
	<fnarg type="scalar-or-series">mês</fnarg>
	<fnarg type="scalar-or-series">dia</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o número do dia na época corrente especificada pelo ano, mês
	  e dia. O número do dia é igual a 1 para o dia 1 de janeiro do ano 1
	  depois de Cristo, no calendário gregoriano proléptico, e 733786 na
	  data 2010-01-01. Se algum dos argumentos for uma série, os valores
	  retornados também terão a forma de uma série, caso contrário será
	  retornado um escalar.
	</para>
	<para>
	  Por padrão os valores do <argname>ano</argname>,
	  <argname>mês</argname> e <argname>dia</argname> assumem-se
	  serem relativos ao calendário gregoriano,
	  mas se o ano for um valor negativo a interpretação
	  muda para o calendário juliano.
	</para>
	<para>
	  Para a inversa dessa função, veja <fncref targ="isodate"/>. Veja
	  também a função <fncref targ="juldate"/> para o calendário juliano.
	</para>
      </description>
    </function>

    <function name="errmsg" section="strings" output="string">
      <fnargs>
	<fnarg type="int">errno</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a mensagem de erro do Gretl associada a
	  <argname>errno</argname>. Veja também <fncref
	  targ="$error"/>.
	</para>
      </description>
    </function>

    <function name="exists" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">name</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna um valor não-nulo se <argname>name</argname> é o identificador de
	  um objeto existente, seja um escalar, uma série, uma matriz, uma lista, uma
	  variável de texto, um pacote (bundle) ou um arranjo
	  (array). Caso contrário retorna 0. Veja também <fncref targ="typeof"/>.
	</para>
      </description>
    </function>

    <function name="exp" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna <math>e</math><sup>x</sup>. Note que no caso de
	  matrizes a função é aplicada em cada elemento. Para a
	  função exponencial matricial veja <fncref targ="mexp"/>.
	</para>
      </description>
    </function>

    <function name="fcstats" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="series-list-or-mat">f</fnarg>
      </fnargs>
      <description>
	<para>
	  Produz uma matriz contendo várias estatísticas que podem ser utilizadas
      para avaliar a série <argname>f</argname>, que consiste na previsão da
      série observada <argname>y</argname>.
	</para>
	<para>
	  Quando <argname>f</argname> é uma série ou um vetor/vector, o resultado é um
      vetor/vector coluna. Quando <argname>f</argname> é uma lista com <math>k</math>
      membros ou uma matriz de ordem <by r="T" c="k"/>, o resultado tem <math>k</math>
      colunas, sendo que cada uma contém as estatísticas do elemento correspondente
      (série ou coluna) do argumento de entrada (série, vetor, lista ou matriz) como
      uma predição de <argname>y</argname>.
	</para>
	<para>
	  Em todos os casos, a dimensão <quote>vertical</quote> do argumento de
	  entrada (o comprimento da amostra corrente para uma série ou uma
	  lista, e o número de linhas para uma matriz) deve coincidir entre
	  os dois argumentos.
	</para>
	<para>
	  As linhas da matriz retornada são constituídas pelas seguintes estatísticas:
	</para>
	<code>
	  1  Erro Médio (ME)
	  2  Raiz do Erro Quadrado Médio (RMSE)
	  3  Erro Absoluto Médio (MAE)
	  4  Erro Percentual Médio (MPE)
	  5  Erro Percentual Absoluto Médio (MAPE)
	  6  U de Theil
	  7  Proporção do viés, UM
	  8  Proporção da regressão, UR
	  9  Proporção do distúrbio, UD
	</code>
	<para>
	  Para mais detalhes sobre o cálculo dessas estatísticas e
	  a interpretação dos valores de <math>U</math>, veja o
	  <guideref targ="chap:forecast"/>.
	</para>
      </description>
    </function>

    <function name="fdjac" section="numerical" output="matrix">
      <fnargs>
	<fnarg type="cvec">b</fnarg>
	<fnarg type="fncall">fcall</fnarg>
	<fnarg optional="true" type="scalar">h</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula uma aproximação numérica para a jacobiana associada ao
	  vetor <argname>b</argname> de ordem <math>n</math> e a função de
	  transformação especificada pelo argumento <argname>fcall</argname>.
	  A chamada da função deve ter <argname>b</argname> como primeiro
	  argumento (tanto na forma direta quanto na forma de ponteiro),
	  seguido por quaisquer argumentos adicionais que podem ser
	  necessários e o valor retornado deverá ser uma matriz de ordem
	  <by r="m" c="1"/>. Se executada com sucesso, <lit>fdjac</lit>
	  retorna uma matriz de ordem <by r="m" c="n"/> contendo a jacobiana.
	  Exemplo:
	</para>
	<para>
	  Pode-se utilizar o terceiro argumento (opcional) para determinar
	  o tamanho da medida <math>h</math> que se usa no mecanismo de
	  aproximação (ver mais abaixo). Quando se omite este argumento,
	  o tamanho da medida determina-se automaticamente.
	</para>
	<para>
	  Aqui está um exemplo do seu uso:
	</para>
	<code>
	  matrix J = fdjac(theta, myfunc(&amp;theta, X))
	</code>
	<para>
	  A função pode utilizar três diferentes métodos: diferença anterior,
	  diferença bilateral ou extrapolação de Richardson com 4 nós.
	  Respectivamente:
	</para>
	<para context="tex">
	  \[ J_0 = \frac{f(x + h) - f(x)}{h} \]
	</para>
	<para context="tex">
	  \[ J_1 = \frac{f(x + h) - f(x - h)}{2h} \]
	</para>
	<para context="tex">
	  \[ J_2 = \frac{8(f(x+h) - f(x-h)) - (f(x+2h) - f(x-2h))}{12h} \]
	</para>
	<para context="notex">
	  <math>J</math><sub>0</sub> = <math>(f(x+h) - f(x))/h</math>
	</para>
	<para context="notex">
	  <math>J</math><sub>1</sub> = <math>(f(x+h) - f(x-h))/2h</math>
	</para>
	<para context="notex">
	  <math>J</math><sub>2</sub>  = <math>[8(f(x+h) - f(x-h)) -
	  (f(x+2h) - f(x-2h))] /12h</math>
	</para>
	<para>
	  As três alternativas acima trazem, geralmente, um dilema
	  entre acurácia e velocidade. É possível escolher os métodos
	  através do comando <cmdref targ="set"/>, ajustando a variável
	  <lit>fdjac_quality</lit> em 0, 1 ou 2.
	</para>
	<para>
	  Para mais detalhes e exemplos veja o capítulo sobre métodos
	  numéricos no <guideref targ="chap:numerical"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="BFGSmax"/>
	          <fncref targ="numhess"/>
            <cmdref targ="set"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="fevd" section="stats" output="matrix">
      <fnargs>
	<fnarg type="int">target</fnarg>
	<fnarg type="int">shock</fnarg>
	<fnarg type="bundle" optional="true">sys</fnarg>
      </fnargs>
      <description>
	<para>
	  Essa função é uma alternativa mais flexível à função de acesso
	  <fncref targ="$fevd"/> para a obtenção da matriz de decomposição
	  da variância do erro de previsão (FEVD) que pode ser obtida após
	  a estimação de um VAR ou VECM. Quando utilizada sem o argumento
	  final, <argname>sys</argname>, está disponível apenas imediatamente
	  após a estimação de um VAR ou VECM. Alternativamente, as informações
	  de uma VAR ou VECM podem ser armazenadas em um pacote via função
	  <fncref targ="$system"/> que, por sua vez, pode ser utilizado
	  como o último argumento da função <lit>fevd</lit>.
	</para>
	<para>
	  Os argumentos <argname>target</argname> e <argname>shock</argname>
	  são índices das variáveis endógenas no sistema, com
	  0 indicando <quote>todas</quote>. Os seguintes exemplos
	  ilustram sua utilização. No primeiro deles a matriz
	  <lit>fe1</lit> armazena as proporções da variância
	  do erro de previsão para <lit>y1</lit> causadas por
	  <lit>y1</lit>, <lit>y2</lit> e <lit>y3</lit> (as linhas
	  somam 1). No segundo, <lit>fe2</lit> armazena as
	  contribuições de <lit>y2</lit> para a variância do erro
	  de previsão de todas as três variáveis (logo as linhas
	  não somam 1). No terceiro caso o valor retornado é um
	  vetor coluna contendo a <quote>própria parcela</quote>
	  da variância do erro de previsão de <lit>y1</lit>.
	</para>
	<code>
	  var 4 y1 y2 y3
	  bundle vb = $system
	  matrix fe1 = fevd(1, 0, vb)
	  matrix fe2 = fevd(0, 2, vb)
	  matrix fe3 = fevd(1, 1, vb)
	</code>
	<para>
	  O número de períodos (linhas) ao longo dos quais a
	  decomposição é traçada é determinado automaticamente
	  com base na frequência dos dados, mas isso pode ser
	  ajustado via comando <cmdref targ="set"/>, como por
	  exemplo <lit>set horizon 10</lit>.
	</para>
	<para>
	  <seelist><fncref targ="irf"/></seelist>
	</para>
      </description>
    </function>

    <function name="fft" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula a transformada de Fourier real discreta. Se a matriz de
	  entrada <argname>X</argname> tiver <math>n</math> colunas, a saída
	  terá 2<math>n</math> colunas, onde as partes reais são armazenadas
	  nas colunas ímpares e as complexas nas pares.
	</para>
	<para>
	  Quando seja necessário calcular a transformada de Fourier em vários
	  vetores com o mesmo número de elementos, é mais eficiente, do ponto
	  de vista numérico, agrupar esses vetores em uma única matriz ao invés
	  de aplicar a função <lit>fft</lit> em cada vetor de forma separada.
	  <seelist>
            <fncref targ="ffti"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ffti" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula a inversa da transformada de Fourier real discreta. Assume-se
	  que <argname>X</argname> contém <math>n</math> colunas complexas, com
	  a parte real nas colunas ímpares e a parte real nas pares. Assim, o
	  número total de colunas deverá ser 2<math>n</math>.
	  Uma matriz com <math>n</math> colunas é retornada.
	  returned.
	</para>
	<para>
	  Quando seja necessário calcular a inversa da transformada de Fourier em
	  vários vetores com o mesmo número de elementos, é mais eficiente, do ponto
	  de vista numérico, agrupar esses vetores em uma única matriz ao invés de
	  aplicar a função <lit>fft</lit> em cada vetor de forma separada.
	  <seelist>
            <fncref targ="fft"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="filter" section="filters" output="seebelow">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
	<fnarg optional="true" type="scalar-or-vec">a</fnarg>
	<fnarg optional="true" type="scalar-or-vec">b</fnarg>
	<fnarg optional="true" type="scalar">y0</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula uma filtragem semelhante ao ARMA do argumento
	  <argname>x</argname>. A transformação pode ser escrita como
	</para>
	<para context="tex">
	  \[ y_t = \sum_{i=0}^q a_i x_{t-i} + \sum_{i=1}^p b_i y_{t-i} \]
	</para>
	<para context="notex">
	  <math>y</math><sub>t</sub> =
	  <math>a</math><sub>0</sub> <math>x</math><sub>t</sub> +
	  <math>a</math><sub>1</sub> <math>x</math><sub>t-1</sub> +
	  ...
	  <math>a</math><sub>q</sub> <math>x</math><sub>t-q</sub> +
	  <math>b</math><sub>1</sub> <math>y</math><sub>t-1</sub> +
	  ...
	  <math>b</math><sub>p</sub><math>y</math><sub>t-p</sub>
	</para>
	<para>
	  Se o argumento <argname>x</argname> for uma série, o resultado
	  será também uma série. Caso contrário, se <argname>x</argname>
	  for uma matriz com <math>T</math> linhas e <math>k</math>
	  colunas, o resultado será uma matriz com o mesmo tamanho e com
	  a filtragem sendo realizada coluna por coluna.
	</para>
	<para>
	  Os argumentos <argname>a</argname> e <argname>b</argname>
	  são opcionais. Eles podem ser escalares, vetores ou a
	  palavra-chave <lit>null</lit>.
	</para>
	<para>
	  Se <argname>a</argname> for um escalar, isto é usado como
	  <math>a</math><sub>0</sub> e implica em <math>q=0</math>. Se
	  ele for um vetor com <math>q+1</math> elementos, eles contêm
	  os coeficientes de <math>a</math><sub>0</sub> a
	  <math>a</math><sub>q</sub>. Se <argname>a</argname> for
	  <lit>null</lit> ou for omitido, isso é equivalente a definir
	  <math>a</math><sub>0</sub> <math>=1</math> e
	  <math>q=0</math>.
	</para>
	<para>
	  Se <argname>b</argname> for um escalar, isto é usado como
	  <math>b</math><sub>1</sub> e implica em <math>p=1</math>. Se
	  ele for um vetor com <math>p</math> elementos, eles contêm
	  os coeficientes de <math>b</math><sub>1</sub> a
	  <math>b</math><sub>p</sub>. Se <argname>b</argname> for
	  <lit>null</lit> ou for omitido, isso é equivalente a definir
	  <math>B(L)=1</math>.
	</para>
	<para>
	  O argumento escalar opcional <argname>y0</argname> for tomado
	  para representa todos os valores de <math>y</math> anteriores
	  ao início da amostra (usado apenas quando <math>p>0</math>).
	  Se for omitido, subentende-se que é igual a 0. Assume-se que
	  valores pré-amostrais de <argname>x</argname> são sempre 0.
	</para>
	<para>
	  <seelist>
            <fncref targ="bkfilt"/>
            <fncref targ="bwfilt"/>
            <fncref targ="fracdiff"/>
            <fncref targ="hpfilt"/>
            <fncref targ="movavg"/>
            <fncref targ="varsimul"/>
	  </seelist>
	</para>
	<para>
	  Exemplo:
	</para>
	<code>
	  nulldata 5
	  y = filter(index, 0.5, -0.9, 1)
	  print index y --byobs
	  x = seq(1,5)' ~ (1 | zeros(4,1))
	  w = filter(x, 0.5, -0.9, 1)
	  print x w
	</code>
	<para>
	  produz
	</para>
	<code>
          index            y

          1            1     -0.40000
          2            2      1.36000
          3            3      0.27600
          4            4      1.75160
          5            5      0.92356

          x (5 x 2)

          1   1
          2   0
          3   0
          4   0
          5   0

          w (5 x 2)

          -0.40000     -0.40000
          1.3600      0.36000
          0.27600     -0.32400
          1.7516      0.29160
          0.92356     -0.26244
	</code>
      </description>
    </function>

    <function name="firstobs" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o número da primeira observação não ausente da
	  série <argname>y</argname>. Note que se alguma forma de
	  subamostragem estiver sendo utilizada o valor retornado
	  poderá ser menor que o valor retornado pela função
	  <fncref targ="$t1"/>.
	  <seelist>
            <fncref targ="lastobs"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="fixname" section="strings" output="string">
      <fnargs>
	<fnarg type="string">rawname</fnarg>
	<fnarg type="bool" optional="true">underscore</fnarg>
      </fnargs>
      <description>
	<para>
	  Tem como intuito principal a utilização em conjunto com o comando
	  <cmdref targ="join"/>. Retorna o resultado da conversão de
	  <argname>rawname</argname> em um identificador válido do Gretl,
	  que deve ser iniciado por uma letra, conter apenas letras ASCII,
	  dígitos e traço inferior (<quote>underscore</quote>), e não deve
	  ter mais que 31 caracteres. As regras utilizadas na conversão são:
	</para>
	<para>
	  1. Remover quaisquer caracteres que não sejam letras no início do
	  nome.
	</para>
	<para>
	  2. Até o limite de 31 caracteres não ter sido ultrapassado ou a
	  entrada tiver sido exaurida: transcreve os caracteres <quote>legais
	  </quote>, omite os caracteres <quote>ilegais</quote>, com exceção
	  dos espaços, e substitui os espaços por traços inferiores. Se o
	  caractere anterior for um traço inferior o espaço será omitido.
	</para>
	<para>
	  Se você estiver seguro de que a entrada não é muito extensa (e, dessa
	  forma, não está sujeita a truncagem), você pode querer que um ou mais
	  dos caracteres ilegais sejam substituídos por um traço inferior ao
	  invés de simplesmente deletá-los. Isto pode produzir um identificador
	  mais legível. Para que isso ocorra, forneça um valor diferente de 0
	  para o segundo argumento (que é opcional). Vale salientar que esse
	  procedimento não é aconselhável quando o comando <cmdref targ="join"/>
	  for utilizado, uma vez que os nomes automaticamente <quote>corrigidos
	  </quote> não utilizarão o traço inferior.
	</para>
      </description>
    </function>

    <function name="floor" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Consiste na função piso. Retorna o maior inteiro menor que ou
	  igual <argname>x</argname>. Note que <fncref targ="int"/> e
	  <lit>floor</lit> possuem efeitos distintos em argumentos negativos:
	  <lit>int(-3.5)</lit> gera &minus;3, enquanto
	  <lit>floor(-3.5)</lit> gera &minus;4.
	</para>
      </description>
    </function>

    <function name="fracdiff" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="scalar">d</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Retorna a diferença fracionária de ordem <argname>d</argname>
	  para a series <argname>y</argname>.
	</para>
	<para context="tex">
          \[
          \Delta^d y_t = y_t - \sum_{i=1}^{\infty} \psi_i y_{t-i}
          \]
	  onde
          \[\psi_i = \frac{\Gamma(i-d)}{\Gamma(-d) \Gamma(i+1)}\]
	</para>
	<para>
	  Note que teoricamente a diferenciação fracionária é um filtro
	  infinitamente longo. Na prática, valores antes da amostra de
	  <math>y</math><sub>t</sub> são assumidos com sendo iguais a zero.
	</para>
	<para>
	  É possível utilizar valores de <argname>d</argname> negativos.
	  Nesse caso é realizada a integração fracionária.
	</para>
      </description>
    </function>

    <function name="gammafun" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a função gama de <argname>x</argname>.
	</para>
      </description>
    </function>

    <function name="genseries" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="string">varname</fnarg>
	<fnarg type="series">rhs</fnarg>
      </fnargs>
      <description>
	<para>
	  Permite que sejam geradas séries cujos nomes não são conhecidos a
	  priori e/ou que sejam criadas séries e adicionadas a uma lista
	  utilizando apenas uma única operação.
	</para>
	<para>
	  O primeiro argumento fornece o nome da série a ser criada (ou
	  modificada) e pode ser um texto literal, uma variável de texto
	  (string), ou uma expressão cujo resultado seja
	  uma variável de texto. O segundo argumento, <argname>rhs</argname>
	  (abreviação em inglês de <quote>lado direito</quote>), define
	  a fonte da série: isto pode ser o nome de uma série existente
	  ou uma expressão cujo resultado seja uma série, da forma que
	  aparece do lado direito do sinal de igualdade quando se definem
	  séries da forma usual.
	</para>
	<para>
	  O valor de retorno dessa função é o número ID das séries no conjunto
	  de dados, um valor que pode ser utilizado para incluir as séries em
	  uma lista (ou &minus;1 caso a execução da função falhe).
	</para>
	<para>
	  Por exemplo, suponha que se queira adicionar <math>n</math> séries
	  aleatórias com distribuição normal ao conjunto de dados e
	  colocá-las em uma lista. O código a seguir fará isso:
	</para>
	<code>
	  list Normals = null
	  loop i=1..n --quiet
	      Normals += genseries(sprintf("norm%d", i), normal())
	  endloop
	</code>
	<para>
	  Ao término da execução a lista <lit>Normals</lit> irá conter as
	  séries <lit>norm1</lit>, <lit>norm2</lit> e assim sucessivamente.
	</para>
      </description>
    </function>

    <function name="getenv" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Se uma variável de ambiente de nome <argname>s</argname>
	  estiver definida a função retorna uma variável com o texto
	  dessa variável, caso contrário, retorna um texto vazio.
	  Veja também <fncref targ="ngetenv"/>.
	</para>
      </description>
    </function>

    <function name="getinfo" section="data-utils" output="bundle">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna, na forma de um pacote (bundle) informações
	  sobre a série especificada, o que pode ser feito por meio de seu nome ou
	  de seu número ID. O pacote retornado contém os atributos que podem ser
	  definidos via comando <cmdref targ="setinfo"/>.
	  Ele também contém informações relevantes adicionais das séries que tenham
	  sido criadas por meio de transformações nos dados primários (defasagens,
	  logs, etc.): isso inclui o nome do comando do Gretl para a transformação
	  sob código <quote>transform</quote> e o nome da série primária associada
	  sob o código <quote>parent</quote>. Para séries defasadas, o número
	  específico de defasagens pode ser encontrado sob o código
	  <quote>lag</quote>.
	</para>
	<para>
	  Exemplo de utilização:
	</para>
	<code>
	  open data9-7
	  lags QNC
	  bundle b = getinfo(QNC_2)
	  print b
	</code>
	<para>
	  Ao executar o código acima tem-se:
	</para>
	<code>
	  has_string_table = 0
	  lag = 2
	  parent = QNC
	  name = QNC_2
	  graph_name =
	  coded = 0
	  discrete = 0
	  transform = lags
	  description = = QNC(t - 2)
	</code>
	<para>
	  Para verificar se a série 5 no conjunto de dados é um termo defasado
	  pode-se proceder da seguinte forma:
	</para>
	<code>
	  if getinfo(5).lag != 0
	     printf "a série 5 é uma defasagem de %s\n", getinfo(5).parent
	  endif
	</code>
	<para>
	  Deve-se ter em mente que a notação ponto (.) para acessar os membros do pacote
	  pode ser utilizada mesmo este seja <quote>anônimo</quote> (ou seja,
	  armazenado sem seu próprio nome).
	</para>
      </description>
    </function>

    <function name="getkeys" section="data-utils" output="strings">
      <fnargs>
    <fnarg type="bundle">b</fnarg>
      </fnargs>
      <description>
    <para>
      Retorna um vetor de textos contendo os códigos que identificam os
      conteúdos de <argname>b</argname>. Se o pacote (bundle)
      estiver vazio é retornado um vetor também vazio.
    </para>
      </description>
    </function>

    <function name="getline" section="strings" output="scalar">
      <fnargs>
	<fnarg type="string">source</fnarg>
	<fnarg type="string">target</fnarg>
      </fnargs>
      <description>
	<para>
	  Essa função lê sucessivamente as linhas de <argname>source</argname>, que
	  deve ser uma variável de texto (string). A cada chamada uma
	  linha do texto é escrita em <argname>target</argname> (que também deve ser
	  uma variável de texto) com o caractere de nova linha removido. O valor
	  retornado é 1, se existir algo a ser lido (incluindo-se linhas em branco),
	  ou 0, se todas as linhas de <argname>source</argname> tiverem sido lidas.
	</para>
	<para>
	  A seguir é apresentado um exemplo onde o conteúdo de um arquivo de texto é
	  dividido em linhas:
	</para>
	<code>
	  string s = readfile("data.txt")
	  string line
	  scalar i = 1
	  loop while getline(s, line)
	      printf "line %d = '%s'\n", i++, line
	  endloop
	</code>
	<para>
	  Neste exemplo pode-se ter a certeza de que o texto foi exaurido quando o
	  loop terminar. Se não for desejado exaurir todas as linhas do texto pode-se
	  chamar a função <lit>getline</lit>, sendo que sucessivas chamadas
	  substituirão o conteúdo de <argname>target</argname> pela nova linha lida.
	  Para reiniciar a leitura a partir da primeira linha de <argname>source
	  </argname> basta utilizar <lit>null</lit> no argumento <argname>target
	  </argname> (ou apenas deixá-lo em branco). Exemplos:
	</para>
	<code>
	  getline(s, line) # recupera uma única linha
	  getline(s, null) # reinicia a leitura
	</code>
	<para>
	  Note que apesar de a posição de leitura avançar em cada chamada de <lit>
	  getline</lit>, o argumento <argname>source</argname> não é modificado por
	  essa função, apenas <argname>target</argname> é alterado.
	</para>
      </description>
    </function>

    <function name="ghk" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">C</fnarg>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix">B</fnarg>
	<fnarg type="matrix">U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;dP</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula a aproximação GHK (Geweke, Hajivassiliou, Keane) para a
	  função de distribuição normal multivariada. Veja, por exemplo, <cite
	  key="geweke91">Geweke (1991)</cite>. O valor retornado é um vetor de
	  probabilidades de ordem <by r="n" c="1"/>.
	</para>
	<para>
	  O argumento <argname>C</argname> (<by r="m" c="m"/>) deve fornecer o
	  fator de Cholesky (triangular inferior) da matriz de covariância de
	  <math>m</math> variáveis normais. Ambos os argumentos <argname>A</argname>
	  e <argname>B</argname> devem ser de ordem <by r="n" c="m"/>, fornecendo,
	  respectivamente, os limites inferior e superior aplicados às variáveis
	  em cada uma das <math>n</math> observações. Quando as variáveis não
	  possuírem limites é necessário que tal característica seja indicada
	  através da constante <fncref targ="$huge"/> ou de sua negativa.
	</para>
	<para>
	  A matriz <argname>U</argname> deve ter ordem <by r="m" c="r"/>, sendo
	  <math>r</math> o número de elementos pseudo-aleatórios extraídos da
	  distribuição uniforme. Funções convenientes para a criação de <argname>
	  U</argname> são <fncref targ="muniform"/> e <fncref targ="halton"/>.
	</para>
	<para>
	  A seguir encontra-se um caso relativamente simples onde as
	  probabilidades multivariadas podem ser calculada de forma
	  analítica. As séries <lit>P</lit> e <lit>Q</lit> devem ser
	  numericamente muito similares entre si, sendo <lit>P</lit>
	  a probabilidade <quote>verdadeira</quote> e <lit>Q</lit>
	  sua aproximação GHK:
	</para>
	<code>
	  nulldata 20
	  series inf1 = -2*uniform()
	  series sup1 = 2*uniform()
	  series inf2 = -2*uniform()
	  series sup2 = 2*uniform()

	  scalar rho = 0.25
	  matrix V = {1, rho; rho, 1}

	  series P = cdf(D, rho, inf1, inf2) - cdf(D, rho, sup1, inf2) \
	  - cdf(D, rho, inf1, sup2) + cdf(D, rho, sup1, sup2)

	  C = cholesky(V)
	  U = halton(2, 100)

	  series Q = ghk(C, {inf1, inf2}, {sup1, sup2}, U)
	</code>
	<para>
	  O argumento opcional <argname>dP</argname> pode ser usado para
	  recuperar a matriz <by r="n" c="k"/> de derivadas das probabilidades,
	  onde <math>k</math> é igual a 2<math>m</math> + <math>m</math>
	  (<math>m</math> + 1)/2. As primeiras <math>m</math> colunas
	  contêm as derivadas em relação aos limites inferiores, as próximas
	  <math>m</math> as derivadas em relação aos limites superiores e as
	  colunas restantes as derivadas em relação aos elementos únicos da
	  matriz <math>C</math> na ordem
	  <quote>vech</quote>.
	</para>
      </description>
    </function>

    <function name="gini" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o índice de desigualdade de Gini para a série ou o
      vetor (não negativos). Um valor de Gini igual a zero indica
      igualdade perfeita. O valor máximo de Gini para uma série com
      <math>n</math> elementos é (<math>n</math> &minus; 1)/<math>n</math>,
      ocorrendo quando apenas um membro possui um valor positivo.
      Um Gini igual a 1,0 é, dessa forma, o limite aproximado por
      uma grande série com desigualdade máxima <argname>y</argname>.
	</para>
      </description>
    </function>

    <function name="ginv" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna <math>A</math><sup>+</sup>, a Moore&ndash;Penrose
	  ou inversa generalizada de <argname>A</argname>, calculada via
	  decomposição em valores singulares.
	</para>
	<para context="notex">
	  Essa matriz possui as seguintes propriedades: <math>A</math>
	  <math>A</math><sup>+</sup> <math>A</math> = <math>A</math>
	  and <math>A</math><sup>+</sup> <math>A</math>
	  <math>A</math><sup>+</sup> = <math>A</math><sup>+</sup>.
	  Além disso, os produtos <math>A</math>
	  <math>A</math><sup>+</sup> e <math>A</math><sup>+</sup>
	  <math>A</math> são simétricos por construção.
	</para>
	<para context="tex">
	  Essa matriz possui as seguintes propriedades:
	  \begin{eqnarray*}
	  A A^+ A &amp; = &amp; A \\
	  A^+ A A^+ &amp; = &amp; A^+
	  \end{eqnarray*}
	  Além disso, os produtos $A^+ A$ e $A A^+$ são
	  simétricos por construção.
	</para>
	<para>
	  <seelist>
            <fncref targ="inv"/>
            <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="GSSmax" section="numerical" output="scalar">
      <fnargs>
    <fnarg type="matrixref">&amp;b</fnarg>
    <fnarg type="fncall">f</fnarg>
    <fnarg optional="true" type="scalar">toler</fnarg>
      </fnargs>
      <description>
    <para>
      Maximização de unidimensional via método Golden Section Search (GSS).
      A matriz <argname>b</argname> deve ser um vetor de ordem 3. Na
      entrada o primeiro elemento é ignorado enquanto que o segundo e o
      terceiro elementos determinam os limites inferior e superior da
      busca. O argumento <argname>fncall</argname> deve especificar a
      chamada a uma função que retorna o valor da variável a ser maximizada.
      O elemento 1 de <argname>b</argname>, que irá armazenar o valor
      corrente do parâmetro ajustável quando a função for chamada, deve ser
      determinado como seu primeiro argumento. Quaisquer argumentos
      requeridos podem então ser incluídos em seguida. A função em questão
      de ser unimodal (ou seja, não deve possuir máximos locais, apenas o
      máximo global) ao longo da amostra estipulada, caso contrário não se
      pode garantir que o GSS irá encontrar o máximo.
    </para>
    <para>
      Ao ser executada com sucesso <lit>GSSmax</lit> retorna
      o valor ótimo da variável a ser maximizada, enquanto
      <argname>b</argname> armazena o valor do parâmetro ótimo
      juntamente dos limites de seu intervalo.
    </para>
    <para>
      O terceiro argumento, que é opcional, pode ser utilizado para
      ajustar a convergência, isto é, a largura máxima aceitável
      do intervalo final do parâmetro. Se esse argumento não for
      fornecido, será utilizado o valor 0,0001.
    </para>
    <para>
      Se o objetivo é de fato a minimização, a chamada à função
      deve retornar o critério com o sinal negativo.
      Alternativamente, ao invés de se utilizar <lit>GSSmax</lit>
      pode-se utilizar a função <lit>GSSmin</lit>.
    </para>
    <para>
      Exemplo de utilização:
    </para>
    <code>
      function scalar trigfunc (scalar theta)
          return 4 * sin(theta) * (1 + cos(theta))
      end function

      matrix m = {0, 0, $pi/2}
      eval GSSmax(&amp;m, trigfunc(m[1]))
      printf "\n%10.7f", m
    </code>
      </description>
    </function>

    <function name="GSSmin" section="numerical" output="scalar">
      <description>
	<para>
	  É uma forma alternativa da função <fncref targ="GSSmax"/>. Se invocada
	  com este nome a função comporta-se como minimizadora.
	</para>
      </description>
    </function>

    <function name="halton" section="stats" output="matrix">
      <fnargs>
	<fnarg type="int">m</fnarg>
	<fnarg type="int">r</fnarg>
	<fnarg optional="true" type="int">offset</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma matriz <by r="m" c="r"/> contendo
	  <math>m</math> sequências de Halton de comprimento <math>r</math>.
	  O <math>m</math> é limitado a um máximo de 40. As sequências são
	  construídas utilizando os primeiros <math>m</math> primos. Por
	  padrão os primeiros 10 elementos de cada sequência são
	  descartados, mas isso pode ser ajustado via argumento
	  opcional <argname>offset</argname>, que deve ser um número inteiro
	  não negativo. Maiores detalhes podem ser encontrados em
	  <cite key="halton64">Halton e Smith (1964)</cite>.
	</para>
      </description>
    </function>

    <function name="hdprod" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">Y</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula o produto direto horizontal. Os dois argumentos
	  devem ter o mesmo número de linhas, <math>r</math>. O valor
	  retornado é uma matriz com <math>r</math> linhas, onde a
	  <math>i</math>-ésima linha corresponde ao produto de
	  Kronecker das linhas correspondentes de <argname>X</argname>
	  e <argname>Y</argname>.
	</para>
	<para context="tex">
	  Em outras palavras, se $X$ é uma matriz $r \times k$, $Y$ é uma
	  matriz $r \times m$ e $Z$ é a matriz resultante do
	  produto direto horizontal de $X$ vezes $Y$, logo $Z$ terá
	  $r$ linhas e $k\cdot m$ colunas. Além disso,
	  \[
	  Z_{in} = X_{ij} Y_{il}
	  \]
	  onde $n = (j-1) m + l$.
	</para>
	<para>
	  Esta operação é chamada de <quote>produto horizontal
	  direto</quote> em conformidade com sua implementação na
	  linguagem de programação GAUSS. Sua equivalente na álgebra
	  linear padrão seria chamada de produto linha a linha de
	  Khatri-Rao.
	</para>
	<para>
	  Exemplo: o código
	</para>
	<code>
	  A = {1,2,3; 4,5,6}
	  B = {0,1; -1,1}
	  C = hdprod(A, B)
	</code>
	<para>
	  produz a seguinte matriz:
	</para>
	<code>
          0    1    0    2    0    3
         -4    4   -5    5   -6    6
	</code>
      </description>
    </function>

    <function name="hfdiff" section="midas" output="list">
      <fnargs>
	<fnarg type="list">hfvars</fnarg>
	<fnarg type="scalar">multiplier</fnarg>
      </fnargs>
      <description>
	<para>
	  Dada uma <cmdref targ="MIDAS_list"/>, produz uma lista com o mesmo
	  tamanho contendo as primeiras diferenças de alta frequência. O
	  segundo argumento é opcional e tem como valor padrão 1: ele pode
	  ser utilizado para multiplicar as diferenças por alguma constante.
	</para>
      </description>
    </function>

    <function name="hfldiff" section="midas" output="list">
      <fnargs>
	<fnarg type="list">hfvars</fnarg>
	<fnarg type="scalar">multiplier</fnarg>
      </fnargs>
      <description>
	<para>
	  Dada uma <cmdref targ="MIDAS_list"/>, produz uma lista com o mesmo
	  tamanho contendo as diferenças logarítmicas de alta frequência. O
	  segundo argumento é opcional e tem como valor padrão 1: ele pode
	  ser utilizado para multiplicar as diferenças por alguma constante.
	  Um exemplo da utilização desse argumento é utilizar o valor 100 para
	  obter as variações percentuais (aproximadas).
	</para>
      </description>
    </function>

    <function name="hflags" section="midas" output="list">
      <fnargs>
	<fnarg type="int">minlag</fnarg>
	<fnarg type="int">maxlag</fnarg>
	<fnarg type="list">hfvars</fnarg>
      </fnargs>
      <description>
	<para>
	  Dada uma <cmdref targ="MIDAS_list"/>, <repl>hfvars</repl>, produz uma lista
	  contendo as defasagens de auta frequência de <repl>minlag</repl> a <repl>
	  maxlag</repl>. Deve-se utilizar valores positivos para defasagens (<math>
	  t</math> - 1) e negativos para adiantamentos (<math>t</math> + 1). Por
	  exemplo, se <repl>minlag</repl> for &minus;3 e <repl>maxlag</repl> for 5
	  então a lista retornada irá conter 9 séries: 3 adiantamentos, o valor atual
	  e 5 defasagens.
	</para>
	<para>
	  Note que a defasagem de alta frequência 0 corresponde ao primeiro
	  período de alta frequência dentro de um período de baixa frequência,
	  por exemplo, o primeiro mês de um trimestre ou o primeiro dia de um
	  mês.
	</para>
      </description>
    </function>

    <function name="hflist" section="midas" output="list">
      <fnargs>
	<fnarg type="vector">x</fnarg>
	<fnarg type="int">m</fnarg>
	<fnarg type="string">prefix</fnarg>
      </fnargs>
      <description>
	  <para>
	  Produz a partir de um vetor <repl>x</repl> uma lista MIDAS
	  (<cmdref targ="MIDAS_list"/>) de <repl>m</repl> séries, onde
	  <repl>m</repl> é a razão entre a frequência das observações
	  para a variável em <repl>x</repl> em relação a frequência base
	  do conjunto de dados corrente. O valor de <repl>m</repl> deve
	  ser ao menos 3 e o comprimento de <repl>x</repl> deve ser
	  <repl>m</repl> vezes o comprimento da amostra selecionada corrente.
    </para>
    <para>
	  Os nomes das séries na lista retornada são definidos a partir de um
	  dado prefixo, dado pelo argumento <repl>prefix</repl> (este deve ser
	  um texto ASCII com 24 ou menos caracteres e que seja um identificador
	  válido para o Gretl) mais 1 ou mais prefixos representando o subperíodo
	  da observação. Um erro será apresentado se algum desses nomes seja
	  idêntico a nomes de objetos já existentes.
    </para>
      </description>
    </function>

    <function name="hpfilt" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="scalar" optional="true">lambda</fnarg>
    <fnarg type="bool" optional="true">one-sided</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o componente cíclico do filtro de Hodrick&ndash;Prescott
	  aplicado à série <argname>y</argname>. Se o parâmetro de suavização
	  <argname>lambda</argname> não for fornecido o Gretl usará valores
	  padrão com base na periodicidade dos dados. O parâmetro será igual
	  a 100 vezes o quadrado da periodicidade (100 para dados anuais, 1600
	  para dados trimestrais, 14400 para dados mensais, etc.).
	</para>
	<para>
	  Por padrão o filtro é a versão bilateral, <quote>two-sided</quote>,
	  mas se o terceiro argumento (opcional) for um valor diferente de zero
	  é computada a versão unilateral, <quote>one-sided</quote>, (de forma
      não prospectiva) é computada na forma proposta por
      <cite key="stock-watson1999">Stock and Watson (1999)</cite>.
	</para>
	<para>
	  O uso mais comum do filtro HP é a retirada de tendência de séries, mas
	  se o interesse for pela tendência em si, basta utilizar a seguinte
	  expressão:
	</para>
	<code>
	  series hptrend = y - hfilt(y)
	</code>
	<para>
	  <seelist>
            <fncref targ="bkfilt"/>
            <fncref targ="bwfilt"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="I" section="matbuild" output="smatrix">
      <fnargs>
	<fnarg type="int">n</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma matriz identidade com <argname>n</argname> linhas e
	  colunas.
	</para>
      </description>
    </function>

    <function name="imaxc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna um vetor com os números das linhas onde as colunas de
	  <argname>X</argname> atingem seus valores máximos.
	</para>
	<para>
	  <seelist>
            <fncref targ="imaxr"/>
            <fncref targ="iminc"/>
            <fncref targ="maxc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="imaxr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna um vetor com os números das colunas onde as linhas de
	  <argname>X</argname> atingem seus valores máximos.
	</para>
	<para>
	  <seelist>
            <fncref targ="imaxc"/>
            <fncref targ="iminr"/>
            <fncref targ="maxr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="imhof" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="scalar">x</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Calcula Prob(<math>u'Au</math> &lt; <math>x</math>) para uma forma
	  quadrática em variáveis normais padrão, <math>u</math>, utilizando o
	  procedimento desenvolvido por <cite key="imhof61">Imhof (1961)</cite>.
	</para>
	<para context="tex">
	  Computes ${\rm Prob}(u'Au &lt; x)$ para uma forma quadrática em variáveis
	  normais padrão, $u$, utilizando o procedimento desenvolvido por
	  <cite key="imhof61">Imhof (1961)</cite>.
	</para>
	<para>
	  Se o primeiro argumento, <argname>M</argname>, for uma matriz quadrada ela
	  será utilizada para especificar <math>A</math>, caso contrário, se for
	  um vetor coluna, será utilizada como sendo os autovalores pré-calculados
	  de <math>A</math>, caso contrário um erro será apresentado.
	</para>
	<para>
	  <seelist>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="iminc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna um vetor com os números das linhas onde as colunas de
	  <argname>X</argname> atingem seus valores mínimos.
	</para>
	<para>
	  <seelist>
            <fncref targ="iminr"/>
            <fncref targ="imaxc"/>
            <fncref targ="minc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="iminr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna um vetor com os números das colunas onde as linhas de
	  <argname>X</argname> atingem seus valores mínimos.
	</para>
	<para>
	  <seelist>
            <fncref targ="iminc"/>
            <fncref targ="imaxr"/>
            <fncref targ="minr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="inbundle" section="data-utils" output="int">
      <fnargs>
	<fnarg type="bundle">b</fnarg>
	<fnarg type="string">key</fnarg>
      </fnargs>
      <description>
	<para>
	  Verifica se um pacote (bundle) <argname>b</argname> contém um item com
	  o nome <argname>key</argname>. O valor retornado é um código (na forma
	  de um número inteiro) para o tipo de item: 0 caso não seja encontrado,
	  1 para escalar, 2 para série,3 para matriz, 4 para variável de texto, 5
	  para pacote (bundle) e 6 para arranjo (array). A função <fncref
	  targ="typestr"/> pode ser utilizada para se obter o nome do tipo do item
	  na forma de variável de texto com base em seu código.
	</para>
      </description>
    </function>

    <function name="infnorm" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Retorna a norma infinito de <argname>X</argname>, isto é,
	  o máximo ao longo das linhas de <argname>X</argname> da
	  soma dos valores absolutos dos elementos da linha.
	</para>
	<para context="tex">
	  Retorna a norma-$\infty$ da matriz <argname>X</argname> de
	  ordem $r\times c$ matrix, ou seja:
          \[\| X \|_{\infty} = \max_i \sum_{j=1}^c |X_{ij}|\]
	</para>
	<para>
	  <seelist>
            <fncref targ="onenorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="inlist" section="data-utils" output="int">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a posição de <argname>y</argname> na
	  lista <argname>L</argname>, ou 0 se <argname>y</argname>
	  não estiver presente em <argname>L</argname>.
	</para>
	<para>
	  O segundo argumento pode ser dado tanto como o nome da série quanto
	  como o número ID da série. Se é sabido que uma série com dado nome
	  (como por exemplo <lit>foo</lit>) existe, então é possível chamar
	  essa função da seguinte forma:
	</para>
    <code>
	  pos = inlist(L, foo)
    </code>
    <para>
	  O que a expressão acima está solicitando é: <quote>Informe a posição da
	  série <lit>foo</lit> na lista <lit>L</lit> (sendo 0 se ela não estiver
	  incluída na lista L)</quote>. Entretanto, se não houver certeza se
	  a série com dado nome existe, deve-se inserir o nome entre aspas. Isso
	  é feito da seguinte forma:
	</para>
	<code>
	  pos = inlist(L, "foo")
    </code>
    <para>
	  Neste caso o que está sendo solicitado é: <quote>Se existir uma série
	  chamada <lit>foo</lit> na lista <lit>L</lit>, me informe sua posição ou
	  0 caso ela não exista.</quote>
	</para>
  </description>
    </function>

    <function name="instring" section="strings" output="int">
      <fnargs>
    <fnarg type="string">s1</fnarg>
    <fnarg type="string">s2</fnarg>
      </fnargs>
      <description>
    <para>
      Função booleana relacionada à <fncref targ="strstr"/>.
      Retorna 1 se <argname>s1</argname> contiver
      <argname>s2</argname>, 0 caso contrário. Assim, a
      expressão condicional
    </para>
    <code>
      if instring("cattle", "cat")
    </code>
    <para>
      é logicamente equivalente a, mas mais eficiente que,
    </para>
    <code>
      if strlen(strstr("cattle", "cat")) > 0
    </code>
      </description>
    </function>

    <function name="int" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a parte inteira <argname>x</argname>, truncando a parte
	  fracional. Note que <lit>int</lit> e <fncref targ="floor"/>
	  possuem efeitos distintos em argumentos negativos:
	  <lit>int(-3.5)</lit> gera &minus;3, enquanto
	  <lit>floor(-3.5)</lit> gera &minus;4.
	  <seelist>
            <fncref targ="ceil"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="inv" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a inversa de <argname>A</argname>. Se
	  <argname>A</argname> for singular ou não quadrada, uma mensagem
	  de erro é produzida e nada é retornado. Note que o Gretl confere
	  automaticamente a estrutura de <argname>A</argname> e utiliza o
	  procedimento numérico mais eficiente para realizar a inversão.
	</para>
	<para>
	  Os tipos de matriz que o Gretl confere são: identidade, diagonal,
	  simétrica e positiva definida, simétrica mas não positiva definida
	  e triangular.
	</para>
	<para>
	  Observação: faz sentido utilizar essa função apenas se o intuito
	  for utilizar a inversa de <argname>A</argname> mais de uma vez.
	  Se o objetivo for apenas calcular uma expressão da forma
	  <math>A</math><sup>-1</sup><math>B</math>, será preferível
	  utilizar os operadores de <quote>divisão</quote>
	  <lit>\</lit> e <lit>/</lit>. Veja <guideref
	  targ="chap:matrices"/> para detalhes.
	</para>
	<para>
	  <seelist>
            <fncref targ="ginv"/>
            <fncref targ="invpd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="invcdf" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">p</fnarg>
      </fnargs>
      <description>
	<para>
	  Calculadora da função de distribuição acumulada inversa. Retorna
	  <math>x</math> tal que
	  <equation status="inline" ascii="P(X &le; x) = p"
		    tex="$P(X \le x) = p$"/>, onde a distribuição de
	  <math>X</math> é especificada pela letra <argname>d</argname>.
	  Entre os argumentos <argname>d</argname> e <argname>p</argname>,
	  zero ou mais argumentos adicionais são necessários para que
	  se especifique os parâmetros da distribuição. Isso é feito da
	  seguinte forma:
	</para>
	<ilist context="notex">
	  <li>
            <para>
              Normal padrão (c = z, n ou N): sem argumentos extras
            </para>
	  </li>
	  <li>
            <para>
              Gama (g ou G): forma; escala
            </para>
	  </li>
	  <li>
            <para>
              t de Student (t): graus de liberdade
            </para>
	  </li>
	  <li>
            <para>
              Qui-quadrado (c, x ou X): graus de liberdade
            </para>
	  </li>
	  <li>
            <para>
              F de Snedecor F (f ou F): graus de liberdade (num.); graus de liberdade (den.)
            </para>
	  </li>
	  <li>
            <para>
              Binomial (b ou B): probabilidade; tentativas
            </para>
	  </li>
	  <li>
            <para>
              Poisson (p ou P): média
            </para>
	  </li>
	  <li>
            <para>
              Laplace (l ou L): média; escala
            </para>
	  </li>
	  <li>
            <para>
              GED padronizada (E): forma
            </para>
	  </li>
	  <li>
	    <para>
	      Qui-quadrado não-central (ncX): graus de liberdade, parâmetro de não-centralidade
	    </para>
	  </li>
	  <li>
	    <para>
	      F não-central (ncF): graus de liberdade (num.), graus de liberdade (den.),
	      parâmetro de não-centralidade
	    </para>
	  </li>
	  <li>
	    <para>
	      t não-central (nct): graus de liberdade, parâmetro de não-centralidade
	    </para>
	  </li>
	</ilist>
	<tabular colspec="lllll">
	  \textit{Distribuição} &amp; \textsl{d} &amp;
	  \textit{Arg} 2 &amp; \textit{Arg} 3 &amp; \textit{Arg} 4 \\[4pt]
	  Normal padrão &amp; \texttt{z}, \texttt{n} or \texttt{N} &amp;
	  -- &amp; --  &amp; -- \\
	  Gama &amp; \texttt{g} ou \texttt{G} &amp;
	  forma &amp; escala  &amp; -- \\
	  $t$ de Student (central) &amp; \texttt{t} &amp;
	  graus de liberdade &amp; --  &amp; -- \\
	  Qui-quadrado &amp; \texttt{c}, \texttt{x} ou \texttt{X} &amp;
	  graus de liberdade &amp; --  &amp; -- \\
	  $F$ de Snedecor &amp; \texttt{f} ou \texttt{F} &amp;
	  g.l. (num.) &amp; g.l. (den.)  &amp; -- \\
	  Binomial &amp; \texttt{b} ou \texttt{B} &amp;
	  $p$ &amp; $n$  &amp; -- \\
	  Poisson &amp; \texttt{p} ou \texttt{P} &amp;
          $\lambda$ &amp; --  &amp; -- \\
      Laplace &amp; \texttt{l} or \texttt{L} &amp;
          média &amp; escala  &amp; -- \\
	  GED padronizada &amp; \texttt{E} &amp; forma &amp; --
	  &amp; -- \\
	  $\chi^2$ não-central &amp; \texttt{ncX} &amp;
	  g.l. &amp; não-centralidade &amp; -- \\
	  $F$ não-central &amp; \texttt{ncF} &amp;
	  g.l. (num.) &amp; g.l. (den.) &amp; não-centralidade \\
	  $t$ não-central &amp; \texttt{nct} &amp;
	  g.l. &amp; não-centralidade &amp; -- \\
	</tabular>
	<para>
	  <seelist>
            <fncref targ="cdf"/>
            <fncref targ="critical"/>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="invmills" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a razão inversa de Mills em <argname>x</argname>, isto
	  é a razão entre a densidade normal padrão e o complemento para
	  para a função de distribuição normal padrão, ambas avaliadas
	  em <argname>x</argname>.
	</para>
	<para>
	  Essa função utiliza um algoritmo dedicado que fornece maior
	  precisão quando comparado ao cálculo via <fncref targ="dnorm"/>
	  e <fncref targ="cnorm"/>, mas a diferença entre os dois
	  métodos é considerável apenas para valores muito negativos
	  de <argname>x</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="cdf"/>
            <fncref targ="cnorm"/>
            <fncref targ="dnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="invpd" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="pdmat">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a inversa da matriz simétrica positiva definida
	  <argname>A</argname>. Essa função é ligeiramente mais rápida
	  que <fncref targ="inv"/> para matrizes grandes, uma vez que
	  não é verificado se a matriz é simétrica. Por essa razão, essa
	  função deve ser utilizada com cuidado.
	</para>
	<para>
	  Observação: se o intuito for inverter uma matriz na forma
	  <math>X'X</math>, onde <math>X</math> é uma matriz grande,
	  é preferível computá-la via operador <lit>X'X</lit>
	  ao invés de utilizar a sintaxe mais geral <lit>X'*X</lit>.
	  A primeira expressão utiliza um algoritmo especializado que
	  tem a dupla vantagem de ser mais eficiente computacionalmente
	  e de garantir que o resultado seja livre, por construção,
	  dos artefatos de precisão de máquina que podem torná-la
	  numericamente não-simétrico.
	</para>
      </description>
    </function>

    <function name="irf" section="stats" output="matrix">
      <fnargs>
	<fnarg type="int">target</fnarg>
	<fnarg type="int">shock</fnarg>
	<fnarg type="pscalar" optional="true">alpha</fnarg>
	<fnarg type="bundle" optional="true">sys</fnarg>
      </fnargs>
      <description>
	<para>
	  Sem utilizar o argumento <argname>sys</argname>, opcional, essa
	  função está disponível apenas quando o último modelo estimado foi um
	  VAR ou um VECM. Alternativamente, as informações de uma VAR ou VECM
	  podem ser armazenadas em um pacote via função <fncref targ="$system"/>
	  que, por sua vez, pode ser utilizado como o último argumento.
	</para>
	<para>
	  Ela retorna uma matriz contendo as respostas estimadas da
	  variável <argname>target</argname> a um impulso (choque) de
	  1 desvio padrão na variável <argname>shock</argname>. Essas
	  variáveis são identificadas de acordo com suas posições na
	  especificação do modelo: por exemplo, se para <argname>target</argname>
	  e <argname>shock</argname> são dados os valores 1 e 3,
	  respectivamente, a matriz que será retornada fornece as
	  respostas da primeira variável no sistema a um choque na
	  terceira variável.
	</para>
	<para>
	  Se o terceiro argumento <argname>alpha</argname>, que é opcional, for
	  dado, a matriz retornada terá três colunas: a estimativa pontual das
	  respostas, seguida dos limites inferior e superior de um intervalo de
	  confiança obtido via bootstrap de 1 &minus; &agr;.
	  Onde <argname>alpha</argname> = 0.1
	  corresponde a 90 por cento de confiança. Se
	  <argname>alpha</argname> for omitido ou igualado a zero, apenas a
	  estimativa pontual será fornecida.
	</para>
	<para>
	  O número de períodos (linhas) da resposta é
	  determinado automaticamente com base na frequência
	  dos dados, mas isso pode ser ajustado via comando <cmdref
	  targ="set"/>, como por exemplo <lit>set horizon 10</lit>.
	</para>
	<para>
	  <seelist><fncref targ="fevd"/></seelist>
	</para>
      </description>
    </function>

    <function name="irr" section="math" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a Taxa Interna de Retorno para <argname>x</argname>,
	  considerado como sendo uma sequência de pagamentos (negativo)
	  e recebimentos (positivo).
	  <seelist>
            <fncref targ="npv"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="isconst" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="int" optional="true">panel-code</fnarg>
      </fnargs>
      <description>
	<para>
	  Sem o segundo argumento (opcional), retorna 1 caso <argname>y</argname>
	  tenha um valor constante ao longo da amostra selecionada (ou ao longo de
	  toda sua extensão no caso de <argname>y</argname> ser um vetor), caso
	  contrário retorna 0.
	</para>
	<para>
	  O segundo argumento somente é aceito se o conjunto de dados corrente
	  for um painel e <argname>y</argname> for uma série. Neste caso um valor
	  de <argname>panel-code</argname> igual a 0 faz a função verificar se a
	  série não varia em relação ao tempo. Um valor igual a 1 faz a função
	  verificar se a série não varia entre as unidades de corte transversal
	  (ou seja, se o valor de <argname>y</argname> é o mesmo para todos os
	  grupos).
	</para>
	<para>
	  Se <argname>y</argname> for uma série, valores ausentes são
	  ignorados durante a verificação da constância da série.
	</para>
      </description>
    </function>

    <function name="isdiscrete" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">name</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>name</argname> for um identificador para uma série
	  correntemente definida, a função retorna 1 se a série for marcada
	  como sendo discreta, caso contrário retorna 0. Se <argname>name</argname>
	  não identifica uma série a função retorna <lit>NA</lit>.
	</para>
      </description>
    </function>

    <function name="isdummy" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Se todos os valores contidos em <argname>x</argname> são iguais a 0 ou 1 (ou ausentes),
	  a função retorna o número de ocorrências do valor 1, caso contrário retorna 0.
	</para>
      </description>
    </function>

    <function name="isnan" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-matrix">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Dado um escalar como argumento, retorna 1 se <argname>x</argname> não
	  for um número, <quote>Not a Number</quote> (NaN), caso contrário 0.
	  Dada uma matriz como argumento, retorna uma matriz com a mesma dimensão
	  com elementos iguais a 1 nas posições onde o elemento correspondente da
	  matriz de entrada for NaN e 0 nas demais posições.
	</para>
      </description>
    </function>

    <function name="isoconv" section="calendar" output="scalar">
      <fnargs>
	<fnarg type="series">date</fnarg>
	<fnarg type="seriesref">&amp;year</fnarg>
	<fnarg type="seriesref">&amp;month</fnarg>
	<fnarg type="seriesref" optional="true">&amp;day</fnarg>
      </fnargs>
      <description>
	<para>
	  Dada uma série <argname>date</argname> contendo datas no formato ISO 8601
	  <quote>básico</quote> (<lit>YYYYMMDD</lit>), essa função escreve os
	  componentes ano, mês e (opcionalmente) dia em séries nomeadas pelos
	  argumentos <argname>year</argname>, <argname>month</argname> e
	  <argname>dayecond</argname>. Um exemplo, assumindo que a série
    <lit>dates</lit> contém os valores adequados de 8 dígitos, seria:
	</para>
	<code>
	  series y, m, d
	  isoconv(dates, &amp;y, &amp;m, &amp;d)
	</code>
	<para>
	  Essa função retorna 0 em caso de sucesso
	  e um valor não-nulo em caso de erro.
	</para>
      </description>
    </function>

    <function name="isodate" section="calendar" output="seebelow">
      <fnargs>
	<fnarg type="scalar-or-series">ed</fnarg>
	<fnarg type="bool" optional="true">as-string</fnarg>
      </fnargs>
      <description>
	<para>
	  O argumento <argname>ed</argname> é interpretado como um dia na
	  época corrente (que por sua vez é igual a 1 para o primeiro dia
	  de janeiro do ano 1 depois de Cristo, no calendário gregoriano
	  proléptico). O valor padrão de retorno &mdash; de mesmo tipo que
	  o de <argname>ed</argname> &mdash; é um número com 8 dígitos, ou
	  uma série composta por tais números, seguindo o padrão <lit>
	  YYYYMMDD</lit> (formato ISO 8601 <quote>básico</quote>), fornecendo
	  a data correspondente no calendário gregoriano ao dia na época.
	</para>
	<para>
	  Se <argname>ed</argname> for (apenas) um escalar e o segundo argumento
	  opcional <argname>as-string</argname> for não-nulo, o valor de retorno
	  não é numérico mas sim uma variável de texto (string)
	  no padrão <lit>YYYY-MM-DD</lit> (padrão ISO 8601
	  <quote>estendido</quote>).
	</para>
	<para>
	  Para a função inversa veja <fncref targ="epochday"/>. Veja
	  também a função <fncref targ="juldate"/>.
	</para>
      </description>
    </function>

    <function name="iwishart" section="stats" output="matrix">
      <fnargs>
	<fnarg type="symmat">S</fnarg>
	<fnarg type="int">v</fnarg>
      </fnargs>
      <description>
	<para>
	  Dado <argname>S</argname> (uma matriz de ordem <by r="p" c="p"/>
	  positiva definida), retorna um valor extraído da distribuição
	  Inversa de Wishart com <argname>v</argname> graus de liberdade.
	  A matriz retornada é também uma <by r="p" c="p"/>. O algoritmo
	  de <cite key="odell-feiveson66">Odell e Feiveson (1966)</cite>
	  é utilizado.
	</para>
      </description>
    </function>

    <function name="jsonget" section="data-utils" output="string">
      <fnargs>
	<fnarg type="string">buf</fnarg>
	<fnarg type="string">path</fnarg>
	<fnarg optional="true" type="scalarref">nread</fnarg>
      </fnargs>
      <description>
	<para>
	  O argumento <argname>buf</argname> deve ser um buffer JSON,
	  que ser obtido de alguma página na internet via
	  função <fncref targ="curl"/>, e o argumento
	  <argname>path</argname> deve ser uma especificação
	  JsonPath.
	</para>
	<para>
	  Esta função retorna uma variável de texto (string)
	  representando os dados encontrados no buffer no path especificado.
	  Dados do tipo double (ponto flutuante), int (inteiro) e string
	  (variável de texto) são suportados. No caso de doubles ou ints, sua
	  representação em forma de texto é retornada (utilizando o locale <quote>C</quote>
	  para os doubles). Se o objeto ao qual o <argname>path</argname> se
	  refere for um arranjo (array), cada um dos membros
	  será escrito em uma linha diferente na variável de texto retornada.
	</para>
	<para>
	  Por padrão, um erro será sinalizado se o <argname>path</argname> não possuir
	  uma correspondência no buffer JSON, porém esse comportamento pode ser modificado
	  se o terceiro argumento, opcional, for dado: nesse caso o argumento recupera
	  o número de correspondências e uma variável de texto vazia é retornada caso
	  nenhuma tenha sido encontrada. Por exemplo:
	</para>
	<code>
	  ngot = 0
	  ret = jsonget(jbuf, "$.some.thing", &amp;ngot)
	</code>
	<para>
	  Apesar disso, um erro ainda será sinalizado no caso de uma
	  consulta (query) mal formulada.
	</para>
	<para>
	  Para maiores detalhes sobre a sintaxe do JsonPath pode-se
	  consultar o website <url>http://goessner.net/articles/JsonPath/</url>.
	  Entretanto, deve-se notar que o back-end para o <lit>jsonget</lit>
	  é fornecido pelo <lit>json-glib</lit> que, por sua, vez não
	  suporta todos os elementos do JsonPath. Além disso, a
	  funcionalidade exata do <lit>json-glib</lit> pode diferir
	  dependendo da versão instalada no sistema. Para maiores
	  detalhes ver:
	  <url>http://developer.gnome.org/json-glib/</url>
	</para>
	<para>
	  Dito isto, os seguintes operadores deverão estar disponíveis
	  para <lit>jsonget</lit>:
	</para>
	  <ilist>
	    <li>
              <para>
		root node, via caractere <lit>$</lit>
              </para>
	    </li>
	    <li>
              <para>
		operador descendente recursivo: <lit>..</lit>
              </para>
	    </li>
	    <li>
              <para>
		operador curinga/wildcard: <lit>*</lit>
              </para>
	    </li>
	    <li>
              <para>
		operador subscrito: <lit>[]</lit>
              </para>
	    </li>
	    <li>
              <para>
		operador de notação de conjunto, por exemplo <lit>[i,j]</lit>
              </para>
	    </li>
	    <li>
              <para>
		operador de repartição: <lit>[start:end:step]</lit>
              </para>
	    </li>
	  </ilist>
      </description>
    </function>

    <function name="jsongetb" section="data-utils" output="bundle">
      <fnargs>
	<fnarg type="string">buf</fnarg>
	<fnarg type="string" optional="true">path</fnarg>
      </fnargs>
      <description>
	<para>
	  O argumento <argname>buf</argname> deve ser um buffer JSON
	  que, por sua vez, pode ser obtido de um website apropriado
	  via função <fncref targ="curl"/>. A especificação e a
	  utilização do argumento opcional <argname>path</argname>,
	  são descritos abaixo.
	</para>
	<para>
	  O valor retornado pela função é um pacote (bundle) em que a estrutura
	  basicamente emula a da entrada: objetos JSON se tornam pacotes
	  (bundles) do Gretl e arrays JASON se tornam arranjos (arrays) do
	  Gretl, com cada um armazenando tanto textos (strings) quanto pacotes
	  (bundles). Nós de <quote>valor</quote> JSON se tornam ou membros de
	  pacotes ou elementos de arranjos. No último caso, valores numéricos
	  são convertidos em texto via função <lit>sprintf</lit>. Note que uma
	  vez que arranjos do Gretl não podem ser aninhados, a entrada aceita
	  por essa função é um pouco mais restritiva que a especificação JSON,
	  que permite aninhamento de arrays.
	</para>
	<para>
	  O argumento opcional <argname>path</argname> pode ser utilizado para
	  limitar os elementos JSON incluídos no bundle retornado. Note que isto
	  não é um <quote>JsonPath</quote> conforme descrito na ajuda da função
	  <fncref targ="jsonget"/>. É uma simples construção sujeita às seguintes
	  especificações:
	</para>
	<ilist>
	  <li>
	    <para>
	      <argname>path</argname> é um array de elemento separados
	      por barras, onde as barras (<quote>/</quote>) indicam a
	      movimentação em um nível mais <quote>profundo</quote> na
	      árvore JSON representada por <argname>buf</argname>. Uma
	      barra no início é permitida, mas não é necessária.
	      Implicitamente o path sempre tem início na raiz. Não devem
	      ser incluídos espaços em branco
	    </para>
	  </li>
	  <li>
	    <para>
	      Cada elemento separado por barras deve assumir uma das
	      seguintes formas: (a) um nome único, de forma que apenas
	      um elemento JSON cujo nome coincide com um dado nível
	      estrutural será incluído; ou (b) <quote>*</quote>
	      (asterisco), de forma que todos os elementos de um dado
	      nível são incluídos; ou (c) um array de nomes separados
	      por vírgulas, delimitados por colchetes (<quote>{</quote>
	      e <quote>}</quote>), de forma que apenas os elementos JSON
	      cujos nomes coincidam com algum dos nomes dados serão
	      incluídos.
	    </para>
	  </li>
	</ilist>
	<para>
	  Veja também a função orientada à textos <fncref targ="jsonget"/>.
	  A depender de seu objetivo uma dessas funções pode ser mais útil que
	  a outra.
	</para>
      </description>
    </function>

    <function name="juldate" section="calendar" output="seebelow">
      <fnargs>
	<fnarg type="scalar-or-series">ed</fnarg>
	<fnarg type="bool" optional="true">as-string</fnarg>
      </fnargs>
      <description>
	<para>
	  O argumento <argname>ed</argname> é interpretado como um dia
	  de época que é igual a 1 no primeiro dia de janeiro do ano 1
	  depois de Cristo no calendário gregoriano proléptico. O valor
	  de retorno padrão&mdash;do mesmo tipo de <argname>ed</argname>
	  &mdash;é um número de 8 dígitos, ou uma série de tais números,
	  seguindo o padrão <lit>YYYYMMDD</lit> (formato ISO 8601
	  <quote>básico</quote>), fornecendo a data correspondente ao
	  dia de época no calendário juliano.
	</para>
	<para>
	  Se <argname>ed</argname> for (apenas) um escalar e o segundo
	  parâmetro <argname>as-string</argname> (que é opcional) for não-nulo,
	  o valor retornado não será numérico e sim um texto (string)
	  seguindo o padrão <lit>YYYY-MM-DD</lit> (formato ISO 8601
	  <quote>estendido</quote>).
	</para>
	<para>
	  Veja também <fncref targ="isodate"/>.
	</para>
      </description>
    </function>

    <function name="kdensity" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg type="scalar" optional="true">scale</fnarg>
	<fnarg type="bool" optional="true">control</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula a estimativa de densidade pelo método do núcleo (kernel) para
	  a série ou vetor <argname>x</argname>. A matriz retornada tem duas
	  colunas, com a primeira contendo um conjunto abscissas uniformemente
	  espaçadas e a segunda a densidade estimada em cada um desses pontos.
	</para>
	<para>
	  O parâmetro opcional <argname>scale</argname> pode ser utilizado
	  para ajustar o grau de suavização em relação ao valor padrão 1.0
	  (maiores valores geram resultados mais suavizados). O parâmetro
	  <argname>control</argname> age como um booleano: 0 (que é o padrão)
	  implica na utilização do núcleo gaussiano, enquanto que um valor
	  não-nulo implica na utilização do núcleo de Epanechnikov.
	</para>
	<para>
	  Um gráfico dos resultados pode ser obtido via comando <cmdref
	  targ="gnuplot"/>, como por exemplo:
	</para>
	<code>
	  matrix d = kdensity(x)
	  gnuplot 2 1 --matrix=d --with-lines --fit=none
	</code>
      </description>
    </function>

    <function name="kdsmooth" section="sspace" output="scalar">
      <fnargs>
	<fnarg type="bundleref">&amp;Mod</fnarg>
	<fnarg type="bool" optional="true">MSE</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza a suavização dos distúrbios para um pacote (bundle) de
	  Kalman previamente definido via função <fncref targ="ksetup"/>
	  e retorna 0 caso a execução tenha sucesso ou 1 se se forem
	  encontrados problemas numéricos.
	</para>
	<para>
	  Se a operação for completada com sucesso os distúrbios
	  suavizados estarão disponíveis como <lit>Mod.smdist</lit>.
	</para>
	<para>
	  O argumento opcional <argname>MSE</argname> determina os conteúdos
	  de <lit>Mod.smdisterr</lit>. Se for omitido ou for igual a 0, essa
	  matriz irá conter os erros padrão não-condicionais dos distúrbios
	  suavizados que, por sua vez, normalmente, são utilizados para
	  calcular os chamados <emphasis>resíduos auxiliares</emphasis>.
	  Caso contrário, <lit>Mod.smdisterr</lit> irá conter a raiz do erro
	  quadrado médio estimado dos resíduos auxiliares em relação aos seus
	  valores verdadeiros.
	</para>
	<para>
	  Para maiores detalhes veja <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="ksetup"/>
            <fncref targ="kfilter"/>
            <fncref targ="ksmooth"/>
            <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="kfilter" section="sspace" output="scalar">
      <fnargs>
	<fnarg type="bundleref">&amp;Mod</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza a filtragem em um pacote (bundle) de Kalman
	  previamente definido via <fncref targ="ksetup"/> e
	  retorna 0 caso a execução tenha sucesso ou 1 se forem
	  encontrados problemas numéricos.
	</para>
	<para>
	  Se a operação for completada com sucesso os erros de
	  previsão de 1 passo à frente estarão disponíveis como
	  <lit>Mod.prederr</lit> e a sequência de suas variâncias
	  como <lit>Mod.pevar</lit>. Além disso, <lit>Mod.llt</lit>
	  dará acesso a um vetor de ordem <math>T</math> contendo
	  o log da verossimilhança por observação.
	</para>
	<para>
	  Para maiores detalhes veja <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="kdsmooth"/>
            <fncref targ="ksetup"/>
            <fncref targ="ksmooth"/>
            <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="kmeier" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">d</fnarg>
	<fnarg type="series-or-vec" optional="true">cens</fnarg>
      </fnargs>
      <description>
	<para>
	  Dada uma amostra de dados de duração, <argname>d</argname>,
	  possivelmente acompanhada por um registro de status de
	  censura, <argname>cens</argname>, calcula o estimador
	  não-paramétrico de Kaplan&ndash;Meier da função de sobrevivência
	  (<cite key="kaplan-meier">Kaplan e Meier, 1958</cite>). A
	  matriz retornada possui três colunas contendo, respectivamente,
	  os valores únicos de <argname>d</argname> de forma ordenada, a
	  função de sobrevivência estimada correspondente ao valor de
	  duração na coluna 1 e o (elevado) erro padrão do estimador,
	  calculado via método de <cite key="greenwood26">Greenwood
	  (1926)</cite>.
	</para>
	<para>
	  Se a série <argname>cens</argname> for dada, um valor 0 serve
	  para indicar uma observação não-censurada, enquanto que um
	  valor 1 indica uma observação censurada à direita (isto é, o
	  período de observação do indivíduo em questão terminou antes
	  que a duração ou o período tenham sido registrados como
	  finalizados). Se <argname>cens</argname> não for dado é assumido
	  que todas as observações são não-censuradas. Observação: a
	  interpretação de <argname>cens</argname> pode ser estendida em
	  algum momento de forma a cobrir outros tipos de censura.
	</para>
	<para>
	  <seelist>
            <fncref targ="naalen"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="kpsscrit" section="stats" output="matrix">
      <fnargs>
	<fnarg type="scalar">T</fnarg>
	<fnarg type="bool">trend</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna um vetor linha contendo os valores críticos aos níveis de 10,
	  5 e 1 porcento do teste KPSS para a estacionariedade de uma série
	  temporal. O argumento <argname>T</argname> deve fornecer o número de
	  observações e o argumento <argname>trend</argname> deve ser igual a 1
	  se o teste inclui uma constante, ou 0, caso contrário.
	</para>
	<para>
	  Os valores críticos são baseados nas superfícies de resposta estimados
	  conforme sugerido por
	  <cite key="sephton95">Sephton (Economics Letters,1995)</cite>.
	  Veja também o comando <cmdref targ="kpss"/>.
 	</para>
      </description>
    </function>

    <function name="ksetup" section="sspace" output="bundle">
      <fnargs>
	<fnarg type="smlist">Y</fnarg>
	<fnarg type="scalar-or-matrix">H</fnarg>
	<fnarg type="scalar-or-matrix">F</fnarg>
	<fnarg type="scalar-or-matrix">Q</fnarg>
	<fnarg optional="true" type="matrix">C</fnarg>
      </fnargs>
      <description>
	<para>
	  Especifica um pacote (bundle) de Kalman, isto é, um objeto que contém
	  todas as informações necessárias para se definir um modelo linear de
	  espaço de estados na forma
	  <equation status="display"
		    tex="\[y_t=H'\alpha_t\]"
		    ascii="y(t) = H'a(t)"
		    graphic="kalman1"/>
	  e com a equação de transição de estados
	  <equation status="display"
		    tex="\[\alpha_{t+1}=F \alpha_t + u_t\]"
		    ascii="a(t+1) = F a(t) + u(t)"
		    graphic="kalman2"/>
	  onde Var<math>(u) = Q</math>.
	</para>
	<para>
	  Objetos criados através dessa função podem ser posteriormente
	  utilizados via funções dedicadas <fncref targ="kfilter"/> para
	  filtragem, <fncref targ="ksmooth"/> e <fncref targ="kdsmooth"/>
	  para suavização e <fncref targ="ksimul"/> para realizar
	  simulações.
	</para>
	<para>
	  A amplitude de classes de modelos que o Gretl pode manusear é,
	  de fato, bem mais abrangente que o implicado pela representação
	  acima: é possível a estimação de modelos com parâmetros variando
	  no tempo, com prioris difusas, com variáveis exógenas na equação
	  de medida e modelos com resíduos interrelacionados. Para maiores
	  detalhes veja <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="kdsmooth"/>
            <fncref targ="kfilter"/>
            <fncref targ="ksmooth"/>
            <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ksimul" section="sspace" output="scalar">
      <fnargs>
	<fnarg type="bundleref">&amp;Mod</fnarg>
      </fnargs>
      <description>
	<para>
	  Utiliza um pacote (bundle) de Kalman previamente definido
	  através da função <fncref targ="ksetup"/> para simular dados.
	</para>
	<para>
	  Para maiores detalhes veja <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="ksetup"/>
            <fncref targ="kfilter"/>
            <fncref targ="ksmooth"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ksmooth" section="sspace" output="matrix">
      <fnargs>
	<fnarg type="bundleref">&amp;Mod</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza uma suavização de ponto fixo em um pacote (bundle)
	  de Kalman previamente definido via função <fncref targ="ksetup"/>
	  e retorna 0 caso a operação tenha sido realizada com sucesso
	  ou 1 se surgirem problemas numéricos.
	</para>
	<para>
	  Em caso de sucesso, os estados suavizados estarão disponíveis
	  como <lit>Mod.state</lit> e a sequência de suas matrizes de
	  covariância como <lit>Mod.stvar</lit>.  Para maiores detalhes
	  veja <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="ksetup"/>
            <fncref targ="kdsmooth"/>
            <fncref targ="kfilter"/>
            <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="kurtosis" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o excesso de curtose da série <argname>x</argname>,
	  descartando quaisquer observações ausentes.
	</para>
      </description>
    </function>

    <function name="lags" section="transforms" output="list-or-mat">
      <fnargs>
	<fnarg type="scalar-or-vec">p</fnarg>
	<fnarg type="series-list-or-mat">y</fnarg>
	<fnarg type="bool" optional="true">bylag</fnarg>
      </fnargs>
      <description>
	<para>
	  Se o primeiro argumento for um escalar, gera as defasagens
	  de 1 até <argname>p</argname> da série <argname>y</argname>,
	  se <argname>y</argname> for uma lista, retorna as defasagens
	  de todas as séries na lista e se for uma matriz, retorna as
	  defasagens de todas as colunas na matriz. Se <argname>
	  p</argname> = 0 e <argname>y</argname> for uma série ou lista,
	  são geradas defasagens até o máximo da periodicidade dos dados.
	  Caso contrário, o valor de <argname>p</argname> deve ser positivo.
	</para>
	<para>
	  Se o primeiro argumento for um vetor, as defasagens serão
	  aquelas especificadas no vetor. Um uso típico neste caso
	  seria fornecer <argname>p</argname> como, por exemplo,
	  <lit>seq(3,7)</lit>, omitindo assim a primeira e a segunda
	  defasagens. Entretanto  ambém é possível fornecer um vetor
	  não contínuo como em <lit>{3,5,7}</lit>, contanto que as
	  defasagens estejam sempre ordenadas de forma crescente.
	</para>
	<para>
	  Quando o valor retornado for uma lista, as variáveis geradas
	  são nomeadas automaticamente de acordo com o esquema
	  <repl>varname</repl><lit>_</lit><repl>i</repl>, onde
	  <repl>varname</repl> é o nome da série original e <repl>i</repl>
	  é a defasagem específica. A parte original do nome é truncada,
	  caso necessário, e pode ser ajustada no caso de não-singularidade
	  no conjunto de nomes assim construído.
	</para>
	<para>
	  Quando <argname>y</argname> for uma lista, ou uma matriz com mais de uma
	  coluna, e a ordem de defasagem for maior que 1, a ordenação padrão dos
	  termos no valor retornado pela função é feita por variável: todas as
	  defasagens da primeira série ou coluna seguida por todas as defasagens da
	  segunda e assim sucessivamente. O terceiro argumento (opcional)
	  pode ser utilizado para alterar esse comportamento: se
	  <argname>bylag</argname> for não-nulo então os termos são ordenados por
	  defasagem: defasagem 1 de todas as séries ou colunas, seguida pela
	  defasagem 2 de todas as séries e colunas e assim sucessivamente.
	</para>
	<para>
	  Veja também <fncref targ="mlag"/> para o uso com matrizes.
	</para>
      </description>
    </function>

    <function name="lastobs" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o número da última observação não ausente da série
	  <argname>y</argname>. Note que se alguma forma de subamostragem
	  estiver sendo utilizada o valor retornado poderá ser maior que o
	  valor retornado pela função <fncref targ="$t2"/>.
	  <seelist>
            <fncref targ="firstobs"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ldet" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o log natural do determinante de <math>A</math>,
	  calculado via decomposição LU.
	  <seelist>
            <fncref targ="det"/>
            <fncref targ="rcond"/>
            <fncref targ="cnumber"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ldiff" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-or-list">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula as diferenças logarítmicas. Os valores iniciais
	  são considerados como <lit>NA</lit>.
	</para>
	<para>
	  Quando uma lista for retornada, as variáveis individuais
	  são automaticamente nomeadas de acordo com o esquema
	  <lit>ld_</lit><repl>varname</repl>, onde <repl>varname</repl>
	  é o nome da série original. Se necessário, o nome será
	  truncado e poderá ser ajustado caso o nome resultante já
	  esteja sendo utilizado pelo Gretl.
	</para>
	<para>
	  <seelist>
            <fncref targ="diff"/>
            <fncref targ="sdiff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="lincomb" section="transforms" output="series">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg type="vector">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula uma nova série como uma combinação linear das séries
	  na lista <argname>L</argname>. Os coeficientes são dados pelo
	  vetor <argname>b</argname> cujo tamanho deve ser igual ao
	  número de séries em series in <argname>L</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="wmean"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="linearize" section="filters" output="series">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  É necessário possuir o TRAMO instalado. Retorna uma versão
	  <quote>linearizada</quote> da série de entrada. Isto é, uma
	  série onde quaisquer valores ausentes são substituídos por
	  valores interpolados e onde as observações aberrantes são
	  ajustadas. O mecanismo completamente automático do TRAMO é
	  usado para isso. Consulte a documentação do TRAMO para detalhes.
	</para>
	<para>
	  Note que se a série de entrada não possuir valores ausentes e
	  e observações aberrantes (conforme identificadas pelo TRAMO), a
	  função retornará uma cópia da série original.
	</para>
      </description>
    </function>

    <function name="ljungbox" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int">p</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula a estatística Q de Ljung&ndash;Box para a série
	  <argname>y</argname>, utilizando a ordem de defasagem
	  <argname>p</argname>, ao longo da amostra selecionada.
	  A defasagem deve ser maior ou igual a 1 e menor que o
	  número de observações disponíveis.
	</para>
	<para>
	  Essa estatística pode ser testada contra a distribuição
	  qui-quadrado com <argname>p</argname> graus de liberdade
	  para verificar a hipótese nula de que a série <argname>
	  y</argname> não é serialmente correlacionada.
	  <seelist>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="lngamma" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o log da função gama de <argname>x</argname>.
	</para>
      </description>
    </function>

    <function name="loess" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series">x</fnarg>
	<fnarg optional="true" type="int">d</fnarg>
	<fnarg optional="true" type="scalar">q</fnarg>
	<fnarg optional="true" type="bool">robust</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza a regressão polinomial localmente ponderada (LOESS) e
	  retorna uma série contendo os valores previstos de <argname>y
	  </argname> para cada valor não-ausente de <argname>x</argname>.
	  O método utilizado é o descrito por <cite key="cleveland79">
	  Cleveland (1979)</cite>.
	</para>
	<para>
	  Os argumentos opcionais <argname>d</argname> e <argname>q
	  </argname> especificam, respectivamente, a ordem do polinômio
	  em <argname>x</argname> e a proporção dos pontos de dados a ser
	  utilizada na estimação local. Por padrão os valores são <argname>
	  d</argname> = 1 e <argname>q</argname> = 0,5. Os outros valores
	  aceitáveis para <argname>d</argname> são 0 e 2. Definir <argname>
	  d</argname> = 0 reduz a regressão local para a forma de uma média
	  móvel. O valor de <argname>q</argname> deve ser maior que 0 e não
	  pode exceder 1. Valores maiores produzem saídas mais suaves.
	</para>
	<para>
	  Se um valor não-nulo for dado ao argumento <argname>robust
	  </argname> as regressões locais serão iteradas duas vezes, com os
	  pesos sendo modificados com base nos resíduos da iteração prévia
	  de forma a reduzir a influência das observações aberrantes (<quote>
	  outliers</quote>).
	</para>
	<para>
	  Veja também <fncref targ="nadarwat"/> e, para maiores detalhes
	  sobre métodos não-paramétricos, veja <guideref
	  targ="chap:nonparam"/>.
	</para>
      </description>
    </function>

    <function name="log" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o logaritmo natural de <argname>x</argname>. Gera
	  <lit>NA</lit> para valores não-positivos. Note que <lit>ln</lit>
	  é um pseudônimo aceitável para <lit>log</lit>.
	</para>
	<para>
	  Quando uma lista for retornada, as variáveis individuais
	  serão automaticamente nomeadas de acordo com o modelo
	  <lit>l_</lit><repl>varname</repl>, onde <repl>varname</repl>
	  é o nome da série original. O nome será truncado se
	  necessário e pode ser ajustado no caso de já estar sendo
	  usado pelo Gretl.
	</para>
      </description>
    </function>

    <function name="log10" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o logaritmo na base 10 de <argname>x</argname>. A função irá
	  gerar <lit>NA</lit> para valores não-positivos.
	</para>
      </description>
    </function>

    <function name="log2" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o logaritmo na base 2 de <argname>x</argname>. A função irá
	  gerar <lit>NA</lit> para valores não-positivos.
	</para>
      </description>
    </function>

    <function name="logistic" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para context="tex">
	  Retorna a função logística do argumento <argname>x</argname>,
	  isto é, $\Lambda(x) = e^x/(1+e^x)$. Se <argname>x</argname> for
	  uma matriz, a função será aplicada em cada elemento.
	</para>
	<para context="notex">
	  Retorna a função logística do argumento
	  <argname>x</argname>, isto é, <math>e</math><sup>x</sup>/(1
	  + <math>e</math><sup>x</sup>).  Se <argname>x</argname> for
	  ma matriz, a função será aplicada em cada elemento.
	</para>
      </description>
    </function>

    <function name="lower" section="matbuild" output="smatrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Retorna uma matriz triangular inferior de ordem <by r="n" c="n"/>.
	  Os elementos da diagonal e abaixo desta são iguais aos elementos
	  correspondentes de <argname>A</argname> e os demais iguais a zero.
	</para>
	<para context="tex">
	  Retorna uma matriz triangular inferior <math>B</math> onde
	  $B_{ij} = A_{ij}$ se $i \ge j$, e 0 caso contrário.
	</para>
	<para>
	  <seelist>
            <fncref targ="upper"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="lrcovar" section="filters" output="matrix">
      <fnargs>
    <fnarg type="matrix">A</fnarg>
    <fnarg type="bool" optional="true">demean</fnarg>
      </fnargs>
      <description>
    <para>
	  Retorna a matriz de variância-covariância de longo prazo das colunas
	  de <argname>A</argname>. Em primeiro lugar é retirada a média dos
	  dados, a menos que o segundo argumento (que é opcional) seja igual
	  a zero. O tipo de kernel/núcleo e o parâmetro de truncagem de
	  defasagem (tamanho da janela) pode ser escolhido antes que a função
	  seja chamada com as opções relacionadas ao HAC, que são oferecidas
	  pelo comando <cmdref targ="set"/>, tais como <lit>hac_kernel</lit>,
	  <lit>hac_lag</lit>, <lit>hac_prewhiten</lit>. Veja também a seção
	  sobre dados de séries de tempo e matrizes de covariância no
	  <guideref targ="chap:robust_vcv"/>.
    </para>
    <para>
      <seelist>
        <fncref targ="lrvar"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="lrvar" section="filters" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="int">k</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a variância de longo prazo de <argname>y</argname>, calculada
	  utilizando um núcleo de Bartlett com tamanho de janela igual a
	  <argname>k</argname>. Se o segundo argumento for omitido, ou for um
	  valor menor que zero, o tamanho da janela toma como padrão a parte
	  inteira da raiz cúbica do tamanho da amostra.
	</para>
	<para context="tex">
	  Fórmula:
	  \[ \hat{\omega}^2(k) = \frac{1}{T} \sum_{t=k}^{T-k}
	  \left[ \sum_{i=-k}^k w_i (y_t - \bar{X}) (y_{t-i} - \bar{Y})
	  \right] \]
	  com
	  \[ w_i = 1 - \frac{|i|}{k + 1} \]
	</para>
	<para>
	  Ver a função <fncref targ="lrcovar"/> para o caso multivariado.
	</para>
      </description>
    </function>

    <function name="max" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Se o argumento <argname>y</argname> for uma série, retorna,
	  na forma de um escalar, o valor máximo das observações não
	  ausentes na série. Se o argumento for uma lista, retorna uma
	  série onde cada elemento é o valor máximo em cada observação
	  entre as séries listadas.
	</para>
	<para>
	  <seelist>
            <fncref targ="min"/>
            <fncref targ="xmax"/>
            <fncref targ="xmin"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="maxc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna um vetor com os valores máximos das colunas de
	  <argname>X</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="imaxc"/>
            <fncref targ="maxr"/>
            <fncref targ="minc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="maxr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna um vetor com os valores máximos das linhas
	  <argname>X</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="imaxr"/>
            <fncref targ="maxc"/>
            <fncref targ="minr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mcorr" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula a matriz de correlações tratando cada coluna de
	  <argname>X</argname> como sendo uma a variável.
	  <seelist>
            <fncref targ="corr"/>
            <fncref targ="cov"/>
            <fncref targ="mcov"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mcov" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula a matriz de covariâncias tratando cada coluna de
	  <argname>X</argname> como sendo uma variável.
	  <seelist>
            <fncref targ="corr"/>
            <fncref targ="cov"/>
            <fncref targ="mcorr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mcovg" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="vector">u</fnarg>
	<fnarg optional="true" type="vector">w</fnarg>
	<fnarg type="int">p</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma matriz covariograma para uma matriz <argname>
	  X</argname> de ordem <by r="T" c="k"/> (normalmente contendo
	  regressores), um vetor <argname>u</argname> (opcional) com
	  <math>T</math> elementos (normalmente contendo resíduos),
	  um vetor de pesos <argname>w</argname> (opcional) com <math>
	  p</math>+1 elementos e uma ordem de defasagem <argname>
	  p</argname>, que deve ser maior ou igual a 0.
	</para>
	<para context="tex">
	  A matriz retornada é dada por
	  \[\sum_{j=-p}^{p} \sum_j w_{|j|} (X_t u_t
	  u_{t-j} X_{t-j}')\]
	</para>
	<para context="notex">
	  A matriz retornada é o somatório com <math>j</math> indo de
	  <math>-p</math> até <math>p</math> de <math>w(|j|) *
	  X(t)X(t-j)' * u(t)u(t-j)</math>, onde <math>X(t)'</math> é
	  a <math>t</math>-ésima linha de <argname>X</argname>.
	</para>
	<para>
	  Se <argname>u</argname> for <lit>null</lit> os termos
	  <math>u</math> são omitidos, e se <argname>w</argname>
	  for <lit>null</lit> todos os pesos são considerados
	  como sendo iguais a 1,0.
	</para>
	<para>
	  Por exemplo, o seguinte código
	</para>
	<code>
	  set seed 123
	  X    = mnormal(6,2)
	  Lag  = mlag(X,1)
	  Lead = mlag(X,-1)
	  print X Lag Lead
	  eval X'X
	  eval mcovg(X, , , 0)
	  eval X'(X + Lag + Lead)
	  eval mcovg(X, , , 1)
	</code>
	<para>
	  produz estes resultados:
	</para>
	<code>
	  ? print X Lag Lead
	  X (6 x 2)

	    -0.76587      -1.0600
	    -0.43188      0.30687
	    -0.82656      0.40681
	     0.39246      0.75479
	     0.36875       2.5498
	     0.28855     -0.55251

	  Lag (6 x 2)

	      0.0000       0.0000
	    -0.76587      -1.0600
	    -0.43188      0.30687
	    -0.82656      0.40681
	     0.39246      0.75479
	     0.36875       2.5498

	  Lead (6 x 2)

	    -0.43188      0.30687
	    -0.82656      0.40681
	     0.39246      0.75479
	     0.36875       2.5498
	     0.28855     -0.55251
	      0.0000       0.0000

	  ? eval X'X
	      1.8295       1.4201
	      1.4201       8.7596

	  ? eval mcovg(X,,, 0)
	      1.8295       1.4201
	      1.4201       8.7596

	  ? eval X'(X + Lag + Lead)
	      3.0585       2.5603
	      2.5603       10.004

	  ? eval mcovg(X,,, 1)
	      3.0585       2.5603
	      2.5603       10.004
	</code>
      </description>
    </function>

    <function name="mean" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>x</argname> for uma série a função retorna a média
	  amostral (na forma de um escalar), descartando quaisquer observações
	  ausentes.
	</para>
	<para>
	  Se <argname>x</argname> for uma lista a função retorna uma série
	  <math>y</math> tal que <math>y</math><sub>t</sub> é a média dos
	  valores das variáveis da lista na observação <math>t</math>, ou
	  <lit>NA</lit> se existir algum valor ausente em <math>t</math>.
	</para>
      </description>
    </function>

    <function name="meanc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna um vetor com as médias das colunas de <argname>X</argname>.
	  <seelist>
            <fncref targ="meanr"/>
            <fncref targ="sumc"/>
            <fncref targ="sdc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="meanr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna um vetor com as médias das linhas de <argname>X</argname>.
	  <seelist>
            <fncref targ="meanc"/>
            <fncref targ="sumr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="median" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>x</argname> for uma série, a função retorna sua mediana amostral
	  (na forma de um escalar), ignorando quaisquer observações ausentes.
	</para>
	<para>
	  Se <argname>x</argname> for uma lista, a função retorna uma
	  séries <math>y</math> tal que <math>y</math><sub>t</sub> é a
	  mediana dos valores das variáveis da lista na observação
	  <math>t</math>, ou <lit>NA</lit> se existir algum valor ausente
	  em <math>t</math>.
	</para>
      </description>
    </function>

    <function name="mexp" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Calcula a matriz exponencial de <argname>A</argname>
	  utilizando o algoritmo 11.3.1 de <cite key="golub96">Golub e
	  Van Loan (1996)</cite>.
	</para>
	<para context="tex">
	  Calcula a matriz exponencial,
	  \[ e^A = \sum_{k=0}^{\infty} \frac{A^k}{k!}
	  = \frac{I}{0!} + \frac{A}{1!} + \frac{A^2}{2!} + \frac{A^3}{3!}
	  + \cdots\]
	  (Essa série irá necessariamente convergir.) O algoritmo utilizado
	  é o 11.3.1 de <cite key="golub96">Golub e Van Loan
	  (1996)</cite>.
	</para>
      </description>
    </function>

    <function name="mgradient" section="midas" output="matrix">
      <fnargs>
	<fnarg type="int">p</fnarg>
	<fnarg type="vector">theta</fnarg>
	<fnarg type="int-or-string">type</fnarg>
      </fnargs>
      <description>
	<para>
	  Derivadas analíticas para os pesos MIDAS. Seja <math>k
	  </math> o número de elementos no vetor de hiper-parâmetros,
	  <repl>theta</repl>. Esta função retorna uma matriz de ordem
	  <by r="p" c="k"/> contendo o gradiente do vetor de pesos
	  (conforme calculado por <fncref targ="mweights"/>) em
	  relação aos elemento de <repl>theta</repl>. O primeiro
	  argumento representa a ordem de defasagem desejada e o último
	  argumento especifica o tipo de parametrização. Veja <lit>
	  mweights</lit> para uma explicação sobre os valores aceitáveis
	  de <repl>type</repl>.
	</para>
	<para>
	  <seelist>
            <fncref targ="mweights"/>
	    <fncref targ="mlincomb"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="min" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Se o argumento <argname>y</argname> for uma série, retorna,
	  na forma de um escalar, o valor mínimo das observações não
	  ausentes na série. Se o argumento for uma lista, retorna uma
	  série onde cada elemento é o valor mínimo em cada observação
	  entre as séries listadas.
	</para>
	<para>
	  <seelist>
            <fncref targ="max"/>
            <fncref targ="xmax"/>
            <fncref targ="xmin"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="minc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna um vetor com os valores mínimos das colunas de <argname>X</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="iminc"/>
            <fncref targ="maxc"/>
            <fncref targ="minr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="minr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna um vetor com os valores mínimos das linhas de <argname>X</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="iminr"/>
            <fncref targ="maxr"/>
            <fncref targ="minc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="missing" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="sslist">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma variável binária igual a 1 se <argname>x</argname> for
	  <lit>NA</lit> e 0, caso contrário. Se <argname>x</argname> for uma
	  série, a comparação é feita em cada um de seus elementos. Se
	  <argname>x</argname> for uma lista de séries, a função retorna uma
	  série igual a 1 nas observações nas quais ao menos uma das séries
	  apresente um <lit>NA</lit> e 0, caso contrário.
	</para>
	<para>
	  <seelist>
            <fncref targ="misszero"/>
            <fncref targ="ok"/>
            <fncref targ="zeromiss"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="misszero" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Converte <lit>NA</lit>s em zeros. Se <argname>x</argname> for uma
	  série a conversão será feita elemento por elemento.
	  <seelist>
            <fncref targ="missing"/>
            <fncref targ="ok"/>
            <fncref targ="zeromiss"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mlag" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="scalar-or-vec">p</fnarg>
	<fnarg type="scalar" optional="true">m</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Desloca para cima ou para baixo as linhas de <argname>X
	  </argname>. Se <argname>p</argname> for um número positivo,
	  retorna uma matriz na qual as colunas de <argname>X</argname>
	  são deslocadas <argname>p</argname> linhas para baixo e as
	  primeiras <argname>p</argname> linhas são preenchidas com o
	  valor <argname>m</argname>. Se <argname>p</argname> for um
	  número negativo, <argname>X</argname> é deslocado para cima
	  e as últimas linhas são preenchidas com o valor <argname>m
	  </argname>. Se <argname>m</argname> não for fornecido, será
	  considerado como sendo igual a zero.
	</para>
	<para context="tex">
	  Desloca para cima ou para baixo as linhas de <argname>X
	  </argname>. Se $p$ for um número positivo, a matriz retornada
	  $Y$ terá como elementos $Y_{i,j} = X_{i-p,j}$ para $i \ge p$
	  e zero caso contrário. Em outras palavras, as colunas de
	  <argname>X</argname> são deslocadas <argname>p</argname>
	  linhas para baixo e as primeiras <argname>p</argname> linhas
	  são preenchidas com o valor <argname>m</argname>. Se
	  <argname>p</argname> for um número negativo, <argname>X
	  </argname> é deslocado para cima e as últimas linhas são
	  preenchidas com o valor <argname>m</argname>. Se <argname>m
	  </argname> não for fornecido, será considerado como sendo
	  igual a zero.
	</para>
	<para context="notex">
	  Se <argname>p</argname> for um vetor, a operação acima
	  é realizada para cada elemento em <argname>p</argname>,
	  combinando as matrizes resultantes horizontalmente.
	</para>
	<para context="tex">
	  Se $p$ for um vetor, a operação acima é realizada para
	  cada elemento em $p$, combinando as matrizes resultantes
	  horizontalmente.
	</para>
	<para>
	  Veja também <fncref targ="lags"/>.
	</para>
      </description>
    </function>

    <function name="mlincomb" section="midas" output="series">
      <fnargs>
	<fnarg type="list">hfvars</fnarg>
	<fnarg type="vector">theta</fnarg>
	<fnarg type="int-or-string">type</fnarg>
      </fnargs>
      <description>
	<para>
	  É uma função MIDAS de conveniência, combinando <fncref targ=
	  "lincomb"/> com <fncref targ="mweights"/>. Dada uma lista
	  <repl>hfvars</repl>, a função calcula uma série que é uma
	  soma ponderada dos elementos da lista, com os pesos baseados
	  no vetor de hiper-parâmetros <repl>theta</repl> e o tipo de
	  parametrização. Veja <lit>mweights</lit> para maiores
	  detalhes. Note que <fncref targ="hflags"/> é, geralmente, a
	  melhor forma de criar uma lista que pode ser adequadamente
	  utilizada como primeiro argumento desta função.
	</para>
	<para>
	  De forma mais explícita, a chamada
	</para>
	<code>
	  series s = mlincomb(hfvars, theta, 2)
	</code>
	<para>
	  é equivalente a
	</para>
	<code>
	  matrix w = mweights(nelem(hfvars), theta, 2)
	  series s = lincomb(hfvars, w)
	</code>
	<para>
	  A vantagem é que a utilização de <lit>mlincomb</lit> é mais
	  concisa e eficiente em termos de processamento.
	</para>
      </description>
    </function>

    <function name="mnormal" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma matriz com <argname>r</argname> linhas e
	  <argname>c</argname> colunas, preenchida com variáveis
	  pseudo aleatórias com distribuição normal padrão.
	  <seelist>
            <fncref targ="normal"/>
            <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mols" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;V</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma matriz de ordem <by r="k" c="n"/> com os parâmetros
	  obtidos da regressão MQO da matriz <argname>Y</argname> de ordem
	  <by r="T" c="n"/> contra a matriz <argname>X</argname> de ordem
	  <by r="T" c="k"/>.
	</para>
	<para>
	  Se o terceiro argumento for diferente de <lit>null</lit>, a
	  matriz <argname>U</argname> de ordem <by r="T" c="n"/> irá conter
	  os resíduos. Se o último argumento for dado e for diferente de
	  <lit>null</lit> a matriz <argname>V</argname> de ordem <by r="k"
	  c="k"/> irá conter (a) a matriz de covariância das estimativas
	  dos parâmetros, se <argname>Y</argname> tiver apenas uma coluna,
	  ou (b) <math>X'X</math><sup>-1</sup> se <argname>Y</argname> tiver
	  múltiplas colunas.
	</para>
	<para>
	  Por padrão, estimativas são obtidas via decomposição de Cholesky.
	  Caso as colunas de <argname>X</argname> apresentem elevada
	  colinearidade é utilizada a decomposição QR. A utilização de SVD
	  pode ser forçada via comando <lit>set svd on</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="mpols"/>
            <fncref targ="mrls"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="monthlen" section="calendar" output="int">
      <fnargs>
	<fnarg type="int">mês</fnarg>
	<fnarg type="int">ano</fnarg>
	<fnarg type="int">dias na semana</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o número de dias (relevantes) no mês e ano especificados
	  (no calendário gregoriano proléptico). O argumento <argname>dias
	  na semana</argname>, que pode ser igual a 5, 6 ou 7, indica o
	  número de dias da semana que devem ser considerados (se for
	  escolhido 6 os domingos são omitidos e se for escolhido 5 os
	  sábados e os domingos serão omitidos).
	</para>
      </description>
    </function>

    <function name="movavg" section="filters" output="series">
      <fnargs>
	<fnarg type="series">x</fnarg>
	<fnarg type="scalar">p</fnarg>
	<fnarg type="int" optional="true">control</fnarg>
	<fnarg type="scalar" optional="true">y0</fnarg>
      </fnargs>
      <description>
	<para>
	  Dependendo do valor do parâmetro <argname>p</argname>,
	  retorna a média móvel simples ou exponencialmente ponderada
	  da série <argname>x</argname>.
	</para>
	<para context="notex">
	  Se <argname>p</argname> &gt; 1, é calculada a média móvel
	  (MM/MA) simples de ordem <argname>p</argname>, isto é, a
	  média aritmética de <math>x</math> do período <math>t</math>
	  até <math>t-p+1</math>. Se for escolhido um valor diferente de zero
	  para o argumento opcional <argname>control</argname>
	  é calculada a média móvel centrada, caso contrário é calculada a
	  média móvel simples. Nesse caso, o argumento opcional <argname>
	  y0</argname> é ignorado.
	</para>
	<para context="tex">
	  Se $p&gt;1$, é calculada a média móvel (MM/MA) simples de ordem
	  <argname>p</argname>, isto é, $\frac{1}{p} \sum_{i=0}^{p-1}
	  x_{t-i}$. Se for escolhido um valor diferente de zero para o
	  argumento opcional <argname>control</argname> é calculada a média
	  móvel centrada, caso contrário é calculada a média móvel simples.
	  Nesse caso, o argumento opcional <argname>y0</argname> é ignorado.
	</para>
	<para context="notex">
	  Se <argname>p</argname> for uma fração positiva, é calculada
	  a média móvel exponencial:
	</para>
	<para context="notex">
	  <math>y(t) = p*x(t) + (1-p)*y(t-1)</math>
	</para>
	<para context="notex">
	  Por padrão, a série de saída, <math>y</math>, é inicializada
	  utilizando o primeiro valor de <argname>x</argname>, mas o
	  argumento <argname>control</argname> pode ser utilizado para
	  especificar o número inicial de observações cuja média deve
	  ser utilizada para produzir <math>y(0)</math>. Um valor zero
	  para <argname>control</argname> indica que todas as observações
	  devem ser utilizadas. Alternativamente, um valor de inicialização
	  pode ser especificado utilizando o argumento opcional
	  <argname>y0</argname>. Nesse caso o argumento <argname>control
	  </argname> é ignorado.
	</para>
	<para context="tex">
	  Se $0 &lt; p &lt; 1$, é calculada a média móvel:
	  \[y_t = p x_t + (1-p)y_{t-1}\]
	  Esta é a fórmula de <cite key="roberts59">Roberts, 1959</cite>.
	  Por padrão a série de saída $y$ é inicializada utilizando o
	  primeiro valor válido de $x$, mas o argumento <argname>control
	  </argname> pode ser utilizado para especificar o número inicial
	  de observações cuja média deve ser utilizada para produzir $y_0$.
	  Um valor zero para <argname>control</argname> indica que todas
	  as observações devem ser utilizadas. Alternativamente, um valor
	  de inicialização pode ser especificado utilizando o argumento
	  opcional <argname>y0</argname>. Nesse caso o argumento <argname>
	  control</argname> é ignorado.
	</para>
      </description>
    </function>

    <function name="mpols" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Funciona de forma semelhante à função <fncref targ="mols"/>. A diferença é que
	  os cálculos são realizados com precisão múltipla utilizando a biblioteca GMP.
	</para>
	<para>
	  Por padrão, a biblioteca GMP utiliza 256 bits para cada número de
	  ponto flutuante. Isso pode ser ajustado via variável de ambiente
	  <lit>GRETL_MP_BITS</lit>, por exemplo, <lit>GRETL_MP_BITS=1024</lit>.
	</para>
      </description>
    </function>

    <function name="mrandgen" section="probdist" output="matrix">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="scalar">p1</fnarg>
	<fnarg type="scalar" conditional="true">p2</fnarg>
	<fnarg type="scalar" conditional="true">p3</fnarg>
	<fnarg type="int">rows</fnarg>
	<fnarg type="int">cols</fnarg>
      </fnargs>
      <examples>
	<example>matrix mx = mrandgen(u, 0, 100, 50, 1)</example>
	<example>matrix mt14 = mrandgen(t, 14, 20, 20)</example>
      </examples>
      <description>
	<para>
	  Funciona da mesma forma que <fncref targ="randgen"/> exceto
	  pelo fato de retornar uma matriz ao invés de uma série. Os
	  argumentos iniciais para essa função (os números que a
	  distribuição selecionada depende) são descritos por
	  <lit>randgen</lit>, mas eles devem ser seguidos por dois
	  inteiros para especificar o número de linhas e colunas da
	  matriz aleatória desejada.
	</para>
	<para>
	  O primeiro exemplo acima gera um vetor coluna com 50 elementos seguindo
	  uma distribuição uniforme, enquanto que o segundo exemplo especifica uma
	  matriz aleatória de ordem <by r="20" c="20"/> com valores extraídos da
	  distribuição <math>t</math> com 14 graus de liberdade.
	</para>
	<para>
	  <seelist>
            <fncref targ="mnormal"/>
            <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mread" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="string">fname</fnarg>
	<fnarg optional="true" type="bool">import</fnarg>
      </fnargs>
      <description>
	<para>
	  Lê uma matriz armazenada no arquivo chamado <argname>fname
	  </argname>. Se o arquivo possuir a extensão <quote><lit>.gz
	  </lit></quote> é assumido que ele foi comprimido no formato
	  gzip, se tiver a extensão <quote><lit>.bin</lit></quote> é
	  assumido que o arquivo está em formato binário (veja <fncref
	  targ="mwrite"/> para detalhes). Caso contrário assume-se que
	  é um arquivo de texto simples, seguindo as seguintes
	  especificações:
	</para>
	<ilist>
	  <li>
            <para>
	          O arquivo pode começar com qualquer qualquer quantidade
	          de comentários, definidos por linhas iniciadas com o
	          caractere <lit>#</lit>. Essas linhas serão ignoradas.
            </para>
	  </li>
	  <li>
            <para>
              A primeira que não for de comentário deve conter dois
              inteiros, separados por um espaço ou uma tabulação,
              indicando o número de linhas e colunas, respectivamente.
            </para>
	  </li>
	  <li>
            <para>
              As colunas devem estar separadas por espaços ou por
              tabulações.
            </para>
	  </li>
	  <li>
            <para>
              O separador decimal deve ser o ponto
              (<quote><lit>.</lit></quote>).
            </para>
	  </li>
	</ilist>
	<para>
	  Se no primeiro argumento não estiver especificado o caminho
	  completo até o arquivo ele será em vários locais que sejam
	  considerados como sendo <quote>prováveis</quote>. O primeiro
	  deles será o diretório de trabalho em uso <cmdref targ="workdir"/>.
	  Entretanto, se o segundo argumento da função, <argname>import</argname>,
	  for um valor não-nulo o arquivo será procurado no diretório
	  <quote>@dotdir</quote>. Isto ocorre para que essa função seja
	  utilizada em conjunto com as que exportam matrizes presentes
	  no contexto do comando <cmdref targ="foreign"/>. Nesse caso o
	  argumento <argname>fname</argname> deve ser um nome simples,
	  sem que se especique o caminho para o arquivo.
	</para>
	<para>
	  <seelist>
            <fncref targ="bread"/>
            <fncref targ="mwrite"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mreverse" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="bool" optional="true">bycol</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma matriz contendo as linhas de <argname>X</argname> em
	  ordem reversa. Para obter uma matriz contendo as colunas em ordem
	  reversa pode-se utilizar um valor não-nulo como segundo argumento.
	</para>
      </description>
    </function>

    <function name="mrls" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">R</fnarg>
	<fnarg type="cvec">q</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;V</fnarg>
      </fnargs>
      <description>
	<para>
	  Mínimos quadrados restritos: retorna uma matriz <by r="k"
	  c="n"/> de parâmetros estimados obtidos através da regressão
	  via mínimos quadrados da matriz <argname>Y</argname>, de ordem
	  <by r="T" c="n"/>, contra a matriz <argname>X</argname>, de
	  ordem <by r="T" c="k"/>, sujeitos à restrição linear <math>RB
	  </math> = <math>q</math>, onde <math>B</math> representa o
	  vetor de coeficientes empilhados. <argname>R</argname> deve
	  possuir <math>kn</math> colunas. Cada linha dessa matriz
	  representa uma restrição linear. O número de linhas em
	  <argname>q</argname> deve coincidir com o número de linhas em
	  <argname>R</argname>.
	</para>
	<para>
	  Se o quinto argumento não for <lit>null</lit>, a matriz
	  <argname>U</argname> de ordem <by r="T" c="n"/> irá armazenar
	  os resíduos. Se o argumento final for dado e não for <lit>null
	  </lit> então a matriz <argname>V</argname> de ordem <by r="k"
	  c="k"/> irá armazenar a contraparte restrita da matriz <math>X'
	  X</math><sup>-1</sup>. A matriz de variância das estimativas
	  para a equação <math>i</math> pode ser construída multiplicando-se
	  a sub-matriz apropriada de <argname>V</argname> por uma estimativa
	  do erro para esta equação.
	</para>
      </description>
    </function>

    <function name="mshape" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">r</fnarg>
	<fnarg type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Rearranja os elementos de <argname>X</argname> em uma matriz com
	  <argname>r</argname> linhas e <argname>c</argname> colunas. Os elementos
	  de <argname>X</argname> são copiados e escritos na matriz de destino. A
	  cópia tem início na coluna 1, linha 1, depois linha 2 e assim
	  sucessivamente. Se <argname>X</argname> tiver menos que <math>k</math>
	   = <math>rc</math> elementos, estes são repetidos de forma cíclica. Caso
	  contrário, se <argname>X</argname> tiver mais elementos, apenas os
	  primeiros <math>k</math> elementos serão utilizados.
	</para>
	<para>
	  <seelist>
            <fncref targ="cols"/>
            <fncref targ="rows"/>
            <fncref targ="unvech"/>
            <fncref targ="vec"/>
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="msortby" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">j</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma matriz onde as linhas de <argname>X</argname>
	  são reordenadas de forma crescente de acordo com os elementos da
	  coluna <argname>j</argname>. Essa ordenação é estável: linhas que
	  compartilham o mesmo valor na coluna <argname>j</argname> não
	  serão invertidas.
	</para>
      </description>
    </function>

    <function name="muniform" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma matriz com <argname>r</argname> linhas e <argname>c</argname>
	  colunas, preenchida com números pseudo-aleatórios seguindo uma distribuição
	  uniforme (0,1). Observação: o método preferencial para gerar escalares
	  pseudo-aleatórios com distribuição uniforme é através da utilização da
	  função <fncref targ="randgen1"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="mnormal"/>
            <fncref targ="uniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mweights" section="midas" output="matrix">
      <fnargs>
	<fnarg type="int">p</fnarg>
	<fnarg type="vector">theta</fnarg>
	<fnarg type="int-or-string">type</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna um vetor de ordem <math>p</math> de pesos MIDAS a serem
	  aplicados nas <math>p</math> defasagens de uma série de alta
	  frequência, com base no vetor de hiper-parâmetros <repl>theta</repl>.
	</para>
	<para>
	  O argumento <repl>type</repl> identifica o tipo de
	  parametrização, a qual determina o número de elementos
	  necessários, <math>k</math>, em <repl>theta</repl>: 1 =
	  exponencial normalizado de Almon (<math>k</math> ao menos 1,
	  tipicamente 2); 2 = beta normalizado com última defasagem nula
	  (<math>k</math> = 2); 3 = beta normalizado com última defasagem
	  não-nula (<math>k</math> = 3); e 4 = polinômio de Almon
	  (<math>k</math> ao menos 1). Note que no caso do beta
	  normalizado os primeiros dois elementos de <repl>theta</repl>
	  devem ser positivos.
	</para>
	<para>
	  O <repl>type</repl> pode ser fornecido como sem um código inteiro,
	  como mostrado acima, ou por um dos seguintes textos
	  (respectivamente): <lit>nealmon</lit>, <lit>beta0</lit>,
	  <lit>betan</lit>, <lit>almonp</lit>. Se for utilizado texto, ele
	  deve ser escrito com aspas duplas. Por exemplo, as duas expressões
	  abaixo são equivalentes:
	</para>
	<code>
	  W = mweights(8, theta, 2)
	  W = mweights(8, theta, "beta0")
	</code>
	<para>
	  <seelist>
            <fncref targ="mgradient"/>
	    <fncref targ="mlincomb"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mwrite" section="data-utils" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="string">fname</fnarg>
	<fnarg optional="true" type="bool">export</fnarg>
      </fnargs>
      <description>
	<para>
	  Salva a matriz <argname>X</argname> em um arquivo especificado
	  por <argname>fname</argname>. Por padrão este arquivo será um
	  arquivo de texto simples. A primeira linha terá dois números
	  inteiros, separados por um caractere de tabulação (tab),
	  representando o número de linhas e colunas. Nas linhas seguintes
	  estarão os elementos da matriz, em notação científica, separados
	  por tabulações (uma linha da matriz em cada linha do arquivo).
	  Veja a seguir os formatos alternativos.
	</para>
	<para>
	  Se já existir um arquivo com o nome <argname>fname</argname> ele
	  será sobrescrito. O valor a ser retornado pela função é 0 em caso
	  de sucesso. Se ocorrer um erro na escrita, que pode ocorrer, por
	  exemplo, se o arquivo estiver bloqueado, o valor de retorno será
	  diferente de 0.
	</para>
	<para>
	  O arquivo de saída será salvo no <cmdref targ="workdir"/> selecionado,
	  a menos que no argumento <repl>filename</repl> seja escrito o caminho
	  completo. Entretanto, se o argumento <argname>export</argname> for
	  diferente de 0, o arquivo será salvo no diretório do usuário, ou seja,
	  no diretório <quote>@dotdir</quote>, onde é acessado por padrão pelas
	  funções que manipulam matrizes no contexto do comando <cmdref
	  targ="foreign"/>. Nesse caso, um nome simples, sem a inclusão do caminho
	  para o arquivo, deve ser usado como segundo argumento.
	</para>
	<para>
	  Matrizes armazenadas via função <lit>mwrite</lit> na sua forma padrão
	  podem ser facilmente lidas por outros programas. Para maiores detalhes
	  veja <guideref targ="chap:matrices"/>.
	</para>
	<para>
	  Duas variantes, mutuamente exclusivas, estão disponíveis para esta
	  função:
	</para>
	<ilist>
	  <li>
	    <para>
	      Se o nome dado para o arquivo, <argname>fname</argname>, terminar
	      com <quote><lit>.gz</lit></quote> então ele será armazenado com
	      compressão gzip.
	    </para>
	  </li>
	  <li>
	    <para>
	      Se <argname>fname</argname> terminar com <quote><lit>.bin</lit>
	      </quote> então o arquivo será armazenado no formato binário.
	      Neste caso os primeiros 19 bytes contêm os caracteres <lit>
	      gretl_binary_matrix</lit>, os 8 bytes seguintes contêm dois
	      inteiros de 32 bit, fornecendo o número de linhas e colunas da
	      matriz, e o restante do arquivo contém os elementos da matriz
	      como <quote>doubles</quote>, com extremidade do tipo little-endian,
	      orientado a coluna (column-major). Se o Gretl for executado em um
	      sistema com extremidade do tipo big-endian, os valores binários são
	      convertidos para little-endian na escrita e convertidos para
	      big-endian na leitura.
	    </para>
	  </li>
	</ilist>
	<para>
	  Note que se o armazenamento da matriz em um arquivo for para seu uso
	  em outros programas não é aconselhável utilizar as variantes gzip ou
	  binária. Mas se o intuito for a posterior leitura pelo próprio Gretl,
	  esses formatos alternativos economizam espaço em disco e, no caso do
	  armazenamento no formato binário, torna a leitura de grandes matrizes
	  bem mais rápida. O formato gzip não é recomendado para matrizes muito
	  grandes, uma vez que a descompressão desses arquivos é bastante lenta.
	</para>
	<para>
	  <seelist>
            <fncref targ="mread"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mxtab" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma matriz contendo a tabulação cruzada dos valores
	  contidos em <argname>x</argname> (por linha) e <argname>y
	  </argname> (por coluna). Os dois argumentos devem ser do
	  mesmo tipo (ambos séries ou ambos vetores) e, devido à forma
	  que essa função é comumente utilizada, assume-se que contêm
	  apenas valores inteiros.
	</para>
	<para>
	  <seelist>
            <fncref targ="values"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="naalen" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">d</fnarg>
	<fnarg type="series-or-vec" optional="true">cens</fnarg>
      </fnargs>
      <description>
	<para>
	  Dada uma amostra de dados de duração, <argname>d</argname>,
	  possivelmente acompanhada por um registro de status de censura,
	  <argname>cens</argname>, calcula o estimador não-paramétrico
	  de Nelson&ndash;Aalen da função de risco (<cite
	  key="nelson72">Nelson, 1972</cite>; <cite
	  key="aalen78">Aalen, 1978</cite>). A matriz retornada possui
	  três colunas contendo, respectivamente, os valores únicos de
	  <argname>d</argname> de forma ordenada, a função de risco
	  acumulada estimada correspondendo ao valor de duração na coluna
	  1 e o erro padrão do estimador.
	</para>
	<para>
	  Se a série <argname>cens</argname> for dada, um valor 0 serve
	  para indicar uma observação não-censurada, enquanto que um
	  valor 1 indica uma observação censurada à direita (isto é, o
	  período de observação do indivíduo em questão terminou antes que
	  a duração ou o período tenham sido registrados como finalizados).
	  Se <argname>cens</argname> não for dado é assumido que todas as
	  observações são não-censuradas. Observação: a interpretação de
	  <argname>cens</argname> pode ser estendida em algum momento de
	  forma a cobrir outros tipos de censura.
	</para>
	<para>
	  <seelist>
            <fncref targ="kmeier"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="nadarwat" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series">x</fnarg>
	<fnarg type="scalar">h</fnarg>
      </fnargs>
      <description>
	<para>
	  Estimador não paramétrico de Nadaraya&ndash;Watson
	  da média condicional de <argname>y</argname> dado
	  <argname>x</argname>. Retorna uma série contendo
	  a estimativa não-paramétrica de <math>E(y</math><sub>
	  i</sub><math>|x</math><sub>i</sub><math>)</math>
	  para cada valor não ausente da série
	  <argname>x</argname>.
	</para>
	<para context="tex">
	  \[
	  m(x_i) = \frac{ \sum_{j=1}^{n} y_j \cdot K_h(x_i -
	  x_j)} {\sum_{j=1}^{n} K_h(x_i - x_j)}
	  \]
	  onde a função núcleo (ou função kernel) <math>K_h(\cdot)
	  </math> é dada por
	  \[
	  K_h(x) = \exp\left(-\frac{x^2}{2h}\right)
	  \]
	  para $|x| &lt; \tau$ e, caso contrário, zero.
	</para>
	<para context="notex">
	  A função núcleo (ou função kernel) <math>K</math> é dada por
	  <math>K = exp(-x</math><sup>2</sup><math> / 2h)</math> para
	  <math>|x| &lt; T</math> e, caso contrário, zero.
	</para>
	<para context="tex">
	  O argumento <argname>h</argname>, conhecido como \emph{largura de
	  banda} (\emph{bandwidth}), é um número real positivo escolhido
	  pelo usuário. Normalmente este é um número pequeno: maiores valores
	  de $h$ tornam $m(x)$ mais suave. Uma escolha comumente utilizada
	  é $h \propto n^{-0.2}$. Mais detalhes podem ser encontrados no
	  <guideref targ="chap:nonparam"/>.
	</para>
	<para context="notex">
	  O argumento <argname>h</argname>, conhecido como largura de banda
	  (bandwidth), é um número real positivo escolhido pelo usuário.
	  Normalmente este é um número pequeno: maiores valores de <argname>h
	  </argname> tornam <math>m(x)</math> mais suave. Uma escolha comumente
	  utilizada é definir <argname>h</argname> como sendo proporcional a
	  <math>n</math><sup>-0.2</sup>. Mais detalhes podem ser encontrados
	  no <guideref targ="chap:nonparam"/>.
	</para>
	<para context="tex">
	  O escalar $\tau$ é utilizado para prevenir problemas numéricos
	  quando a função núcleo é avaliada em um ponto muito distante de
	  zero e é chamado de parâmetro de truncagem.
	</para>
	<para context="notex">
	  O escalar <math>T</math> é utilizado para prevenir problemas
	  numéricos quando a função núcleo é avaliada em um ponto muito
	  distante de zero e é chamado de parâmetro de truncagem.
	</para>
	<para>
	  O parâmetro de truncagem pode ser alterado através do ajuste
	  de <lit>nadarwat_trim</lit>, como um múltiplo de <argname>h
	  </argname>. O valor padrão é 4.
	</para>
	<para>
	  O usuário pode fornecer valores negativos para a largura de
	  banda: esta é interpretada como sintaxe convencional para obter
	  o estimador leave-one-out. Este é uma variante do estimador
	  que não usa a <math>i</math>-ésima observação para avaliar
	  <math>m(x</math><sub>i</sub><math>)</math>. Isso faz com que
	  o estimador de Nadaraya&ndash;Watson seja mais numericamente
	  robusto e sua utilização é normalmente aconselhada quando o
	  estimador é calculado com o propósito de realizar inferências.
	  Vale salientar que a largura de banda utilizada é, na verdade,
	  o valor absoluto de <argname>h</argname>.
	</para>
	<para context="tex">
          Em termos algébricos, o estimador leave-one-out estimator é dado por:
          \[
          m(x_i) = \frac{ \sum_{j \ne i} y_j \cdot K_h(x_i -
          x_j)} {\sum_{j \ne i} K_h(x_i - x_j)}
          \]
	</para>

      </description>
    </function>

    <function name="nelem" section="data-utils" output="int">
      <fnargs>
	<fnarg type="listetc">L</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o número de elementos no argumento que, por sua vez,
	  pode ser uma lista, uma matriz, um pacote (bundle) ou um arranjo
	  (array). A função não pode ser utilizada em séries.
	</para>
      </description>
    </function>

    <function name="ngetenv" section="strings" output="scalar">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Se uma variável de ambiente de nome <argname>s</argname>
	  estiver definida e possuir um valor numérico a função
	  retorna este valor, caso contrário, retorna NA. Veja
	  também <fncref targ="getenv"/>.
	</para>
      </description>
    </function>

    <function name="nlines" section="strings" output="scalar">
      <fnargs>
	<fnarg type="string">buf</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a quantidade de linhas completas (isto é, linhas que terminam
	  com um caractere de nova linha) em <argname>buf</argname>.
	</para>
    <para>
        Exemplo:
    </para>
    <code>
        string web_page = readfile("http://gretl.sourceforge.net/")
        scalar number = nlines(web_page)
        print number
    </code>
      </description>
    </function>

    <function name="NMmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg optional="true" type="int">maxfeval</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza a maximização numérica via método simplex sem derivadas
	  de Nelder&ndash;Mead. O argumento <argname>b</argname> deve
	  conter os valores iniciais de um conjunto de parâmetros e o
	  argumento <argname>f</argname> deve especificar uma chamada
	  à função que calcule o critério (escalar) a ser maximizado,
	  dados os valores correntes dos parâmetros e quaisquer outros
	  dados que sejam relevantes. Se for completada com sucesso,
	  <lit>NMmax</lit> retorna o valor maximizado do critério e
	  <argname>b</argname> armazena os valores dos parâmetros que
	  maximizam a função.
	</para>
	<para>
	  O terceiro argumento, opcional, pode ser utilizado para determinar
	  o número máximo de avaliações da função. Se for omitido ou
	  for igual a zero o máximo de avaliações será, por padrão, igual
	  a 2000. O valor do argumento <argname>maxfeval</argname> pode ser
	  especificado como um número negativo. Neste caso é tomado o valor
	  absoluto e a função <lit>NMmax</lit> sinaliza um erro se o melhor
	  valor encontrado para a função objetivo, respeitando o número máximo
	  de avaliações de funções, não for um ótimo local. Caso contrário
	  a falta de convergência neste sentido não é tratada como um erro.
	</para>
	<para>
	  Se de fato o objetivo for a minimização, a função pode retornar
	  o valor negativo do critério. Alternativamente pode-se utilizar
	  a função <lit>NMmax</lit> através de sua forma alternativa <lit>
	  NMmin</lit>.
	</para>
	<para>
	  Para maiores detalhes e exemplos <guideref
	  targ="chap:numerical"/>.
	  <seelist>
            <fncref targ="simann"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="NMmin" section="numerical" output="scalar">
      <description>
	<para>
	  É uma forma alternativa da função <fncref targ="NMmax"/>. Se invocada
	  com este nome a função comporta-se como minimizadora.
	</para>
      </description>
    </function>

    <function name="nobs" section="stats" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o número de observações não ausentes para a variável
	  <argname>y</argname> na amostra corrente selecionada.
	</para>
      </description>
    </function>

    <function name="normal" section="probdist" output="series">
      <fnargs>
	<fnarg type="scalar">&mu;</fnarg>
	<fnarg type="scalar">&sigma;</fnarg>
      </fnargs>
      <description>
	<para>
	  Cria uma série de números gaussianos pseudo-aleatórios com
	  média &mu; e desvio padrão &sigma;. Se não forem fornecidos
	  argumentos, será produzida uma série padrão normalizada
	  <math>N</math>(0,1). Os valores são calculados utilizando
	  o método Ziggurat <cite key="marsaglia00" p="true">(Marsaglia e
	  Tsang, 2000)</cite>.
	</para>
	<para>
	  <seelist>
            <fncref targ="randgen"/>
            <fncref targ="mnormal"/>
            <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="normtest" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="string" optional="true">method</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza um teste de normalidade em <argname>y</argname>.
	  Por padrão é utilizado o teste de Doornik&ndash;Hansen, mas
	  é possível escolher outros métodos via argumento opcional
	  <argname>method</argname>. Os testes disponíveis são:
	  <lit>swilk</lit> para o teste de Shapiro&ndash;Wilk, <lit>
	  jbera</lit> para o teste de Jarque&ndash;Bera, ou <lit>lillie
	  </lit> para o de teste Lilliefors.
	</para>
	<para>
	  O segundo argumento pode ser fornecido com ou sem aspas. Porém,
	  quando o argumento estiver na forma de uma variável de texto
	  (string), o valor dessa variável é substituído. Os seguintes
	  exemplos mostram três formas aceitáveis de se realizar o teste
	  de Shapiro&ndash;Wilk:
	</para>
	<code>
	  matrix nt = normtest(y, swilk)
	  matrix nt = normtest(y, "swilk")
	  string testtype = "swilk"
	  matrix nt = normtest(y, testtype)
	</code>
	<para>
	  A matriz retornada tem ordem <by r="1" c="2"/> e armazena a
	  estatística de teste e seu p-valor. Veja também o comando
	  <cmdref targ="normtest"/>.
	</para>
      </description>
    </function>

    <function name="npcorr" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="string" optional="true">method</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula uma medida de correlação entre <argname>x</argname>
	  e <argname>y</argname> utilizando um método não-paramétrico.
	  Se for dado, o terceiro argumento deve ser <lit>kendall</lit>
	  (para a versão b do tau de Kendall, sendo este o método padrão)
	  ou <lit>spearman</lit> (para o rô de Spearman).
	</para>
	<para>
	  O valor de retorno é um vetor de ordem 3 contendo a medida de
	  correlação, a estatística de teste e o p-valor para a hipótese
	  nula de não-autocorrelação. Note que se o tamanho da amostra
	  for muito pequeno a estatística de teste e/ou p-valor podem
	  <lit>NaN</lit> (ou seja, não é um número ou é ausente).
	</para>
	<para>
	  Veja também <fncref targ="corr"/> para a correlação de Pearson.
	</para>
      </description>
    </function>

    <function name="npv" section="math" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg type="scalar">r</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o Valor Presente Líquido (VPL ou NPV) de <argname>x
	  </argname>, considerado como sendo uma sequência de pagamentos
	  (negativos) e recebimentos (positivos), avaliada à taxa de
	  desconto anual <argname>r</argname>, que deve ser expressa
	  como uma fração decimal e não como uma porcentagem (ou seja,
	  0.05 ao invés de 5<lit>%</lit>). O primeiro valor é considerado
	  como sendo o <quote>agora</quote> e não é descontado. Para
	  emular a função <lit>npv</lit> na qual o primeiro valor é
	  descontado, basta inserir um zero no início da sequência.
	</para>
	<para>
	  A função pode ser utilizada com dados anuais, trimestrais, mensais e
	  sem data (neste último caso, os dados são tratados como sendo anuais).
	</para>
	<para>
	  <seelist>
            <fncref targ="irr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="NRmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="fncall" optional="true">g</fnarg>
	<fnarg type="fncall" optional="true">h</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza a maximização numérica via método de Newton&ndash;Raphson.
	  O argumento <argname>b</argname> deve conter os valores
	  iniciais de um conjunto de parâmetros e o argumento
	  <argname>f</argname> deve especificar uma chamada à função
	  que calcule o critério (escalar) a ser maximizado, dados
	  os valores correntes dos parâmetros e quaisquer outros
	  dados que sejam relevantes. Se o objetivo for de fato uma
	  minimização, esta função deverá retornar o negativo do
	  critério. Se for completada com sucesso, <lit>NRmax</lit>
	  retorna o valor maximizado do critério e <argname>b</argname>
	  armazena os valores dos parâmetros que maximizam a função.
	</para>
	<para>
	  O terceiro e o quarto argumento, opcionais, estabelecem
	  uma maneira de fornecer derivadas analíticas e uma hessiana
	  (negativa) analítica, respectivamente. As funções representadas
	  por <argname>g</argname> e <argname>h</argname> devem ter como
	  seus primeiros argumentos uma matriz pré-definida que tenha o
	  tamanho adequado para armazenar o gradiente ou hessiana,
	  respectivamente, dado na forma de ponteiro. Elas também precisam
	  ter o vetor de parâmetros como um argumento (na forma de
	  ponteiro ou não). Outros argumentos são opcionais. Se alguns
	  dos parâmetros opcionais forem omitidos, é utilizada uma
	  aproximação numérica.
	</para>
	<para>
	  Para maiores detalhes e exemplos veja
	  <guideref targ="chap:numerical"/>.
	  <seelist>
            <fncref targ="BFGSmax"/>
            <fncref targ="fdjac"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="NRmin" section="numerical" output="scalar">
      <description>
	<para>
	  É uma forma alternativa da função <fncref targ="NRmax"/>. Se
	  invocada com este nome a função comporta-se como minimizadora.
	</para>
      </description>
    </function>

    <function name="nullspace" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Calcula o espaço nulo direito de <argname>A</argname>,
	  via decomposição em valores singulares: o resultado é
	  uma matriz <math>B</math> tal que o produto <math>AB</math>
	  é uma matriz nula, exceto quando <argname>A</argname>
	  tem posto completo, nesse caso uma matriz vazia é retornada.
	  Caso contrário, se <argname>A</argname> é uma matriz <by r="m"
	  c="n"/>, <math>B</math> terá dimensão <math>n</math> por
	  (<math>n</math> &minus; <math>r</math>), onde <math>r</math>
	  é o posto de <argname>A</argname>.
	</para>
	<para context="notex">
	  Se <argname>A</argname> não tiver posto completo
	  a concatenação vertical de <argname>A</argname> com
	  a transposta de <argname>B</argname> produz uma
	  matriz de posto completo.
	</para>
	<para context="tex">
	  Calcula o espaço nulo direito de <argname>A</argname>,
	  via decomposição em valores singulares: o resultado é
	  uma matriz $B$ tal que
	  \begin{itemize}
	  \item $AB = [0]$, exceto quando $A$
	  tem posto completo, nesse caso uma matriz vazia é retornada.
	  Caso contrário, se $A$ é uma matriz $m \times n$, $B$ será
	  uma matriz $n \times (n-r)$, onde $r$ é o posto de $A$.
	  \item Se $A$ não tiver posto completo a concatenação vertical
	  de $A$ com $B'$ produz uma matriz de posto completo.
	  \end{itemize}
	</para>
    <para>
        Exemplo:
    </para>
    <code>
      A = mshape(seq(1,6),2,3)
      B = nullspace(A)
      C = A | B'

      print A B C

      eval A*B
      eval rank(C)
    </code>
    <para>
        O exemplo acima produz:
    </para>
    <code>
      ? print A B C
      A (2 x 3)

      1   3   5
      2   4   6

      B (3 x 1)

      -0.5
         1
      -0.5

      C (3 x 3)

         1      3      5
         2      4      6
      -0.5      1   -0.5

      ? eval A*B
      -4.4409e-16
      -4.4409e-16

      ? eval rank(C)
      3
    </code>
    <para>
      <seelist>
        <fncref targ="rank"/>
        <fncref targ="svd"/>
      </seelist>
	</para>
      </description>
    </function>

    <function name="numhess" section="numerical" output="matrix">
      <fnargs>
	<fnarg type="cvec">b</fnarg>
	<fnarg type="fncall">fcall</fnarg>
	<fnarg optional="true" type="scalar">d</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula uma aproximação numérica para a hessiana associada
	  ao vetor <argname>b</argname> de ordem <math>n</math> e à
	  função objetivo especificada pelo argumento <argname>fcall</argname>.
	  A chamada à função deve ter <argname>b</argname> como
	  primeiro argumento (de forma direta ou na forma de ponteiro),
	  seguido de quaisquer argumentos adicionais que possam ser
	  necessários. A função retorna um escalar como resultado. Se
	  executada com sucesso, <lit>numhess</lit> retorna uma matriz
	  de ordem <by r="n" c="n"/> contendo a hessiana que, por sua
	  vez, é simétrica por construção.
	</para>
	<para>
	  O método utilizado é a extrapolação de Richardson, com quatro passos.
	  O terceiro argumento, opcional, pode ser utilizado para ajustar a
	  fração <math>d</math> do valor do parâmetro utilizado no ajuste do
	  tamanho do passo inicial. Se este argumento for omitido, será
	  utilizado <math>d</math> = 0,01 como padrão.
	</para>
	<para>
	  Exemplo::
	</para>
	<code>
	  matrix H = numhess(theta, myfunc(&amp;theta, X))
	</code>
	<para>
	  <seelist>
            <fncref targ="BFGSmax"/>
	    <fncref targ="fdjac"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="obs" section="data-utils" output="series">
      <description>
	<para>
	  Retorna uma série de números inteiros consecutivos começando em
	  1 no início do conjunto de dados. Note que esse resultado não é
	  afetado por subamostragem. Essa função é especialmente útil com
	  conjunto de dados de séries temporais. Você também pode escrever
	  <lit>t</lit> ao invés de <lit>obs</lit> para obter a série.
	</para>
	<para>
	  <seelist>
            <fncref targ="obsnum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="obslabel" section="data-utils" output="string">
      <fnargs>
	<fnarg type="int">t</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o rótulo da observação <argname>t</argname>,
	  onde <argname>t</argname> é número que representa
	  esta observação. A função inversa é dada por
	  <fncref targ="obsnum"/>.
	</para>
      </description>
    </function>

    <function name="obsnum" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>obsnum
	  Retorna o número que corresponde a observação especificada pela
	  variável <math>s</math>. Note que o resultado desta função não é
	  afetado por subamostragens. Ela é especialmente útil em dados de
	  séries temporais. Por exemplo, o código seguinte
	</para>
	<code>
	  open denmark
	  k = obsnum(1980:1)
	</code>
	<para>
	  fornece <lit>k = 25</lit>, indicando que o primeiro trimestre de
	  1980 é a vigésima quinta observação nos dados <lit>denmark</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="obs"/>
            <fncref targ="obslabel"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ok" section="data-utils" output="seebelow">
      <fnargs>
	<fnarg type="anyfloat-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>x</argname> for um escalar, retorna 1 se <argname>x
	  </argname> não for <lit>NA</lit>, caso contrário 0. Se <argname>x
	  </argname> for uma série, retorna uma série com valor 1 nas
	  observações sem valores ausentes e 0 onde houver valores ausentes.
	  Se <argname>x</argname> for uma lista, a saída da função é uma
	  série com 0 nas observações onde ao menos uma das séries na lista
	  tenha valor ausente, caso contrário retorna 1.
	</para>
	<para>
	  Se <argname>x</argname> for uma matriz o comportamento da função
	  é um pouco diferente, uma vez que matrizes não podem conter <lit>
	  NA</lit>'s. Assim, nesse caso, a função retorna uma matriz com as
	  mesmas dimensões que <argname>x</argname>, com 1's nas posições
	  com elementos finitos de <argname>x</argname> and 0's nas posições
	  onde os elementos são não-finitos (podendo ser números infinitos
	  ou NaN, conforme padrão IEEE 754).
	</para>
	<para>
	  <seelist>
            <fncref targ="missing"/>
            <fncref targ="misszero"/>
            <fncref targ="zeromiss"/>
	  </seelist>
	  Mas note que essas funções não são aplicáveis no caso de matrizes.
	</para>
      </description>
    </function>

    <function name="onenorm" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Retorna a norma-1 da matriz <argname>X</argname>, isto é,
	  a máxima soma dos valores absolutos dos elementos de cada
	  coluna de <argname>X</argname>.
	</para>
	<para context="tex">
	  Retorna a norma-1 of the $r \times c$ matrix
	  <argname>X</argname>:
	  \[\| X \|_1 = \max_j \sum_{i=1}^r |X_{ij}| \]
	</para>
	<para>
	  <seelist>
            <fncref targ="infnorm"/>
            <fncref targ="rcond"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ones" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma matriz com <math>r</math> linhas e <math>c</math>
	  colunas preenchida com valores iguais a 1.
	</para>
	<para>
	  <seelist>
            <fncref targ="seq"/>
            <fncref targ="zeros"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="orthdev" section="transforms" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Aplicável apenas quando o conjunto de dados atualmente aberto é composto
	  por dados em painel. Calcula os desvios ortogonais anteriores (ou seja, o
	  desvio entre <math>t</math> e <math>t+1</math>) da variável <argname>y
	  </argname>.
	</para>
	<para context="tex">
	  Aplicável apenas quando o conjunto de dados atualmente aberto é composto
	  por dados em painel. Calcula os desvios ortogonais anteriores (ou seja, o
	  desvio entre $t$ e $t+1$) da variável <argname>y</argname>, isto é
	  \[ \tilde{y}_{i,t} =
	  \sqrt{ \frac{T_i - t}{T_i - t + 1}} \left( y_{i,t} -
	  \frac{1}{T_i - t} \sum_{s=t+1}^{T_i} y_{i,s} \right) \]
	</para>
	<para>
	  Esta transformação é realizada algumas vezes ao invés da diferenciação
	  para remover efeitos individuais do dado em painel. Para fins de
	  compatibilidade com a primeira diferença, os desvios são armazenados
	  um paso à frente em relação à sua verdadeira localização temporal (isto
	  é, o valor na observação <math>t</math> é o desvio que, estritamente
	  falando, pertence ao tempo <math>t</math> &minus;1). Assim, perde-se a
	  primeira observação em cada série de tempo, e não a última.
	</para>
	<para>
	  <seelist>
            <fncref targ="diff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pdf" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <examples>
	<example>f1 = pdf(N, -2.5)</example>
	<example>f2 = pdf(X, 3, y)</example>
	<example>f3 = pdf(W, forma, escala, y)</example>
      </examples>
      <description>
	<para>
	  Calculadora de função densidade de probabilidade. Retorna
	  a densidade em <argname>x</argname> da distribuição
	  identificada pelo código <argname>d</argname>. Veja
	  <fncref targ="cdf"/> para detalhes acerca dos argumentos
	  (escalares) requeridos. As distribuições suportadas pela
	  função <lit>pdf</lit> são: normal, <math>t</math> de
	  Student, qui-quadrado, <math>F</math>, Gama, Exponencial,
	  Weibull, Laplace, Erro Generalizado, Binomial e Poisson.
	  Note que para a Binomial e a Poisson o que de fato é
	  calculado é a massa de probabilidade no ponto especificado.
	  Para <math>t</math> de Student, qui-quadrado e <math>F</math>
	  também estão disponíveis as suas variantes não-centrais.
	</para>
	<para>
	  Para a distribuição normal veja também <fncref targ="dnorm"/>.
	</para>
      </description>
    </function>

    <function name="pergm" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg optional="true" type="scalar">bandwidth</fnarg>
      </fnargs>
      <description>
	<para>
	  Se apenas o primeiro argumento for dado, calcula o periodograma da
	  amostra para dada variável ou vetor. Se o segundo argumento for dado,
	  calcula uma estimativa do espectro de <argname>x</argname> utilizando
	  janela de defasagem de Bartlett para a largura de banda dada, até o
	  número de observações (<math>T</math>/2).
	</para>
	<para>
	  Retorna uma matriz com duas colunas e <math>T</math>/2 linhas:
	  a primeira coluna contendo a frequência, &omega;, de
	  2&pi;/<math>T</math> até &pi; e a segunda contendo a densidade
	  espectral correspondente.
	</para>
      </description>
    </function>

    <function name="pexpand" section="data-utils" output="series">
      <fnargs>
	<fnarg type="vector">v</fnarg>
      </fnargs>
      <description>
	<para>
	  É aplicável somente se o conjunto de dados corrente tiver uma
	  estrutura de painel. Realiza a operação inversa de
	  <fncref targ="pshrink"/>. Isto é, dado um vetor de comprimento
	  igual ao número de indivíduos na amostra (de painel) corrente,
	  retorna uma série na qual cada valor é repetido <math>T</math>
	  vezes, onde <math>T</math> representa o comprimento temporal
	  do painel. A série resultante é dessa forma não variante em
	  relação ao tempo.
	</para>
      </description>
    </function>

    <function name="pmax" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para>
	  É aplicável somente se o conjunto de dados corrente tiver uma
	  estrutura de painel. Retorna uma série contendo o máximo da
	  variável <argname>y</argname> para cada unidade de corte
	  transversal (isso é repetido parar cada período de tempo).
	</para>
	<para>
	  Se o segundo argumento (opcional) for fornecido, as
	  observações onde o valor de <argname>mask</argname>
	  for igual a zero são ignoradas.
	</para>
	<para>
	  <seelist>
            <fncref targ="pmin"/>
            <fncref targ="pmean"/>
            <fncref targ="pnobs"/>
            <fncref targ="psd"/>
            <fncref targ="pxsum"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pmean" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  É aplicável somente se o conjunto de dados corrente tiver uma
	  estrutura de painel. Retorna uma série contendo a média temporal
	  da variável <argname>y</argname> para cada unidade de corte
	  transversal. Os valores são repetidos para cada período e as
	  observações ausentes são ignoradas no cálculo das médias.
	</para>
	<para context="tex">
	  É aplicável somente se o conjunto de dados corrente tiver uma
	  estrutura de painel. Calcula a média temporal de
	  <argname>y</argname> para cada unidade de corte transversal, isto
	  é, \[ \bar{y}_i = \frac{1}{T_i} \sum_{t=1}^{T_i} y_{i,t}\]
	  onde $T_i$ é o número de observações válidas da unidade
	  $i$.
	</para>
	<para>
	  Se o segundo argumento (opcional) for fornecido, as
	  observações onde o valor de <argname>mask</argname>
	  for igual a zero são ignoradas.
	</para>
	<para>
	  <seelist>
            <fncref targ="pmax"/>
            <fncref targ="pmin"/>
            <fncref targ="pnobs"/>
            <fncref targ="psd"/>
            <fncref targ="pxsum"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pmin" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para>
	  É aplicável somente se o conjunto de dados corrente tiver uma
	  estrutura de painel. Retorna uma série contendo o mínimo da
	  variável <argname>y</argname> para cada unidade de corte
	  transversal (isso é repetido para cada período de tempo).
	</para>
	<para>
	  Se o segundo argumento (opcional) for fornecido, as
	  observações onde o valor de <argname>mask</argname>
	  for igual a zero são ignoradas.
	</para>
	<para>
	  <seelist>
            <fncref targ="pmax"/>
            <fncref targ="pmean"/>
            <fncref targ="pnobs"/>
            <fncref targ="psd"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pnobs" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para>
	  É aplicável somente se o conjunto de dados corrente tiver uma
	  estrutura de painel. Retorna uma série contendo o número de
	  observações válidas em <argname>y</argname> para cada unidade
	  de corte transversal (isso é repetido para cada período de tempo).
	</para>
	<para>
	  Se o segundo argumento (opcional) for fornecido, as
	  observações onde o valor de <argname>mask</argname>
	  for igual a zero são ignoradas.
	</para>
	<para>
	  <seelist>
            <fncref targ="pmax"/>
            <fncref targ="pmin"/>
            <fncref targ="pmean"/>
            <fncref targ="psd"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="polroots" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="vector">a</fnarg>
      </fnargs>
      <description>
	<para>
	  Encontra as raízes de um polinômio. Se o polinômio for de ordem
	  <math>p</math>, o vetor <argname>a</argname> deverá conter
	  <math>p</math> + 1 coeficientes em ordem crescente, &ie; iniciando
	  com a constante e terminando com o coeficiente de
	  <math>x</math><sup>p</sup>.
	</para>
	<para>
	  Se todas as raízes forem reais elas serão retornadas em um
	  vetor coluna de comprimento <math>p</math>, caso contrário uma
	  matriz de ordem <by r="p" c="2"/> será retornada, com as partes
	  reais na primeira coluna e as partes imaginárias na segunda.
	</para>
      </description>
    </function>

    <function name="polyfit" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int">q</fnarg>
      </fnargs>
      <description>
	<para>
	  Ajusta uma tendência polinomial de ordem <argname>q</argname> à
	  série <argname>y</argname> usando o método dos
	  polinômios ortogonais. A série retornada contém os valores
	  ajustados.
	</para>
      </description>
    </function>

    <function name="princomp" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">p</fnarg>
	<fnarg optional="true" type="bool">covmat</fnarg>
      </fnargs>
      <description>
	<para>
	  Seja a matriz <argname>X</argname> de ordem <by r="T" c="k"/>,
	  contendo <math>T</math> observações de <math>k</math>
	  variáveis. O argumento <argname>p</argname> deve ser um
	  inteiro positivo menor ou igual a <math>k</math>. Esta função
	  retorna a matriz de ordem <by r="T" c="p"/>, <math>P</math>,
	  contendo os primeiros <math>p</math> principais componentes de
	  <argname>X</argname>.
	</para>
	<para>
	  O terceiro argumento, opcional, age como uma chave booleana: se for
	  um valor não-nulo os componentes principais são calculados com base
	  na matriz de covariâncias das colunas de <argname>X</argname>
	  (o padrão desta função é a utilização da matriz de correlação).
	</para>
	<para context="notex">
	  Os elementos de <math>P</math> são calculados como sendo a soma de
	  <math>i</math> até <math>k</math> de
	  <math>Z</math><sub>ti</sub> multiplicado por
	  <math>v</math><sub>ji</sub>, onde
	  <math>Z</math><sub>ti</sub> é o valor padronizado da
	  variável <math>i</math> na observação <math>t</math> e
	  <math>v</math><sub>ji</sub> é o <math>j</math>-ésimo
	  autovetor da matriz de correlação (ou covariância) dos
	  <math>X</math><sub>i</sub>s, com os autovetores ordenados
	  de forma decrescente de acordo com o valores dos autovalores
	  correspondentes.
	</para>
	<para context="tex">
	  Os elementos de $P$ são calculados como
	  \[ P_{tj} = \sum_{i=1}^{k} Z_{ti} \, v^{(j)}_i \]
	  onde $Z_{ti}$ é o valor padronizado da
	  variável $i$ na observação $t$, $Z_{ti} = (X_{ti} -
	  \bar{X}_i) / \hat{\sigma}_i$, e $v^{(j)}_i$ é o $j$-ésimo
	  autovetor da matriz de correlação (ou covariância) dos
	  $X_i$s, com os autovetores ordenados de forma decrescente
	  de acordo com o valores dos autovalores
	  correspondentes.
	</para>
	<para>
	  <seelist>
            <fncref targ="eigensym"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="prodc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o produto dos elementos das colunas de
	  <argname>X</argname>.
	  <seelist>
            <fncref targ="prodr"/>
            <fncref targ="meanc"/>
            <fncref targ="sdc"/>
            <fncref targ="sumc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="prodr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o produto dos elementos das linhas de
	  <argname>X</argname>.
	  <seelist>
            <fncref targ="prodc"/>
            <fncref targ="meanr"/>
            <fncref targ="sumr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="psd" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  É aplicável somente se o conjunto de dados corrente tiver uma
	  estrutura de painel. Retorna uma série contendo desvio padrão
	  amostral da variável <math>y</math> para cada unidade de corte
	  transversal (sendo os valores repetidos para cada período de
	  tempo). O denominador utilizado o tamanho da amostra em cada
	  unidade menos 1, a menos que o número de observações válidas
	  para dada unidade ser 1 (nesse caso será retornado 0) ou 0
	  (nesse caso será retornado <lit>NA</lit>).
	</para>
	<para context="tex">
	  É aplicável somente se o conjunto de dados corrente tiver uma
	  estrutura de painel. Calcula o desvio padrão amostral da variável
	  <math>y</math> para cada unidade de corte transversal, isto é,
	   \[ \sigma_i = \sqrt{\frac{1}{T_i - 1} \sum_{t=1}^{T_i} (y_{i,t} -
	  \bar{y}_i)^2 } \] A fórmula acima mantém-se para $T_i \ge 2$,
	  onde $T_i$ é o número de observações válidas para a unidade
	  $i$. Se $T_i = 0$ será retornado <lit>NA</lit> e se $T_i = 1$
	  será retornado 0.
	</para>
	<para>
	  Se o segundo argumento (opcional) for fornecido, as
	  observações onde o valor de <argname>mask</argname>
	  for igual a zero são ignoradas.
  </para>
	<para>
	  Observação: essa função torna possível testar se dada variável
	  (como por exemplo, <lit>X</lit>) não varia ao longo do tempo
	  utilizando a condição <lit>max(psd(X)) == 0</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="pmax"/>
            <fncref targ="pmin"/>
            <fncref targ="pmean"/>
            <fncref targ="pnobs"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="psdroot" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="symmat">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula a variante generalizada da decomposição de Cholesky da
	  matriz <argname>A</argname>, que deve ser positiva semi-definida
	  (mas que pode ser singular). Se a matriz de entrada não for
	  quadrada é sinalizado um erro, apesar disso, a simetria é assumida
	  pela função, mas não verificada. Apenas o triângulo inferior de
	  <argname>A</argname> é lido. O resultado é uma matriz triangular
	  inferior <math>L</math> que satisfaz <equation status="inline"
	  ascii="A = LL'" tex="$A = LL'$"/>. Elementos indeterminados na
	  solução são zerados.
	</para>
	<para>
	  Para o caso onde <argname>A</argname> é positivo definido,
	  veja <fncref targ="cholesky"/>.
	</para>
      </description>
    </function>

    <function name="pshrink" section="data-utils" output="matrix">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  É aplicável somente se o conjunto de dados corrente tiver uma
	  estrutura de painel. Retorna um vetor coluna contendo a primeira
	  observação válida da série <argname>y</argname> para cada unidade
	  de corte transversal no painel, ao longo extensão da amostra
	  corrente. Se uma unidade não possuir observações válidas da série
	  de entrada ela será ignorada.
	</para>
	<para>
	  Essa função fornece uma maneira de compactar as séries
	  retornadas por funções como <fncref targ="pmax"/> e
	  <fncref targ="pmean"/>, nas quais um valor pertencente a
	  cada unidade de corte transversal é repetido para cada
	  período de tempo.
	</para>
	<para>
	  Veja <fncref targ="pexpand"/> para a operação inversa.
	</para>
      </description>
    </function>

    <function name="psum" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  É aplicável somente se o conjunto de dados corrente tiver uma
	  estrutura de painel. Retorna uma série contendo a soma ao longo
	  do tempo da variável <argname>y</argname> para cada unidade de
	  corte transversal. Os valores são repetidos para cada período e
	  as observações ausentes são ignoradas no cálculo das somas.
	</para>
	<para context="tex">
	  É aplicável somente se o conjunto de dados corrente tiver
	  uma estrutura de painel. Calcula a soma ao longo do tempo
	  da variável <argname>y</argname> para cada unidade de corte
	  transversal, isto é, \[ S_i = \sum_{t=1}^{T_i} y_{i,t}\]
	  onde $T_i$ é o número de observações válidas da unidade
	  $i$.
	</para>
	<para>
	  Se o segundo argumento (opcional) for fornecido, as
	  observações onde o valor de <argname>mask</argname>
	  for igual a zero são ignoradas.
	</para>
	<para>
	  <seelist>
            <fncref targ="pmax"/>
            <fncref targ="pmean"/>
            <fncref targ="pmin"/>
            <fncref targ="pnobs"/>
            <fncref targ="psd"/>
            <fncref targ="pxsum"/>
            <fncref targ="pshrink"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pvalue" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="char">c</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <examples>
	<example>p1 = pvalue(z, 2.2)</example>
	<example>p2 = pvalue(X, 3, 5.67)</example>
	<example>p2 = pvalue(F, 3, 30, 5.67)</example>
      </examples>
      <description>
	<para>
	  Calculadora de <math>P</math>-valores. Retorna <equation
	  status="inline" ascii="P(X > x)" tex="$P(X > x)$"/>, onde
	  a distribuição de <math>X</math> é especificada pela letra
	  <argname>c</argname>. Entre os argumentos
	  <argname>c</argname> e <argname>x</argname>, zero ou mais
	  argumentos adicionais são necessários para que especifique
	  os parâmetros da distribuição. Veja <fncref targ="cdf"/>
	  para detalhes. As distribuições suportadas pela função
	  <lit>pvalue</lit> são: normal padrão, <math>t</math>,
	  qui-quadrada, <math>F</math>, gama, binomial, Poisson,
	  Weibull e Erro Generalizado.
	</para>
	<para>
	  <seelist>
            <fncref targ="critical"/>
            <fncref targ="invcdf"/>
            <fncref targ="urcpval"/>
            <fncref targ="imhof"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pxnobs" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para>
	  É aplicável somente se o conjunto de dados corrente tiver uma
	  estrutura de painel. Retorna uma série contendo o número de
	  observações válidas de <argname>y</argname> em cada período
	  de tempo (essa operação é repetida para cada unidade de corte transversal).
	</para>
	<para>
	  Se o segundo argumento (opcional) for fornecido, as
	  observações onde o valor de <argname>mask</argname>
	  for igual a zero são ignoradas.
	</para>
	<para>
	  Note que esta função opera em uma dimensão diferente da função
	  <fncref targ="pnobs"/>.
	</para>
      </description>
    </function>

    <function name="pxsum" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  É aplicável somente se o conjunto de dados corrente tiver uma estrutura
	  de painel. Retorna uma série contendo a soma dos valores de
	  <argname>y</argname> para cada unidade de corte transversal em cada
	  período de tempo (sendo os valores repetidos para cada unidade de corte).
	</para>
	<para context="tex">
	  É aplicável somente se o conjunto de dados corrente tiver
	  uma estrutura de painel. Calcula a dos valores da variável
	  <argname>y</argname> em cada período de tempo. Isto é,
	  \[ \tilde{y}_t = \sum_{i=1}^{N} y_{i,t}\] onde $N$ é o
	  número de unidades de corte transversal.
	</para>
	<para>
	  Se o segundo argumento (opcional) for fornecido, as
	  observações onde o valor de <argname>mask</argname>
	  for igual a zero são ignoradas.
	</para>
	<para>
	  Note que esta função opera em uma dimensão diferente da função
	  <fncref targ="psum"/>.
	</para>
      </description>
    </function>

    <function name="qform" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">x</fnarg>
	<fnarg type="symmat">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Calcula a forma quadrática <equation status="inline"
	  ascii="Y = xAx'" tex="$Y = x A x'$"/>. A utilização desta
	  função, ao invés da multiplicação matricial comum, garante
	  mais velocidade e maior precisão quando <argname>A</argname>
	  é uma matriz simétrica genérica. Porém, no caso especial
	  onde <argname>A</argname> é uma matriz identidade, a simples
	  expressão <lit>x'x</lit> tem desempenho bastante superior em
	  relação a <lit>qform(x',I(rows(x))</lit>.
	</para>
	<para context="tex">
	  Calcula a forma quadrática <equation status="inline"
	  ascii="Y = xAx'" tex="$Y = x A x'$"/>.  A utilização desta
	  função, ao invés da multiplicação matricial comum, garante
	  mais velocidade e maior precisão quando <argname>A</argname>
	  é uma matriz simétrica genérica. Porém, no caso especial
	  <equation status="inline" ascii="A = I" tex="$A = I$"/>, a
	  simples expressão <lit>x'x</lit> tem desempenho bastante
	  superior em relação a <lit>qform(x',I(rows(x))</lit>.
	</para>
	<para>
	  Se <argname>x</argname> e <argname>A</argname> não forem
	  compatíveis, ou <argname>A</argname> não for simétrica, é
	  retornado um erro.
	</para>
      </description>
    </function>

    <function name="qlrpval" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="scalar">X2</fnarg>
	<fnarg type="int">df</fnarg>
	<fnarg type="scalar">p1</fnarg>
	<fnarg type="scalar">p2</fnarg>
      </fnargs>
      <description>
	<para>
	  Fornece os <math>p</math>-valores para a estatística de
	  teste do teste sup-Wald QLR para uma quebra estrutural em
	  um ponto desconhecido (veja <cmdref targ="qlrtest"/>),
	  conforme <cite key="hansen97">Hansen (1997)</cite>.
	</para>
	<para>
	  O primeiro argumento, <argname>X2</argname>, representa a
	  máxima estatística de teste (na forma de qui-quadrado) de
	  Wald e <argname>df</argname> representa os graus de liberdade.
	  O terceiro e o quarto argumento representa, na forma de
	  frações decimais da amplitude de estimação geral, os pontos
	  inicial e final da amplitude central das observações ao longo
	  das quais os sucessivos testes de Wald são calculados. Por
	  exemplo, se a abordagem padrão de corte de 15 por cento for
	  utilizada <argname>p1</argname> deve ser igual a 0.15 e
	  <argname>p2</argname> igual a 0.85.
	</para>
	<para>
	  <seelist>
            <fncref targ="pvalue"/>
	    <fncref targ="urcpval"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="qnorm" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna os quantis para a distribuição normal padrão. Se
	  <argname>x</argname> não estiver entre 0 e 1, será retornado
	  <lit>NA</lit>.
	  <seelist>
            <fncref targ="cnorm"/>
            <fncref targ="dnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="qrdecomp" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;R</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula a decomposição QR de uma matriz <argname>X</argname> de ordem
	  <by r="m" c="n"/>, isto é, <math>X = QR</math> onde <math>Q</math> é
	  uma matriz ortogonal <by r="m" c="n"/> e <math>R</math> é uma matriz
	  triangular superior <by r="n" c="n"/>. A matriz <math>Q</math> é
	  retornada diretamente, enquanto que <math>R</math> pode ser obtida
	  via utilização do segundo argumento (opcional).
	</para>
	<para>
	  <seelist>
            <fncref targ="eigengen"/>
            <fncref targ="eigensym"/>
            <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="quadtable" section="stats" output="matrix">
      <fnargs>
	<fnarg type="int">n</fnarg>
	<fnarg type="int" optional="true">type</fnarg>
	<fnarg type="scalar" optional="true">a</fnarg>
	<fnarg type="scalar" optional="true">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma matriz de ordem <by r="n" c="2"/> para utilização
	  a quadratura gaussiana (integração numérica). A primeira
	  coluna contém os nós ou abscissas e a segunda os pesos.
	</para>
	<para>
	  O primeiro argumento especifica o número de pontos (linhas)
	  a serem computados. O segundo argumento indica o tipo de
	  quadratura: use 1 para Gauss&ndash;Hermite (tipo padrão);
	  2 para Gauss&ndash;Legendre; ou 3 para Gauss&ndash;Laguerre.
	  O significado dos parâmetros opcionais <argname>a</argname>
	  e <argname>b</argname> dependem da escolha do argumento
	  <argname>type</argname>, conforme explicado a seguir.
	</para>
	<para context="notex">
	  A quadratura gaussiana é um método para aproximar numericamente
	  a integral definida de dada função de interesse. Seja a
	  função representada pelo produto <math>f(x)W(x)</math>.
	  Os tipos de quadratura diferem de acordo com a especificação
	  do componente <math>W(x)</math>: no caso de Hermite ela é
	  definida como exp(&minus;<math>x</math><sup>2</sup>); no caso
	  de Laguerre, exp(&minus;<math>x</math>); e no caso de Legendre
	  como <math>W(x)</math> = 1.
	</para>
	<para context="tex">
	  A quadratura gaussiana é um método para aproximar numericamente
	  a integral definida de dada função de interesse. Seja a
	  função representada pelo produto $f(x)W(x)$. Os tipos de
	  quadratura diferem de acordo com a especificação do componente
	  $W(x)$: no caso de Hermite ela é definida como $W(x) = \exp(-x^2)$;
	  no caso de Laguerre, $W(x) = \exp(-x)$; e no caso de Legendre
	  $W(x) = 1$.
	</para>
	<para context="notex">
	  Para cada especificação de <math>W</math>, pode-se calcular um
	  conjunto de abscissas, <math>x</math><sub>i</sub>, e pesos,
	  <math>w</math><sub>i</sub>, tais que o somatório de
	  <math>i</math>=1 até <math>n</math> de
	  <math>w</math><sub>i</sub>
	  <math>f</math>(<math>x</math><sub>i</sub>) se aproxima da
	  integral desejada. O método de <cite key="golub69">Golub
	  e Welsch (1969)</cite> é utilizado.
	</para>
	<para context="tex">
	  Para cada especificação de $W(x)$, pode-se calcular um conjunto
	  de abscissas, $x_i$, e pesos, $w_i$, tais que $\sum_{i=1}^n
	  f(x_i) w_i$ se aproxima da integral desejada. O método de
	  <cite key="golub69">Golub e Welsch (1969)</cite> é utilizado.
	</para>
	<para context="notex">
	  Quando o tipo Gauss&ndash;Legendre é selecionado, os argumentos
	  opcionais <argname>a</argname> e <argname>b</argname> podem ser
	  utilizados para controlar os limites inferior e superior de
	  integração, sendo os valores padrão &minus;1 e 1. Na quadratura
	  de Hermite os limites são fixados entre menos infinito e mais
	  infinito, enquanto que no caso de Laguerre eles são fixados
	  entre zero e infinito.
	</para>
	<para context="tex">
	  Quando o tipo Gauss&ndash;Legendre é selecionado, os argumentos
	  opcionais <argname>a</argname> e <argname>b</argname> podem ser
	  utilizados para controlar os limites inferior e superior de
	  integração, sendo os valores padrão $-1$ e 1. Na quadratura de
	  Hermite os limites são fixados entre $-\infty$ e $+\infty$,
	  enquanto que no caso de Laguerre eles são fixados entre 0 e $\infty$.)
	</para>
	<para context="notex">
	  No caso de Hermite <argname>a</argname> e <argname>b
	  </argname> exercem um papel diferente: eles podem ser
	  utilizados para substituir a forma padrão de <math>W
	  </math>(<math>x</math>) pela (proximanente relacionada)
	  distribuição normal com média <argname>a</argname> e
	  desvio padrão <argname>b</argname>. Fornecendo os
	  valores de 0 e 1 para estes parâmetros, por exemplo,
	  tem o efeito de transformar <math>W</math>(<math>x
	  </math>) em uma FDP normal padrão, que é equivalente
	  a multiplicar as abscissas padrão pela raiz quadrada
	  de dois e dividir os pesos pela raiz quadrada de &pi;.
	</para>
	<para context="tex">
	  No caso de Hermite <argname>a</argname> e <argname>b
	  </argname> exercem um papel diferente: eles podem ser
	  utilizados para substituir a forma padrão de $W(x)$
	  pela (proximamente relacionada) distribuição normal
	  com média <argname>a</argname> desvio padrão <argname>
	  b</argname>. Fornecendo os valores de 0 e 1 para estes
	  parâmetros, por exemplo, tem o efeito de transformar
	  $W(x)$ em uma FDP normal padrão, que é equivalente a
	  multiplicar os valores padrão $x_i$ por $\sqrt{2}$ e
	  dividir os valores padrão de $w_i$ por $\sqrt{\pi}$.
	</para>
      </description>
    </function>

    <function name="quantile" section="stats" output="scalar" altout="matrix">
      <fnargs>
	<fnarg type="series-or-mat">y</fnarg>
	<fnarg type="pscalar">p</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>y</argname> for uma série, retorna o quantil
	  <argname>p</argname> da série. Por exemplo, quando <math>
	  p</math> = 0,5, a mediana é retornada.
	</para>
	<para>
	  Se <argname>y</argname> for uma matriz, retorna um vetor
	  linha contendo os <argname>p</argname>-quantis das colunas
	  de <argname>y</argname>. Isto é, cada coluna é tratada
	  como sendo uma série.
	</para>
	<para>
	  Adicionalmente, para a matriz <argname>y</argname> existe uma
	  segunda alternativa para o segundo argumento: <argname>p
	  </argname> pode ser dado como um vetor. Nesse caso o valor de
	  retorno é uma matriz de ordem <by r="m" c="n"/> onde <repl>m
	  </repl> representa o número de elementos em <argname>p</argname>
	  e <repl>n</repl> é o número de colunas em <argname>y</argname>.
	</para>
	<para context="tex">
	  Para uma série de comprimento $n$, o $p$-ésimo quantil, $q$, é
	  definido como:
	  \[q = y_{[k]} + [(n+1) \cdot p - k] (y_{[k+1]} - y_{[k]})\]
	  onde $k$ é a parte inteira de $(n+1) \cdot p$ e
	  $y_{[i]}$ é o $i$-ésimo elemento da série quando ordenada do
	  menor para o maior valor.
	</para>
      </description>
    </function>

    <function name="randgen" section="probdist" output="series">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="scalar-or-series">p1</fnarg>
	<fnarg type="scalar-or-series" conditional="true">p2</fnarg>
	<fnarg type="scalar" conditional="true">p3</fnarg>
      </fnargs>
      <examples>
	<example>series x = randgen(u, 0, 100)</example>
	<example>series t14 = randgen(t, 14)</example>
	<example>series y = randgen(B, 0.6, 30)</example>
	<example>series g = randgen(G, 1, 1)</example>
	<example>series P = randgen(P, mu)</example>
      </examples>
      <description>
	<para>
	  Gerador de número aleatório de uso geral. O argumento
	  <argname>d</argname> é um texto (string)
	  (sendo geralmente composto por apenas um caractere) que
	  especifica a distribuição da qual serão extraídos os
	  pseudo-números. Os argumentos <argname>p1</argname> a
	  <argname>p3</argname> especificam os parâmetros da
	  distribuição selecionada, sendo que o número de parâmetros
	  depende da distribuição escolhida. Para distribuições que
	  não a beta-binomial, os parâmetros <argname>p1</argname>
	  e <argname>p2</argname> (se for aplicável) podem estar na
	  forma escalar ou de série. Se forem utilizados na forma
	  escalar a série resultante será identicamente distribuída.
	  Se forem utilizadas séries em <argname>p1</argname> ou
	  <argname>p2</argname> a distribuição será condicional ao
	  valor do parâmetro em cada observação. No caso da
	  beta-binomial todos os parâmetros devem ser escalares.
	</para>
	<para>
	  Especificidades são apresentadas abaixo: o código para
	  cada distribuição é mostrado entre parênteses, seguido
	  da interpretação do argumento <argname>p1</argname> e,
	  quando for aplicável, <argname>p2</argname> e
	  <argname>p3</argname>.
	</para>

	<ilist context="notex">
	  <li>
            <para>
              Uniforme (contínua) (u ou U): mínimo, máximo
            </para>
	  </li>
	  <li>
            <para>
              Uniforme (discreta) (i): mínimo, máximo
            </para>
	  </li>
	  <li>
            <para>
              Normal (z, n ou N): média, desvio padrão
            </para>
	  </li>
	  <li>
            <para>
              t de Student (t): graus de liberdade
            </para>
	  </li>
	  <li>
            <para>
              Qui-quadrado (c, x ou X): graus de liberdade
            </para>
	  </li>
	  <li>
            <para>
              F de Snedecor (f ou F): graus de liberdade (num.), graus de liberdade (den.)
            </para>
	  </li>
	  <li>
            <para>
              Gama (g ou G): forma, escala
            </para>
	  </li>
	  <li>
            <para>
              Binomial (b ou B): probabilidade, quantidade de tentativas
            </para>
	  </li>
	  <li>
            <para>
              Poisson (p ou P): média
            </para>
	  </li>
	  <li>
            <para>
              ExponenCial (exp): escala
            </para>
	  </li>
	  <li>
            <para>
              Weibull (w ou W): forma, escala
            </para>
	  </li>
	  <li>
            <para>
              Laplace (l ou L): média, escala
            </para>
	  </li>
	  <li>
            <para>
              Erro Generalizado (E): forma
            </para>
	  </li>
	  <li>
            <para>
              Beta (beta): forma1, forma2
            </para>
	  </li>
	  <li>
            <para>
              Beta-Binomial (bb): tentativas, forma1, forma2
            </para>
	  </li>
	</ilist>
	<tabular colspec="lllll">
	  \textbf{Distribuição} &amp; \textsl{d} &amp; \textsl{p1} &amp; \textsl{p2} &amp; \textsl{p3}\\[4pt]
	  Uniforme (contínua) &amp; \texttt{u} ou \texttt{U} &amp; mínimo &amp; máximo &amp; --\\
	  Uniforme (discreta) &amp; \texttt{i} &amp; mínimo &amp; máximo &amp; --\\
	  Normal &amp; \texttt{z}, \texttt{n} ou \texttt{N} &amp; média &amp; desvio padrão &amp; --\\
	  $t$ de Student &amp; \texttt{t} &amp; graus de liberdade &amp; -- &amp; --\\
	  Qui-quadrado &amp; \texttt{c}, \texttt{x} ou \texttt{X} &amp; graus de liberdade &amp; -- &amp; --\\
	  $F$ de Snedecor &amp; \texttt{f} ou \texttt{F} &amp; g.l. (num.) &amp; g.l. (den.) &amp; --\\
	  Gama &amp; \texttt{g} ou \texttt{G} &amp; forma &amp; escala  &amp; --\\
	  Binomial &amp; \texttt{b} ou \texttt{B} &amp; $p$ &amp; $n$  &amp; --\\
	  Poisson &amp; \texttt{p} ou \texttt{P} &amp; média &amp; --  &amp; --\\
	  Exponencial &amp; \texttt{exp} &amp; escala &amp; -- &amp; --\\
	  Weibull &amp; \texttt{w} ou \texttt{W} &amp; forma &amp; escala &amp; --\\
	  Laplace &amp; \texttt{l} ou \texttt{L} &amp; média &amp; escala &amp; --\\
	  Erro Generalizado &amp; \texttt{e} ou \texttt{E} &amp; forma &amp; -- &amp; --\\
	  Beta &amp; \texttt{beta} &amp; forma1 &amp; forma2 &amp; --\\
	  Beta-Binomial &amp; \texttt{bb} &amp; $n$ &amp; forma1 &amp; forma2
	</tabular>
	<para>
	  <seelist>
            <fncref targ="normal"/>
            <fncref targ="uniform"/>
            <fncref targ="mrandgen"/>
            <fncref targ="randgen1"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="randgen1" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="char">d</fnarg>
	<fnarg type="scalar">p1</fnarg>
	<fnarg type="scalar" conditional="true">p2</fnarg>
      </fnargs>
      <examples>
	<example>scalar x = randgen1(z, 0, 1)</example>
	<example>scalar g = randgen1(g, 3, 2.5)</example>
      </examples>
      <description>
	<para>
	  Funciona da mesma forma que <fncref targ="randgen"/> exceto
	  pelo fato de retornar um escalar ao invés de uma série.
	</para>
	<para>
	  O primeiro exemplo acima retorna um valor da distribuição
	  normal padrão, enquanto que o segundo especifica um valor
	  a ser extraído da distribuição Gama com forma 3 e escala 2.5.
	</para>
	<para>
	  <seelist>
            <fncref targ="mrandgen"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="randint" section="probdist" output="int">
      <fnargs>
	<fnarg type="int">min</fnarg>
	<fnarg type="int">max</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna um inteiro pseudo-aleatório no intervalo fechado
	  [<argname>min</argname>, <argname>max</argname>].
	  <seelist>
	    <fncref targ="randgen"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="rank" section="linalg" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o posto de <argname>X</argname>, calculada numericamente
	  via decomposição em valores singulares.
	  <seelist>
            <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ranking" section="stats" output="asinput">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma série ou vetor com os ranks de <math>
	  y</math>. O rank para a observação <math>i</math>
	  é o número de elementos que são menores que <math>
	  y</math><sub>i</sub> mais 1. Se houver números
	  iguais a <math>y</math><sub>i</sub> adiciona-se 0,5.
	  Intuitivamente, pode-se pensar em uma partida de
	  xadrez, onde uma vitória vale 1 ponto e um empate
	  vale 0,5 pontos). É adicionado 1 ao rank de forma
	  que o menor rank possível é 1 ao invés de 0.
	</para>
	<para context="tex">
	  Formalmente tem-se,
	  \[ \mathrm{rank}(y_i) = 1 + \sum_{j \ne i} \left[
	  I(y_j &lt; y_i) + 0.5 \cdot I(y_j = y_i) \right] \]
	  onde $I$ representa a função indicadora.
	</para>
	<para>
	  <seelist>
            <fncref targ="sort"/>
            <fncref targ="sortby"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="rcond" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o número condicional recíproco para <argname>A</argname>
	  em relação à norma-1. Em várias circunstâncias, é uma medida de
	  sensibilidade melhor de <argname>A</argname> em relação a operações
	  numéricas, tais como a inversão, que o determinante.
	</para>
	<para context="notex">
	  O valor é calculado como a recíproca do produto, norma-1 de
	  <argname>A</argname> multiplicada pela norma-1 de
	  <argname>A</argname>-inverso.
	</para>
	<para context="tex">
	  Dado que <math>A</math> é não-singular, podemos definir
	  \[\kappa(A) = ||A||_1 \cdot ||A^{-1}||_1\]
	  Essa função retorna $\kappa(A)^{-1}$.
	</para>
	<para>
	  <seelist>
            <fncref targ="det"/>
            <fncref targ="ldet"/>
            <fncref targ="onenorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="readfile" section="strings" output="string">
      <fnargs>
	<fnarg type="string">fname</fnarg>
	<fnarg type="string" optional="true">codeset</fnarg>
      </fnargs>
      <description>
	<para>
	  Se um arquivo com o nome <argname>fname</argname> existir e puder
	  ser lido, a função retorna um texto (string) com o
	  conteúdo desse arquivo, caso contrário retorna um erro. Se <argname>
	  fname</argname> não contiver o caminho completo até o arquivo, ele
	  será procurado em algumas localizações <quote>prováveis</quote>,
	  começando pelo <cmdref targ="workdir"/> corrente.
	</para>
	<para>
	  Se <argname>fname</argname> começar com o identificador de um
	  protocolo de internet suportado (<lit>http://</lit>,
	  <lit>ftp://</lit> ou <lit>https://</lit>), libcurl será utilizado
	  para baixar o arquivo. Veja também <fncref targ="curl"/> para
	  baixar arquivos de forma mais elaborada.
	</para>
	<para>
	  Se o texto a ser lido não estiver codificado como UTF-8, Gretl
	  tentará recodificá-lo a partir da codificação corrente se esta
	  não for UTF-8, ou, caso contrário, a partir da codificação
	  ISO-8859-15. Se essa estratégia padrão não funcionar é possível
	  utilizar o segundo argumento (que é opcional) para especificar a
	  codificação. Por exemplo, caso seja desejada a leitura de texto
	  com codificação Microsoft 1251 e esta não seja a configuração local,
	  pode-se fornecer o segundo argumento <lit>"cp1251"</lit>.
	</para>
    <para>
        Exemplos:
    </para>
    <code>
        string web_page = readfile("http://gretl.sourceforge.net/")
        print web_page

        string current_settings = readfile("@dotdir/.gretl2rc")
        print current_settings
    </code>
	<para>
	  Veja também as funções <fncref targ="sscanf"/> e <fncref
	  targ="getline"/>.
	</para>
      </description>
    </function>

    <function name="regsub" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg type="string">match</fnarg>
	<fnarg type="string">repl</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma cópia de <argname>s</argname> onde todas as
	  ocorrências do padrão <argname>match</argname> são
	  substituídas por <argname>repl</argname>. Os argumentos
	  <argname>match</argname> e <argname>repl</argname>
	  são interpretados como expressões regulares no estilo Perl.
	</para>
	<para>
	  Veja também <fncref targ="strsub"/> para substituições simples
	  de textos.
	</para>
      </description>
    </function>

    <function name="remove" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">fname</fnarg>
      </fnargs>
      <description>
	<para>
	  Deleta o arquivo <argname>fname</argname> caso ele exista
	  e seja gravável pelo usuário. Retorna 0 em caso de sucesso
	  e um valor não-nulo se o arquivo não existir ou não puder
	  ser removido.
	</para>
	<para>
	  Se <argname>fname</argname> contiver o caminho completo
	  para o arquivo o Gretl tentará deletá-lo e retornará um
	  erro se ele não existir ou não puder ser apagado por algum
	  motivo (um exemplo seria um arquivo do tipo somente-leitura).
	  Se <argname>fname</argname> não contiver o caminho completo
	  então será assumido que o arquivo está no diretório de
	  trabalho (<cmdref targ="workdir"/>). Se o arquivo não
	  existir ou não for gravável o Gretl não irá procurá-lo em
	  nenhum outro diretório.
	</para>
      </description>
    </function>

    <function name="replace" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
	<fnarg type="scalar-or-vec">find</fnarg>
	<fnarg type="scalar-or-vec">subst</fnarg>
      </fnargs>
      <description>
	<para>
	  Substitui cada elemento de <argname>x</argname> igual ao
	  <math>i</math>-ésimo elemento de <argname>find</argname>
	  pelo correspondente elemento de <argname>subst</argname>.
	</para>
	<para>
	  Se <argname>find</argname> for um escalar, <argname>subst</argname>
	  também deve ser um escalar. Se <argname>find</argname> e
	  <argname>subst</argname> forem vetores, eles precisam ter o mesmo
	  número de elementos. Mas se <argname>find</argname> for um vetor e
	  <argname>subst</argname> um escalar, então todas as ocorrências serão
	  substituídas por <argname>subst</argname>.
	</para>
	<para>
	  Exemplo:
	</para>
	<code>
	  a = {1,2,3;3,4,5}
	  find = {1,3,4}
	  subst = {-1,-8, 0}
	  b = replace(a, find, subst)
	  print a b
	</code>
	<para>
	  produz
	</para>
	<code>
          a (2 x 3)

          1   2   3
          3   4   5

          b (2 x 3)

          -1    2   -8
          -8    0    5
	</code>
      </description>
    </function>

    <function name="resample" section="stats" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
	<fnarg optional="true" type="int">blocksize</fnarg>
      </fnargs>
      <description>
	<para>
	  A descrição inicial desta função refere-se aos dados de corte
	  transversal ou de séries de tempo. Ao final é tratado o caso
	  de dados em painel.
	</para>
	<para>
	  Realiza a reamostragem de <argname>x</argname> com substituição.
	  Quando uma série é utilizada como argumento, cada valor da série
	  de retorno, <math>y</math><sub>t</sub>, é sorteado entre todos
	  os valores de <math>x</math><sub>t</sub> com igual probabilidade.
	  Quando uma matriz é utilizada como argumento, cada linha da matriz
	  retornada é sorteada entre todas as linhas de <argname>x</argname>
	  com igual probabilidade.
	</para>
	<para>
	  O argumento opcional <argname>blocksize</argname> representa o
	  tamanho do bloco para a reamostragem via deslocamento de blocos.
	  Caso este argumento seja dado, ele deve ser um número inteiro
	  positivo maior ou igual a 2. Ao se utilizar este argumento a
	  saída é composta pela seleção aleatória com substituição de todas
	  as sequências contíguas possíveis com tamanho igual ao valor de
	  <argname>blocksize</argname> na entrada (no caso da utilização de
	  matrizes na entrada as linhas são contíguas). Se o comprimento do
	  dado não for um número inteiro e múltiplo do tamanho do bloco, o
	  bloco selecionado será truncado para se ajustar.
	</para>
	<para>
	  Se o argumento <argname>x</argname> for uma série e o conjunto de
	  dados for do tipo painel, a reamostragem via deslocamento de blocos
	  não é suportada. A forma básica de reamostragem é suportada, mas
	  passa a ter a seguinte interpretação: os dados são reamostrado
	  <quote>por indivíduo</quote>. Suponha que você tenha um painel no
	  qual 100 indivíduos são observados ao longo de 5 períodos. Nesse
	  caso a série retornada será novamente composta de 100 blocos de 5
	  observações: cada bloco será sorteado com igual probabilidade entre
	  100 séries de tempo individuais, com a ordem da série temporal sendo
	  preservada.
	</para>
      </description>
    </function>

    <function name="round" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Arredondamento para o número inteiro mais próximo. Note que quando
	  <math>x</math> estiver exatamente entre dois inteiros, o arredondamento é
	  feito de moda a "se afastar de zero", assim, por exemplo, 2.5 é arredondado
	  para 3, mas <lit>round(-3.5)</lit> retorna &minus;4. Esta é uma convenção
	  comum em programas de planilha eletrônica, mas outros programas podem
	  gerar resultados diferentes.
	  <seelist>
            <fncref targ="ceil"/>
            <fncref targ="floor"/>
            <fncref targ="int"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="rnameget" section="strings" output="string-or-strings">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="int" optional="true">row</fnarg>
      </fnargs>
      <description>
	<para>
	  Se o argumento <argname>row</argname> for dado, retorna o nome
	  da linha <argname>col</argname> da matriz <argname>M</argname>.
	  Se <argname>M</argname> não possuir nomes em suas linhas então
	  será retornada um texto (string) vazio. Se
	  <argname>row</argname> for maior que o número de linhas da matriz
	  será sinalizado um erro.
	</para>
	<para>
	  Se não se indicar o segundo argumento, retornará um vetor de
      texto contendo os nomes das linhas de <argname>M</argname>,
	  ou um vetor de texto vazio se <argname>M</argname> não tiver
      nomes de linhas atribuídos.
	</para>
	<para>
	  Exemplo:
	</para>
	<code>
	  matrix A = { 11, 23, 13 ; 54, 15, 46 }
	  rnameset(A, "First Second")
	  string name = rnameget(A, 2)
	  print name
	</code>
	<para>
	  <seelist>
            <fncref targ="rnameset"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="rnameset" section="matbuild" output="int">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="strings-or-list">S</fnarg>
      </fnargs>
      <description>
	<para>
	  Adiciona nomes para as linhas da matriz <argname>M</argname> de
	  ordem <by r="m" c="n"/> . Se <argname>S</argname> for uma lista,
	  os nomes serão os das séries listadas. A lista precisa ter <math>
	  m</math> membros. Se <argname>S</argname> for um arranjo
	  (array) de variáveis de texto (string), ele
	  precisa ter <math>m</math> elementos. Para manter a compatibilidade
	  com versões anteriores do Gretl, uma única variável de texto também
	  pode ser utilizada como segundo argumento. Nesse caso ela precisa
	  ter <math>m</math> textos separados por espaços.
	</para>
	<para>
	  Retorna o valor 0 se as linhas forem nomeadas com sucesso. Caso contrário
	  será retornado um valor não-nulo. Veja também <fncref targ="cnameset"/>.
	</para>
	<para>
	  Exemplo:
	</para>
	<code>
	  matrix M = {1, 2; 2, 1; 4, 1}
	  strings S = array(3)
	  S[1] = "Row1"
	  S[2] = "Row2"
	  S[3] = "Row3"
	  rnameset(M, S)
	  print M
	</code>
      </description>
    </function>

    <function name="rows" section="matshape" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o número de linhas da matriz <argname>X</argname>.
	  <seelist>
            <fncref targ="cols"/>
            <fncref targ="mshape"/>
            <fncref targ="unvech"/>
            <fncref targ="vec"/>
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sd" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>x</argname> for uma série a função retorna o
	  desvio padrão amostral, descartando as observações ausentes.
	</para>
	<para>
	  Se <argname>x</argname> for uma lista a função retorna uma
	  série <math>y</math> tal que <math>y</math><sub>t</sub>
	  representa o desvio padrão amostral dos valores das variáveis
	  na lista na observação <math>t</math>, ou <lit>NA</lit> se
	  existirem valores ausentes em <math>t</math>.
	</para>
	<para>
	  <seelist>
            <fncref targ="var"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sdc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="scalar" optional="true">df</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna os desvios padrão das colunas da matriz <argname>X
	  </argname>. Se <argname>df</argname> for positivo ele será
	  utilizado como o divisor para as variâncias das colunas,
	  caso contrário o divisor será igual ao número de linhas em
	  <argname>X</argname> (isto é, não será aplicada a correção
	  de graus de liberdade).
	  <seelist>
            <fncref targ="meanc"/>
            <fncref targ="sumc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sdiff" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-or-list">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula diferenças sazonais: <equation status="inline"
	  ascii="y(t) - y(t-k)"  tex="$y_t - y_{t-k}$"/>, onde
	  <math>k</math> é a periodicidade do conjunto de dados corrente (veja
	  <fncref targ="$pd"/>). Valores iniciais são definidos como
	  <lit>NA</lit>.
	</para>
	<para>
	  Quando uma lista for retornada, as variáveis individuais são automaticamente
	  nomeadas de acordo com o seguinte padrão <lit>sd_</lit><repl>varname</repl>,
	  onde <repl>varname</repl> é o nome da série original. A porção que
	  representa o nome original da série será truncado, caso seja necessário, e
	  ajustado no caso de não ser único no conjunto de nomes assim
	  construído.
	</para>
	<para>
	  <seelist>
            <fncref targ="diff"/>
            <fncref targ="ldiff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="seasonals" section="data-utils" output="list">
      <fnargs>
	<fnarg optional="true" type="int">baseline</fnarg>
	<fnarg optional="true" type="bool">center</fnarg>
      </fnargs>
      <description>
	<para>
	  Aplicável somente se o conjunto de dados tiver uma estrutura de série
	  temporal com periodicidade maior que 1. Retorna uma lista com variáveis
	  dummy que representam os períodos sazonais. As dummies sazonais são
	  nomeadas como <lit>S1</lit>, <lit>S2</lit> e assim por diante.
	</para>
	<para>
	  O argumento opcional <argname>baseline</argname> pode ser utilizado
	  para excluir um período do conjunto de dummies. Por exemplo, se for
	  fornecido um valor igual a 1 em um conjunto de dados trimestrais a
	  lista retornada conterá as dummies apenas para os trimestres 2, 3 e
	  4. Se este argumento for omitido ou for igual a 0 serão geradas as
	  dummies para todos os períodos. É importante notar que o argumento
	  deve ser um número inteiro e menor ou igual a periodicidade dos dados.
	</para>
	<para>
	  O argumento <argname>center</argname>, se for não-nulo, faz com que
	  as dummies sejam centradas, isto é, que sejam subtraídas suas médias
	  populacionais. Por exemplo, com dados trimestrais as dummies sazonais
	  centradas terão valores iguais a &minus;0.25 e 0.75 ao invés de 0 e
	  1.
	</para>
      </description>
    </function>

    <function name="selifc" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="rvec">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Seleciona em <argname>A</argname> apenas as colunas para as
	  quais o elemento correspondente em <argname>b</argname> é
	  não-nulo. <argname>b</argname> deve ser um vetor linha com
	  o mesmo número de colunas de <argname>A</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="selifr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="selifr" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="cvec">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Seleciona em <argname>A</argname> apenas as linhas para as
	  quais o elemento correspondente em <argname>b</argname> é
	  não-nulo. <argname>b</argname> deve ser um vetor coluna com
	  o mesmo número de linhas de <argname>A</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="selifc"/>
            <fncref targ="trimr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="seq" section="matbuild" output="rvec">
      <fnargs>
	<fnarg type="scalar">a</fnarg>
	<fnarg type="scalar">b</fnarg>
	<fnarg optional="true" type="scalar">k</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna um vetor com a sequência crescente de <argname>a</argname>
	  até <argname>b</argname> se o primeiro argumento for menor que o segundo.
	  Se o primeiro argumento for maior que o segundo a sequência será
	  decrescente. Em ambos os casos o incremento/decremento será de 1 unidade.
	</para>
	<para>
	  Se o argumento opcional <argname>k</argname> for dado a função retorna um
	  vetor com a sequência iniciada em <argname>a</argname> e aumentada, caso
	  <argname>a</argname> for menor <argname>b</argname>), em <argname>k
	  </argname> unidades a cada passo. A sequência será finalizada no maior
	  valor possível que seja menor ou igual a <argname>b</argname>. Se o
	  primeiro argumento for maior que o segundo a sequência será reduzida em
	  <argname>k</argname> unidades e será finalizada no menor valor possível
	  que seja maior ou igual a <argname>b</argname>). O argumento <argname>k
	  </argname> deve ser positivo.
	</para>
	<para>
	  <seelist>
            <fncref targ="ones"/>
            <fncref targ="zeros"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="setnote" section="data-utils" output="int">
      <fnargs>
	<fnarg type="bundle">b</fnarg>
	<fnarg type="string">key</fnarg>
	<fnarg type="string">note</fnarg>
      </fnargs>
      <description>
	<para>
	  Insere uma nota descritiva para o objeto identificado
	  por <argname>key</argname> em um pacote (bundle)
	  <argname>b</argname>. Esta nota será apresentada
	  quando o comando <lit>print</lit> for utilizado no pacote.
	  A função retorna 0 em caso de sucesso e um valor não-nulo
	  em caso de falha (por exemplo, se não existir o objeto
	  <argname>key</argname> em <argname>b</argname>).
	</para>
      </description>
    </function>

    <function name="simann" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="int" optional="true">maxit</fnarg>
      </fnargs>
      <description>
	<para>
	  Implementa o algoritmo <quote>simulated annealing</quote>
	  (conhecido também por recozimento simulado) que pode ser útil
	  para melhorar a questão da inicialização em problemas de
	  otimização numérica.
	</para>
	<para>
	  O primeiro argumento contém o valor inicial de vetor de parâmetros
	  e o segundo especifica uma chamada de função que retorna o valor
	  (escalar) valor da variável a ser maximizada. O terceiro argumento,
	  que é opcional, especifica o número máximo de iterações (a quantidade
	  padrão é 1024). Caso seja executada com sucesso, a função <lit>simann
	  </lit> retorna o valor final da variável a ser maximizada e <argname>
	  b</argname> armazena o vetor de parâmetros associado.
	</para>
	<para>
	  Para maiores detalhes e exemplo veja <guideref
	  targ="chap:numerical"/>.
	  <seelist>
            <fncref targ="BFGSmax"/>
            <fncref targ="NRmax"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sin" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o seno de <argname>x</argname>.
	  <seelist>
            <fncref targ="cos"/>
            <fncref targ="tan"/>
            <fncref targ="atan"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sinh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o seno hiperbólico de <argname>x</argname>.
	</para>
	<para context="tex">
	  \[ \sinh x = \frac{e^x - e^{-x}}{2}  \]
	</para>
	<para>
	  <seelist>
            <fncref targ="asinh"/>
            <fncref targ="cosh"/>
            <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="skewness" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o valor de assimetria para a série <argname>x</argname>,
	  descartando quaisquer observações ausentes.
	</para>
      </description>
    </function>

    <function name="sleep" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="int">ns</fnarg>
      </fnargs>
      <description>
	<para>
	  Faz com que o processo (thread) corrente <quote>hiberne</quote>&mdash;
	  isto é, que interrompa suas atividades&mdash;por <argname>ns</argname>
	  segundos. Ao despertar da hibernação, a função retorna o valor 0. Apesar
	  de não ser diretamente relacionada à econometria, essa função pode ser
	  útil para testes de métodos de paralelização.
	</para>
      </description>
    </function>

    <function name="smplspan" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="string">startobs</fnarg>
	<fnarg type="string">endobs</fnarg>
	<fnarg type="int">pd</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o número de observações entre
	  <argname>startobs</argname> e <argname>endobs</argname>
	  (inclusive) de uma série temporal com frequência
	  <argname>pd</argname>.
	</para>
	<para>
	  Os dois primeiros argumentos devem ser dados na forma padrão
	  do Gretl para dados anuais, trimestrais ou mensais&mdash;
	  por exemplo, <lit>1970</lit>, <lit>1970:1</lit>
	  ou <lit>1970:01</lit> para cada uma das frequências,
	  respectivamente&mdash;ou como datas no formato ISO 8601,
	  <lit>YYYY-MM-DD</lit>.
	</para>
	<para>
	  O argumento <argname>pd</argname> deve ser igual a 1, 4 ou 12
	  (anual, trimestral, mensal); uma das frequências diárias
	  (5, 6, 7); ou 52 (semanal). Se <argname>pd</argname> for igual
	  a 1, 4 ou 12, então pode-se utilizar datas no formato ISO 8601
	  nos dois primeiros argumentos se elas indicarem o início e o
	  fim do período em questão. Por exemplo, <lit>2015-04-01</lit>
	  pode ser utilizada no lugar de <lit>2015:2</lit> para representar
	  o segundo trimestre de 2015.
	</para>
	<para>
	  Se um conjunto de dados já aberto e com frequência <argname>pd</argname>,
	  com uma suficiente quantidade de observações, então o resultado
	  dessa função poderia ser facilmente emulada utilizando
	  <fncref targ="obsnum"/>. A vantagem de <lit>smplspan</lit>
	  é o fato de poder calcular o número de observações sem que seja
	  necessário um conjunto de dados adequado (ou até mesmo nenhum
	  conjunto de dados). Exemplo:
	</para>
	<code>
	  scalar T = smplspan("2010-01-01", "2015-12-31", 5)
	  nulldata T
	  setobs 7 2010-01-01
	</code>
	<para>
	  O código acima produz o seguinte resultado:
	</para>
	<code>
	  ? scalar T = smplspan("2010-01-01", "2015-12-31", 5)
	  Gerou-se o escalar T = 1565
	  ? nulldata T
	  periodicidade: 1, máx. obs: 1565
	  intervalo das observações: 1 a 1565
	  ? setobs 7 2010-01-01
	  Intervalo completo dos dados: 2010-01-01 - 2014-04-14 (n = 1565)
	</code>
	<para>
	  Após utilizar esse código pode-se ter a certeza de que a
	  última observação no conjunto de dados criado via comando
	  <cmdref targ="nulldata"/> será <lit>2015-12-31</lit>. Note
	  que a obtenção do número 1565 seria bem mais complicada de
	  sem o uso dessa função.
	</para>
      </description>
    </function>

    <function name="sort" section="matshape" output="asinput">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Ordena <argname>x</argname> de forma ascendente, descartando
	  observações com valores ausentes quando <math>x</math> for uma
	  série.
	  <seelist>
            <fncref targ="dsort"/>
            <fncref targ="values"/>
	  </seelist>
	  Especificamente para matrizes veja <fncref targ="msortby"/>.
	</para>
      </description>
    </function>

    <function name="sortby" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y1</fnarg>
	<fnarg type="series">y2</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma série contendo os elementos de <argname>y2</argname>
	  ordenados de acordo com os valores crescente do primeiro argumento
	  <argname>y1</argname>.
	  <seelist>
            <fncref targ="sort"/>
            <fncref targ="ranking"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sprintf" section="strings" output="string">
      <fnargs>
	<fnarg type="string">format</fnarg>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  O texto (string) retornado é construído pela exibição dos valores dos
	  argumentos finais, indicados pelas reticências acima, sob o controle
	  do argumento <argname>format</argname>. Esta função tem como objetivo
	  oferecer mais flexibilidade na criação de textos. O argumento <argname>
	  format</argname> é utilizado para especificar de uma maneira precisa a
	  forma como você deseja que os argumentos sejam exibidos.
	</para>
	<para>
	  Em geral, o argumento <argname>format</argname> (que pode ser chamado
	  de texto de formatação) deve ser uma expressão avaliada como um texto,
	  mas na maioria dos casos será apenas um texto literal (uma sequência
	  alfanumérica delimitada por aspas duplas). Algumas sequências de caracteres
	  em <argname>format</argname> têm um significado especial: aqueles iniciados
	  pelo símbolo de porcentagem (%) são interpretados como <quote>espaços
	  reservados</quote> para os ítens contidos na lista de argumentos. Além
	  disso, caracteres especiais, tal como o que indica nova linha (<lit>\n
	  </lit>), são representados através da combinação com uma barra invertida.
	</para>
	<para>
	  Por exemplo, o código a seguir
	</para>
	<code>
	  scalar x = sqrt(5)
	  string claim = sprintf("sqrt(%d) é (aproximadamente) %6.4f.\n", 5, x)
	  print claim
	</code>
	<para>
	  irá produzir
	</para>
	<code>
	  sqrt(5) é (aproximadamente) 2.2361.
	</code>
	<para>
	  A expressão <lit>%d</lit> dentro do argumento <argname>format</argname>
	  indica que queremos na saída um número inteiro neste local. Como é a
	  expressão <quote>porcento</quote> mais a esquerda, ela então tem efeito
	  sobre o primeiro argumento, isto é, 5. A segunda sequência especial é
	  <lit>%6.4f</lit>, que indica um valor decimal com ao menos 6 dígitos de
	  largura e com ao menos 4 casas decimais.
	  A quantidade de sequências como estas deve coincidir com o número de
	  argumentos após o texto de formatação.
	</para>
	<para>
	  Ver também a ajuda para o comando <cmdref targ="printf"/> para
	  maiores detalhes sobre a sintaxe que você pode utilizar para a
	  formatação de textos (strings).
	</para>
      </description>
    </function>

    <function name="sqrt" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a raiz quadrada positiva de <argname>x</argname>. Gera
	  <lit>NA</lit> quando utilizada em valores negativos.
	</para>
	<para>
	  Note que se o argumento for uma matriz, a operação será realizada para
	  cada elemento. Além disso, dado que as matrizes não podem conter valores
	  <lit>NA</lit>, a função irá gerar um erro se existirem valores negativos.
	  Para a <quote>raiz quadrada matricial</quote> veja <fncref targ="cholesky"/>.
	</para>
      </description>
    </function>

    <function name="square" section="transforms" output="list">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg optional="true" type="bool">cross-products</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma lista contendo os quadrados das variáveis na lista
	  <argname>L</argname>. Seus elementos são nomeados de acordo
	  com o seguinte esquema :<lit>sq_</lit><repl>varname</repl>. Se
	  o segundo argumento (opcional) estiver presente e tiver um valor
	  não-nulo, a lista também incluirá os produtos cruzados dos elementos
	  de <argname>L</argname> que, por sua vez, são nomeados de acordo com
	  o seguinte esquema: <repl>var1</repl><lit>_</lit><repl>var2</repl>.
	  Nesses esquemas os nomes das séries de entrada serão truncados caso
	  seja necessário e os nomes de saída podem ser ajustados em caso de
	  de nomes duplicados na lista retornada.
	</para>
      </description>
    </function>

    <function name="sscanf" section="strings" output="int">
      <fnargs>
	<fnarg type="string">src</fnarg>
	<fnarg type="string">format</fnarg>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Lê os valores de <argname>src</argname> sob controle do argumeto
	  <argname>format</argname> e os usa para determinar os valores de
	  um ou mais argumentos subsequentes, indicados pelas reticências
	  acima. A função retorna o número de valores determinados. Esta é
	  uma versão simplificada da função <lit>sscanf</lit> na linguagem
	  de programação C.
	</para>
	<para>
	  O argumento <repl>src</repl> pode ser tanto um texto literal,
	  delimitado por aspas duplas, ou o nome de uma variável de texto
	  (string) previamente definida. O <repl>format</repl> é definido
	  de forma similar ao texto de formatação utilizado em <cmdref
	  targ="printf"/> (mais detalhes serão dados abaixo). Os demais
	  argumentos, representados acima pelas reticências devem ser uma
	  lista separada por vírgulas contendo os nomes de variáveis
	  pré-definidas: estas são os alvos da conversão de <repl>src</repl>.
	  Para os usuários com familiaridade com a linguagem C, pode-se
	  prefixar os nomes de variáveis numéricas com <lit>&amp;</lit>, mas
	  isso não é uma exigência.
	</para>
	<para>
	  O texto literal em <repl>format</repl> é comparado com <repl>src
	  </repl>. Especificadores de conversão começam com <lit>%</lit>,
	  sendo os especificadores reconhecidos <lit>%f</lit>, <lit>%g</lit>
	  ou <lit>%lf</lit> para números de ponto flutuante; <lit>%d</lit>
	  para inteiros; <lit>%s</lit> para textos; e <lit>%m</lit> para
	  matrizes. Você pode inserir um número inteiro positivo após o símbolo
	  de porcentagem: isso ajusta o número máximo de caracteres a serem
	  lidos por dado especificador de conversão (ou o número máximo de
	  linhas no caso de conversão de matrizes). Alternativamente, você pode
	  inserir um asterisco (<lit>*</lit>) após o símbolo de porcentagem
	  para suprimir a conversão (ignorando assim quaisquer caracteres que
	  teriam sido convertidos para um dado tipo). Por exemplo, <lit>%3d</lit>
	  converte os próximos 3 caracteres de <repl>source</repl> em um número
	  inteiro, se possível; <lit>%*g</lit> ignora a quantidade necessária
	  de caracteres de <repl>source</repl> para que se obtenha apenas um
	  número de ponto flutuante.
	</para>
	<para>
	  A conversão de matrizes funciona da seguinte forma: a função lê uma
	  linha da entrada e conta (com base na separação por espaço ou por
	  tabulação) o número de campos numéricos. Isto define o número de
	  colunas na matriz. Por padrão a leitura continua sendo feita enquanto
	  enquanto a leitura de linhas devolver a mesma quantidade de colunas
	  numéricas, mas o número máximo de linhas a serem lidas pode ser
	  limitado de acorodo com o descrito acima.
	</para>
	<para>
	  No caso de textos, em adição especificador <lit>%s</lit>, também é
	  possível utilizar uma versão simplificada do formato utilizado na
	  linguagem C: <lit>%</lit><repl>N</repl><lit>[</lit><repl>chars
	  </repl><lit>]</lit>. Neste formato <repl>N</repl> é o número máximo
	  de caracteres a serem lidos <repl>chars</repl> é um conjunto de
	  caracteres aceitáveis, delimitados por colchetes: a leitura para se
	  <repl>N</repl> for atingido ou se um caractere que não está em <repl>
	  chars</repl> for encontrado. O comportamento de <repl>chars</repl>
	  pode ser revertido se for utilizado um circunflexo, <lit>^</lit>,
	  como sendo o primeiro caractere. Neste caso a leitura para se um
	  caractere no dado conjunto for encontrado. Diferentemente de C, o
	  hífen não exerce papel especial no conjunto
	  <repl>chars</repl>.
	</para>
	<para>
	  Se o texto fonte (<repl>src</repl>) não apresentar correspondência
	  (completa) com o texto de formatação (<repl>format</repl>), o número
	  de conversões pode ficar abaixo do número de argumentos dados. Isto
	  não é por si só um erro no que diz respeito ao Gretl. Caso queira
	  verificar o número de conversões realizadas basta utilizar o valor
	  retornado pela função.
	</para>
	<para>
	  Alguns exemplos:
	</para>
	<code>
	  scalar x
	  scalar y
	  sscanf("123456", "%3d%3d", x, y)

	  S = sprintf("1 2 3 4\n5 6 7 8")
	  S
	  matrix m
	  sscanf(S, "%m", m)
	  print m
	</code>
      </description>
    </function>

    <function name="sst" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a soma dos quadrados dos desvios em relação à média
	  das observações não ausentes na série <argname>y</argname>.
	  <seelist>
            <fncref targ="var"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="stringify" section="strings" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="strings">S</fnarg>
      </fnargs>
      <description>
	<para>
	  Fornece uma maneira de definir valores de texto para a série
	  <argname>y</argname>. Duas condições são necessárias para isso:
	  a variável alvo deve ser formada apenas por números inteiros,
	  com nenhum deles sendo menor que 1, e o arranjo (array) <argname>S
	  </argname> deve possuir ao menos <math>n</math> elementos, onde
	  <math>n</math> é o maior valor em <argname>y</argname>.
	  Adicionalmente, cada elemento de <argname>S</argname> deve estar
	  representado com base na codificação UTF-8.
	  <seelist>
            <fncref targ="strvals"/>
	  </seelist>
	</para>
	<para>
	  O valor retornado é zero em caso de sucesso ou um código positivo
	  de erro caso a função não tenha sucesso.
	</para>
      </description>
    </function>

    <function name="strlen" section="strings" output="int">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o número de caracteres no texto (string)
	  <argname>s</argname>. Note que isso não será necessariamente
	  igual ao número de bytes se alguns caracteres estiverem fora
	  do intervalo de impressão ASCII.
	</para>
    <para>
        Exemplo:
    </para>
    <code>
        string s = "regression"
        scalar number = strlen(s)
        print number
    </code>
      </description>
    </function>

    <function name="strncmp" section="strings" output="int">
      <fnargs>
	<fnarg type="string">s1</fnarg>
	<fnarg type="string">s2</fnarg>
	<fnarg optional="true" type="int">n</fnarg>
      </fnargs>
      <description>
	<para>
	  Compara dois textos (string) e retorna um
	  inteiro menor que, igual ou maior que 0 se <argname>s1</argname>
	  se for, respectivamente menor que, igual ou maior que
	  <argname>s2</argname>, até o primeiro caractere <argname>n</argname>.
	  Se <argname>n</argname> for omitido a comparação irá prosseguir
	  até onde for possível.
	</para>
	<para>
	  Caso deseje apenas verificar se dois textos são iguais não é
	  necessário utilizar esta função. Ao invés disso é pode-se usar
	  a seguinte expressão: <lit>if (s1 == s2)...</lit>.
	</para>
      </description>
    </function>

    <function name="strsplit" section="strings" output="string-or-strings">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg optional="true" type="int">i</fnarg>
    <fnarg optional="true" type="string">sep</fnarg>
      </fnargs>
      <description>
	<para>
	  Em seu uso mais simples, ou seja, com apenas um argumento, retorna
	  o arranjo (array) com textos (string)
	  resultante da separação de <argname>s</argname> de acordo com os
	  espaços em branco.
	</para>
	<para>
	  Se for fornecido um número inteiro e maior que
      zero como segundo argumento, retorna o elemento
      <argname>i</argname> do texto <argname>s</argname>,
      após ter sido separado por espaços. Se
      <argname>i</argname> for menor irá gerar um erro.
      Se <argname>i</argname> for maior que o número
      total de elementos será retornado um texto vazio.
	</para>
    <para>
      O terceiro argumento opcional pode ser utilizado para definir qual
      será o critério a ser utilizado para separar <argname>s</argname>.
      Por exemplo:
    </para>
    <code>
      string basket = "banana,apple,jackfruit,orange"
      strings S = strsplit(basket,,",")
    </code>
    <para>
      Os comandos acima irão separar o texto de entrada em um vetor
      contendo quatro textos utilizando a vírgula como separadora.
      A vírgula <quote>extra</quote> na entrada acima serve para
      indicar que o argumento <argname>i</argname> não foi utilizado.
    </para>
    <para>
      As sequências de escape <quote><lit>\n</lit></quote> e
      <quote><lit>\t</lit></quote> são utilizadas para representar
      uma nova linha ou um espaço por tabulação no argumento
      opcional <argname>sep</argname>. Caso o separador seja
      literalmente uma barra invertida deve-se utilizar a barra de
      forma duplicada, <quote><lit>\\</lit></quote>. Exemplo:
    </para>
    <code>
      string s = "c:\fiddle\sticks"
      strings S = strsplit(s, "\\")
    </code>
      </description>
    </function>

    <function name="strstr" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s1</fnarg>
	<fnarg type="string">s2</fnarg>
      </fnargs>
      <description>
	<para>
	  Procura em <argname>s1</argname> o texto <argname>s2</argname>.
	  Se o texto for encontrado a função retorna uma cópia da parte
	  de <argname>s1</argname> que começa com <argname>s2</argname>,
	  caso contrário retorna um texto vazio.
	</para>
    <para>
        Exemplo:
    </para>
    <code>
        string s1 = "Gretl is an econometrics package"
        string s2 = strstr(s1, "an")
        print s2
    </code>
    <para>
      Se o objetivo for apenas verificar se <argname>s1</argname>
      contém <argname>s2</argname> (teste booleano), ver
      <fncref targ="instring"/>.
    </para>
      </description>
    </function>

    <function name="strstrip" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma cópia de <argname>s</argname> na qual os espaços
	  em branco do início e do fim do texto são removidos.
	</para>
    <para>
        Exemplo:
    </para>
    <code>
        string s1 = "    A lot of white space.  "
        string s2 = strstrip(s1)
        print s1 s2
    </code>
      </description>
    </function>

    <function name="strsub" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg type="string">find</fnarg>
	<fnarg type="string">subst</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma cópia de <argname>s</argname> na qual todas as
	  ocorrências de <argname>find</argname> são substituídas por
	  <argname>subst</argname>. Veja também <fncref targ="regsub"/>
	  para substituições mais complexas via expressões regulares.
	</para>
    <para>
        Exemplo:
    </para>
    <code>
        string s1 =  "Hello, Gretl!"
        string s2 = strsub(s1, "Gretl", "Hansl")
        print s2
    </code>
      </description>
    </function>

    <function name="strvals" section="strings" output="strings">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Se uma série <argname>y</argname> for não-numérica, retorna um arranjo (array)
	  contendo todos os seus valores distintos, ordenados pelos valores numéricos
	  associados iniciados em 1. Se <argname>y</argname> não for não-numérico, retorna
	  um arranjo de texto (strings) vazio. Observação: variáveis não-numéricas surgem,
	  normalmente, quando existem séries cujas observações são textos.
	  <seelist>
            <fncref targ="stringify"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="substr" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg type="int">start</fnarg>
	<fnarg type="int">end</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma parte do texto <argname>s</argname>
	  começando em <argname>start</argname> e terminando
	  em <argname>end</argname>, inclusive.
	</para>
    <para>
        Exemplos:
    </para>
    <code>
        string s1 = "Hello, Gretl!"
        string s2 = substr(s1, 8, 12)
        string s3 = substr("Hello, Gretl!", 8, 12)
        print s2
        print s3
    </code>
    <para>
        Esses exemplos fornecem:
    </para>
    <code>
      ? print s2
      Gretl
      ? print s3
      Gretl
    </code>
    <para>
          Deve-se notar que em alguns casos pode-se desejar trocar
          a clareza da sintaxe pela sua simplicidade e usar operadores
          de seleção e incremento. Por exemplo:
    </para>
    <code>
          string s1 = "Hello, Gretl!"
          string s2 = s1[8:12]
          string s3 = s1 + 7
          print s2
          print s3
    </code>
    <para>
      Esses exemplos fornecem:
    </para>
    <code>
      ? print s2
      Gretl
      ? print s3
      Gretl!
    </code>
      </description>
    </function>

    <function name="sum" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="smlist">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>x</argname> for uma série, retorna a soma,
	  na forma de um escalar, das observações não ausentes em
	  <argname>x</argname>. Veja também <fncref targ="sumall"/>.
	</para>
	<para>
	  Se <argname>x</argname> for uma matriz, retorna a soma dos
	  elementos da matriz.
	</para>
	<para>
	  Se <argname>x</argname> for uma lista, retorna uma série
	  <math>y</math> na qual <math>y</math><sub>t</sub> é a
	  soma dos valores das variáveis da lista na observação
	  <math>t</math>, ou <lit>NA</lit> se existir qualquer valor
	  ausente em <math>t</math>.
	</para>
      </description>
    </function>

    <function name="sumall" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a soma das observações de <argname>x</argname> dentro
	  da amostra selecionada. Se existir qualquer valor ausente a
	  função retornará <lit>NA</lit>. Use <fncref targ="sum"/>
	  caso deseje que os valores correntes sejam descartados.
	</para>
      </description>
    </function>

    <function name="sumc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna um vetor com a soma das colunas de <argname>X</argname>
	  <seelist>
            <fncref targ="meanc"/>
            <fncref targ="sumr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sumr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna um vetor com a soma das linhas de <argname>X</argname>
	  <seelist>
            <fncref targ="meanr"/>
            <fncref targ="sumc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="svd" section="linalg" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;V</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Realiza a decomposição em valores singulares da matriz
	  <argname>X</argname>.
	</para>
	<para context="tex">
	  Realiza a decomposição em valores singulares da matriz
	  $X$ de ordem $r \times c$:
	  \[ X = U \left[
	  \begin{array}{cccc}
	  \sigma_1 \\
	  &amp; \sigma_2 \\
	  &amp; &amp; \ddots \\
	  &amp; &amp; &amp; \sigma_n ,
	  \end{array}
	  \right] V \]
	  onde $n = \min(r,c)$. $U$ tem ordem $r \times
	  n$ e $V$ tem ordem $n \times c$, com $U'U = I$ e $VV' = I$.
	</para>
	<para>
	  Os valores singulares são retornados em um vetor linha. Os vetores
	  singulares à esquerda e/ou à direta <math>U</math> e <math>V</math>
	  podem ser obtidos ao se fornecer valores não-nulos para os argumentos
	  2 e 3, respectivamente. Para qualquer matriz <lit>A</lit>, o código
	</para>
	<code>
	  s = svd(A, &amp;U, &amp;V)
	  B = (U .* s) * V
	</code>
	<para>
	  deve gerar <lit>B</lit> idêntico a <lit>A</lit> (desconsiderando as
	  possíveis discrepâncias geradas pela questão da precisão de máquina).
	</para>
	<para>
	  <seelist>
            <fncref targ="eigengen"/>
            <fncref targ="eigensym"/>
            <fncref targ="qrdecomp"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="tan" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a tangente de <argname>x</argname>.
	  <seelist>
            <fncref targ="atan"/>
            <fncref targ="cos"/>
            <fncref targ="sin"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="tanh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a tangente hiperbólica de <argname>x</argname>.
	</para>
	<para context="tex">
	  \[ \tanh x = \frac{e^{2x} - 1}{e^{2x} + 1}  \]
	</para>
	<para>
	  <seelist>
            <fncref targ="atanh"/>
            <fncref targ="cosh"/>
            <fncref targ="sinh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="toepsolv" section="linalg" output="cvec">
      <fnargs>
	<fnarg type="vector">c</fnarg>
	<fnarg type="vector">r</fnarg>
	<fnarg type="vector">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Resolve um sistema de Toeplitz de equações lineares, isto é
	  <math>Tx = b</math> onde <math>T </math> é uma matriz quadrada
	  cujo elemento <math>T</math><sub>i,j</sub> é igual a
	  <math>c</math><sub>i-j</sub> para
	  <equation status="inline"
	  ascii="i&gt;=j" tex="$i\ge j$"/>
	  e <math>r</math><sub>j-i</sub> para
	  <equation status="inline" ascii="i&lt;=j"
	  tex="$i\le j$"/>.
	  Note que os primeiros elementos de <math>c</math> e
	  <math>r</math> precisam ser iguais, caso contrário um erro é
	  retornado. Se executada com sucesso, a função retorna o vetor
	  <math>x</math>.
	</para>
	<para>
	  O algoritmo utilizado por esta função se aproveita da estrutura
	  especial que a matriz <math>T</math> possui, o que o torna bem
	  mais eficiente que outros algoritmos não especializados, em
	  especial para grandes problemas. Atenção! Em certos casos a função
	  pode, de forma espúria, emitir uma mensagem apontando que a matriz
	  tem problemas de singularidade quando na verdade <math>T</math> é
	  não-singular. Este problema, entretanto, não pode ocorrer quando
	  <math>T</math> é definida positiva.
	</para>
      </description>
    </function>

    <function name="tolower" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma cópia de <argname>s</argname> na qual todos os
	  caracteres maiúsculos são convertidos em minúsculos.
	</para>
    <para>
        Exemplos:
    </para>
    <code>
        string s1 = "Hello, Gretl!"
        string s2 = tolower(s1)
        print s2

        string s3 = tolower("Hello, Gretl!")
        print s3
    </code>
      </description>
    </function>

    <function name="toupper" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma cópia de <argname>s</argname> na qual todos os
	  caracteres minúsculos são convertidos em maiúsculos.
	</para>
    <para>
        Exemplos:
    </para>
    <code>
        string s1 = "Hello, Gretl!"
        string s2 = toupper(s1)
        print s2

        string s3 = toupper("Hello, Gretl!")
        print s3
    </code>
      </description>
    </function>

    <function name="tr" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o traço de uma matriz quadrada <argname>A</argname>,
	  isto é, a soma dos elementos de sua diagonal.
	  <seelist>
            <fncref targ="diag"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="transp" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a transposta de <argname>X</argname>. Observação: esta função é
	  raramente utilizada. Para transpor uma matriz, na maior parte dos casos,
	  pode-se simplesmente utilizar o operador de transposição: <lit>X'</lit>.
	</para>
      </description>
    </function>

    <function name="trimr" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">ttop</fnarg>
	<fnarg type="int">tbot</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma cópia da matriz <argname>X</argname> com <argname>
	  ttop</argname> linhas superiores excluídas e <argname>tbot</argname>
	  linhas inferiores excluídas. Os dois últimos argumentos devem ser
	  não-negativos e sua soma deve ser menor que o total de linhas de
	  <argname>X</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="selifr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="typeof" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">name</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o código numérico de tipo se <argname>name</argname>
	  for o identificador de um objeto definido: 1 para escalar, 2
	  para série, 3 para matriz, 4 para texto (string), 5 para pacote
	  (bundle), 6 para arranjo (array) e 7 para lista. Caso contrário
	  retorna 0. A função <fncref targ="typestr"/> pode ser utilizada
	  para obter o nome do objeto que corresponde ao código numérico.
	</para>
	<para>
	  Essa função também pode ser utilizada para obter o tipo de um
	  membro de um pacote ou de um elemento de um arranjo. Por exemplo:
	</para>
	<code>
	  matrices M = array(1)
	  eval typestr(typeof(M))
	  eval typestr(typeof(M[1]))
	</code>
	<para>
	  O primeiro resultado do comando <lit>eval</lit> é <quote>array
	  </quote> e o segundo é <quote>matrix</quote>.
	</para>
      </description>
    </function>

    <function name="typestr" section="data-utils" output="string">
      <fnargs>
	<fnarg type="int">typecode</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o nome do tipo de dado correspondente a
	  <argname>typecode</argname>. Pode ser utilizada
	  em conjunto com as funções <fncref targ="typeof"/>
	  e <fncref targ="inbundle"/>. O valor retornado pode
	  ser <quote>scalar</quote>, <quote>series</quote>,
	  <quote>matrix</quote>, <quote>string</quote>,
	  <quote>bundle</quote>, <quote>array</quote> ou
	  <quote>null</quote>.
	</para>
      </description>
    </function>

    <function name="uniform" section="probdist" output="series">
      <fnargs>
	<fnarg type="scalar">a</fnarg>
	<fnarg type="scalar">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Cria uma variável pseudo-aleatória uniforme no intervalo (<argname>
	  a</argname>, <argname>b</argname>) ou, se não forem fornecidos
	  argumentos, será utilizado o intervalo (0,1). O algoritmo utilizado
	  por padrão é o <quote>SIMD-oriented Fast Mersenne Twister</quote>
	  desenvolvido por <cite key="saito_matsumoto08">Saito and Matsumoto
	  (2008)</cite>.
	</para>
	<para>
	  <seelist>
            <fncref targ="randgen"/>
            <fncref targ="normal"/>
            <fncref targ="mnormal"/>
            <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="uniq" section="stats" output="cvec">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna um vetor contendo os elementos distintos de <argname>x
	  </argname> de forma não ordenada, mas na ordem em que aparecem
	  em <argname>x</argname>. Veja <fncref targ="values"/> para a
	  variante desta função que retorna os valores ordenados.
	</para>
      </description>
    </function>

    <function name="unvech" section="matbuild" output="smatrix">
      <fnargs>
	<fnarg type="vector">v</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma matriz simétrica de ordem <by r="n" c="n"/>
	  rearranjando os elementos de <math>v</math>. O número de
	  elementos de <math>v</math> deve ser um inteiro triangular,
	  ou seja, um número <math>k</math> tal que exista um inteiro
	  <math>n</math> que tenha a seguinte propriedade: <equation
          status="inline" ascii="k = n(n+1)/2"
          tex="$k = n(n+1)/2$"/>. Esta função é a inversa de
	  <fncref targ="vech"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="mshape"/>
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="upper" section="matbuild" output="smatrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Retorna uma matriz triangular superior de ordem <by r="n" c="n"/>.
	  Os elementos da diagonal e acima desta são iguais aos elementos
	  correspondentes de <argname>A</argname> e os demais iguais a zero.
	</para>
	<para context="tex">
	  Retorna uma matriz triangular superior <math>B</math> de ordem
	  $n\times n$ onde $B_{ij} = A_{ij}$ se $i \le j$, e 0 caso contrário.
	</para>
	<para>
	  <seelist>
            <fncref targ="lower"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="urcpval" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="scalar">tau</fnarg>
	<fnarg type="int">n</fnarg>
	<fnarg type="int">niv</fnarg>
	<fnarg type="int">itv</fnarg>
      </fnargs>
      <description>
	<para>
	  <math>P</math>-valores para a estatística de teste do
	  teste de raízes unitárias de Dickey&ndash;Fuller e do
	  teste de cointegração de Engle&ndash;Granger, conforme
	  <cite key="mackinnon96">James MacKinnon (1996)</cite>.
	</para>
	<para>
	  Os argumentos dessa função são: <argname>tau</argname> representa
	  a estatística de teste; <argname>n</argname> representa o número
	  de observações (ou 0 para um resultado assintótico); <argname>niv</argname>
	  representa o número de variáveis potencialmente cointegradas quando
	  se estiver testando a cointegração (ou 1 para testes univariados de
	  raiz unitária) e; <argname>itv</argname> é um código para a
	  especificação do modelo: 1 para teste sem constante, 2 para teste
	  com constante, 3 para teste com contante e tendência linear, 4
	  para teste com constante e tendência quadrática.
	</para>
	<para>
	  Note que se a regressão de teste for <quote>aumentada</quote> com
	  defasagens da variável dependente, então será necessário fornecer um
	  valor <argname>n</argname> igual a 0 para obter resultados assintóticos.
	</para>
	<para>
	  <seelist>
            <fncref targ="pvalue"/>
	    <fncref targ="qlrpval"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="values" section="stats" output="cvec">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna um vetor contendo os elementos distintos de
	  <argname>x</argname> ordenados de forma ascendente. Caso
	  deseje truncar a parte decimal antes de aplicar a função,
	  utilize a expressão <lit>values(int(x))</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="uniq"/>
            <fncref targ="dsort"/>
            <fncref targ="sort"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="var" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>x</argname> for uma série, retorna a variância
	  amostral na forma de um escalar, ignorando quaisquer observações
	  ausentes.
	</para>
	<para>
	  Se <argname>x</argname> for uma lista, retorna uma série
	  <math>y</math> tal que <math>y</math><sub>t</sub> é a variância
	  amostral dos valores das variáveis na lista na observação
	  <math>t</math>, ou <lit>NA</lit> se existir algum valor ausente
	  em <math>t</math>.
	</para>
	<para>
	  Em cada caso, a soma dos desvios ao quadrado em relação à média
	  é dividido por (<math>n</math> &minus; 1) para <math>n</math>
	  &gt; 1. Caso contrário, a variância é igual a zero se <math>n
	  </math> = 1, ou é <lit>NA</lit> se <math>n</math> = 0.
	</para>
	<para>
	  <seelist>
            <fncref targ="sd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="varname" section="strings" output="string">
      <fnargs>
	<fnarg type="int-or-list">v</fnarg>
      </fnargs>
      <description>
	<para>
	  Se for utilizado um inteiro como argumento, a função retorna o
	  nome da variável com número ID igual a <argname>v</argname> ou
	  um erro se esta variável não existir.
	</para>
	<para>
	  Se for utilizado uma lista como argumento, retorna o texto
	  (string) contendo os nomes das variáveis na lista,
	  separados por vírgulas. Se for fornecida uma lista vazia será
	  retornado um texto vazio. Para obter um arranjo (array)
	  de textos pode-se utilizar <fncref targ="varnames"/>.
	</para>
    <para>
        Exemplo:
    </para>
    <code>
        open broiler.gdt
        string s = varname(7)
        print s
    </code>
      </description>
    </function>

    <function name="varnames" section="strings" output="strings">
      <fnargs>
	<fnarg type="list">L</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna um arranjo (array) de textos (string)
	  contendo os nomes das variáveis na lista <argname>L</argname>.
	  Se a lista for vazia será retornado um arranjo vazio.
	</para>
    <para>
        Exemplo:
    </para>
    <code>
        open keane.gdt
        list L = year wage status
        strings S = varnames(L)
        eval S[1]
        eval S[2]
        eval S[3]
    </code>
      </description>
    </function>

    <function name="varnum" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">varname</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o número ID da variável
	  <argname>varname</argname> ou NA
	  se a variável não existir.
	</para>
      </description>
    </function>

    <function name="varsimul" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix">U</fnarg>
	<fnarg type="matrix">y0</fnarg>
      </fnargs>
      <description>
	<para>
	  Simula um VAR de ordem <math>p</math> com <math>n</math> variáveis,
	  ou seja,
	  <equation status="inline"
		    ascii="y(t) = A1 y(t-1) + ... + Ap y(t-p) + u(t)."
		    tex="$y_t = \sum_{i=1}^p A_i y_{t-i} + u_t$."/>
	  A matriz de coeficientes <argname>A</argname> é composta através do
	  empilhamento das matrizes <math>A</math><sub>i</sub> horizontalmente,
	  e tem ordem <by r="n" c="np"/>, com uma linha por equação. Isso
	  corresponde as primeiras <math>n</math> linhas da matriz companheira,
	  acessada via <lit>$compan</lit> após o uso dos comandos <lit>var</lit>
	  e <lit>vecm</lit>.
	</para>
	<para>
	  Os vetores <math>u_t</math> estão contidos (como linhas) em <argname>
	  U</argname> (<by r="T" c="n"/>). Valores iniciais estão contidos em
	  <argname>y0</argname> (<by r="p" c="n"/>).
	</para>
	<para>
	  Se o VAR contiver termos determinísticos e/ou regressores exógenos,
	  estes podem ser incluídos na matriz <argname>U</argname>.
	  Cada linha de <argname>U</argname> passa a
	  incluir esses termos, ou seja,
	  <equation status="inline"
		    ascii="u(t) = B'x(t) + e(t)."
		    tex="$u_t = B' x_t + e_t$."/>
	</para>
	<para>
	  A matriz de saída tem <math>T</math> + <math>p</math> linhas e
	  <math>n</math> colunas e armazena os <math>p</math> valores
	  iniciais das variáveis endógenas mais <math>T</math> valores
	  simulados.
	</para>
	<para>
	  <seelist>
            <fncref targ="$compan"/>
            <cmdref targ="var"/>
            <cmdref targ="vecm"/>
	  </seelist>
	</para>

      </description>
    </function>

    <function name="vec" section="matbuild" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Empilha as colunas de <argname>X</argname> como um vetor coluna.
	  <seelist>
            <fncref targ="mshape"/>
            <fncref targ="unvech"/>
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="vech" section="matbuild" output="cvec">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna em um vetor coluna os elementos de <argname>A</argname>
	  que estão em sua diagonal e acima dela. Normalmente essa função
	  é utilizada em matrizes simétricas. Neste caso a essa operação
	  pode ser revertida através da função <fncref targ="unvech"/>.
	  <seelist>
            <fncref targ="vec"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="weekday" section="calendar" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-series">ano</fnarg>
	<fnarg type="scalar-or-series">mês</fnarg>
	<fnarg type="scalar-or-series">dia</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o dia da semana (domingo = 0, segunda-feira = 1,
	  etc.) para a(s) data(s) especificadas por três argumentos
	  ou <lit>NA</lit> se a data for inválida. Note que os três
	  argumentos devem ser do mesmo tipo, ou seja, devem ser
	  todos do tipo escalar (inteiro) ou todos do tipo séries.
	</para>
      </description>
    </function>

    <function name="wmean" section="stats" output="series">
      <fnargs>
	<fnarg type="list">Y</fnarg>
	<fnarg type="list">W</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma série <math>y</math> tal que
	  <math>y</math><sub>t</sub> é a média ponderada dos
	  valores das variáveis na lista <argname>Y</argname> na
	  observação <math>t</math>, com os respectivos pesos dados pelos
	  valores das variáveis na lista <argname>W</argname> em
	  <math>t</math>. Os pesos podem assim variar
	  no tempo. As listas <argname>Y</argname> e
	  <argname>W</argname> devem ter o mesmo tamanho e os
	  pesos devem ser não-negativos.
	</para>
	<para>
	  <seelist>
            <fncref targ="wsd"/>
            <fncref targ="wvar"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="wsd" section="stats" output="series">
      <fnargs>
	<fnarg type="list">Y</fnarg>
	<fnarg type="list">W</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma série <math>y</math> tal que
	  <math>y</math><sub>t</sub> é o desvio padrão amostral
	  ponderado dos valores das variáveis na lista
	  <argname>Y</argname> na observação <math>t</math>, com os
	  respectivos pesos dados pelos valores das variáveis na
	  lista <argname>W</argname> em <math>t</math>. Os pesos
	  podem assim variar no tempo. As listas
	  <argname>Y</argname> e <argname>W</argname> devem ter o
	  mesmo tamanho e os pesos devem ser não-negativos.
	</para>
	<para>
	  <seelist>
            <fncref targ="wmean"/>
            <fncref targ="wvar"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="wvar" section="stats" output="series">
      <fnargs>
	<fnarg type="list">X</fnarg>
	<fnarg type="list">W</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma série <math>y</math> tal que
	  <math>y</math><sub>t</sub> é a variância amostral
	  ponderada dos valores das variáveis na lista
	  <argname>Y</argname> na observação <math>t</math>, com os
	  respectivos pesos dados pelos valores das variáveis na
	  lista <argname>W</argname> em <math>t</math>. Os pesos
	  podem assim variar no tempo. As listas
	  <argname>Y</argname> e <argname>W</argname> devem ter o
	  mesmo tamanho e os pesos devem ser não-negativos.
	</para>
	<para context="tex">
	  A variância amostral ponderada é calculada como:
	  \[ s^2_w = \frac{n'}{n'-1} \,
	  \frac{\sum_{i=1}^n w_i(x_i - \bar{x}_w)^2}{\sum_{i=1}^n w_i} \]
	  onde $n'$ é o número de pesos não-nulos e $\bar{x}_w$ é
	  a média ponderada.
	</para>
	<para>
	  <seelist>
            <fncref targ="wmean"/>
            <fncref targ="wsd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="xmax" section="math" output="scalar">
      <fnargs>
	<fnarg type="scalar">x</fnarg>
	<fnarg type="scalar">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o maior valor na comparação entre <argname>x</argname>
	  e <argname>y</argname>. Se algum dos valores for ausente será
	  retornado <lit>NA</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="xmin"/>
            <fncref targ="max"/>
            <fncref targ="min"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="xmin" section="math" output="scalar">
      <fnargs>
	<fnarg type="scalar">x</fnarg>
	<fnarg type="scalar">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o menor valor na comparação entre <argname>x</argname>
	  e <argname>y</argname>. Se algum dos valores for ausente será
	  retornado <lit>NA</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="xmax"/>
            <fncref targ="max"/>
            <fncref targ="min"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="xmlget" section="data-utils" output="string">
      <fnargs>
	<fnarg type="string">buf</fnarg>
	<fnarg type="string-or-strings">path</fnarg>
      </fnargs>
      <description>
	<para>
	  O argumento <argname>buf</argname> deve ser um buffer
	  XML, que pode ser obtido de alguma página na internet
	  via função <fncref targ="curl"/> (ou lida a partir de
	  arquivo via função <fncref targ="readfile"/>), e o
	  argumento <argname>path</argname> deve ser uma
	  especificação única ou um vetor de especificações.
	</para>
	<para>
	  Esta função retorna uma variável de texto (string) representando os
	  dados encontrados no buffer XML no path especificado. Se múltiplos
	  nós corresponderem com a expressão path, os itens dos dados são
	  apresentados em linhas separadas no texto retornado. Se um vetor de
	  paths for utilizado como segundo argumento, o texto retornado assume
	  a forma de um buffer separado por vírgulas, com a coluna <math>i
	  </math> contendo as correspondências do path <math>i</math>. Nesse caso,
	  se um texto obtido do buffer XML contiver quaisquer espaços ou vírgulas
	  ela ficará entre aspas duplas.
	</para>
	<para>
	  Por padrão um erro é sinalizado se <argname>path</argname> não encontrar
	  correspondência no buffer XML, mas esse comportamento é modificado se o
	  terceiro argumento, que é opcional, for dado: nesse caso o argumento
	  recupera o número de correspondências e uma variável de texto vazia é
	  retornada caso não haja correspondências. Exemplo:
	</para>
	<code>
	  ngot = 0
	  ret = xmlget(xbuf, "//some/thing", &amp;ngot)
	</code>
	<para>
	  Entretanto, um erro ainda é sinalizado no caso de uma consulta
	  (query) mal formada.
	</para>
	<para>
	  Uma boa introdução sobre a utilização da sintaxe de XPath
	  pode ser encontrada em
	  <url>https://www.w3schools.com/xml/xml_xpath.asp</url>. O
	  backend para <lit>xmlget</lit> é fornecido pelo módulo xpath
	  do biblioteca libxml2 que, por sua vez, suporta o XPath 1.0
	  mas não o XPath 2.0.
	</para>
	<para>
	  <seelist>
	    <fncref targ="jsonget"/>
	    <fncref targ="readfile"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="zeromiss" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Converte zeros para <lit>NA</lit>s. Se <argname>x</argname> for uma
	  série a conversão será feita elemento por elemento.
	  <seelist>
            <fncref targ="missing"/>
            <fncref targ="misszero"/>
            <fncref targ="ok"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="zeros" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma matriz nula com <math>r</math> linhas e
	  <math>c</math> colunas.
      <seelist>
        <fncref targ="ones"/>
        <fncref targ="seq"/>
      </seelist>
    </para>
      </description>
    </function>

  </funclist>
</funcref>
