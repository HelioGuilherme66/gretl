<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE funcref SYSTEM "genr_funcs.dtd">

<funcref language="portuguese">

  <funclist name="Accessors" ref="accessors">

    <function name="$ahat" section="access" output="series">
      <description>
	<para>
	  Deve seguir a estimação de um modelo de dados em painel com efeitos
	  fixos. Retorna uma série com as estimativas dos efeitos individuais
	  fixos (interceptos por unidade).
	</para>
      </description>
    </function>

    <function name="$aic" section="access" output="scalar">
      <description>
	<para>
	  Retorna o Critério de Informação de Akaike do último modelo
	  estimado, quando disponível. Veja <guideref targ="chap:criteria"/>
	  para detalhes sobre os cálculos.
	</para>
      </description>
    </function>

    <function name="$bic" section="access" output="scalar">
      <description>
	<para>
	  Retorna o Critério de Informação Bayesiano de Schwarz para o
	  último modelo estimado, quando disponível. Veja <guideref
	  targ="chap:criteria"/> para detalhes sobre os cálculos.
	</para>
      </description>
    </function>

    <function name="$chisq" section="access" output="scalar">
      <description>
	<para>
	  Retorna estatística qui-quadrado global do último modelo
	  estimado, quando disponível.
	</para>
      </description>
    </function>

    <function name="$coeff" section="access" output="matrix" altout="scalar">
      <fnargs>
	<fnarg optional="true" type="coeffname">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Quando utilizado sem argumentos, <lit>$coeff</lit> retorna um vetor
	  coluna com os coeficientes estimados do último modelo. Com o argumento
	  opcional de texto (<quote>string</quote>) a função retorna, na forma
	  de um escalar, o parâmetro estimado <argname>s</argname>.
	  <seelist>
            <fncref targ="$stderr"/>
            <fncref targ="$vcv"/>
	  </seelist>
	</para>
	<para>
	  Exemplo:
	</para>
	<code>
	  open bjg
	  arima 0 1 1 ; 0 1 1 ; lg
	  b = $coeff               # fornece um vetor
	  macoef = $coeff(theta_1) # fornece um escalar
	</code>
	<para>
	  Se o <quote>modelo</quote> em questão for um sistema, o
	  resultado dependerá das características do sistema: para
	  VARs e VECMs o valor retornado será uma matriz com uma
	  coluna por equação, caso contrário será um vetor coluna
	  contendo os coeficientes da primeira equação seguidos pelos
	  coeficientes da segunda equação e assim sucessivamente.
	</para>
      </description>
    </function>

    <function name="$command" section="access" output="string">
      <description>
	<para>
	  Deve ser utilizada após a estimação de um modelo e retorna
	  o seu tipo, por exemplo <lit>ols</lit> ou <lit>probit</lit>.
	</para>
      </description>
    </function>

    <function name="$compan" section="access" output="matrix">
      <description>
	<para>
	  Deve ser utilizada após a estimação de um VAR ou um VECM e
	  retorna a matriz companheira.
	</para>
      </description>
    </function>

    <function name="$datatype" section="access" output="scalar">
      <description>
	<para>
	  Retorna um número representando o tipo dos dados que estão sendo
	  atualmente utilizados: 0 = sem dados, 1 = dados de corte transversal
	  (não datados), 2 = dados de séries temporais, 3 = dados em painel.
	</para>
      </description>
    </function>

    <function name="$depvar" section="access" output="string">
      <description>
	<para>
	  Deve ser utilizada após a estimação de um modelo com equação
	  única e retorna o nome da variável dependente.
	</para>
      </description>
    </function>

    <function name="$df" section="access" output="scalar">
      <description>
	<para>
	  Retorna os graus de liberdade do último modelo estimado. Se o
	  último modelo for um sistema de equações, o valor retornado
	  será o número de graus de liberdade por equação. Se os graus de
	  liberdade das equações forem diferentes então o valor dado será
	  calculado como a diferença entre o número de observações e a
	  média do número de coeficientes por equação (essa média será
	  arredondada para o valor inteiro imediatamente superior).
	</para>
      </description>
    </function>

    <function name="$diagpval" section="access" output="scalar">
      <description>
	<para>
	  Deve ser utilizada após a estimação de um sistema de equações e
	  retorna o <math>P</math>-valor associado com a estatística <fncref
	  targ="$diagtest"/>.
	</para>
      </description>
    </function>

    <function name="$diagtest" section="access" output="scalar">
      <description>
	<para>
	  Deve ser utilizada após a estimação de um sistema de equações.
	  Retorna a estatística de teste para a hipótese nula de que a
	  matriz de covariâncias dos resíduos das equações do sistema é
	  diagonal. Este é o teste de Breusch&ndash;Pagan, exceto quando
	  o estimador for o SUR iterado (irrestrito), nesse caso será um
	  teste de razão de verossimilhança. Veja <guideref targ="chap:system"/>
	  para detalhes e também <fncref targ="$diagpval"/>.
	</para>
      </description>
    </function>

    <function name="$dwpval" section="access" output="scalar">
      <description>
	<para>
	  Retorna o p-valor para a estatística de Durbin&ndash;Watson
	  do último modelo estimado (quando disponível). É calculada
	  via procedimento de Imhof.
	</para>
	<para>
	  Devido a precisão limitada da aritmética computacional,
	  a integral de Imhof pode se tornar negativa quando a
	  estatística de Durbin&ndash;Watson estiver próxima de
	  seu limite inferior. Nesse caso o acessor retorna <lit>NA
	  </lit>. Uma vez que qualquer outra falha será sinalizada,
	  é possivelmente seguro assumir que um resultado NA indica
	  que o verdadeiro p-valor é <quote>muito pequeno</quote>,
	  embora não seja possível quantificá-lo.
	</para>
      </description>
    </function>

    <function name="$ec" section="access" output="matrix">
      <description>
	<para>
	  Deve ser utilizada após a estimação de um VECM e retorna uma matriz
	  contendo os termos de correção de erros. O número de linhas é igual
	  ao número de observações utilizadas e o número de colunas é igual à
	  ordem de cointegração do sistema.
	</para>
      </description>
    </function>

    <function name="$error" section="access" output="scalar">
      <description>
	<para>
	  Retorna o código interno de erro do programa. Esse código será
	  um valor não-nulo quando a função <cmdref targ="catch"/> tiver
	  sido utilizada. Note que o código interno de erro irá retornar
	  para zero quando este acessor for utilizado novamente. Para
	  consultar, posteriormente, a mensagem de erro associada a um
	  dado <lit>$error</lit> será necessário armazená-la em uma
	  variável. Isso pode ser feito da sequinte forma:
	</para>
	<code>
	  err = $error
	  if (err)
	      printf "Got error %d (%s)\n", err, errmsg(err);
	  endif
	</code>
	<para>
	  <seelist>
            <cmdref targ="catch"/>
            <fncref targ="errmsg"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$ess" section="access" output="scalar">
      <description>
	<para>
	  Retorna o erro da soma dos quadrados do último modelo
	  estimado, quando disponível.
	</para>
      </description>
    </function>

    <function name="$evals" section="access" output="matrix">
      <description>
	<para>
	  Deve ser utilizada após a estimação de um VECM e retorna
	  um vetor contendo os autovalores que foram utilizados no
	  cálculo do teste traço para verificação da cointegração.
	</para>
      </description>
    </function>

    <function name="$fcast" section="access" output="matrix">
      <description>
	<para>
	  Deve ser utilizada após o comando <cmdref targ="fcast"/> e
	  retorna os valores previstos na forma de uma matriz. Se foi
	  utilizado um sistema de equações para realizar as previsões
	  a matriz será composta por uma coluna para cada equação,
	  caso contrário será um vetor coluna.
	</para>
      </description>
    </function>

    <function name="$fcerr" section="access" output="matrix">
      <description>
	<para>
	  Deve ser utilizada após o comando <cmdref targ="fcast"/> e retorna
	  os erros padrão das previsões, quando disponíveis, na forma de uma
	  matriz. Se foi utilizado um sistema de equações para realizar as
	  previsões a matriz será composta por uma coluna para cada equação,
	  caso contrário será um vetor coluna.
	</para>
      </description>
    </function>

    <function name="$fevd" section="access" output="matrix">
      <description>
	<para>
	  Deve ser utilizada após a estimação de um VAR e retorna uma matriz
	  contendo a decomposição da variância dos erros de previsão (FEVD, na
	  sigla em inglês). Essa matriz possui <math>h</math> linhas, ou seja,
	  indica a quantidade de períodos do horizonte de previsão que, por sua
	  vez, pode ser escolhida de forma manual via <lit>set horizon</lit> ou
	  de forma automática com base na frequência dos dados.
	</para>
	<para>
	  Para um VAR com <math>p</math> variáveis, a matriz possui <math>p</math>
	  <sup>2</sup> colunas: as primeiras <math>p</math> colunas contém
	  a FEVD para a primeira variável do VAR, as <math>p</math> colunas
	  seguintes contém a FEVD para a segunda variável do VAR e assim
	  sucessivamente. A fração (em termos decimais) do erro de previsão
	  da variável <math>i</math> causado por uma inovação na variável
	  <math>j</math> é então encontrado na coluna (<math>i</math> &minus; 1)
	  <math>p</math> + <math>j</math>.
	</para>
      </description>
    </function>

    <function name="$Fstat" section="access" output="scalar">
      <description>
	<para>
	  Retorna estatística F global do último modelo estimado, quando
	  disponível.
	</para>
      </description>
    </function>

    <function name="$gmmcrit" section="access" output="scalar">
      <description>
	<para>
	  Deve ser utilizada após um bloco <lit>gmm</lit>. Retorna o valor
	  da função objetivo GMM em seu mínimo.
	</para>
      </description>
    </function>

    <function name="$h" section="access" output="series">
      <description>
	<para>
	  Deve ser utilizada após o comando <lit>garch</lit>. Retorna a
	  série da variância condicional estimada.
	</para>
      </description>
    </function>

    <function name="$hausman" section="access" output="rvec">
      <description>
	<para>
	  Deve ser utilizada após a estimação de um modelo via <lit>tsls</lit>
	  ou <lit>panel</lit> com a opção de efeitos aleatórios. Retorna um
	  vetor <by r="1" c="3"/> contendo o valor da estatística do teste de
	  Hausman, os graus de liberdade correspondentes e o p-valor para o
	  teste, respectivamente.
	</para>
     </description>
    </function>

    <function name="$hqc" section="access" output="scalar">
      <description>
	<para>
	  Retorna o Critério de Informação de Hannan-Quinn para o último
	  modelo estimado, quando disponível. Veja <guideref
	  targ="chap:criteria"/> para detalhes sobre os cálculos.
	</para>
      </description>
    </function>

    <function name="$huge" section="access" output="scalar">
      <description>
	<para>
	  Retorna um número positivo com valor bastante elevado. Por padrão é igual
	  a 1.0E100, mas pode ser alterado via comando <cmdref targ="set"/>.
	</para>
      </description>
    </function>

    <function name="$jalpha" section="access" output="matrix">
      <description>
	<para>
	  Deve ser utilizada após a estimação de um VECM e retorna a matriz de
	  cargas. O número de linhas dessa matriz é igual ao número de variáveis
	  do VECM e o número de colunas é igual a ordem de cointegração.
	</para>
      </description>
    </function>

    <function name="$jbeta" section="access" output="matrix">
      <description>
	<para>
	  Deve ser utilizada após a estimação de um VECM e retorna a matriz
	  de cointegração. O número de linhas dessa matriz é igual ao número
	  de variáveis no VECM (se existirem variáveis exógenas restritas ao
	  espaço de cointegração adiciona-se mais uma linha) e o número de
	  colunas é igual a ordem de cointegração.
	</para>
      </description>
    </function>

    <function name="$jvbeta" section="access" output="smatrix">
      <description>
	<para>
	  Deve ser utilizada após a estimação de um VECM e retorna a matriz de
	  covariâncias estimada para os elementoss dos vetores de cointegração.
	</para>
	<para>
	  No caso de uma estimação sem restrições, o número de linhas dessa
	  matriz é igual ao número de elementos irrestritos do espaço de
	  cointegração após a normalização de Phillips. Entretanto, se for
	  estimado um sistema restrito via comando <lit>restrict</lit> com
	  a opção <lit>--full</lit>, uma matriz singular com <math>(n+m)r
	  </math> linhas será retornada (sendo <math>n</math> o número de
	  variáveis endógenas, <math>m</math> o número de variáveis exógenas
	  restritas ao espaço de cointegração e <math>r</math> a ordem de
	  cointegração).
	</para>
	<para>
	  Exemplo: o código
	</para>
	<code>
	  open denmark.gdt
	  vecm 2 1 LRM LRY IBO IDE --rc --seasonals -q
	  s0 = $jvbeta

	  restrict --full
	    b[1,1] = 1
	    b[1,2] = -1
	    b[1,3] + b[1,4] = 0
	  end restrict
	  s1 = $jvbeta

	  print s0
	  print s1
	</code>
	<para>
	  produz a seguinte saída.
	</para>
	<code>
	  s0 (4 x 4)

          0.019751     0.029816  -0.00044837     -0.12227
          0.029816      0.31005     -0.45823     -0.18526
	   -0.00044837     -0.45823       1.2169    -0.035437
          -0.12227     -0.18526    -0.035437      0.76062

	  s1 (5 x 5)

	  0.0000       0.0000       0.0000       0.0000       0.0000
	  0.0000       0.0000       0.0000       0.0000       0.0000
	  0.0000       0.0000      0.27398     -0.27398    -0.019059
	  0.0000       0.0000     -0.27398      0.27398     0.019059
	  0.0000       0.0000    -0.019059     0.019059    0.0014180
	</code>
      </description>
    </function>

    <function name="$lang" section="access" output="string">
      <description>
	<para>
	  Retorna o texto (<quote>string</quote>) com o código do idioma que
	  está sendo utilizado no momento, desde que este possa ser determinado.
	  O texto é composto pelo código ISO 639-1 com duas letras (por exemplo,
	  <lit>en</lit> para inglês, <lit>jp</lit> para japonês, <lit>el</lit>
	  para grego) seguido de um sublinhado e o código do país de acordo com
	  o ISO 3166-1. Assim, por exemplo, o português de Portugal é
	  representado por <lit>pt_PT</lit> enquanto o português do Brasil
	  é representado por <lit>pt_BR</lit>.
	</para>
	<para>
	  Se o idioma não puder ser determinado será retornado o texto
	  <quote><lit>unknown</lit></quote>.
	</para>
      </description>
    </function>

    <function name="$llt" section="access" output="series">
      <description>
	<para>
	  Para determinado modelos estimados via Máxima Verossimilhança a
	  função retorna os valores do log da verossimilhança para cada
	  observação. Atualmente essa função está disponível para logit
	  e probit binários, tobit e heckit.
	</para>
      </description>
    </function>

    <function name="$lnl" section="access" output="scalar">
      <description>
	<para>
	  Retorna a log-verossimilhança para o último modelo estimado
	  (quando for aplicável).
	</para>
      </description>
    </function>

    <function name="$macheps" section="access" output="scalar">
      <description>
	<para>
	  Retorna o valor do <quote>épsilon da máquina</quote> que, por sua vez,
	  fornece um limite superior para o erro relativo devido ao arredondamento
	  na aritmética de ponto flutuante com precisão dupla.
	</para>
      </description>
    </function>

    <function name="$mnlprobs" section="access" output="matrix">
      <description>
	<para>
	  Deve seguir a estimação de um modelo logit multinomial (apenas)
	  e retorna uma matriz com as probabilidades estimadas para cada
	  resultado possível em cada observação dentro da amostra utilizada
	  na estimação do modelo. Cada linha representa uma observação e
	  cada coluna representa um resultado.
	</para>
      </description>
    </function>

    <function name="$model" section="access" output="bundle">
      <description>
	<para>
	  Deve seguir a estimação de modelos de equação única e retorna um
	  pacote (<quote>bundle</quote>) contendo vários itens pertencentes
	  ao modelo. Todos os acessores de modelos regulares são incluídos
	  e são referenciados por chaves iguais aos nomes dos acessores
	  regulares menos o cifrão inicial. Assim, por exemplo, os resíduos
	  aparecem sob a chave <lit>uhat</lit> e o quadrado da soma dos
	  erros sob <lit>ess</lit>.
	</para>
	<para>
	  Dependendo do estimador, informações adicionais podem ser
	  disponibilizadas. As chaves para tais informações são normalmente
	  auto-explicativas. Para ver o que está disponível basta salvar o
	  pacote e imprimir seu conteúdo. Isso é mostrado no exemplo a seguir:
	</para>
	<code>
	  ols y 0 x
	  bundle b = $model
	  print b
	</code>
      </description>
    </function>

    <function name="$ncoeff" section="access" output="int">
      <description>
	<para>
	  Retorna o número total de coeficientes estimados no último
	  modelo.
	</para>
      </description>
    </function>

    <function name="$nobs" section="access" targ="dnobs" output="int">
      <description>
	<para>
	  Retorna o número de observações na amostra atualmente
	  selecionada.
	</para>
      </description>
    </function>

    <function name="$nvars" section="access" output="int">
      <description>
	<para>
	  Retorna o número de variáveis no conjunto de dados (incluindo a
	  constante).
	</para>
      </description>
    </function>

    <function name="$obsdate" section="access" output="series">
      <description>
	<para>
	  Deve ser utilizada quando o conjunto de dados corrente for composto por
	  séries temporais com frequência decenal, anual, trimestral, mensal,
	  semanal (datada) ou diária (datada). Pode ser utilizada também com dados
	  em painel quando a informação temporal estiver ajustada corretamente
	  (veja o comando <cmdref targ="setobs"/>). A série que será retornada é
	  composta por números com 8 dígitos seguindo o padrão <lit>YYYYMMDD</lit>
	  (formato de dados <quote>básico</quote> do ISO 8601), que correspondem
	  ao dia da observação ou ao primeiro dia da observação no caso de
	  frequências de séries temporais menores que a diária.
	</para>
	<para>
	  Esta série pode ser útil na utilização do comando <cmdref
	  targ="join"/>.
	</para>
      </description>
    </function>

    <function name="$obsmajor" section="access" output="series">
      <description>
	<para>
	  É aplicável quando as observações no conjunto de dados corrente
	  têm uma estrutura maior:menor, como em séries temporais trimestrais
	  (ano:trimestre), séries temporais mensais (ano:mês), dados de horas
	  (dia:hora) e dados em painel (indíviduo:período). Retorna uma série
	  contendo o componente maior, ou de menor frequência, de cada
	  observação (por exemplo, o ano).
	</para>
	<para>
	  <seelist>
            <fncref targ="$obsminor"/>
            <fncref targ="$obsmicro"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$obsmicro" section="access" output="series">
      <description>
	<para>
	  É aplicável quando as observações no conjunto de dados corrente
	  têm uma estrutura maior:menor:micro, como em séries temporais
	  datadas diárias (ano:mês:dia). Retorna uma série contendo o
	  componente micro, ou de maior frequência, de cada observação
	  (por exemplo, o dia).
	</para>
	<para>
	  <seelist>
            <fncref targ="$obsmajor"/>
            <fncref targ="$obsminor"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$obsminor" section="access" output="series">
      <description>
	<para>
	  É aplicável quando as observações no conjunto de dados corrente
	  têm uma estrutura maior:menor, como em séries temporais trimestrais
	  (ano:trimestre), séries temporais mensais (ano:mês), dados de horas
	  (dia:hora) e dados em painel (indíviduo:período). Retorna uma série
	  contendo o componente menor, ou de maior frequência, de cada
	  observação (por exemplo, o mês).
	</para>
	<para>
	  No caso de dados diários datados, <lit>$obsminor</lit> retorna o
	  mês de cada observação.
	</para>
	<para>
	  <seelist>
            <fncref targ="$obsmajor"/>
            <fncref targ="$obsmicro"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$pd" section="access" output="int">
      <description>
	<para>
	  Retorna a frequência ou periodicidade dos dados (por exemplo: 4 para
	  dados trimestrais). No caso de dados em painel o valor retornado será
	  a quantidade de períodos de tempo no conjunto de dados.
	</para>
      </description>
    </function>

    <function name="$pi" section="access" output="scalar">
      <description>
	<para>
	  Retorna o valor de &pi; com dupla precisão.
	</para>
      </description>
    </function>

    <function name="$pvalue" section="access" targ="dpvalue" output="scalar-or-matrix">
      <description>
	<para>
	  Retorna o p-valor da estatística de teste que foi gerada
	  pelo último comando explícito de teste de hipóteses (por
	  exemplo: <lit>chow</lit>). Veja <guideref targ="chap:genr"/>
	  para detalhes.
	</para>
	<para>
	  Geralmente retorna um escalar, mas em alguns casos retorna uma
	  matriz. Isso ocorre, por exemplo, com os p-valores dos testes
	  lâmbda traço e lâmbda máximo associadas ao teste de cointegração
	  de Johansen). Nesse caso os valores na matriz estarão dispostos
	  da mesma forma que na saída do teste.
	</para>
	<para>
	  <seelist>
            <fncref targ="$test"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$qlrbreak" section="access" output="scalar">
      <description>
	<para>
	  Deve ser utilizada após o comando <cmdref targ="qlrtest"/>
	  (que realiza o teste QLR para quebra estrutural em um ponto
	  desconhecido. Retorna o número da observação no qual a
	  estatística de teste é maximizada.
	</para>
      </description>
    </function>

    <function name="$rho" section="access" output="scalar">
      <fnargs>
	<fnarg optional="true" type="scalar">n</fnarg>
      </fnargs>
      <description>
	<para>
	  Se for utilizada sem argumentos a função retorna o coeficiente
	  autorregressivo de primeira ordem para os resíduos do último
	  modelo. Após a estimação de um modelo via comando <lit>ar</lit>,
	  a sintaxe <lit>$rho(n)</lit> retorna a esimativa correspondente
	  de &rgr;(<math>n</math>).
	</para>
      </description>
    </function>

    <function name="$rsq" section="access" output="scalar">
      <description>
	<para>
	  Retorna o <math>R</math><sup>2</sup> não ajustado do último
	  modelo estimado, quando disponível.
	</para>
      </description>
    </function>

    <function name="$sample" section="access" output="series">
      <description>
	<para>
	  Deve ser utilizada após a estimação de um modelo com equação simples
	  e retona uma variável dummy com valores iguais a 1 nas observações
	  utilizadas na estimação, 0 nas observações na amostra corrente e que
	  não foram utilizadas na estimação (possivelmente devido a valores
	  ausentes) e NA nas observações fora da amostra selecionada corrente.
	</para>
	<para>
	  Caso se queira calcular estatísticas baseadas na amostra que foi
	  utilizada para um dado modelo, pode-se fazer, por exemplo:
	</para>
	<code>
	  ols y 0 xlist
	  genr sdum = $sample
	  smpl sdum --dummy
	</code>
      </description>
    </function>

    <function name="$sargan" section="access" output="rvec">
      <description>
	<para>
	  Deve ser utilizada após o comando <lit>tsls</lit>. Retorna
	  um vetor <by r="1" c="3"/> contendo a estatística do teste
	  de sobre-identificação de Sargan e os correspondentes graus
	  de liberdade e p-valor, respectivamente. Se o modelo for
	  exatamente identificado a estatística não estará disponível
	  e tentar acessá-la irá provocar um erro.
	</para>
      </description>
    </function>

    <function name="$sigma" section="access" output="scalar-or-matrix">
      <description>
	<para>
	  Se o último modelo estimado foi uma equação simples, retorna
	  o erro padrão da regressão na forma de um escalar (ou, em
	  outras palavras, retorna o desvio padrão dos resíduos com uma
	  correção apropriada de graus de liberdade). Se o último model
	  foi um sistema de equações, retorna a matriz de covariâncias
	  dos resíduos das equações do sistema.
	</para>
      </description>
    </function>

    <function name="$stderr" section="access" output="matrix" altout="scalar">
      <fnargs>
	<fnarg optional="true" type="coeffname">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Quando utilizado sem argumentos, <lit>$stderr</lit> retorna um
	  vetor coluna com os erros padrão dos coeficientes do último
	  modelo estimado. Com o argumento opcional de texto (<quote>string</quote>) a função
	  retorna, na forma de um escalar, o parâmetro estimado
	  <argname>s</argname>.
	</para>
	<para>
	  Se o <quote>modelo</quote> um sistema, o resultado dependerá de
	  suas características: para VARs e VECMs o valor retornado será
	  uma matriz contendo uma coluna para cada equação, caso contrário,
	  será um vetor coluna contendo os coeficientes da primeira equação
	  seguidos pelos coeficientes da segunda equação e assim
	  sucessivamente.
	</para>
	<para>
	  <seelist>
            <fncref targ="$coeff"/>
            <fncref targ="$vcv"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$stopwatch" section="access" output="scalar">
      <description>
	<para>
	  Deve ser precedida pelo comando <lit>set stopwatch</lit> que, por sua
	  vez, ativa a medição de tempo da CPU. Na primeira utilização do acessor
	  obtem-se a quantidade de segundos que se passaram desde o comando
	  <lit>set stopwatch</lit>. A cada acesso o relógio será reiniciado de
	  forma que as utilizações subsequentes de <lit>$stopwatch</lit> irão
	  fornecer os segundos da CPU entre as duas utilizações.
	</para>
      </description>
    </function>

    <function name="$sysA" section="access" output="matrix">
      <description>
	<para>
	  Deve ser utilizada após a estimação de um sistema de equações
	  simultâneas. Retorna a matriz com os coeficientes das variáveis
	  endógenas defasadas, caso existam, na forma estrutural do
	  sistema. Veja o comando <cmdref targ="system"/>.
	</para>
      </description>
    </function>

    <function name="$sysB" section="access" output="matrix">
      <description>
	<para>
	  Deve ser utilizada após a estimação de um sistema de
	  equações simultâneas. Retorna a matriz com os coeficientes
	  das variáveis exógenas na forma estrutural do sistema.
	  Veja o comando <cmdref targ="system"/>.
	</para>
      </description>
    </function>

    <function name="$sysGamma" section="access" output="matrix">
      <description>
	<para>
	  Deve ser utilizada após a estimação de um sistema de
	  equações simultâneas. Retorna a matriz com os coeficientes
	  das variáveis endógenas contemporâneas na forma estrutural
	  do sistema. Veja o comando <cmdref targ="system"/>.
	</para>
      </description>
    </function>

    <function name="$sysinfo" section="access" output="bundle">
      <description>
	<para>
	  Retorna um pacote (<quote>bundle</quote>) contendo informações
	  sobre o Gretl e o sistema operacional onde está sendo executado.
	  O elementos do pacote são especificados a seguir.
	</para>
	<ilist>
	  <li>
            <para>
              <lit>mpi</lit>: inteiro, igual a 1 se o sistema suporta
              MPI (Message Passing Interface), caso contrário 0.
            </para>
	  </li>
	  <li>
            <para>
              <lit>omp</lit>: inteiro, igual a 1 se o Gretl foi compilado
              com suporte a Open MP, caso contrário 0.
            </para>
	  </li>
	  <li>
            <para>
              <lit>nproc</lit>: inteiro, indica o número de processadores
              disponíveis.
            </para>
	  </li>
	  <li>
            <para>
              <lit>mpimax</lit>: inteiro, indica o número máximo de processos
              MPI que podem ser executados em paralelo. É igual a zero se não
              houver suporte para MPI, caso contrário é igual ao valor de
              <lit>nproc</lit> local. Se for especificado um arquivo de hosts
              MPI, <lit>mpimax</lit> será igual a soma do número de
              processadores ou <quote>slots</quote> ao longo de todas a
              máquinas referenciadas no arquivo.
            </para>
	  </li>
	  <li>
            <para>
              <lit>wordlen</lit>: inteiro, igual a 32 ou 64 para sistemas de
              32 bit e 64, respectivamente.
            </para>
	  </li>
	  <li>
            <para>
              <lit>os</lit>: texto representando o sistema operacional e é
              igual a <lit>linux</lit>, <lit>osx</lit>,
              <lit>windows</lit> ou <lit>other</lit>.
            </para>
	  </li>
	  <li>
            <para>
              <lit>hostname</lit>: informa o nome da máquina (ou
              <quote>host</quote>) onde o Gretl está sendo executado
              no momento. Se não for possível determinar o nome,
              será retornado o <lit>localhost</lit>.
            </para>
	  </li>
	</ilist>
	<para>
	  Note que elemntos individuais no pacote podem ser acessados via
	  utilização da notação <quote>dot</quote> sem a necessidade de
	  copiar o pacote inteiro. Por exemplo,
	</para>
	<code>
	  if $sysinfo.os == "linux"
	      # faça alguma coisa que seja própria do Linux
	  endif
	</code>
      </description>
    </function>

    <function name="$T" section="access" output="int">
      <description>
	<para>
	  Retorna o número de observações utilizadas na estimação do
	  último modelo.
	</para>
      </description>
    </function>

    <function name="$t1" section="access" output="int">
      <description>
	<para>
	  Retorna o número da primeira observação na amostra
	  selecionada corrente.
	</para>
      </description>
    </function>

    <function name="$t2" section="access" output="int">
      <description>
	<para>
	  Retorna o número da última observação na amostra
	  selecionada corrente.
	</para>
      </description>
    </function>

    <function name="$test" section="access" output="scalar-or-matrix">
      <description>
	<para>
	  Retorna o valor da estatística de teste que foi gerada
	  pelo último comando explícito de teste de hipóteses (por
	  exemplo: <lit>chow</lit>). Veja <guideref targ="chap:genr"/>
	  para detalhes.
	</para>
	<para>
	  Geralmente retorna um escalar, mas em alguns casos retorna
	  uma matriz. Isso ocorre, por exemplo, com as estatísticas
	  lâmbda traço e lâmbda máximo associadas ao teste de cointegração
	  de Johansen). Nesse caso os valores na matriz estarão dispostos
	  da mesma forma que na saída do teste.
	</para>
	<para>
	  <seelist>
            <fncref label="\$pvalue" targ="dpvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$trsq" section="access" output="scalar">
      <description>
	<para>
	  Retorna <math>TR</math><sup>2</sup> (tamanho da amostra multiplicado
	  pelo R-quadrado) do último modelo, quando disponível.
	</para>
      </description>
    </function>

    <function name="$uhat" section="access" output="series">
      <description>
	<para>
	  Retorna os resíduos do último modelo. Isto pode ter diferentes
	  significados a depender dos estimadores utilizados. Por exemplo,
	  após a estimação de um ARMA <lit>$uhat</lit> irá conter os erros
	  de previsão de 1 passo à frente, após a estimação de um probit
	  irá conter os resíduos generalizados.
	</para>
	<para>
	  Se o <quote>modelo</quote> em questão for um sistema
	  (um VAR, um VECM ou um sistema de equações simultâneas),
	  o <lit>$uhat</lit> sem parâmetros fornece a matriz de
	  resíduos, uma coluna por equação.
	</para>
      </description>
    </function>

    <function name="$unit" section="access" output="series">
      <description>
	<para>
	  Vale apenas para dados de painel. Retorna uma série com valor igual
	  a 1 em todas as observações na primeira unidade ou grupo, 2 em todas
	  as observações na segunda unidade ou grupo e assim sucessivamente.
	</para>
      </description>
    </function>

    <function name="$vcv" section="access" output="matrix" altout="scalar">
      <fnargs>
	<fnarg optional="true" type="coeffname">s1</fnarg>
	<fnarg optional="true" type="coeffname">s2</fnarg>
      </fnargs>
      <description>
	<para>
	  Quando utilizado sem argumentos, <lit>$vcv</lit> retorna uma matriz
	  contendo a matriz de covariâncias estimadas para os coeficientes do
	  último modelo. Se o último modelo foi uma equação simples, então é
	  possível fornecer os nomes dos dois parâmetros entre parênteses para
	  se obter a covariância estimada entre <argname>s1</argname> e
	  <argname>s2</argname>.
	  <seelist>
            <fncref targ="$coeff"/>
            <fncref targ="$stderr"/>
	  </seelist>
	</para>
	<para>
	  Este acessor não está disponível para VARs ou VECMs. Para modelos
	  desse tipo <fncref targ="$sigma"/> e <fncref targ="$xtxinv"/>.
	</para>
      </description>
    </function>

    <function name="$vecGamma" section="access" output="matrix">
      <description>
	<para>
	  Deve ser utilizada após a estimação de um VECM e retorna uma
	  matriz na qual as matrizes Gama (coeficientes das diferenças
	  defasadas das variáveis cointegradas) são empilhadas lado a
	  lado. Cada linha representa uma equação. Para um VECM de ordem
	  <math>p</math> existem <math>p</math> &minus; 1 sub-matrizes.
	</para>
      </description>
    </function>

    <function name="$version" section="access" output="scalar">
      <description>
	<para>
	  Retorna um valor inteiro que identifica a versão do Gretl.
	  Atualmente a versão do Gretl é composta por um texto com o
	  seguinte formato: ano, com 4 dígitos, seguido de uma letra,
	  de a até j, representando as atualizações dentro desse ano
	  (por exemplo, 2015d). O valor retornado por essa função é
	  igual ao ano multiplicado por 10 e adicionado de um número
	  representando, em ordem léxica, a letra. Assim, 2015d seria
	  representado por 20153.
	</para>
	<para>
	  Em versões anteriores ao Gretl 2015d, o identificador possuia
	  a seguinte forma: x.y.z (três inteiros separados por pontos) e
	  o valor da função era calculado como <lit>10000*x + 100*y + z
	  </lit>. Assim, por exemplo, a versão 1.10.2 era traduzida como
	  11002. Note que dessa forma a ordem numérica de <lit>$version
	  </lit> foi preservada mesmo com a mudança no esquema de versões.
	</para>
      </description>
    </function>

    <function name="$vma" section="access" output="matrix">
      <description>
	<para>
	  Deve ser utilizada após a estimação de um VAR ou um VECM e
	  retorna uma matriz contendo a representação VMA até a ordem
	  especificada via comando <lit>set horizon</lit>. Veja
	  <guideref targ="chap:var"/> para detalhes.
	</para>
      </description>
    </function>

    <function name="$windows" section="access" output="int">
      <description>
	<para>
	  Retorna o valor 1 se o Gretl estiver sendo utilizado no Windows e 0 caso contrário.
	  Através dessa função é possível utilizar comandos <quote>shell </quote>
	  em scripts que possam ser executados em diferentes sistemas operacionais.
	</para>
	<para>
	  Veja também o comando <cmdref targ="shell"/>.
	</para>
      </description>
    </function>

    <function name="$xlist" section="access" output="list">
      <description>
	<para>
	  Se o último modelo estimado foi um equação simples a função retorna
	  uma lista com os regressores. Se o último modelo foi um sistema de
	  equações ela retorna uma lista <quote>global</quote> com as variáveis
	  exógenas e predeterminadas (na mesma ordem que aparecem na função
	  <fncref targ="$sysB"/>). Se o último modelo foi um VAR ela retorna
	  uma lista com os regressores exógenos, caso existam.
	</para>
      </description>
    </function>

    <function name="$xtxinv" section="access" output="matrix">
      <description>
	<para>
	  Após a estimação de um VAR ou VECM (apenas), retorna
	  <math>X'X</math><sup>-1</sup>, onde <math>X</math> é
	  a matriz comum de regressores utilizados em cada equação.
	  Esse acessor não está dsponível para VECMs estimados com
	  restrições impostas na a matriz de cargas(&agr;).
	</para>
      </description>
    </function>

    <function name="$yhat" section="access" output="series">
      <description>
	<para>
	  Retorna os valores ajustados da última regressão.
	</para>
      </description>
    </function>

    <function name="$ylist" section="access" output="list">
      <description>
	<para>
	  Se o último modelo estimado foi um VAR, um VECM ou um sistema de
	  equações simultâneas a função retorna uma lista com as variáveis
	  endógenas. Se o último modelo foi uma equação simples o acessor
	  retorna uma lista com apenas um elemento, a variável dependente.
	  No caso especial do modelo biprobit a lista irá conter dois
	  elementos.
	</para>
      </description>
    </function>

  </funclist>

  <funclist name="Functions proper" ref="functions">

    <function name="abs" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o valor absoluto de <argname>x</argname>.
	</para>
      </description>
    </function>

    <function name="acos" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o arco-cosseno de <argname>x</argname>, isto é, o valor
	  cujo cosseno é <argname>x</argname>. Resultado em radianos e o
	  argumento deve estar entre &minus;1 e 1.
	</para>
      </description>
    </function>

    <function name="acosh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o cosseno hiperbólico inverso de <argname>x</argname>
	  (solução positiva). <argname>x</argname> deve ser maior que 1,
	  caso contrário a função retornará NA.
	  <seelist>
            <fncref targ="cosh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="aggregate" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
	<fnarg type="series-or-list">byvar</fnarg>
	<fnarg type="string" optional="true">funcname</fnarg>
      </fnargs>
      <description>
	<para>
	  Na forma mais simples de uso, <argname>x</argname> é igual a
	  <lit>null</lit>, <argname>byvar</argname> é uma séries individual
	  e o terceiro argumento é omitido. Neste caso é retornada uma
	  matriz com duas colunas contendo na primeira coluna os valores
	  distintos de <argname>byvar</argname>, ordenados de forma crescente,
	  e na segunda a quantidade de observações de <argname>byvar</argname>
	  para cada um dos valores distintos.
	  Por exemplo,
	</para>
	<code>
	  open data4-1
	  eval aggregate(null, bedrms)
	</code>
	<para>
	  will show that the series <lit>bedrms</lit> has values
	  3 (with count 5) and 4 (with count 9).
	</para>
	<para>
	  If <argname>x</argname> and <argname>byvar</argname> are
	  both individual series and the third argument is given, the
	  return value is a matrix with three columns holding,
	  respectively, the distinct values of
	  <argname>byvar</argname>, sorted in ascending order; the
	  count of observations at which <argname>byvar</argname>
	  takes on each of these values; and the values of the
	  estatística especificada por <argname>funcname</argname> calculada na
	  série <argname>x</argname>, usando apenas aquelas observações
	  nas quais <argname>byvar</argname> tem valor igual aos dados
	  na primeira coluna.
	</para>
	<para>
	  Mais geralmente, se <argname>byvar</argname> for uma lista
	  com <math>n</math> membros então as <math>n</math> colunas a
	  esquerda contêm as combinações dos valores distintos de cada
	  uma das <math>n</math> séries e a coluna de contagem contém
	  o número de observações nas quais cada combinação é feita.
	  Se <argname>x</argname> for uma lista com <math>m</math>
	  membros então as <math>m</math> colunas mais a direita contêm
	  os valores da estatística especificada para cada uma das
	  <argname>x</argname> variáveis, novamente calculadas na
	  subamostra indicada na(s) primeira(s) coluna(s).
	</para>
	<para>
	  Os seguintes valores de <argname>funcname</argname> são
	  suportados de forma <quote>nativa</quote>: <fncref targ="sum"/>,
	  <fncref targ="sumall"/>, <fncref targ="mean"/>, <fncref targ=
	  "sd"/>, <fncref targ="var"/>, <fncref targ="sst"/>, <fncref
	  targ="skewness"/>, <fncref targ="kurtosis"/>, <fncref targ=
	  "min"/>, <fncref targ="max"/>, <fncref targ="median"/>, <fncref
	  targ="nobs"/> e <fncref targ="gini"/>. Cada uma dessas funções
	  utiliza uma série como argumento e retorna um valor escalar e,
	  nesse sentido, pode-se dizer que <quote>agregam</quote> a série
	  de alguma forma. É possível utilizar uma função definida pelo
	  usuário como um agregador. Da mesma forma que as funções
	  nativas, tal função deve ter como argumento apenas uma única
	  série e retornar um valor escalar.
	</para>
	<para>
	  Note que apesar de a contagem de casos ser realizada de forma
	  automática pela função <lit>nobs</lit>, a função <lit>aggregate
	  </lit> não é redundante como uma agregadora, uma vez que fornece
	  o número de observações válidas (não ausentes) em <argname>x
	  </argname> em cada combinação <argname>byvar</argname>.
	</para>
	<para>
	  Para exemplificar isso, suponha que <lit>region</lit>
	  representa um código de uma região geográfica usando valores
	  inteiros de 1 até <math>n</math> e <lit>income</lit> representa
	  a renda doméstica. Então o cálculo a seguir deverá produzir uma
	  matriz de ordem <by r="n" c="3"/> contendo os códigos das regiões,
	  a contagem de observações em cada região e a renda média doméstica
	  para cada uma das regiões:
	</para>
	<code>
	  matrix m = aggregate(income, region, mean)
	</code>
	<para>
	  Para um exemplo usando listas, seja <lit>gender</lit> uma variável
	  dummy macho/fêmea, seja <lit>race</lit> uma variável categórica com
	  três valores e considere o seguinte código:
	</para>
	<code>
	  list BY = gender race
	  list X = income age
	  matrix m = aggregate(X, BY, sd)
	</code>
	<para>
	  A utilização de <lit>aggregate</lit> produzirá uma matriz de ordem
	  <by r="6" c="5"/>. As primeiras duas colunas contêm as 6 distintas
	  combinações dos valores de gênero e raça. A coluna do meio contém
	  a contagem para cada uma dessas combinações. As duas colunas mais
	  à direita contêm os devios padrão amostrais de <lit>income</lit> e
	  <lit>age</lit>.
	</para>
	<para>
	  Note que se <argname>byvar</argname> for uma lista, algumas combinações
	  dos valores de <argname>byvar</argname> podem não estar presentes nos
	  dados (fornecendo uma contagem igual a zero). Nesse caso os valores das
	  estatísticas para <argname>x</argname> são considerados como <lit>NaN</lit>
	  (ou seja, não são números). Caso seja desejado ignorar esses
	  casos é possível utilizar a função <fncref targ="selifr"/> para
	  selecionar apenas aquelas linhas que não possuam uma contagem igual a
	  zero. A coluna a ser testada estará uma posição à direita após o número
	  de variáveis de <argname>byvar</argname>, assim, pode-seutilizar o
	  seguinte código:
	</para>
	<code>
	  matrix m = aggregate(X, BY, sd)
	  scalar c = nelem(BY)
	  m = selifr(m, m[,c+1])
	</code>
      </description>
    </function>

    <function name="argname" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Seja <argname>s</argname> o nome de um parâmetro de uma função definida
	  pelo usuário, retorna o nome do argumento correspondente ou uma variável
	  de texto (<quote>string</quote>) vazia se o argumento for anônimo.
	</para>
      </description>
    </function>

    <function name="array" section="data-utils" output="seebelow">
      <fnargs>
	<fnarg type="int">n</fnarg>
      </fnargs>
      <description>
	<para>
	  É a função <quote>construtora</quote> básica de uma nova variável
	  do tipo arranjo (<quote>array</quote>). Ao usar esta função é
	  necessário que se especifique um tipo (na forma plural) para o
	  arranjo: <lit>strings</lit>, <lit>matrices</lit>, <lit>bundles</lit>
	  ou <lit>lists</lit>. O valor de retorno é um arranjo do
	  tipo especificado e com <argname>n</argname> elementos <quote>vazios</quote>
	  (exemplos: variável de texto (<quote>string</quote>)
	  vazia ou matriz nula). Exemplos de utilização:
	</para>
	<code>
	  strings S = array(5)
	  matrices M = array(3)
	</code>
	<para>
	  Veja também <fncref targ="defarray"/>.
	</para>
      </description>
    </function>

    <function name="asin" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o arco-seno de <argname>x</argname>, isto é, o valor
	  cujo seno é <argname>x</argname>. Resultado em radianos e o
	  argumento deve estar entre &minus;1 e 1.
	</para>
      </description>
    </function>

    <function name="asinh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o seno hiperbólico inverso de <argname>x</argname>.
	  <seelist>
            <fncref targ="sinh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="atan" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o arco-tangente de <argname>x</argname>, isto é, o valor
	  cuja tangente é <argname>x</argname>. Resultado em radianos.
	</para>
	<para>
      <seelist>
        <fncref targ="cos"/>
        <fncref targ="sin"/>
        <fncref targ="tan"/>
      </seelist>
	</para>
      </description>
    </function>

    <function name="atanh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a tangente hiperbólica inversa de <argname>x</argname>.
	  <seelist>
            <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="atof" section="strings" output="scalar">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Função semelhante à existente na linguagem de programação C, retorna
	  o resultado da conversão da variável de texto (<quote>string</quote>)
	  <argname>s</argname> (ou sua porção inicial, após descartar quaisquer
	  espaços em branco no seu início) em número de ponto flutuante.
	  Diferente do que ocorre na linguagem C, a função <lit>atof</lit> (por
	  questões de portabilidade) sempre assume que o caractere decimal é o
	  <quote><lit>.</lit></quote>. Todos os caracteres que se seguem após a
	  parte de <argname>s</argname> que pode ser convertida para um número
	  de ponto flutuante são ignorados.
	</para>
	<para>
	  Se nenhum dos caracteres de <argname>s</argname> (que se seguem após
	  os espaços em branco que são descartados) puderem ser convertidos a
	  função retornará <lit>NA</lit>.
	</para>
	<code>
	  # Exemplos:
	  x = atof("1.234") # retorna x = 1.234
	  x = atof("1,234") # retorna x = 1
	  x = atof("1.2y")  # retorna x = 1.2
	  x = atof("y")     # retorna x = NA
	  x = atof(",234")  # retorna x = NA
	</code>
	<para>
	  Veja também <fncref targ="sscanf"/> para maior flexibilidade nas
	  conversões de textos em números.
	</para>
      </description>
    </function>

    <function name="bessel" section="math" output="asinput">
      <fnargs>
	<fnarg type="char">type</fnarg>
	<fnarg type="scalar">v</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula uma das variantes da função de Bessel de ordem <argname>v</argname>
	  e argumento <argname>x</argname>. O valor retornado
	  será do mesmo tipo de <argname>x</argname>. A função específica
	  é selecionada pelo primeiro argumento e deve ser <lit>J</lit>,
	  <lit>Y</lit>, <lit>I</lit> ou <lit>K</lit>. Uma boa discussão
	  sobre as funções de Bessel pode ser encontrada na Wikipédia. Aqui
	  serão feitos comentários breves.
	</para>
	<para>
	  caso <lit>J</lit>: função de Bessel de primeiro tipo. Se assemelha
	  a uma onda senoidal amortecida. Definida para <argname>v</argname>
	  real e <argname>x</argname>. Se <argname>x</argname> for negativo
	  então <argname>v</argname> deve ser um inteiro.
	</para>
	<para>
	  caso <lit>Y</lit>: função de Bessel de segundo tipo. Definida
	  para <argname>v</argname> real e <argname>x</argname>, mas com
	  uma singularidade em <argname>x</argname> = 0.
	</para>
	<para>
	  caso <lit>I</lit>: função de Bessel modificada de primeiro tipo.
	  Uma função com crescimento exponencial. Argumentos que podem ser
	  usados são os mesmos do caso <lit>J</lit>.
	</para>
	<para>
	  caso <lit>K</lit>: função de Bessel modificada de segundo tipo. Uma
	  função com decaimento exponencial. Diverge em <argname>x</argname> =
	  0 e não é definida para valores negativos de <argname>x</argname>.
	  É simétrica em torno de <argname>v</argname> = 0.
	</para>
      </description>
    </function>

    <function name="BFGSmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="fncall" optional="true">g</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza a maximização numérica via método de Broyden,
	  Fletcher, Goldfarb e Shanno. O argumento <argname>
	  b</argname> deve conter os valores inciais de um conjunto
	  de parâmetros e o argumento <argname>f</argname> deve
	  especificar uma chamada à função que calcule o critério
	  (escalar) a ser maximizado, dados os valores correntes
	  dos parâmetros e quaisquer outros dados que sejam
	  relevantes. Se o objetivo for de fato uma minimização,
	  esta função deverá retornar o negativo do critério. Se
	  for completada com sucesso, <lit>BFGSmax</lit> retorna
	  o valor maximizado do critério e <argname>b</argname>
	  contém os valores dos parâmetros que maximizam a função.
	</para>
	<para>
	  O terceiro argumento, opcional, estabelece uma maneira de
	  fornecer derivadas analíticas (caso contrário o gradiente
	  será computado numericamente). A função gradiente <argname>
	  g</argname> deve ter como primeiro argumento uma matriz
	  pré-definida que tenha o tamanho adequado para armazenar
	  o gradiente, dado na forma de fonteiro. Ela também precisa
	  ter o vetor de parâmetros como um argumento (na forma de
	  ponteiro ou não). Outros argumentos são opcionais.
	</para>
	<para>
	  Para maiores detalhes e exemplos veja o capítulo sobre
	  métodos numéricos em <guideref targ="chap:numerical"/>.
	  <seelist>
	    <fncref targ="BFGScmax"/>
            <fncref targ="NRmax"/>
            <fncref targ="fdjac"/>
            <fncref targ="simann"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="BFGScmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="matrix">bounds</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="fncall" optional="true">g</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza a maximização com restrições via L-BFGS-B (BFGS
	  com memória limitada, veja <cite key="byrd-etal95">Byrd,
	  Lu, Nocedal e Zhu, 1995</cite>). O argumento <argname>b
	  </argname> deve conter os valores inciais de um conjunto
	  de parâmetros, <argname>bounds</argname> deve conter as
	  restrições que aplicadas aos valores dos parâmetros (veja
	  abaixo) e <argname>f</argname> deve especificar uma chamada
	  à função que calcule o critério (escalar) a ser maximizado,
	  dados os valores correntes dos parâmetros e quaisquer outros
	  dados que sejam relevantes. Se o objetivo for de fato uma
	  minimização, esta função deverá retornar o negativo do
	  critério. Se for completada com sucesso, <lit>BFGScmax</lit>
	  retorna o valor maximizado do critério, sujeito às restrições
	  em <argname>bounds</argname> e <argname>b</argname> contém
	  os valores dos parâmetros que maximizam a função.
	</para>
	<para>
	  A matriz <argname>bounds</argname> deve ter 3 colunas e um
	  número de linhas igual ao número de elementos restritos no
	  vetor de parâmetros. O primeiro elemento de uma dada linha
	  é o índice (de base 1) do parâmetro restrito, o segundo e o
	  terceiro são os limites inferiores e superiores, respectivamente.
	  Os valores <lit>-$huge</lit> e <lit>$huge</lit> devem ser
	  usados para indicar que o parâmetro não possui restrições
	  inferiores ou superiores, respectivamente. Por exemplo, a
	  expressão a seguir é a forma de se especificar que o segundo
	  elemento do vetor de parâmetros deve ser não-negativo:
	</para>
	<code>
	  matrix bounds = {2, 0, $huge}
	</code>
	<para>
	  O quarto argumento, opcional, estabelece uma maneira de
	  fornecer derivadas analíticas (caso contrário o gradiente
	  será computado numericamente). A função gradiente <argname>
	  g</argname> deve ter como primeiro argumento uma matriz
	  pré-definida que tenha o tamanho adequado para armazenar
	  o gradiente, dado na forma de fonteiro. Ela também precisa
	  ter o vetor de parâmetros como um argumento (na forma de
	  ponteiro ou não). Outros argumentos são opcionais.
	</para>
	<para>
	  Para maiores detalhes e exemplos veja o capítulo sobre
	  métodos numéricos em <guideref targ="chap:numerical"/>.
	  <seelist>
	    <fncref targ="BFGSmax"/>
            <fncref targ="NRmax"/>
            <fncref targ="fdjac"/>
            <fncref targ="simann"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="bkfilt" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int" optional="true">f1</fnarg>
	<fnarg type="int" optional="true">f2</fnarg>
	<fnarg type="int" optional="true">k</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o resultado da aplicação do filtro passa-banda
	  de Baxter&ndash;King para a série <argname>y</argname>. Os parâmetros
	  opcionais <argname>f1</argname> e <argname>f2</argname> representam,
	  respectivamente, os limites inferior e superior da amplitude
	  de frequência a ser extraída, enquanto <argname>k</argname>
	  é a ordem de aproximação a ser
	  utilizada.
	</para>
	<para>
	  Se esses argumentos não forem fornecidos então os valores padrão
	  irão depender da periodicidade do conjunto de dados. Para dados
	  anuais os padrões para <argname>f1</argname>,
	  <argname>f2</argname> e <argname>k</argname> são 2, 8 e
	  3, respectivamente. Para dados trimestrais são 6, 32 e 12. Para
	  dados mensais são 18, 96 e 36. Esses valores são escolhidos para
	  coincidir com a escolha mais comum entre os praticantes, que é a
	  utilização desse filtro para extrair o componente de frequência
	  do <quote>ciclo de negócios</quote>. Isso, por sua vez, é
	  comumente definido como sendo entre 18 meses e 8 anos. O
	  filtro, por escolha padrão, abrange 3 anos de dados.
	</para>
	<para>
	  Se <argname>f2</argname> for maior ou igual ao número
	  de observações disponíveis, então a versão
	  <quote>passa-baixa</quote> do filtro será executada
	  e a série resultante deve ser considerada como uma estimativa
	  do componente de tendência, ao invés de ciclo.
	  <seelist>
            <fncref targ="bwfilt"/>
            <fncref targ="hpfilt"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="boxcox" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="scalar">d</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a transformação de Box&ndash;Cox com parâmetro
	  <argname>d</argname> para uma série positiva <argname>y</argname>.
	</para>
	<para context="tex">
	  \[ y_t^{(d)} = \left\{ \begin{array}{ll} \frac{y_t^d - 1}{d} &amp;
	  {\rm if}\quad d\neq 0 \\ \log (y_t) &amp; {\rm if}\quad d=0
	  \end{array} \right. \]
	</para>
	<para context="notex">
	  A série transformada é (<math>y</math><sup>d</sup> -
	  1)/<math>d</math> para <math>d</math> diferente de zero ou
	  log(<math>y</math>) para <math>d</math> = 0.
	</para>
      </description>
    </function>

    <function name="bread" section="data-utils" output="bundle">
      <fnargs>
	<fnarg type="string">fname</fnarg>
	<fnarg optional="true" type="bool">import</fnarg>
      </fnargs>
      <description>
	<para>
	  Lê um pacote (<quote>bundle</quote>) a partir de um arquivo de texto. A
	  variável de texto (<quote>string</quote>) <argname>fname</argname> deve
	  conter o nome do arquivo no qual o pacote será lido. Se esse nome tiver
	  a extensão <quote><lit>.gz</lit></quote> será assumido que foi aplicada
	  a compactação do arquivo via gzip.
	</para>
	<para>
	  O arquivo em questão deve ser um XML apropriadamente definido:
	  ele dever conter um elemento <lit>gretl-bundle</lit>, utilizado
	  para armazenar zero ou mais elementos <lit>bundled-item</lit>. Por
	  exemplo:
	</para>
	<code>
	  &lt;?xml version="1.0" encoding="UTF-8"?&gt;
	  &lt;gretl-bundle name="temp"&gt;
          &lt;bundled-item key="s" type="string"&gt;moo&lt;/bundled-item&gt;
          &lt;bundled-item key="x" type="scalar"&gt;3&lt;/bundled-item&gt;
	  &lt;/gretl-bundle&gt;
	</code>
	<para>
	  Como esperado, tais arquivos são gerados automaticamente pela
	  função associada <fncref targ="bwrite"/>.
	</para>
	<para>
	  Se o nome do arquivo não contiver a especificação completa
	  de seu caminho, ele será procurado em vários locais
	  <quote>prováveis</quote>, começando no
	  <cmdref targ="workdir"/> corrente. Entretanto, se for dado
	  um valor não-nulo para o argumento opcional
	  <argname>import</argname>, o arquivo será procurado no diretório
	  <quote>@dotdir</quote>. Nesse caso o argumento
	  <argname>fname</argname> deverá ser um nome simples, sem a
	  inclusão do caminho.
	</para>
	<para>
	  Se ocorrer algum erro (tal como o arquivo ter sido mal
	  formatado ou ser inacessível), um erro será retornado
	  via acessor <fncref targ="$error"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="mread"/>
            <fncref targ="bwrite"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="bwfilt" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int">n</fnarg>
	<fnarg type="scalar">omega</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o resultado da aplicação de um filtro passa-baixo
	  de Butterworth de ordem <argname>n</argname> e
	  frequência de corte <argname>omega</argname> na série
	  <argname>y</argname>. O corte é expresso em graus e
	  deve ser maior ou igual a 0 e menor que 180. Valores de corte
	  menores restringem o passa-banda a menores frequências e assim
	  produzem uma tendência mais suave. Valores maiores de
	  <argname>n</argname> produzem um corte mais agudo, mas ao custo
	  de possível instabilidade numérica.
	</para>
	<para>
	  A inspeção preliminar do periodograma da série de interesse é útil
	  quando se deseja aplicar esta função.
	  Veja <guideref targ="chap:tsfilter"/> para detalhes.
	  <seelist>
            <fncref targ="bkfilt"/>
            <fncref targ="hpfilt"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="bwrite" section="data-utils" output="int">
      <fnargs>
	<fnarg type="bundle">B</fnarg>
	<fnarg type="string">fname</fnarg>
	<fnarg optional="true" type="bool">export</fnarg>
      </fnargs>
      <description>
	<para>
	  Escreve um pacote (<quote>bundle</quote>) <argname>B</argname>
	  em um arquivo XML com nome <argname>fname</argname>. Para uma
	  descrição sumária de seu formato, veja <fncref targ="bread"/>.
	  Se já existir um arquivo <argname>fname</argname> ele será
	  sobrescrito. O valor de retorno da função é 0 em caso de
	  sucesso. Se ocorrerem erros, tais como a impossibilidade de
	  sobrescrever o arquivo, a função retorna um valor não-nulo.
	</para>
	<para>
	  O arquivo de saída será salvo no diretório <cmdref targ="workdir"/>,
	  a menos que a variável <argname>fname</argname> contenha um
	  caminho para o diretório onde será armazenado. Entretanto,
	  se for dado um valor não-nulo para o argumento <argname>
	  export</argname>, o arquivo de saída será armazenado no
	  diretório <quote>@dotdir</quote>. Neste caso um nome simples,
	  sem especificação de caminho, deverá ser utilizado como
	  segundo argumento.
	</para>
	<para>
	  Por padrão, o arquivo XML é armazenado sem compressão, mas se
	  <argname>fname</argname> tiver a extensão <lit>.gz</lit>
	  é aplicada a compressão gzip.
	</para>
	<para>
	  <seelist>
            <fncref targ="bread"/>
            <fncref targ="mwrite"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cdemean" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Centraliza as colunas da matriz <argname>X</argname> em torno
	  de suas médias.
	</para>
      </description>
    </function>

    <function name="cdf" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <examples>
	<example>p1 = cdf(N, -2.5)</example>
	<example>p2 = cdf(X, 3, 5.67)</example>
	<example>p3 = cdf(D, 0.25, -1, 1)</example>
      </examples>
      <description>
	<para>
	  Calculadora da função de distribuição acumulada. Retorna
	  <equation status="inline" ascii="P(X &le; x)" tex="$P(X \le
	  x)$"/>, onde a distribuição de <math>X</math> é especificada
	  pela letra <argname>d</argname>. Entre os argumentos <argname>
	  d</argname> e <argname>x</argname>, zero ou mais argumentos
	  adicionais são necessários para que se especifique os parâmetros
	  da distribuição. Isso é feito da seguinte forma (note que a
	  distribuição normal tem, por conveniência, uma função própria,
	  <fncref targ="cnorm"/>):
	</para>
	<ilist context="notex">
	  <li>
            <para>
              Normal padrão (c = z, n ou N): sem argumentos extras
            </para>
	  </li>
	  <li>
            <para>
              Normal bivariada (D): coeficiente de correlação
            </para>
	  </li>
	  <li>
            <para>
              t de Student (t): graus de liberdade
            </para>
	  </li>
	  <li>
            <para>
              Qui-quadrado (c, x ou X): graus de liberdade
            </para>
	  </li>
	  <li>
            <para>
              F de Snedecor F (f ou F): graus de liberdade (num.); graus de liberdade (den.)
            </para>
	  </li>
	  <li>
            <para>
              Gama (g ou G): forma; escala
            </para>
	  </li>
	  <li>
            <para>
              Binomial (b ou B): probabilidade; quantidade de tentativas
            </para>
	  </li>
	  <li>
            <para>
              Poisson (p ou P): média
            </para>
	  </li>
	  <li>
            <para>
              Weibull (w ou W): forma; escala
            </para>
	  </li>
	  <li>
            <para>
              Erro Generalizado (E): forma
            </para>
	  </li>
	  <li>
	    <para>
	      Qui-quadrado não-central (ncX): graus de liberdade, parâmetro de não-centralidade
	    </para>
	  </li>
	  <li>
	    <para>
	      F não-central (ncF): graus de liberdade (num.), graus de liberdade (den.),
	      parâmetro de não-centralidade
	    </para>
	  </li>
	  <li>
	    <para>
	      t não-central (nct): graus de liberdade, parâmetro de não-centralidade
	    </para>
	  </li>
	</ilist>
	<tabular colspec="lllll">
	  \textit{Distribuição} &amp; \textsl{d} &amp;
	  \textit{Arg} 2 &amp; \textit{Arg} 3 &amp; \textit{Arg} 4 \\[4pt]
	  Normal padrão &amp; \texttt{z}, \texttt{n} ou \texttt{N} &amp;
	  -- &amp; -- &amp; --\\
	  Normal bivariada &amp; \texttt{D} &amp;
	  $\rho$ &amp; -- &amp; --\\
	  $t$ de Student (central) &amp; \texttt{t} &amp;
	  g.l. &amp; -- &amp; --\\
	  Qui-quadrado &amp; \texttt{c}, \texttt{x} ou \texttt{X} &amp;
	  g.l. &amp; -- &amp; --\\
	  $F$ de Snedecor &amp; \texttt{f} ou \texttt{F} &amp;
	  g.l. (num.) &amp; g.l. (den.) &amp; --\\
	  Gama &amp; \texttt{g} ou \texttt{G} &amp;
	  forma &amp; escala &amp; --\\
	  Binomial &amp; \texttt{b} ou \texttt{B} &amp;
	  probabilidade &amp; tentativas &amp; --\\
	  Poisson &amp; \texttt{p} ou \texttt{P} &amp;
	  média &amp; -- &amp; --\\
	  Weibull &amp; \texttt{w} ou \texttt{W} &amp;
	  forma &amp; escala &amp; --\\
	  Erro Generalizado &amp; \texttt{E} &amp;
	  forma &amp; -- &amp; --\\
	  $\chi^2$ não-central &amp; \texttt{ncX} &amp;
	  g.l. &amp; não-centralidade &amp; -- \\
	  $F$ não-central &amp; \texttt{ncF} &amp;
	  g.l. (num.) &amp; g.l. (den.) &amp; não-centralidade \\
	  Non-central $t$ &amp; \texttt{nct} &amp;
	  g.l. &amp; não-centralidade &amp; -- \\
	</tabular>
	<para>
	  Note que na maioria dos casos existem pseudônimos para ajudar na
	  memorização dos códigos. O caso da norma bivariada é especial: a
	  sintaxe é <lit>x = cdf(D, rho, z1, z2)</lit> onde <lit>rho</lit>
	  é a correlação entre as variáveis <lit>z1</lit>
	  e <lit>z2</lit>.
	</para>
	<para context="tex">
	  A parametrização que o \app{Gretl} usa para a a variável aleatória
	  Gama implica que sua função de densidade pode ser escrita como
	  \[
	  f(x; k, \theta) = \frac{x^{k-1}}{\theta^k} \frac{e^{-x/\theta}}{\Gamma(k)}
	  \]
	  onde $k>0$ é o parâmetro de forma e $\theta>0$ é o parâmetro de
	  escala.
	</para>
	<para>
	  <seelist>
            <fncref targ="pdf"/>
            <fncref targ="critical"/>
            <fncref targ="invcdf"/>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cdiv" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">Y</fnarg>
      </fnargs>
      <description>
	<para>
	  Divisão de números complexos. Os dois argumentos devem possuir o mesmo
	  número de linhas, <math>n</math>, e devem possuir uma ou duas colunas.
	  A primeira coluna contém a parte real e a segunda (se estiver presente)
	  contém a parte imaginária. A função retorna uma matriz de ordem
	  <by r="n" c="2"/> ou, caso não exista a parte imaginária, um vetor com
	  <math>n</math> linhas.
	  <seelist>
            <fncref targ="cmult"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ceil" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Consiste na função teto. Retorna o menor inteiro que seja maior
	  ou igual a <argname>x</argname>.
	  <seelist>
            <fncref targ="floor"/>
            <fncref targ="int"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cholesky" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="pdmat">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza a decomposição de Cholesky da matriz <argname>A</argname>,
	  assumindo que seja simétrica e definida positiva. O resultado será
	  uma matriz triangular inferior <math>L</math> que satisfaz
	  <equation status="inline" ascii="A = LL'"  tex="$A = LL'$"/>. A
	  função irá falhar se <argname>A</argname> não for simétrica ou não
	  for definida positiva.
	  <seelist>
            <fncref targ="psdroot"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="chowlin" section="transforms" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="int">xfac</fnarg>
	<fnarg type="matrix" optional="true">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Expande os dados de entrada, <argname>Y</argname>, para uma frequência
	  maior utilizando o método de <cite
	  key="chowlin71">Chow e Lin (1971)</cite>. É assumido
	  que as colunas de <argname>Y</argname>
	  representam séries. A matriz retornada tem a mesma quantidade de colunas
	  de <argname>Y</argname> e <argname>xfac</argname> vezes
	  o número de linhas.
	</para>
	<para>
	  O segundo argumento representa o fator de expansão. Deve ser igual
	  a 3 para expandir dados trimestrais em mensais ou igual a 4 para expandir
	  de anual para trimestral (estes são os únicos fatores atualmente suportados).
	  O terceiro argumento, que é opcional, pode ser utilizado para fornecer uma
	  matriz de covariáveis com frequência maior.
	</para>
	<para>
	  Os regressores utilizados por padrão são uma constante e uma tendência
	  quadrática. Se <argname>X</argname> for fornecido, suas colunas devem ser
	  utilizadas como regressores adicionais. A função retornará um erro se o
	  número de linhas em <argname>X</argname> não for igual a
	  <argname>xfac</argname> vezes o número de linhas em
	  <argname>Y</argname>.
	</para>
      </description>
    </function>

    <function name="cmult" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">Y</fnarg>
      </fnargs>
      <description>
	<para>
	  Multiplicação complexa. Os dois argumentos devem ter o mesmo
	  número de linhas, <math>n</math>, e uma ou duas colunas.
	  A primeira coluna contendo a parte real e a segunda (se existir)
	  a parte imaginária. O valor retornado é uma matriz
	  <by r="n" c="2"/>, ou, se o resultado não contiver parte
	  imaginária, um vetor de tamanho <math>n</math>.
	  <seelist>
            <fncref targ="cdiv"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cnorm" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a função de distribuição acumulada para uma normal
	  padrão.
	  <seelist>
            <fncref targ="dnorm"/>
            <fncref targ="qnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cnumber" section="linalg" output="scalar">
      <fnargs>
    <fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o número condicional da matriz <argname>X</argname> de
	  ordem <by r="n" c="k"/>, conforme definido em <cite
	  key="belsley-etal80">Belsley, Kuh e Welsch
	  (1980)</cite>. Se as colunas de <argname>X</argname> forem
	  mutuamente ortogonais o número condicional de
	  <argname>X</argname> é a unidade. Um número condicional grande
	  é um indicador de multicolinearidade, sendo que é considerado
	  normalmente um valor <quote>grande</quote> algo acima de 50
	  (ou, algumas vezes, de 30).
	</para>
	<para>
	  Os passos para esses cálculos são: (1) contruir uma matriz
	  <math>Z</math> onde suas colunas são a divisão das colunas de
	  <argname>X</argname> divididas por suas respectivas normas
	  euclidianas; (2) construir <math>Z'Z</math> e obter seus
	  autovalores e; (3) calcular a raiz quadrada da razão entre
	  o maior e o menor autovalor.
	</para>
	<para>
	  <seelist>
            <fncref targ="rcond"/>
	  </seelist>
	</para>
      </description>
    </function>


    <function name="colname" section="strings" output="string">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="int">col</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o nome da coluna <argname>col</argname> da matriz
	  <argname>M</argname>. Se as colunas de <argname>M</argname>
	  não possuírem nomes então será retornada um texto
	  (<quote>string</quote>) vazio. Se <argname>col</argname> for
	  maior que o número de colunas da matriz será sinalizado um
	  erro. Veja também <fncref targ="colnames"/>.
	</para>
	<para>
	  Exemplo:
	</para>
	<code>
	  matrix A = { 11, 23, 13 ; 54, 15, 46 }
	  colnames(A, "Col_A Col_B Col_C")
	  string name = colname(A, 3)
	  print name
	</code>
      </description>
    </function>

    <function name="colnames" section="matbuild" output="scalar">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="strings-or-list">S</fnarg>
      </fnargs>
      <description>
	<para>
	  Adiciona nomes para as colunas da matriz <argname>M</argname> de
	  ordem <by r="T" c="k"/> . Se <argname>S</argname> for uma lista,
	  os nomes serão os das séries listadas. A lista precisa ter
	  <math>k</math> membros. Se <argname>S</argname> for um arranjo
	  (<quote>array</quote>) de textos (<quote>string</quote>), ele
	  precisa ter <math>k</math> elementos. Para manter a compatibilidade
	  com versões anteriores do Gretl, uma única variável de texto também
	  pode ser utilizada como segundo argumento. Nesse caso ela precisa
	  ter <math>k</math> textos separados por espaços.
	</para>
	<para>
	  Retorna o valor 0 se as colunas forem nomeadas com sucesso. Caso
	  contrário retorna um valor não-nulo. Veja também <fncref targ="rownames"/>.
	</para>
	<para>
	  Exemplo:
	</para>
	<code>
	  matrix M = {1, 2; 2, 1; 4, 1}
	  variável de textos S = array(2)
	  S[1] = "Col1"
	  S[2] = "Col2"
	  colnames(M, S)
	  print M
	</code>
      </description>
    </function>

    <function name="cols" section="matshape" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o número de colunas da matriz <argname>X</argname>.
	  <seelist>
            <fncref targ="mshape"/>
            <fncref targ="rows"/>
            <fncref targ="unvech"/>
            <fncref targ="vec"/>
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="corr" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y1</fnarg>
	<fnarg type="series-or-vec">y2</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula o coeficiente de correlação entre <argname>y1</argname>
	  e <argname>y2</argname>. Os argumentos devem ser duas séries ou
	  dois vetores com o mesmo tamanho.
	  <seelist>
            <fncref targ="cov"/>
            <fncref targ="mcov"/>
            <fncref targ="mcorr"/>
            <fncref targ="npcorr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="corrgm" section="stats" output="matrix">
      <fnargs>
	<fnarg type="smlist">x</fnarg>
	<fnarg type="int">p</fnarg>
	<fnarg optional="true" type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Se forem fornecidos apenas os dois primeiros argumentos
	  a função calcula o correlograma de <argname>x</argname>
	  para as defasagens de 1 até <argname>p</argname>. Sendo
	  <math>k</math> o número de elementos em <argname>x</argname>
	  (igual a 1 se <argname>x</argname> for uma série, ao número
	  de colunas se <argname>x</argname> for uma matriz ou ao
	  número de membros se <argname>x</argname> for uma lista).
	  O valor retornado será uma matriz com <argname>p</argname>
	  linhas e 2<math>k</math> colunas, onde as <math>k</math>
	  primeiras colunas conterão as respectivas autocorrelações
	  e o restante as respectivas autocorrelações parciais.
	</para>
	<para>
	  Se um terceiro argumento for fornecido a função irá computar
	  o correlograma cruzado para cada um dos <math>k</math> elementos
	  em <argname>x</argname> e <argname>y</argname>, partindo de
	  <math>+</math><argname>p</argname> até <math>-</math><argname>
	  p</argname>. A matriz retornada possui 2<math>p</math> + 1 linhas
	  e <math>k</math> colunas. Se <argname>x</argname> for uma série
	  ou lista e <argname>y</argname> for um vetor, <argname>y</argname>
	  precisa ter linhas na mesma quantidade que o total de observações
	  na amostra selecionada.
	</para>
      </description>
    </function>

    <function name="cos" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o cosseno de <argname>x</argname>.
	<seelist>
          <fncref targ="sin"/>
          <fncref targ="tan"/>
          <fncref targ="atan"/>
	</seelist>
	</para>
      </description>
    </function>

    <function name="cosh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o cosseno hiperbólico de <argname>x</argname>.
	</para>
	<para context="tex">
	  \[ \cosh x = \frac{e^x + e^{-x}}{2}  \]
	</para>
	<para>
	  <seelist>
            <fncref targ="acosh"/>
            <fncref targ="sinh"/>
            <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cov" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y1</fnarg>
	<fnarg type="series-or-vec">y2</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a covariância <argname>y1</argname> e
	  <argname>y2</argname>. Os argumentos devem ser duas séries
	  ou dois vetores (estes devem possuir o mesmo cumprimento).
	  <seelist>
            <fncref targ="corr"/>
            <fncref targ="mcov"/>
            <fncref targ="mcorr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="critical" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="char">c</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">p</fnarg>
      </fnargs>
      <examples>
	<example>c1 = critical(t, 20, 0.025)</example>
	<example>c2 = critical(F, 4, 48, 0.05)</example>
      </examples>
      <description>
	<para>
	  Calculadora de valores críticos. Retorna <math>x</math> tal que
	  <equation status="inline" ascii="P(X &gt; x) = p"
		    tex="$P(X &gt; x) = p$"/>, onde a distribuição <math>X</math> é
	  determinada pela letra <argname>c</argname>. Entre os
	  argumentos <argname>c</argname> e <argname>p</argname>, zero ou
	  mais argumentos escalares são necessários para especificar os
	  parâmetros da distribuição, Isso é feito da seguinte forma:
	</para>
	<ilist context="notex">
	  <li>
            <para>
              Normal padrão (c = z, n ou N): sem argumentos extras
            </para>
	  </li>
	  <li>
            <para>
              t de Student (t): graus de liberdade
            </para>
	  </li>
	  <li>
            <para>
              Chi square (c, x ou X): graus de liberdade
            </para>
	  </li>
	  <li>
            <para>
              F de Snedecor (f ou F): g.l. (num.); g.l. (den.)
            </para>
	  </li>
	  <li>
            <para>
              Binomial (b ou B): probabilidade; tentativas
            </para>
	  </li>
	  <li>
            <para>
              Poisson (p ou P): média
            </para>
	  </li>
	</ilist>
	<tabular colspec="llll">
	  \textit{Distribuição} &amp; \textsl{c} &amp;
	  \textit{Arg} 2 &amp; \textit{Arg} 3 \\[4pt]
	  Normal padrão &amp; \texttt{z}, \texttt{n} ou \texttt{N} &amp;
	  -- &amp; -- \\
	  $t$ de Student (central) &amp; \texttt{t} &amp;
	  graus de liberdade &amp; -- \\
	  Qui-quadrado &amp; \texttt{c}, \texttt{x} ou \texttt{X} &amp;
	  degrees of freedom &amp; -- \\
	  $F$ de Snedecor &amp; \texttt{f} ou \texttt{F} &amp;
	  g.l. (num.) &amp; g.l. (den.) \\
	  Binomial &amp; \texttt{b} ou \texttt{B} &amp;
	  $p$ &amp; $n$ \\
	  Poisson &amp; \texttt{p} ou \texttt{P} &amp;
	  $\lambda$ &amp; -- \\
	</tabular>
	<para>
	  <seelist>
            <fncref targ="cdf"/>
            <fncref targ="invcdf"/>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cum" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Acumula <argname>x</argname> (isto é, cria uma soma móvel).
	  Quando <argname>x</argname> for uma série, produz uma série
	  <math>y</math> onde cada um de seus elementos é igual a soma
	  dos valores de <argname>x</argname> até a observação correspondente.
	  O ponto de partida para a acumulação é a primeira observação
	  não-ausente da amostra selecionada corrente. Quando <argname>x</argname>
	  for uma matriz, seus elementos são acumulados por colunas.
	</para>
	<para context="tex">
	  Acumula <argname>x</argname>. Quando <math>x</math> or uma série,
	  produz uma série $y_t = \sum_{s=m}^t x_s$. O ponto de partida para
	  a acumulação, <math>m</math>, é a primeira observação não-ausente
	  a amostra selecionada corrente. Se forem encontrados valores ausentes
	  em <math>x</math>, os valores subsequentes de <math>y</math> serão
	  definidos como valor ausente. Quando <argname>x</argname>for uma
	  matriz, seus elementos são acumulados por colunas.
	</para>
	<para>
	  <seelist>
            <fncref targ="diff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="curl" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="bundleref">&amp;b</fnarg>
      </fnargs>
      <description>
	<para>
	  Fornece uma maneira relativamente flexível de se obter um buffer de
	  texto contendo dados de um servidor de internet utilizando a biblioteca
	  libcurl. O argumento <argname>b</argname>, do tipo pacote (<quote>
	  bundle</quote>), deve conter uma variável de texto (<quote>string</quote>)
	  chamada <lit>URL</lit> que fornece o endereço completo do recurso
	  no host alvo. Outros elementos opcionais são apresentados a seguir.
	</para>
	<ilist>
	  <li>
	    <para>
	      <quote><lit>header</lit></quote>: a variável de texto especificando
	      um header HTTP que será enviado para o host.
	    </para>
	  </li>
	  <li>
	    <para>
	      <quote><lit>postdata</lit></quote>: a variável de texto contendo
	      os dados que serão enviados para o host.
	    </para>
	  </li>
	</ilist>
	<para>
	  Os campos <lit>header</lit> e <lit>postdata</lit> são destinados
	  para o uso com uma requisição HTTP do tipo <lit>POST</lit>. Se
	  <lit>postdata</lit> estiver presente o método <lit>POST</lit> é
	  implícito, caso contrário o método <lit>GET</lit> é
	  implícito. Mas note que para requisições <lit>GET</lit> diretas
	  a função <fncref targ="readfile"/> oferece uma interface
	  mais simples.
	</para>
	<para>
	  Se outro elemento opcional do pacote, um escalar chamado
	  <lit>include</lit> estiver presente e possuir valor não-nulo,
	  a requisição irá incluir o header recebido
	  do host com o corpo de saída.
	</para>
	<para>
	  Ao completar-se a requisição, o texto recebido do
	  servidor é adicionado ao pacote e recebe o nome de
	  <quote><lit>output</lit></quote>.
	</para>
	<para>
	  Se um erro ocorrer na formulação da requisição (por exemplo, não existir
	  a <lit>URL</lit> na entrada) a função irá falhar, caso contrário ela
	  retornará o valor 0 se a requisição for bem sucedida ou um valor não
	  nulo, sendo que neste caso a mensagem de erro da biblioteca curl
	  será adicionado ao pacote e identificado como
	  <quote><lit>errmsg</lit></quote>. Note, entretanto, que
	  <quote>sucesso</quote> neste sentido não significa necessariamente
	  que os dados desejados foram obtidos. Na verdade significa apenas que
	  alguma resposta foi recebida do servidor. Assim, é necessário conferir
	  o conteúdo do buffer de saída (que pode ser de fato uma mensagem tal como
	  <quote>Página não encontrada</quote>).
	</para>
	<para>
	  Um bom exemplo de como utilizar essa função é baixar alguns dados do
	  site do US Bureau of Labor Statistics, que requere o envio de um query
	  JSON. Note o uso de <cmdref targ="sprintf"/> para
	  inserir aspas duplas no dado <lit>POST</lit>.
	</para>
	<code>
	  bundle req
	  req.URL = "http://api.bls.gov/publicAPI/v1/timeseries/data/"
	  req.include = 1
	  req.header = "Content-Type: application/json"
	  string s = sprintf("{\"seriesid\":[\"LEU0254555900\"]}")
	  req.postdata = s
	  err = curl(&amp;req)
	  if err == 0
	      s = req.output
	      string line
	      loop while getline(s, line) --quiet
	          printf "%s\n", line
	      endloop
	  endif
	</code>
	<para>
	  Veja também a função <fncref targ="jsonget"/> para
	  processamento de dados recebidos no formato JSON.
	</para>
      </description>
    </function>

    <function name="dayspan" section="calendar" output="int">
      <fnargs>
	<fnarg type="int">ed1</fnarg>
	<fnarg type="int">ed2</fnarg>
	<fnarg type="int">weeklen</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the number of (relevant) days between the epoch days
	  <argname>ed1</argname> and <argname>ed2</argname>,
	  inclusive. The <argname>weeklen</argname>, which must equal
	  5, 6 or 7, gives the number of days in the week that should
	  be counted (a value of 6 omits Sundays, and a value of 5
	  omits both Saturdays and Sundays).
	</para>
	<para>
	  To obtain epoch days from the more familiar form of dates,
	  see <fncref targ="epochday"/>.
	</para>
      </description>
    </function>

    <function name="defarray" section="data-utils" output="seebelow">
      <fnargs>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Permite a definição de uma variável do tipo arranjo (<quote>array</quote>)
	  <emphasis>de forma direta</emphasis>, através do fornecimento de um ou mais
	  elementos. Ao utilizar essa função é necessário que se especifique um tipo
	  (na forma plural) para o arranjo: <lit>strings</lit>, <lit>matrices</lit>,
	  <lit>bundles</lit> ou <lit>lists</lit>. Cada um dos argumentos dever ser
	  um objeto do mesmo tipo que o especificado na definição do arranjo.
	  Em caso de sucesso na definição, será retornado um arranjo com
	  <math>n</math> elementos, onde <math>n</math> é igual ao número de
	  argumentos.
	</para>
	<code>
	  strings S = defarray("foo", "bar", "baz")
	  matrices M = defarray(I(3), X'X, A*B, P[1:])
	</code>
	<para>
	  Veja também <fncref targ="array"/>.
	</para>
      </description>
    </function>

    <function name="deseas" section="filters" output="series">
      <fnargs>
	<fnarg type="series">x</fnarg>
	<fnarg optional="true" type="char">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Precisa que o TRAMO/SEATS e/ou X-12-ARIMA estejam instalados.
	  Retorna a série <argname>x</argname> dessazonalizada (ou seja,
	  sazonalmente ajustada). A série a ser dessazonalida precisa ser
	  mensal ou trimestral. Para utilizar o X-12-ARIMA forneça
	  <lit>X</lit> como segundo argumento e para usar o TRAMO/SEATS
	  forneça <lit>T</lit>. Se o segundo argumento for omitido o Gretl
	  irá utilizar o X-12-ARIMA.
	</para>
	<para>
	  Note que se a série de entrada não possuir um componente sazonal
	  detectável a execução da função irá falhar. Note também que tanto
	  o TRAMO/SEATS quanto o X-12-ARIMA oferecem um grande número de
	  opções, mas a função <lit>deseas</lit> utilizará apenas os seus
	  valores padrão. Em ambos os programas os fatores sazonais são
	  calculados com base em um modelo ARIMA automaticamente selecionado.
	  Uma das diferenças entre os dois que pode levar a resultados
	  bastante distintos é o ajuste prévio de observações aberrantes
	  que o TRAMO/SEATS realiza e que não é feito pelo X-12-ARIMA.
	</para>
      </description>
    </function>

    <function name="det" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o determinante de <argname>A</argname>, calculado via
	  decomposição LU.
	  <seelist>
            <fncref targ="ldet"/>
            <fncref targ="rcond"/>
            <fncref targ="cnumber"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="diag" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a diagonal principal de <argname>X</argname> em um
	  vetor coluna. Se <argname>X</argname> for uma matriz de ordem
	  <by r="m" c="n"/> o número de elementos do vetor resultante
	  será igual a min(<math>m</math>, <math>n</math>).
	  <seelist>
            <fncref targ="tr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="diagcat" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix">B</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a soma direta de <argname>A</argname> e
	  <argname>B</argname>, isto é, uma matriz contendo
	  <argname>A</argname> no canto superior esquerdo e
	  <argname>B</argname> no canto inferior direito. Se
	  <argname>A</argname> e <argname>B</argname> forem ambas
	  quadradas, a matriz resultante será diagonal em blocos.
	</para>
      </description>
    </function>

    <function name="diff" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="smlist">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula a primeira diferença. Se <argname>y</argname> for
	  uma série ou uma lista de séries, os valores iniciais serão
	  iguais a <lit>NA</lit>. Se <argname>y</argname> for uma
	  matriz, a diferenciação é feita por colunas e os valores
	  iniciais serão iguais a 0.
	</para>
	<para>
	  Quando for retornada uma lista, cada uma das variáveis
	  será automaticamente nomeada conforme o modelo
	  <lit>d_</lit><repl>varname</repl>, onde <repl>varname</repl>
	  é o nome da série original. O nome será truncado caso
	  necessário e pode ser ajustado caso já exista uma variável
	  com o mesmo nome.
	</para>
	<para>
	  <seelist>
            <fncref targ="cum"/>
            <fncref targ="ldiff"/>
            <fncref targ="sdiff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="digamma" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Retorna a função digama (ou Psi) de
	  <argname>x</argname> e consiste na derivada logarítmica
	  da função gama.
	</para>
	<para context="tex">
	  Retorna a função digama (ou Psi) de $x$, isto é,
	  $\frac{d}{dx}\, \mbox{ln } \Gamma(x)$.
	</para>
      </description>
    </function>

    <function name="dnorm" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a densidade da distribuição normal padrão em
	  <argname>x</argname>. Para obter a densidade para uma
	  distribuição normal não-padrão em <math>x</math>, utilize
	  o escore-<math>z</math> de <math>x</math> como argumento
	  da função <lit>dnorm</lit> e multiplique o resultado pela
	  jacobiana da transformação <math>z</math>, ou seja,
	  1/&sigma;, conforme ilustrado a seguir:
	</para>
	<code>
	  mu = 100
	  sigma = 5
	  x = 109
	  fx = (1/sigma) * dnorm((x-mu)/sigma)
	</code>
	<para>
	  <seelist>
            <fncref targ="cnorm"/>
            <fncref targ="qnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="dropcoll" section="transforms" output="list">
      <fnargs>
	<fnarg type="list">X</fnarg>
	<fnarg optional="true" type="scalar">epsilon</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma lista com os mesmo elementos de <argname>X</argname>,
	  mas excluindo as séries colineares. Assim, se todas as séries em
	  <argname>X</argname> forem linearmente independentes, a lista
	  resultante será simplesmente uma cópia de
	  <argname>X</argname>.
	</para>
	<para>
	  O algoritmo utiliza a decomposição QR (tranformação de Householder),
	  de forma que está sujeita a erro de precisão finita. Para avaliar
	  a sensibilidade do algoritmo, um segundo parâmetro (opcional)
	  <argname>epsilon</argname> pode ser especificado para tornar o
	  teste de colinearidade mais ou menos estrito, conforme desejado.
	  O valor padrão para <argname>epsilon</argname> é 1.0e-8. Ajustando
	  <argname>epsilon</argname> para um maior valor eleva a probabilidade
	  de uma série ser descartada.
	</para>
	<para>
	  Exemplo:
	</para>
	<code>
	  nulldata 20
	  set seed 9876
	  series foo = normal()
	  series bar = normal()
	  series foobar = foo + bar
	  list X = foo bar foobar
	  list Y = dropcoll(X)
	  list print X
	  list print Y
	  # defina épsilon como sendo um valor bastante pequeno
	  list Y = dropcoll(X, 1.0e-30)
	  list print Y
	</code>
	<para>
	  produz
	</para>
	<code>
	  ? list print X
	  foo bar foobar
	  ? list print Y
	  foo bar
	  ? list Y = dropcoll(X, 1.0e-30)
	  Replaced list Y
	  ? list print Y
	  foo bar foobar
	</code>
      </description>
    </function>

    <function name="dsort" section="matshape" output="asinput">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Ordena <argname>x</argname> de forma decrescente, descartando
	  observações com valores ausentes quando <argname>x</argname> for
	  uma série.
	  <seelist>
            <fncref targ="sort"/>
            <fncref targ="values"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="dummify" section="transforms" output="list">
      <fnargs>
	<fnarg type="series">x</fnarg>
	<fnarg optional="true" type="scalar">omitval</fnarg>
      </fnargs>
      <description>
	<para>
	  O argumento <argname>x</argname> deve ser uma série
	  discreta. Essa função cria um conjunto de variáveis dummy,
	  sendo uma para cada um dos valores distintos na série. Por padrão
	  o menor valor é tratado como a categoria omitida e não é
	  explicitamente representado.
	</para>
	<para>
	  O segundo argumento (opcional) representa o valor de <argname>x</argname>
	  que deve ser tratado como sendo a categoriaomitida. O efeito quando o
	  argumento único for dado é equivalente a utilizar o seguinte comando:
	  <lit>dummify(x, min(x))</lit>. Para produzir um conjunto completo de
	  dummies, ou seja, sem a categoria omitida, pode-se usar
	  <lit>dummify(x, NA)</lit>.
	</para>
	<para>
	  As variáveis geradas são automaticamente nomeadas de acordo
	  com o seguinte padrão:
	  <lit>D</lit><repl>varname</repl><lit>_</lit><repl>i</repl>
	  onde <repl>varname</repl> é o nome da séries original
	  e <repl>i</repl> é um índice iniciado em 1. A porção que representa
	  o nome original da série será truncado, caso seja necessário,
	  e ajustado no caso de não ser único no conjunto de nomes assim
	  construído.
	</para>
      </description>
    </function>

    <function name="easterday" section="calendar" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Com o argumento <argname>x</argname> representando um ano, retorna
	  a data da Páscoa no calendário gregoriano no formato <math>mês +
	  dia/100</math>. Note que 10 de abril é, nesta convenção, 4.1.
	  Assim, 4.2 representa 20 de abril e não 2 de abril (que seria
	  representado por 4.02).
	</para>
	<code>
	  scalar e = easterday(2014)
	  scalar m = floor(e)
	  scalar d = 100*(e-m)
	</code>
      </description>
    </function>

    <function name="ecdf" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Calcula a função distribuição acumulada (FDA) empírica de
	  <argname>y</argname>. Esta é retornada em uma matriz com
	  duas colunas: a primeira contém os valores únicos e ordenados
	  de <argname>y</argname> e a segunda a frequência relativa
	  cumulativa, isto é, a quantidade de vezes em que o valor da
	  observação é menor ou igual ao valor na primeira coluna,
	  dividida pelo número total deobservações.
	</para>
	<para context="tex">
	  Calcula a função distribuição acumulada (FDA) de <argname>
	  y</argname>. Esta é retornada em uma matriz com duas colunas:
	  a primeira contém os valores únicos e ordenados de <argname>
	  y</argname> e a segunda a frequência relativa,
	  \[ F(y) =
	  \frac{1}{n} \sum_{i=1}^n I(y_i \leq y)
	  \]
	  onde $n$ é o número total de observações e $I()$ representa
	  a função indicadora.
	</para>
      </description>
    </function>

    <function name="eigengen" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula os autovalores e, opcionalmente, os autovetores, da
	  matriz <argname>A</argname> de ordem <by r="n" c="n"/>. Se todos os
	  autovalores forem reais uma matriz <by r="n" c="1"/> é retornada.
	  Caso contrário, o resultado é uma matriz <by r="n" c="2"/>, com a primeira
	  coluna contendo os componentes reais e a segunda coluna os componentes
	  imaginários. Não é garantido que os autovalores sejam
	  classificados em alguma ordem particular.
	</para>
	<para>
	  Existem duas possibilidades para o segundo argumento. Ele deve ser o nome
	  de uma matriz existente precedida por <lit>&amp;</lit> (para indicar o
	  <quote>endereço</quote> da matriz em questão), sendo que nesse caso
	  um resultado auxiliar é armazenado nesta matriz. A outra possibilidade é a
	  utilização da palavra-chave <lit>null</lit>, sendo que nesse caso o resultado
	  auxiliar não é produzido.
	</para>
	<para>
	  Se o segundo argumento for não-nulo, a matriz especificada será sobrescrita
	  com o resultado auxiliar. Vale salientar que não é necessário que a matriz
	  existente tenha a dimensão adequada para receber o resultado. A matriz
	  <argname>U</argname> é organizada da seguinte forma:
	</para>
	<ilist>
	  <li>
            <para>
              Se o <math>i</math>-ésimo autovalor for real, a
              <math>i</math>-ésima coluna de <math>U</math> irá conter
              o autovetor correspondente;
            </para>
	  </li>
	  <li>
            <para>
              Se o <math>i</math>-ésimo autovalor for complexo, a
              <math>i</math>-ésima coluna de <argname>U</argname> irá conter
              a parte real do autovetor correspondente e a coluna seguinte
              a parte imaginária. O autovetor para o autovalor conjugado
              é a conjugada do autovetor.
            </para>
	  </li>
	</ilist>
	<para>
	  Em outras palavras, os autovetores são armazenados na mesma ordem que os
	  autovalores, mas os autovetores reais ocupam uma coluna, enquanto que os
	  autovetores complexos ocupam duas (sendo que a parte real é armazenada
	  primeiro). O número total de colunas ainda é <math>n</math>, pois o
	  autovetor conjugado é ignorado.
	</para>
	<para>
	  <seelist>
            <fncref targ="eigensym"/>
            <fncref targ="eigsolve"/>
            <fncref targ="qrdecomp"/>
            <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="eigensym" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="symmat">A</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Funciona da mesma forma que <fncref targ="eigengen"/>, mas o
	  argumento <argname>A</argname> deve ser simétrico (sendo que
	  neste caso os cálculos podem ser reduzidos). Diferentemente
	  de <fncref targ="eigengen"/>, autovalores são retornados em
	  ordem ascendente.
	</para>
	<para>
	  Note: se o interesse é na decomposição espectral de uma
	  matriz da forma <math>X'X</math>, onde <math>X</math> é
	  uma matriz grande, é preferível calculá-la via operador
	  <lit>X'X</lit> ao invés de utilizar a sintaxe mais geral
	  <lit>X'*X</lit>. A primeira expressão utiliza um
	  algoritmo especializado que tem a dupla vantagem de ser
	  mais eficiente computacionalmente e de garantir que o
	  resultado seja livre, por construção, dos artefatos de precisão
	  de máquina que podem torná-la numericamente não-simétrico.
	</para>
      </description>
    </function>

    <function name="eigsolve" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="symmat">A</fnarg>
	<fnarg type="symmat">B</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  esolve o problema do autovalor generalizado |<math>A</math>
	  &minus; &lgr;<math>B</math>| = 0, onde <math>A</math> e
	  <math>B</math> são simétricas e <math>B</math> é positiva
	  definida. Os autovalores são retornados diretamente,
	  ordenados de forma ascendente. Se for utilizado o terceiro
	  argumento (opcional) ele deve ser o nome de uma matriz
	  existente precedida por <lit>&amp;</lit>. Neste caso os
	  autovetores generalizados serão escritos nesta matriz.
	</para>
      </description>
    </function>

    <function name="epochday" section="calendar" output="scalar-or-series">
      <fnargs>
	<fnarg type="scalar-or-series">year</fnarg>
	<fnarg type="scalar-or-series">month</fnarg>
	<fnarg type="scalar-or-series">day</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o número do dia na época corrente especificada pelo ano, mês
	  e dia. O número do dia é igual a 1 para o dia 1 de janeiro do ano 1
	  depois de Cristo, no calendário gregoriano proléptico, e 733786 na
	  data 2010-01-01. Se algum dos argumentos for uma série, os valores
	  retornados também terão a forma de uma série, caso contrário será
	  retornado um escalar.
	</para>
	<para>
	  By default the <argname>year</argname>,
	  <argname>month</argname> and <argname>day</argname> values
	  are assumed to be given relative to the Gregorian calendar,
	  but if the year is a negative value the interpretation
	  switches to the Julian calendar.
	</para>
	<para>
	  Para a inversa dessa função, veja <fncref targ="isodate"/>. Veja
	  também a função <fncref targ="juldate"/> para o calendário juliano.
	</para>
      </description>
    </function>

    <function name="errmsg" section="strings" output="string">
      <fnargs>
	<fnarg type="int">errno</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a mensagem de erro do Gretl associada a
	  <argname>errno</argname>. Veja também <fncref
	  targ="$error"/>.
	</para>
      </description>
    </function>

    <function name="exists" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">name</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna um valor não-nulo se <argname>name</argname> é o identificador de
	  um objeto existente, seja um escalar, uma série, uma matriz, uma lista, uma
	  variável de texto, um pacote (<quote>bundle</quote>) ou um arranjo (<quote>
	  array</quote>). Caso contrário retorna 0. Veja também <fncref targ="typeof"/>.
	</para>
      </description>
    </function>

    <function name="exp" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna <math>e</math><sup>x</sup>. Note que no caso de
	  matrizes a função é aplicada em cada elemento. Para a
	  função exponencial matricial veja <fncref targ="mexp"/>.
	</para>
      </description>
    </function>

    <function name="fcstats" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="series-or-vec">f</fnarg>
      </fnargs>
      <description>
	<para>
	  Produz um vetor coluna contendo várias estatísticas que podem ser
	  utilizadas para avaliar a série <argname>f</argname>, que consiste na
	  previsão da série <argname>y</argname>, ao longo da amostra
	  selecionada. Dois vetores de mesmo tamanho podem ser utilizados
	  no lugar das duas séries.
	</para>
	<para>
	  O vetor é constituído pelas seguintes estatísticas:
	</para>
	<code>
	  1  Erro Médio (ME)
	  2  Raiz do Erro Quadrado Médio (RMSE)
	  3  Erro Absoluto Médio (MAE)
	  4  Erro Percentual Médio (MPE)
	  5  Erro Percentual Absoluto Médio (MAPE)
	  6  U de Theil
	  7  Proporção do viés, UM
	  8  Proporção da regressão, UR
	  9  Proporção do distúrbio, UD
	</code>
	<para>
	  Para maiores detalhes sobre o cálculo dessas estatísticas e
	  a interpretação dos valores de <math>U</math>, veja o
	  <guideref targ="chap:forecast"/>.
	</para>
      </description>
    </function>

    <function name="fdjac" section="numerical" output="matrix">
      <fnargs>
	<fnarg type="cvec">b</fnarg>
	<fnarg type="fncall">fcall</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula uma aproximação numérica para a jacobiana associada ao vetor
	  <argname>b</argname> de ordem <math>n</math> e a função de transformação
	  especificada pelo argumento <argname>fcall</argname>. A chamada da
	  função deve ter <argname>b</argname> como primeiro argumento
	  (tanto na forma direta quanto na forma de ponteiro),
	  seguido por quaisquer argumentos adicionais que podem ser necessários
	  e o valor retornado deverá ser uma matriz de ordem <by r="m" c="1"/>.
	  Se executada com sucesso, <lit>fdjac</lit> retorna uma matriz de ordem
	  <by r="m" c="n"/> contendo a jacobiana.
	  Exemplo:
	</para>
	<code>
	  matrix J = fdjac(theta, myfunc(&amp;theta, X))
	</code>
	<para>
	  A função pode utilizar três diferentes métodos: diferença anterior,
	  diferença bilateral ou extrapolação de Richardson com 4 nós.
	  Respectivamente:
	</para>
	<para context="tex">
	  \[ J_0 = \frac{f(x + h) - f(x)}{h} \]
	</para>
	<para context="tex">
	  \[ J_1 = \frac{f(x + h) - f(x - h)}{2h} \]
	</para>
	<para context="tex">
	  \[ J_2 = \frac{8(f(x+h) - f(x-h)) - (f(x+2h) - f(x-2h))}{12h} \]
	</para>
	<para context="notex">
	  <math>J</math><sub>0</sub> = <math>(f(x+h) - f(x))/h</math>
	</para>
	<para context="notex">
	  <math>J</math><sub>1</sub> = <math>(f(x+h) - f(x-h))/2h</math>
	</para>
	<para context="notex">
	  <math>J</math><sub>2</sub>  = <math>[8(f(x+h) - f(x-h)) -
	  (f(x+2h) - f(x-2h))] /12h</math>
	</para>
	<para>
	  As três alternativas acima trazem, geralmente, um dilema
	  entre acurácia e velocidade. É possível escolher os métodos
	  através do comando <cmdref targ="set"/>, ajustando a variável
	  <lit>fdjac_quality</lit> em 0, 1 ou 2.
	</para>
	<para>
	  Para maiores detalhes e exemplos veja o capítulo sobre métodos
	  numéricos no <guideref targ="chap:numerical"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="BFGSmax"/>
            <cmdref targ="set"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="fft" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula a transformada de Fourier real discreta. Se a matriz de
	  entrada <argname>X</argname> tiver <math>n</math> colunas, a saída
	  terá 2<math>n</math> colunas, onde as partes reais são armazenadas
	  nas colunas ímpares e as complexas nas pares.
	</para>
	<para>
	  Quando seja necessário calcular a transformada de Fourier em vários
	  vetores com o mesmo número de elementos, é mais eficiente, do ponto
	  de vista numérico, agrupar esses vetores em uma única matriz ao invés
	  de aplicar a função <lit>fft</lit> em cada vetor de forma separada.
	  <seelist>
            <fncref targ="ffti"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ffti" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula a inversa da transformada de Fourier real discreta. Assume-se
	  que <argname>X</argname> contém <math>n</math> colunas complexas, com
	  a parte real nas colunas ímpares e a parte real nas pares. Assim, o
	  número total de colunas deverá ser 2<math>n</math>.
	  Uma matriz com <math>n</math> colunas é retornada.
	  returned.
	</para>
	<para>
	  Quando seja necessário calcular a inversa da transformada de Fourier em
	  vários vetores com o mesmo número de elementos, é mais eficiente, do ponto
	  de vista numérico, agrupar esses vetores em uma única matriz ao invés de
	  aplicar a função <lit>fft</lit> em cada vetor de forma separada.
	  <seelist>
            <fncref targ="fft"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="filter" section="filters" output="seebelow">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
	<fnarg optional="true" type="scalar-or-vec">a</fnarg>
	<fnarg optional="true" type="scalar-or-vec">b</fnarg>
	<fnarg optional="true" type="scalar">y0</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula uma filtragem semelhante ao ARMA do argumento
	  <argname>x</argname>. A transformação pode ser escrita como
	</para>
	<para context="tex">
	  \[ y_t = \sum_{i=0}^q a_i x_{t-i} + \sum_{i=1}^p b_i y_{t-i} \]
	</para>
	<para context="notex">
	  <math>y</math><sub>t</sub> =
	  <math>a</math><sub>0</sub> <math>x</math><sub>t</sub> +
	  <math>a</math><sub>1</sub> <math>x</math><sub>t-1</sub> +
	  ...
	  <math>a</math><sub>q</sub> <math>x</math><sub>t-q</sub> +
	  <math>b</math><sub>1</sub> <math>y</math><sub>t-1</sub> +
	  ...
	  <math>b</math><sub>p</sub><math>y</math><sub>t-p</sub>
	</para>
	<para>
	  Se o argumento <argname>x</argname> for uma série, o resultado
	  será também uma série. Caso contrário, se <argname>x</argname>
	  for uma matriz com <math>T</math> linhas e <math>k</math>
	  colunas, o resultado será uma matriz com o mesmo tamanho e com
	  a filtragem sendo realizada coluna por coluna.
	</para>
	<para>
	  Os argumentos <argname>a</argname> e <argname>b</argname>
	  são opcionais. Eles podem ser escalares, vetores ou a
	  palavra-chave <lit>null</lit>.
	</para>
	<para>
	  Se <argname>a</argname> for um escalar, isto é usado como
	  <math>a</math><sub>0</sub> e implica em <math>q=0</math>. Se
	  ele for um vetor com <math>q+1</math> elementos, eles contêm
	  os coeficientes de <math>a</math><sub>0</sub> a
	  <math>a</math><sub>q</sub>. Se <argname>a</argname> for
	  <lit>null</lit> ou for omitido, isso é equivalente a definir
	  <math>a</math><sub>0</sub> <math>=1</math> e
	  <math>q=0</math>.
	</para>
	<para>
	  Se <argname>b</argname> for um escalar, isto é usado como
	  <math>b</math><sub>1</sub> e implica em <math>p=1</math>. Se
	  ele for um vetor com <math>p</math> elementos, eles contêm
	  os coeficientes de <math>b</math><sub>1</sub> a
	  <math>b</math><sub>p</sub>. Se <argname>b</argname> for
	  <lit>null</lit> ou for omitido, isso é equivalente a definir
	  <math>B(L)=1</math>.
	</para>
	<para>
	  O argumento escalar opcional <argname>y0</argname> for tomado
	  para representa todos os valores de <math>y</math> anteriores
	  ao início da amostra (usado apenas quando <math>p>0</math>).
	  Se for omitido, subentende-se que é igual a 0. Assume-se que
	  valores pré-amostrais de <argname>x</argname> são sempre 0.
	</para>
	<para>
	  <seelist>
            <fncref targ="bkfilt"/>
            <fncref targ="bwfilt"/>
            <fncref targ="fracdiff"/>
            <fncref targ="hpfilt"/>
            <fncref targ="movavg"/>
            <fncref targ="varsimul"/>
	  </seelist>
	</para>
	<para>
	  Exemplo:
	</para>
	<code>
	  nulldata 5
	  y = filter(index, 0.5, -0.9, 1)
	  print index y --byobs
	  x = seq(1,5)' ~ (1 | zeros(4,1))
	  w = filter(x, 0.5, -0.9, 1)
	  print x w
	</code>
	<para>
	  produz
	</para>
	<code>
          index            y

          1            1     -0.40000
          2            2      1.36000
          3            3      0.27600
          4            4      1.75160
          5            5      0.92356

          x (5 x 2)

          1   1
          2   0
          3   0
          4   0
          5   0

          w (5 x 2)

          -0.40000     -0.40000
          1.3600      0.36000
          0.27600     -0.32400
          1.7516      0.29160
          0.92356     -0.26244
	</code>
      </description>
    </function>

    <function name="firstobs" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o número da primeira observação não ausente da
	  série <argname>y</argname>. Note que se alguma forma de
	  subamostragem estiver sendo utilizada o valor retornado
	  poderá ser menor que o valor retornado pela função
	  <fncref targ="$t1"/>.
	  <seelist>
            <fncref targ="lastobs"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="fixname" section="strings" output="string">
      <fnargs>
	<fnarg type="string">rawname</fnarg>
      </fnargs>
      <description>
	<para>
	  Tem a intenção de ser utilizada em conjunto com o comando
    <cmdref targ="join"/>. Retorna o resultado da conversão de
	  <argname>rawname</argname> em um identificador válido do Gretl,
	  que deve ser iniciado por uma letra, conter apenas letras ASCII,
	  dígitos e traço inferior (<quote>underscore</quote>), e não deve
	  ter mais que 31 caracteres. As regras utilizadas na conversão são:
	</para>
	<para>
	  1. Remover quaisquer caracteres que não sejam letras no início do nome.
	</para>
	<para>
	  2. Até o limite de 31 caracteres não ter sido ultrapassado ou a entrada
	  tiver sido exaurida: transcreve os caracteres <quote>legais</quote>, omite
	  os caracteres <quote>ilegais</quote>, com exceção dos espaços, e
	  substitui os espaços por traços inferiores. Se o
	  o caractere anterior for um traço inferior o espaço será
    omitido.
	</para>
      </description>
    </function>

    <function name="floor" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Consiste na função piso. Retorna o maior inteiro menor que ou
	  igual <argname>x</argname>. Note que <fncref targ="int"/> e
	  <lit>floor</lit> possuem efeitos distintos em argumentos negativos:
	  <lit>int(-3.5)</lit> gera &minus;3, enquanto
	  <lit>floor(-3.5)</lit> gera &minus;4.
	</para>
      </description>
    </function>

    <function name="fracdiff" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="scalar">d</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Retorna a diferença fracionária de ordem <argname>d</argname>
	  para a series <argname>y</argname>.
	</para>
	<para context="tex">
          \[
          \Delta^d y_t = y_t - \sum_{i=1}^{\infty} \psi_i y_{t-i}
          \]
	  onde
          \[\psi_i = \frac{\Gamma(i-d)}{\Gamma(-d) \Gamma(i+1)}\]
	</para>
	<para>
	  Note que teoricamente a diferenciação fracionária é um filtro
	  infinitamente longo. Na prática, valores antes da amostra de
	  <math>y</math><sub>t</sub> são assumidos com sendo iguais a zero.
	</para>
	<para>
	  É possível utilizar valores de <argname>d</argname> negativos.
	  Nesse caso é realizada a integração fracionária.
	</para>
      </description>
    </function>

    <function name="gammafun" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a função gama de <argname>x</argname>.
	</para>
      </description>
    </function>

    <function name="genseries" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="string">varname</fnarg>
	<fnarg type="series">rhs</fnarg>
      </fnargs>
      <description>
	<para>
	  Permite que sejam geradas séries cujos nomes não são conhecidos a
	  priori e/ou que sejam criadas séries e adicionadas a uma lista
	  utilizando apenas uma única operação.
	</para>
	<para>
	  O primeiro argumento fornece o nome da série a ser criada (ou
	  modificada) e pode ser um texto literal, uma variável de texto
	  (<quote>string</quote>), ou uma expressão cujo resultado seja
	  uma variável de texto. O segundo argumento, <argname>rhs</argname>
	  (abreviação em inglês de <quote>lado direito</quote>), define
	  a fonte da série: isto pode ser o nome de uma série existente
	  ou uma expressão cujo resultado seja uma série, da forma que
	  aparece do lado direito do sinal de igualdade quando se definem
	  séries da forma usual.
	</para>
	<para>
	  O valor de retorno dessa função é o número ID das séries no conjunto
	  de dados, um valor que pode ser utilizado para incluir as séries em
	  uma lista (ou &minus;1 caso a execução da função falhe).
	</para>
	<para>
	  Por exemplo, suponha que se queira adicionar <math>n</math> séries
	  aleatórias com distribuição normal ao conjunto de dados e
	  colocá-las em uma lista. O código a seguir fará isso:
	</para>
	<code>
	  list Normals = null
	  loop i=1..n --quiet
	      Normals += genseries(sprintf("norm%d", i), normal())
	  endloop
	</code>
	<para>
	  Ao término da execução a lista <lit>Normals</lit> irá conter as
	  séries <lit>norm1</lit>, <lit>norm2</lit> e assim sucessivamente.
	</para>
      </description>
    </function>

    <function name="getenv" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Se uma variável de ambiente de nome <argname>s</argname>
	  estiver definida a função retorna uma variável com o texto
	  dessa variável, caso contrário, retorna um texto vazio.
	  Veja também <fncref targ="ngetenv"/>.
	</para>
      </description>
    </function>

    <function name="getline" section="strings" output="scalar">
      <fnargs>
	<fnarg type="string">source</fnarg>
	<fnarg type="string">target</fnarg>
      </fnargs>
      <description>
	<para>
	  Essa função lê sucessivamente as linhas de <argname>source</argname>, que
	  deve ser uma variável de texto (<quote>string</quote>). A cada chamada uma
	  linha do texto é escrita em <argname>target</argname> (que também deve ser
	  uma variável de texto) com o caractere de nova linha removido. O valor
	  retornado é 1, se existir algo a ser lido (incluindo-se linhas em branco),
	  ou 0, se todas as linhas de <argname>source</argname> tiverem sido lidas.
	</para>
	<para>
	  A seguir é apresentado um exemplo onde o conteúdo de um arquivo de texto é
	  dividido em linhas:
	</para>
	<code>
	  string s = readfile("data.txt")
	  string line
	  scalar i = 1
	  loop while getline(s, line)
	      printf "line %d = '%s'\n", i++, line
	  endloop
	</code>
	<para>
	  Neste exemplo pode-se ter a certeza de que o texto foi exaurido quando o
	  loop terminar. Se não for desejado exaurir todas as linhas do texto pode-se
	  chamar a função <lit>getline</lit>, sendo que sucessivas chamadas
	  substituirão o conteúdo de <argname>target</argname> pela nova linha lida.
	  Para reiniciar a leitura a partir da primeira linha de <argname>source
	  </argname> basta utilizar <lit>null</lit> no argumento <argname>target
	  </argname> (ou apenas deixá-lo em branco). Exemplos:
	</para>
	<code>
	  getline(s, line) # recupera uma única linha
	  getline(s, null) # reinicia a leitura
	</code>
	<para>
	  Note que apesar de a posição de leitura avançar em cada chamada de <lit>
	  getline</lit>, o argumento <argname>source</argname> não é modificado por
	  essa função, apenas <argname>target</argname> é alterado.
	</para>
      </description>
    </function>

    <function name="ghk" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">C</fnarg>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix">B</fnarg>
	<fnarg type="matrix">U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;dP</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula a aproximação GHK (Geweke, Hajivassiliou, Keane) para a
	  função de distribuição normal multivariada. Veja, por exemplo, <cite
	  key="geweke91">Geweke (1991)</cite>. O valor retornado é um vetor de
	  probabilidades de ordem <by r="n" c="1"/>.
	</para>
	<para>
	  O argumento <argname>C</argname> (<by r="m" c="m"/>) deve fornecer o
	  fator de Cholesky (triangular inferior) da matriz de covariância de
	  <math>m</math> variáveis normais. Ambos os argumentos <argname>A</argname>
	  e <argname>B</argname> devem ser de ordem <by r="n" c="m"/>, fornecendo,
	  respectivamente, os limites inferior e superior aplicados às variáveis
	  em cada uma das <math>n</math> observações. Quando as variáveis não
	  possuírem limites é necessário que tal característica seja indicada
	  através da constante <fncref targ="$huge"/> ou de sua negativa.
	</para>
	<para>
	  A matriz <argname>U</argname> deve ter ordem <by r="m" c="r"/>, sendo
	  <math>r</math> o número de elementos pseudo-aleatórios extraídos da
	  distribuição uniforme. Funções convenientes para a criação de <argname>
	  U</argname> são <fncref targ="muniform"/> e <fncref targ="halton"/>.
	</para>
	<para>
	  A seguir encontra-se um caso relativamente simples onde as
	  probabilidades multivariadas podem ser calculada de forma
	  analítica. As séries <lit>P</lit> e <lit>Q</lit> devem ser
	  numericamente muito similares entre si, sendo <lit>P</lit>
	  a probabilidade <quote>verdadeira</quote> e <lit>Q</lit>
	  sua aproximação GHK:
	</para>
	<code>
	  nulldata 20
	  series inf1 = -2*uniform()
	  series sup1 = 2*uniform()
	  series inf2 = -2*uniform()
	  series sup2 = 2*uniform()

	  scalar rho = 0.25
	  matrix V = {1, rho; rho, 1}

	  series P = cdf(D, rho, inf1, inf2) - cdf(D, rho, sup1, inf2) \
	  - cdf(D, rho, inf1, sup2) + cdf(D, rho, sup1, sup2)

	  C = cholesky(V)
	  U = halton(2, 100)

	  series Q = ghk(C, {inf1, inf2}, {sup1, sup2}, U)
	</code>
	<para>
	  O argumento opcional <argname>dP</argname> pode ser usado para
	  recuperar a matriz <by r="n" c="k"/> de derivadas das probabilidades,
	  onde <math>k</math> é igual a 2<math>m</math> + <math>m</math>
	  (<math>m</math> + 1)/2. As primeiras <math>m</math> colunas
	  contêm as derivadas em relação aos limites inferiores, as próximas
	  <math>m</math> as derivadas em relação aos limites superiores e as
	  colunas restantes as derivadas em relação aos elementos únicos da
	  matriz <math>C</math> na ordem
	  <quote>vech</quote>.
	</para>
      </description>
    </function>

    <function name="gini" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o índice de desigualdade de Gini para a série
	  <argname>y</argname>.
	</para>
      </description>
    </function>

    <function name="ginv" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna <math>A</math><sup>+</sup>, a Moore&ndash;Penrose
	  ou inversa generalizada de <argname>A</argname>, calculada via
	  decomposição em valores singulares.
	</para>
	<para context="notex">
	  Essa matriz possui as seguintes propriedades: <math>A</math>
	  <math>A</math><sup>+</sup> <math>A</math> = <math>A</math>
	  and <math>A</math><sup>+</sup> <math>A</math>
	  <math>A</math><sup>+</sup> = <math>A</math><sup>+</sup>.
	  Além disso, os produtos <math>A</math>
	  <math>A</math><sup>+</sup> e <math>A</math><sup>+</sup>
	  <math>A</math> são simétricos por construção.
	</para>
	<para context="tex">
	  Essa matriz possui as seguintes propriedads:
	  \begin{eqnarray*}
	  A A^+ A &amp; = &amp; A \\
	  A^+ A A^+ &amp; = &amp; A^+
	  \end{eqnarray*}
	  Além disso, os produtos $A^+ A$ e $A A^+$ são
	  simétricos por construção.
	</para>
	<para>
	  <seelist>
            <fncref targ="inv"/>
            <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="halton" section="stats" output="matrix">
      <fnargs>
	<fnarg type="int">m</fnarg>
	<fnarg type="int">r</fnarg>
	<fnarg optional="true" type="int">offset</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma matriz <by r="m" c="r"/> contendo
	  <math>m</math> sequências de Halton de cumprimento <math>r</math>.
	  O <math>m</math> é limitado a um máximo de 40. As sequências são
	  contruídas utilizando os primeiros <math>m</math> primos. Por
	  padrão os primeiros 10 elementos de cada sequência são
	  descartados, mas isso pode ser ajustado via argumento
	  opcional <argname>offset</argname>, que deve ser um número inteiro
	  não negativo. Maiores detalhes podem ser encontrados em
	  <cite key="halton64">Halton e Smith (1964)</cite>.
	</para>
      </description>
    </function>

    <function name="hdprod" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">Y</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula o produto direto horizontal. Os dois argumentos
	  devem ter o mesmo número de linhas, <math>r</math>. O valor
	  retornado é uma matriz com <math>r</math> linhas, onde a
	  <math>i</math>-ésima linha corresponde ao produto de
	  Kronecker das linhas correspondentes de <argname>X</argname>
	  e <argname>Y</argname>.
	</para>
	<para context="tex">
	  Em outras palavras, se $X$ é uma matriz $r \times k$, $Y$ é uma
	  matriz $r \times m$ e $Z$ é a matriz resultante do
	  produto direto horizontal de $X$ vezes $Y$, logo $Z$ terá
	  $r$ linhas e $k\cdot m$ colunas. Além disso,
	  \[
	  Z_{in} = X_{ij} Y_{il}
	  \]
	  onde $n = (j-1) m + l$.
	</para>
	<para>
	  Esta operação é chamada de <quote>produto horizontal
	  direto</quote> em conformidade com sua implementação na
	  linguagem de programação GAUSS. Sua equivalente na álgebra
	  linear padrão seria chamada de produto linha a linha de
	  Khatri-Rao.
	</para>
	<para>
	  Exemplo: o código
	</para>
	<code>
	  A = {1,2,3; 4,5,6}
	  B = {0,1; -1,1}
	  C = hdprod(A, B)
	</code>
	<para>
	  produz a seguinte matriz:
	</para>
	<code>
          0    1    0    2    0    3
         -4    4   -5    5   -6    6
	</code>
      </description>
    </function>

    <function name="hfdiff" section="midas" output="list">
      <fnargs>
	<fnarg type="list">hfvars</fnarg>
	<fnarg type="scalar">multiplier</fnarg>
      </fnargs>
      <description>
	<para>
	  Dada uma <cmdref targ="MIDAS_list"/>, produz uma lista com o mesmo
	  tamanho contendo as primeiras diferenças de alta frequência. O
	  segundo argumento é opcional e tem como valor padrão 1: ele pode
	  ser utilizado para multiplicar as diferenças por alguma constante.
	</para>
      </description>
    </function>

    <function name="hfldiff" section="midas" output="list">
      <fnargs>
	<fnarg type="list">hfvars</fnarg>
	<fnarg type="scalar">multiplier</fnarg>
      </fnargs>
      <description>
	<para>
	  Dada uma <cmdref targ="MIDAS_list"/>, produz uma lista com o mesmo
	  tamanho contendo as diferenças logarítmicas de alta frequência. O
	  segundo argumento é opcional e tem como valor padrão 1: ele pode
	  ser utilizado para multiplicar as diferenças por alguma constante.
	  Um exemplo da utilização desse argumento é utilizar o valor 100 para
	  obter as variações percentuais (aproximadas).
	</para>
      </description>
    </function>

    <function name="hflags" section="midas" output="list">
      <fnargs>
	<fnarg type="int">minlag</fnarg>
	<fnarg type="int">maxlag</fnarg>
	<fnarg type="list">hfvars</fnarg>
      </fnargs>
      <description>
	<para>
	  Dada uma <cmdref targ="MIDAS_list"/>, <repl>hfvars</repl>, produz uma lista
	  contendo as defasagens de auta frequência de <repl>minlag</repl> a <repl>
	  maxlag</repl>. Deve-se utilizar valores positivos para defasagens (<math>
	  t</math> - 1) e negativos para adiantamentos (<math>t</math> + 1). Por
	  exemplo, se <repl>minlag</repl> for &minus;3 e <repl>maxlag</repl> for 5
	  então a lista retornada irá conter 9 séries: 3 adiantamentos, o valor atual
	  e 5 defasagens.
	</para>
	<para>
	  Note que a efasagem de alta frequência 0 corresponde ao primeiro
	  período de alta frequência dentro de um período de baixa frequência,
	  por exemplo, o primeiro mês de um trimestre ou o primeiro dia de um
	  mês.
	</para>
      </description>
    </function>

    <function name="hflist" section="midas" output="list">
      <fnargs>
	<fnarg type="vector">x</fnarg>
	<fnarg type="int">m</fnarg>
	<fnarg type="string">prefix</fnarg>
      </fnargs>
      <description>
	  <para>
	  Produz a partir de um vetor <repl>x</repl> uma lista MIDAS
	  (<cmdref targ="MIDAS_list"/>) de <repl>m</repl> séries, onde
	  <repl>m</repl> é a razão entre a frequência das observações
	  para a variável em <repl>x</repl> em relação a frequência base
	  do conjunto de dados corrente. O valor de <repl>m</repl> deve
	  ser ao menos 3 e o comprimento de <repl>x</repl> deve ser
	  <repl>m</repl> vezes o comprimento da amostra selecionada corrente.
    </para>
    <para>
	  Os nomes das séries na lista retornada são definidos a partir de um
	  dado prefixo, dado pelo argumento <repl>prefix</repl> (este deve ser
	  um texto ASCII com 24 ou menos caracteres e que seja um identificador
	  válido para o Gretl) mais 1 ou mais prefixos representando o subperíodo
	  da observação. Um erro será apresentado se algum desses nomes seja
	  idêntico a nomes de objetos já existentes.
    </para>
      </description>
    </function>

    <function name="hpfilt" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="scalar" optional="true">lambda</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o componente cíclico do filtro de Hodrick&ndash;Prescott
	  aplicado à série <argname>y</argname>. Se o parâmetro de suavização
	  <argname>lambda</argname> não for fornecido o Gretl usará valores
	  padrão com base na periodicidade dos dados. O parâmetro será igual
	  a 100 vezes o quadrado da periodicidade (100 para dados anuais, 1600
	  para dados trimestrais, etc.).
	  <seelist>
            <fncref targ="bkfilt"/>
            <fncref targ="bwfilt"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="I" section="matbuild" output="smatrix">
      <fnargs>
	<fnarg type="int">n</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma matriz identidade com <argname>n</argname> linhas e
	  colunas.
	</para>
      </description>
    </function>

    <function name="imaxc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna um vetor com os números das linhas onde as colunas de
	  <argname>X</argname> atingem seus valores máximos.
	</para>
	<para>
	  <seelist>
            <fncref targ="imaxr"/>
            <fncref targ="iminc"/>
            <fncref targ="maxc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="imaxr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna um vetor com os números das colunas onde as linhas de
	  <argname>X</argname> atingem seus valores máximos.
	</para>
	<para>
	  <seelist>
            <fncref targ="imaxc"/>
            <fncref targ="iminr"/>
            <fncref targ="maxr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="imhof" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="scalar">x</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Calcula Prob(<math>u'Au</math> &lt; <math>x</math>) para uma forma
	  quadrática em variáveis normais padrão, <math>u</math>, utilizando o
	  procedimento desenvolvido por <cite key="imhof61">Imhof (1961)</cite>.
	</para>
	<para context="tex">
	  Computes ${\rm Prob}(u'Au &lt; x)$ para uma forma quadrática em variáveis
	  normais padrão, $u$, utilizando o procedimento desenvolvido por
	  <cite key="imhof61">Imhof (1961)</cite>.
	</para>
	<para>
	  Se o primeiro argumento, <argname>M</argname>, for uma matriz quadrada ela
	  será utilizada para especificar <math>A</math>, caso contrário, se for
	  um vetor coluna, será utilizada como sendo os autovalores pré-calculados
	  de <math>A</math>, caso contrário um erro será apresentado.
	</para>
	<para>
	  <seelist>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="iminc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna um vetor com os números das linhas onde as colunas de
	  <argname>X</argname> atingem seus valores mínimos.
	</para>
	<para>
	  <seelist>
            <fncref targ="iminr"/>
            <fncref targ="imaxc"/>
            <fncref targ="minc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="iminr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna um vetor com os números das colunas onde as linhas de
	  <argname>X</argname> atingem seus valores mínimos.
	</para>
	<para>
	  <seelist>
            <fncref targ="iminc"/>
            <fncref targ="imaxr"/>
            <fncref targ="minr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="inbundle" section="data-utils" output="int">
      <fnargs>
	<fnarg type="bundle">b</fnarg>
	<fnarg type="string">key</fnarg>
      </fnargs>
      <description>
	<para>
	  Verifica se um pacote (<quote>bundle</quote>) <argname>b</argname> contém um item com o nome
    <argname>key</argname>. O valor retornado é um código (na forma de um número inteiro)
	  para o tipo de item: 0 caso não seja encontrado, 1 para escalar, 2 para série,
	  3 para matriz, 4 para variável de texto, 5 para pacote (<quote>bundle</quote>)
	  e 6 para arranjo (<quote>array</quote>). A função <fncref targ="typestr"/> pode
	  ser utilizada para se obter o nome do tipo do item na forma de variável de texto
	  com base em seu código.
	</para>
      </description>
    </function>

    <function name="infnorm" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Retorna a norma infinito de <argname>X</argname>, isto é,
	  o máximo ao longo das linhas de <argname>X</argname> da
	  soma dos valores absolutos dos elementos da linha.
	</para>
	<para context="tex">
	  Retorna a norma-$\infty$ da matriz <argname>X</argname> de
	  ordem $r\times c$ matrix, ou seja:
          \[\| X \|_{\infty} = \max_i \sum_{j=1}^c |X_{ij}|\]
	</para>
	<para>
	  <seelist>
            <fncref targ="onenorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="inlist" section="data-utils" output="int">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a posição de <argname>y</argname> na
	  lista <argname>L</argname>, ou 0 se <argname>y</argname>
	  não estiver presente em <argname>L</argname>.
	</para>
	<para>
	  O segundo argumento pode ser dado tanto como o nome da série quanto
	  como o número ID da série. Se é sabido que uma série com dado nome
	  (como por exemplo <lit>foo</lit>) existe, então é possível chamar
	  essa função da seguinte forma:
	</para>
    <code>
	  pos = inlist(L, foo)
    </code>
    <para>
	  O que a expressão acima está solicitando é: <quote>Informe a posição da
	  série <lit>foo</lit> na lista <lit>L</lit> (sendo 0 se ela não estiver
	  incluída na lista L)</quote>. Entretanto, se não houver certeza se
	  a série com dado nome existe, deve-se inserir o nome entre aspas. Isso
	  é feito da seguinte forma:
	</para>
	<code>
	  pos = inlist(L, "foo")
    </code>
    <para>
	  Neste caso o que está sendo solicitado é: <quote>Se existir uma série
	  chamada <lit>foo</lit> na lista <lit>L</lit>, me informe sua posição ou
	  0 caso ela não exista.</quote>
	</para>
  </description>
    </function>

    <function name="int" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a parte inteira <argname>x</argname>, truncando a parte
	  fracional. Note que <lit>int</lit> e <fncref targ="floor"/>
	  possuem efeitos distintos em argumentos negativos:
	  <lit>int(-3.5)</lit> gera &minus;3, enquanto
	  <lit>floor(-3.5)</lit> gera &minus;4.
	  <seelist>
            <fncref targ="ceil"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="inv" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a inversa de <argname>A</argname>. Se
	  <argname>A</argname> for singular ou não quadrada, uma mensagem
	  de erro é produzida e nada é retornado. Note que o Gretl confere
	  automaticamente a estrutura de <argname>A</argname> e utiliza o
	  procedimento numérico mais eficiente para realizar a inversão.
	</para>
	<para>
	  Os tipos de matriz que o Gretl confere são: identidade, diagonal,
	  simétrica e positiva definida, simétrica mas não positiva definida
	  e triangular.
	</para>
	<para>
	  Observação: faz sentido utilizar essa função apenas se o intuito
	  for utilizar a inversa de <argname>A</argname> mais de uma vez.
	  Se o objetivo for apenas calcular uma expressão da forma
	  <math>A</math><sup>-1</sup><math>B</math>, será preferível
	  utilizar os operadores de <quote>divisãon</quote>
	  <lit>\</lit> e <lit>/</lit>. Veja <guideref
	  targ="chap:matrices"/> para detalhes.
	</para>
	<para>
	  <seelist>
            <fncref targ="ginv"/>
            <fncref targ="invpd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="invcdf" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">p</fnarg>
      </fnargs>
      <description>
	<para>
	  Calculadora da função de distribuição acumulada inversa. Retorna
	  <math>x</math> tal que
	  <equation status="inline" ascii="P(X &le; x) = p"
		    tex="$P(X \le x) = p$"/>, onde a distribuição de
	  <math>X</math> é especificada pela letra <argname>d</argname>.
	  Entre os argumentos <argname>d</argname> e <argname>p</argname>,
	  zero ou mais argumentos adicionais são necessários para que
	  se especifique os parâmetros da distribuição. Isso é feito da
	  seguinte forma:
	</para>
	<ilist context="notex">
	  <li>
            <para>
              Normal padrão (c = z, n ou N): sem argumentos extras
            </para>
	  </li>
	  <li>
            <para>
              Gama (g ou G): forma; escala
            </para>
	  </li>
	  <li>
            <para>
              t de Student (t): graus de liberdade
            </para>
	  </li>
	  <li>
            <para>
              Qui-quadrado (c, x ou X): graus de liberdade
            </para>
	  </li>
	  <li>
            <para>
              F de Snedecor F (f ou F): graus de liberdade (num.); graus de liberdade (den.)
            </para>
	  </li>
	  <li>
            <para>
              Binomial (b ou B): probabilidade; tentativas
            </para>
	  </li>
	  <li>
            <para>
              Poisson (p ou P): média
            </para>
	  </li>
	  <li>
            <para>
              GED padronizada (E): forma
            </para>
	  </li>
	  <li>
	    <para>
	      Qui-quadrado não-central (ncX): graus de liberdade, parâmetro de não-centralidade
	    </para>
	  </li>
	  <li>
	    <para>
	      F não-central (ncF): graus de liberdade (num.), graus de liberdade (den.),
	      parâmetro de não-centralidade
	    </para>
	  </li>
	  <li>
	    <para>
	      t não-central (nct): graus de liberdade, parâmetro de não-centralidade
	    </para>
	  </li>
	</ilist>
	<tabular colspec="lllll">
	  \textit{Distribuição} &amp; \textsl{d} &amp;
	  \textit{Arg} 2 &amp; \textit{Arg} 3 &amp; \textit{Arg} 4 \\[4pt]
	  Norma padrão &amp; \texttt{z}, \texttt{n} or \texttt{N} &amp;
	  -- &amp; --  &amp; -- \\
	  Gama &amp; \texttt{g} ou \texttt{G} &amp;
	  forma &amp; escala  &amp; -- \\
	  $t$ de Student (central) &amp; \texttt{t} &amp;
	  graus de liberdade &amp; --  &amp; -- \\
	  Qui-quadrado &amp; \texttt{c}, \texttt{x} ou \texttt{X} &amp;
	  graus de liberdade &amp; --  &amp; -- \\
	  $F$ de Snedecor &amp; \texttt{f} ou \texttt{F} &amp;
	  g.l. (num.) &amp; g.l. (den.)  &amp; -- \\
	  Binomial &amp; \texttt{b} ou \texttt{B} &amp;
	  $p$ &amp; $n$  &amp; -- \\
	  Poisson &amp; \texttt{p} ou \texttt{P} &amp;
          $\lambda$ &amp; --  &amp; -- \\
	  GED padronizada &amp; \texttt{E} &amp; forma &amp; --
	  &amp; -- \\
	  $\chi^2$ não-central &amp; \texttt{ncX} &amp;
	  g.l. &amp; não-centralidade &amp; -- \\
	  $F$ não-central &amp; \texttt{ncF} &amp;
	  g.l. (num.) &amp; g.l. (den.) &amp; não-centralidade \\
	  $t$ não-central &amp; \texttt{nct} &amp;
	  g.l. &amp; não-centralidade &amp; -- \\
	</tabular>
	<para>
	  <seelist>
            <fncref targ="cdf"/>
            <fncref targ="critical"/>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="invmills" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a razão inversa de Mills em <argname>x</argname>, isto
	  é a razão entre a densidade normal padrão e o complemento para
	  para a função de distribuição normal padrão, ambas avaliadas
	  em <argname>x</argname>.
	</para>
	<para>
	  Essa função utiliza um algoritmo dedicado que fornece maior
	  precisão quando comparado ao cálculo via <fncref targ="dnorm"/>
	  e <fncref targ="cnorm"/>, mas a diferençae entre os dois
	  métodos é considerável apenas para valores muito negativos
	  de <argname>x</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="cdf"/>
            <fncref targ="cnorm"/>
            <fncref targ="dnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="invpd" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="pdmat">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a inversa da matriz simétrica positiva definida
	  <argname>A</argname>. Essa função é ligeiramente mais rápida
	  que <fncref targ="inv"/> para matrizes grandes, uma vez que
	  não é verificado se a matriz é simétrica. Por essa razão, essa
	  função deve ser utilizada com cuidado.
	</para>
	<para>
	  Observação: se o intuito for inverter uma matriz na forma
	  <math>X'X</math>, onde <math>X</math> é uma matriz grande,
	  é preferível computá-la via operador <lit>X'X</lit>
	  ao invés de utilizar a sintaxe mais geral <lit>X'*X</lit>.
	  A primeira expressão utiliza um algoritmo especializado que
	  tem a dupla vantagem de ser mais eficiente computacionalmente
	  e de garantir que o resultado seja livre, por construção,
	  dos artefatos de precisão de máquina que podem torná-la
	  numericamente não-simétrico.
	</para>
      </description>
    </function>

    <function name="irf" section="stats" output="matrix">
      <fnargs>
	<fnarg type="int">target</fnarg>
	<fnarg type="int">shock</fnarg>
	<fnarg type="pscalar" optional="true">alpha</fnarg>
      </fnargs>
      <description>
	<para>
	  Essa função está disponível apenas quando o último modelo
	  estimado foi um VAR ou um VECM. Ela retorna uma matriz contendo
	  as respostas estimadas da variável <argname>target</argname> a
	  um impulso (choque) de 1 desvio padrão na variável
	  <argname>shock</argname>. Essas variáveis são identificadas de
	  acordo com suas posições na especificação do modelo: por exemplo,
	  se para <argname>target</argname> e <argname>shock</argname> são
	  dados os valores 1 e 3, respectivamente, a matriz que será
	  retornada fornece as respostas da primeira variável no sistema
	  a um choque na terceira variável.
	</para>
	<para>
	  Se o terceiro argumento <argname>alpha</argname>, que é opcional, for
	  dado, a matriz retornada terá três colunas: a estimativa pontual das
	  respostas, seguida dos limites inferior e superior de um intervalo de
	  confiança obtido via bootstrap de 1 &minus; &agr;.
	  Onde <argname>alpha</argname> = 0.1
	  corresponde a 90 por cento de confiança. Se
	  <argname>alpha</argname> for omitido ou igualado a zero, apenas a
	  estimativa pontual será fornecida.
	</para>
	<para>
	  O número de períodos (linhas) da resposta é
	  determinado automaticamente com based na frequencia
	  dos dados, mas isso pode ser ajustado via comando <cmdref
	  targ="set"/>, como por exemplo <lit>set horizon 10</lit>.
	</para>
      </description>
    </function>

    <function name="irr" section="math" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a Taxa Interna de Retorno para <argname>x</argname>,
	  considerado como sendo uma sequência de pagamentos (negativo)
	  e recebimentos (positivo).
	  <seelist>
            <fncref targ="npv"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="isconst" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="int" optional="true">panel-code</fnarg>
      </fnargs>
      <description>
	<para>
	  Sem o segundo argumento (opcional), retorna 1 caso <argname>y</argname>
	  tenha um valor constante ao longo da amostra selecionada (ou ao longo de
	  toda sua extensão no caso de <argname>y</argname> ser um vetor), caso
	  contrário retorna 0.
	</para>
	<para>
	  O segundo argumento somente é aceito se o conjunto de dados corrente
	  for um painel e <argname>y</argname> for uma série. Neste caso um valor
	  de <argname>panel-code</argname> igual a 0 faz a função verificar se a
	  série não varia em relação ao tempo. Um valor igual a 1 faz a função
	  verificar se a série não varia entre as unidades de corte transversal
	  (ou seja, se o valor de <argname>y</argname> é o mesmo para todos os
	  grupos).
	</para>
	<para>
	  Se <argname>y</argname> for uma série, valores ausentes são
	  ignorados durante a verificação da constância da série.
	</para>
      </description>
    </function>

    <function name="isdiscrete" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">name</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>name</argname> for um identificador para uma série
	  correntemente definida, a função retorna 1 se a série for marcada
	  como sendo discreta, caso contrário retorna 0. Se <argname>name</argname>
	  não identifica uma série a função retorna <lit>NA</lit>.
	</para>
      </description>
    </function>

    <function name="isdummy" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Se todos os valores contidos em <argname>x</argname> são iguais a 0 ou 1 (ou ausentes),
	  a função retorna o número de ocorrências do valor 1, caso contrário retorna 0.
	</para>
      </description>
    </function>

    <function name="isnan" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-matrix">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Dado um escalar como argumento, retorna 1 se <argname>x</argname> não
	  for um número, <quote>Not a Number</quote> (NaN), caso contrário 0.
	  Dada uma matriz como argumento, retorna uma matriz com a mesma dimensão
	  com elementos iguais a 1 nas posições onde o elemento correspondente da
	  matriz de entrada for NaN e 0 nas demais posições.
	</para>
      </description>
    </function>

    <function name="isnull" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">name</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna 0 se <argname>name</argname> for o identificador de um objeto
	  correntemente definido, seja um escalar, uma série, uma matriz, uma lista,
	  uma variável de texto ou um pacote (<quote>bundle</quote>). Caso contrário 1.
	</para>
	<para>
	  Esta função é considerada obsoleta e recomenda-se substituí-la pela
	  (negação de) <fncref targ="exists"/>.
	</para>
      </description>
    </function>

    <function name="isoconv" section="calendar" output="scalar">
      <fnargs>
	<fnarg type="series">date</fnarg>
	<fnarg type="seriesref">&amp;year</fnarg>
	<fnarg type="seriesref">&amp;month</fnarg>
	<fnarg type="seriesref" optional="true">&amp;day</fnarg>
      </fnargs>
      <description>
	<para>
	  Dada uma série <argname>date</argname> contendo datas no formato ISO 8601
	  <quote>básico</quote> (<lit>YYYYMMDD</lit>), essa função escreve os
	  componentes ano, mês e (opcionalmente) dia em séries nomeadas pelos
	  argumentos <argname>year</argname>, <argname>month</argname> e
	  <argname>dayecond</argname>. Um exemplo, assumindo que a série
    <lit>dates</lit> contém os valores adequados de 8 dígitos, seria:
	</para>
	<code>
	  series y, m, d
	  isoconv(dates, &amp;y, &amp;m, &amp;d)
	</code>
	<para>
	  Essa função retorna 0 em caso de sucesso
	  e um valor não-nulo em caso de erro.
	</para>
      </description>
    </function>

    <function name="isodate" section="calendar" output="seebelow">
      <fnargs>
	<fnarg type="scalar-or-series">ed</fnarg>
	<fnarg type="bool" optional="true">as-string</fnarg>
      </fnargs>
      <description>
	<para>
	  O argumento <argname>ed</argname> é interpretado como um dia na
	  época corrente (que por sua vez é igual a 1 para o primeiro dia
	  de janeiro do ano 1 depois de Cristo, no calendário gregoriano
	  proléptico). O valor padrão de retorno &mdash; de mesmo tipo que
	  o de <argname>ed</argname> &mdash; é um número com 8 dígitos, ou
	  uma série composta por tais números, seguindo o padrão <lit>
	  YYYYMMDD</lit> (formato ISO 8601 <quote>básico</quote>), fornecendo
	  a data correspondente no calendário gregoriano ao dia na época.
	</para>
	<para>
	  Se <argname>ed</argname> for (apenas) um escalar e o segundo argumento
	  opcional <argname>as-string</argname> for não-nulo, o valor de retorno
	  não é numérico mas sim uma variável de texto (<quote>string</quote>)
	  no padrão <lit>YYYY-MM-DD</lit> (padrão ISO 8601
	  <quote>estendido</quote>).
	</para>
	<para>
	  Para a função inversa veja <fncref targ="epochday"/>. Veja
	  também a função <fncref targ="juldate"/>.
	</para>
      </description>
    </function>

    <function name="iwishart" section="stats" output="matrix">
      <fnargs>
	<fnarg type="symmat">S</fnarg>
	<fnarg type="int">v</fnarg>
      </fnargs>
      <description>
	<para>
	  Dado <argname>S</argname> (uma matriz de ordem <by r="p" c="p"/>
	  positiva definida), retorna um valor extraído da distribuição
	  Inversa de Wishart com <argname>v</argname> graus de liberdade.
	  A matriz retornada é também uma <by r="p" c="p"/>. O algoritmo
	  de <cite key="odell-feiveson66">Odell e Feiveson (1966)</cite>
	  é utilizado.
	</para>
      </description>
    </function>

    <function name="jsonget" section="data-utils" output="string">
      <fnargs>
	<fnarg type="string">buf</fnarg>
	<fnarg type="string">path</fnarg>
      </fnargs>
      <description>
	<para>
	  The argument <argname>buf</argname> should be a JSON
	  buffer, as may be retrieved from a suitable website via the
	  <fncref targ="curl"/> function, and the
	  <argname>path</argname> argument should be a JsonPath
	  specification.
	</para>
	<para>
	  This function returns a variável de texto (<quote>string</quote>) representando the data found
	  in the buffer at the specified path. Data types of double
	  (floating-point), int (integer) and variável de texto are supported. In
	  the case of doubles or ints, their variável de texto representation is
	  returned (using the <quote>C</quote> locale for doubles).
	  If the object to which <argname>path</argname> refers is an
	  arranjo (<quote>array</quote>), the members are printed one per line in the returned
	  variável de texto.
	</para>
	<para>
	  An accurate account of JsonPath syntax can be found at
	  <url>http://goessner.net/articles/JsonPath/</url>. However,
	  please note that the back-end for <lit>jsonget</lit> is
	  provided by <lit>json-glib</lit>, which does not necessarily
	  support all elements of JsonPath. Moreover, the exact
	  functionality of <lit>json-glib</lit> may differ depending
	  on the version you have on your system. See
	  <url>http://developer.gnome.org/json-glib/</url> if you
	  need details.
	</para>
	<para>
	  Dito isto, os seguintes operadores deverão estar disponíveis
	  para <lit>jsonget</lit>:
	</para>
	  <ilist>
	    <li>
              <para>
		root node, via caracter <lit>$</lit>
              </para>
	    </li>
	    <li>
              <para>
		operador descendente recursivo: <lit>..</lit>
              </para>
	    </li>
	    <li>
              <para>
		operador wildcard: <lit>*</lit>
              </para>
	    </li>
	    <li>
              <para>
		subscript operator: <lit>[]</lit>
              </para>
	    </li>
	    <li>
              <para>
		set notation operator, por exemplo <lit>[i,j]</lit>
              </para>
	    </li>
	    <li>
              <para>
		slice operator: <lit>[start:end:step]</lit>
              </para>
	    </li>
	  </ilist>
      </description>
    </function>

    <function name="juldate" section="calendar" output="seebelow">
      <fnargs>
	<fnarg type="scalar-or-series">ed</fnarg>
	<fnarg type="bool" optional="true">as-string</fnarg>
      </fnargs>
      <description>
	<para>
	  The argument <argname>ed</argname> is interpreted as an
	  epoch day, which equals 1 for the first of January in the
	  year AD 1 on the proleptic Gregorian calendar. The default
	  return value &mdash; of the same type as
	  <argname>ed</argname> &mdash; is an 8-digit number, or a
	  series of such numbers, on the pattern <lit>YYYYMMDD</lit>
	  (ISO 8601 <quote>basic</quote> format), giving the Julian
	  calendar date corresponding to the epoch day.
	</para>
	<para>
	  If <argname>ed</argname> is a scalar (only) and the optional
	  second argument <argname>as-string</argname> is non-zero,
	  the return value is not numeric but rather a string on the
	  pattern <lit>YYYY-MM-DD</lit> (ISO 8601
	  <quote>extended</quote> format).
	</para>
	<para>
	  See also <fncref targ="isodate"/>.
	</para>
      </description>
    </function>

    <function name="kdensity" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg type="scalar" optional="true">scale</fnarg>
	<fnarg type="bool" optional="true">control</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes a kernel density estimate para a series or vector
	  <argname>x</argname>. The returned matrix has two columns, the
	  first holding a set of evenly spaced abscissae and the second
	  the estimated density at each of these points.
	</para>
	<para>
	  The optional <argname>scale</argname> parameter can be used to
	  adjust the degree of smoothing relative to the default of 1.0
	  (higher values produce a smoother result). The
	  <argname>control</argname> parameter acts as a boolean: 0 (the
	  default) means that the Gaussian kernel is used; a non-zero
	  value switches to the Epanechnikov kernel.
	</para>
	<para>
	  A plot of the results may be obtained using the <cmdref
	  targ="gnuplot"/> command, as in
	</para>
	<code>
	  matrix d = kdensity(x)
	  gnuplot 2 1 --matrix=d --with-lines --suppress-fitted
	</code>
      </description>
    </function>

    <function name="kdsmooth" section="sspace" output="scalar">
      <fnargs>
	<fnarg type="bundleref">&amp;Mod</fnarg>
	<fnarg type="bool" optional="true">MSE</fnarg>
      </fnargs>
      <description>
	<para>
	  Performs disturbance smoothing for a Kalman bundle
	  previously set up by means of <fncref targ="ksetup"/>
	  and returns 0 on successful completion or 1 if numerical
	  problems are encountered.
	</para>
	<para>
	  On successful completion, the smoothed disturbances will be
	  available as <lit>Mod.smdist</lit>.
	</para>
	<para>
	  The optional <argname>MSE</argname> argument determines the
	  contents of the <lit>Mod.smdisterr</lit> key. If 0 or
	  omitted, this matrix will contain the unconditional standard
	  errors of the smoothed disturbances, which are normally used
	  to compute the so-called <emphasis>auxiliary
	  residuals</emphasis>. Otherwise, <lit>Mod.smdisterr</lit>
	  will contain the estimated root mean square deviations of
	  the auxiliary residuals from their true value.
	</para>
	<para>
	  Para maiores detalhes veja <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="ksetup"/>
            <fncref targ="kfilter"/>
            <fncref targ="ksmooth"/>
            <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="kfilter" section="sspace" output="scalar">
      <fnargs>
	<fnarg type="bundleref">&amp;Mod</fnarg>
      </fnargs>
      <description>
	<para>
	  Performs a forward, filtering pass on a Kalman bundle
	  previously set up by means of <fncref targ="ksetup"/>
	  and returns 0 on successful completion or 1 if numerical
	  problems are encountered.
	</para>
	<para>
	  Se a operação for completada com sucesso os erros de
	  previsão de 1 passo à frente estarão disponíveis como
	  <lit>Mod.prederr</lit> e a sequência de suas variâncias
	  como <lit>Mod.pevar</lit>. Além disso, <lit>Mod.llt</lit>
	  dará acesso a um <math>T</math>-vector contendo o log
	  da verossimilhança por observação.
	</para>
	<para>
	  Para maiores detalhes veja <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="kdsmooth"/>
            <fncref targ="ksetup"/>
            <fncref targ="ksmooth"/>
            <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="kmeier" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">d</fnarg>
	<fnarg type="series-or-vec" optional="true">cens</fnarg>
      </fnargs>
      <description>
	<para>
	  Given a sample of duration data, <argname>d</argname>,
	  possibly accompanied by a record of censoring status,
	  <argname>cens</argname>, computes the Kaplan&ndash;Meier
	  nonparametric estimator of the survival function (<cite
	  key="kaplan-meier">Kaplan and Meier, 1958</cite>). The
	  returned matrix has three columns holding, respectively, the
	  sorted unique values in <argname>d</argname>, the estimated
	  survival function corresponding to the duration value in
	  column 1 and the (large sample) standard error of the
	  estimator, calculated via the method of <cite
	  key="greenwood26">Greenwood (1926)</cite>.
	</para>
	<para>
	  If the <argname>cens</argname> series is given, the value 0
	  is taken to indicate an uncensored observation while a value
	  of 1 indicates a right-censored observation (that is, the
	  period of observation of the individual in question has
	  ended before the duration or spell has been recorded as
	  terminated). If <argname>cens</argname> is not given, it is
	  assumed that all observations are uncensored. (Note: the
	  semantics of <argname>cens</argname> may be extended at some
	  point to cover other types of censoring.)
	</para>
	<para>
	  <seelist>
            <fncref targ="naalen"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="kpsscrit" section="stats" output="matrix">
      <fnargs>
	<fnarg type="scalar">T</fnarg>
	<fnarg type="bool">trend</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna um vetor linha contendo os valores críticos aos níveis de 10,
	  5 e 1 porcento do teste KPSS para a estacionariedade de uma série
	  temporal. O argumento <argname>T</argname> deve fornecer o número de
	  observações e o argumento <argname>trend</argname> deve ser igual a 1
	  se o teste inclui uma constante, ou 0, caso contrário.
	</para>
	<para>
	  Os valores críticos são baseados nas superfícies de resposta estimados
	  conforme sugerido por
	  <cite key="sephton95">Sephton (Economics Letters,1995)</cite>.
	  Veja também o comando <cmdref targ="kpss"/>.
 	</para>
      </description>
    </function>

    <function name="ksetup" section="sspace" output="bundle">
      <fnargs>
	<fnarg type="smlist">Y</fnarg>
	<fnarg type="scalar-or-matrix">H</fnarg>
	<fnarg type="scalar-or-matrix">F</fnarg>
	<fnarg type="scalar-or-matrix">Q</fnarg>
	<fnarg optional="true" type="matrix">C</fnarg>
      </fnargs>
      <description>
	<para>
	  Sets up a Kalman bundle, that is an object which contains
	  all the information needed to define a linear state space
	  model of the form
	  <equation status="display"
		    tex="\[y_t=H'\alpha_t\]"
		    ascii="y(t) = H'a(t)"
		    graphic="kalman1"/>
	  and state transition equation
	  <equation status="display"
		    tex="\[\alpha_{t+1}=F \alpha_t + u_t\]"
		    ascii="a(t+1) = F a(t) + u(t)"
		    graphic="kalman2"/>
	  onde Var<math>(u) = Q</math>.
	</para>
	<para>
	  Objects created via this function can be later used via the
	  dedicated functions <fncref targ="kfilter"/> for filtering,
	  <fncref targ="ksmooth"/> and <fncref targ="kdsmooth"/> for
	  smoothing and <fncref targ="ksimul"/> for performing
	  simulations.
	</para>
	<para>
	  The class of models that gretl can handle is in fact much
	  wider than the one implied by the representation above: it
	  is possible to have time-varying models, models with diffuse
	  priors and exogenous variável in the measurement equation
	  and models with cross-correlated innovations. For further
	  details, see <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="kdsmooth"/>
            <fncref targ="kfilter"/>
            <fncref targ="ksmooth"/>
            <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ksimul" section="sspace" output="scalar">
      <fnargs>
	<fnarg type="bundleref">&amp;Mod</fnarg>
      </fnargs>
      <description>
	<para>
	  Utiliza um pacote (<quote>bundle</quote>) de Kalman previamente
	  definido através da função <fncref targ="ksetup"/> para simular dados.
	</para>
	<para>
	  Para detahes veja <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="ksetup"/>
            <fncref targ="kfilter"/>
            <fncref targ="ksmooth"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ksmooth" section="sspace" output="matrix">
      <fnargs>
	<fnarg type="bundleref">&amp;Mod</fnarg>
      </fnargs>
      <description>
	<para>
	  Performs a fixed-point smoothing (backward) pass on a
	  Kalman bundle previously set up by means of <fncref
	  targ="ksetup"/> and returns 0 on successful completion or 1
	  if numerical problems are encountered.
	</para>
	<para>
	  On successful completion, the smoothed states will be
	  available as <lit>Mod.state</lit> and the sequence of their
	  covariance matrizes as <lit>Mod.stvar</lit>. Para maiores detalhes
	  veja <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="ksetup"/>
            <fncref targ="kdsmooth"/>
            <fncref targ="kfilter"/>
            <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="kurtosis" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o excesso de curtose da série <argname>x</argname>,
	  descartando quaisquer observações ausentes.
	</para>
      </description>
    </function>

    <function name="lags" section="transforms" output="list-or-mat">
      <fnargs>
	<fnarg type="scalar-or-vec">p</fnarg>
	<fnarg type="series-list-or-mat">y</fnarg>
	<fnarg type="bool" optional="true">bylag</fnarg>
      </fnargs>
      <description>
	<para>
	  Se o primeiro argumento for um escalar, gera as defasagens
	  de 1 até <argname>p</argname> da série <argname>y</argname>,
	  se <argname>y</argname> for uma lista, retorna as defasagens
	  de todas as séries na lista e se for uma matriz, retorna as
	  defasagens de todas as colunas na matriz. Se <argname>
	  p</argname> = 0 e <argname>y</argname> for uma série ou lista,
	  são geradas defasagens até o máximo da periodicidade dos dados.
	  Caso contrário, o valor de <argname>p</argname> deve ser positivo.
	</para>
	<para>
	  Se o primeiro argumento for um vetor, as defasagens serão
	  aquelas especificadas no vetor. Um uso típico neste caso
	  seria fornecer <argname>p</argname> como, por exemplo,
	  <lit>seq(3,7)</lit>, omitindo assim a primeira e a segunda
	  defasagens. Entretanto  ambém é possível fornecer um vetor
	  não contínuo como em <lit>{3,5,7}</lit>, contanto que as
	  defasagens estejam sempre ordenadas de forma crescente.
	</para>
	<para>
	  Quando o valor retornado for uma lista, as variáveis geradas
	  são nomeadas automaticamente de acordo com o esquema
	  <repl>varname</repl><lit>_</lit><repl>i</repl>, onde
	  <repl>varname</repl> é o nome da série original e <repl>i</repl>
	  é a defasagem específica. A parte original do nome é truncada,
	  caso necessário, e pode ser ajustada no caso de não-singularidade
	  no conjunto de nomes assim construído.
	</para>
	<para>
	  Quando <argname>y</argname> for uma lista, ou uma matriz com mais de uma
	  coluna, e a ordem de defasagem for maior que 1, a ordenação padrão dos
	  termos no valor retornado pelafunção é feita por variável: todas as
	  defasagens da primeira série ou coluna seguida por todas as defasagens da
	  segunda e assim sucessivamente. O terceiro argumento (opcional)
	  pode ser utilizado para alterar esse comportamento: se
	  <argname>bylag</argname> for não-nulo então os termos são ordenados por
	  defasagem: defasagem 1 de todas as séries ou colunas, seguida pela
	  defasagem 2 de todas as séries e colunas e assim sucessivamente.
	</para>
	<para>
	  Veja também <fncref targ="mlag"/> para o uso com matrizes.
	</para>
      </description>
    </function>

    <function name="lastobs" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o número da última observação não ausente da série
	  <argname>y</argname>. Note que se alguma forma de subamostragem
	  estiver sendo utilizada o valor retornado poderá ser maior que o
	  valor retornado pela função <fncref targ="$t2"/>.
	  <seelist>
            <fncref targ="firstobs"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ldet" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o log natural do determinante de <math>A</math>,
	  calculado via decomposição LU.
	  <seelist>
            <fncref targ="det"/>
            <fncref targ="rcond"/>
            <fncref targ="cnumber"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ldiff" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-or-list">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula as diferenças logarítmicas. Os valores iniciais
	  são considerados como <lit>NA</lit>.
	</para>
	<para>
	  Quando uma lista for retornada, as variáveis individuais
	  são automaticamente nomeadas de acordo com o esquema
	  <lit>ld_</lit><repl>varname</repl>, onde <repl>varname</repl>
	  é o nome da série original. Se necessário, o nome será
	  truncado e poderá ser ajustado caso o nome resultante já
	  esteja sendo utilizado pelo Gretl.
	</para>
	<para>
	  <seelist>
            <fncref targ="diff"/>
            <fncref targ="sdiff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="lincomb" section="transforms" output="series">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg type="vector">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula uma nova série como uma combinação linear das séries
	  na lista <argname>L</argname>. Os coeficientes são dados pelo
	  vetor <argname>b</argname> cujo tamanho deve ser igual ao
	  número de séries em series in <argname>L</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="wmean"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="linearize" section="filters" output="series">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  É necessário possuir o TRAMO instalado. Retorna uma versão
	  <quote>linearizada</quote> da série de entrada. Isto é, uma
	  série onde quaisquer valores ausentes são substituídos por
	  valores interpolados e onde as observações aberrantes são
	  ajustadas. O mecanismo completamente automático do TRAMO é
	  usado para isso. Consulte a documentação do TRAMO para detalhes.
	</para>
	<para>
	  Note que se a série de entrada não possuir valores ausentes e
	  e observações aberrantes (conforme idetificadas pelo TRAMO), a
	  função retornará uma cópia da série original.
	</para>
      </description>
    </function>

    <function name="ljungbox" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int">p</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula a estatística Q de Ljung&ndash;Box para a série
	  <argname>y</argname>, utilizando a ordem de defasagem
	  <argname>p</argname>, ao longo da amostra selecionada.
	  A defasagem deve ser maior ou igual a 1 e menor que o
	  número de observações disponíveis.
	</para>
	<para>
	  Essa estatística pode ser testada contra a distribuição
	  qui-quadrado com <argname>p</argname> graus de liberdade
	  para verificar a hipótese nula de que a série <argname>
	  y</argname> não é serialmente correlacionada.
	  <seelist>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="lngamma" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o log da função gama de <argname>x</argname>.
	</para>
      </description>
    </function>

    <function name="loess" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series">x</fnarg>
	<fnarg optional="true" type="int">d</fnarg>
	<fnarg optional="true" type="scalar">q</fnarg>
	<fnarg optional="true" type="bool">robust</fnarg>
      </fnargs>
      <description>
	<para>
	  Performs locally-weighted polynomial regression and returns
	  a series holding predicted values of <argname>y</argname>
	  for each non-missing value of <argname>x</argname>.  The
	  method is as described by <cite key="cleveland79">William
	  Cleveland (1979)</cite>.
	</para>
	<para>
	  The optional arguments <argname>d</argname> and
	  <argname>q</argname> specify the order of the polynomial in
	  <argname>x</argname> and the proportion of the data points
	  to be used in local estimation, respectively.  The default
	  values are <argname>d</argname> = 1 and <argname>q</argname>
	  = 0.5. The other acceptable values for <argname>d</argname>
	  are 0 and 2. Setting <argname>d</argname> = 0 reduces the
	  local regression to a form of moving average. The value
	  of <argname>q</argname> must be greater than 0 and cannot
	  exceed 1; larger values produce a smoother outcome.
	</para>
	<para>
	  If a non-zero value is given for the <argname>robust</argname>
	  argument the local regressions are iterated twice, with the
	  weights being modified based on the residuals from the previous
	  iteration so as to give less influence to outliers.
	</para>
	<para>
	  Veja também <fncref targ="nadarwat"/>. Adicionalmente,
	  para detalhes acerca de métodos não-paramétricos veja
	  <guideref targ="chap:nonparam"/>..
	</para>
      </description>
    </function>

    <function name="log" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o logaritmo natural de <argname>x</argname>. Gera
	  <lit>NA</lit> para valores não-positivos. Note que <lit>ln</lit>
	  é um pseudônimo aceitável para <lit>log</lit>.
	</para>
	<para>
	  Quando uma lista for retornada, as variáveis individuais
	  serão automaticamente nomeadas de acordo com o modelo
	  <lit>l_</lit><repl>varname</repl>, onde <repl>varname</repl>
	  é o nome da série original. O nome será truncado se
	  necessário e pode ser ajustado no caso de já estar sendo
	  usado pelo Gretl.
	</para>
      </description>
    </function>

    <function name="log10" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o logaritmo na base 10 de <argname>x</argname>. A função irá
	  gerar <lit>NA</lit> para valores não-positivos.
	</para>
      </description>
    </function>

    <function name="log2" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o logaritmo na base 2 de <argname>x</argname>. A função irá
	  gerar <lit>NA</lit> para valores não-positivos.
	</para>
      </description>
    </function>

    <function name="logistic" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para context="tex">
	  Retorna a função logística do argumento <argname>x</argname>,
	  isto é, $\Lambda(x) = e^x/(1+e^x)$. Se <argname>x</argname> for
	  uma matriz, a função será aplicada em cada elemento.
	</para>
	<para context="notex">
	  Retorna a função logística do argumento
	  <argname>x</argname>, isto é, <math>e</math><sup>x</sup>/(1
	  + <math>e</math><sup>x</sup>).  Se <argname>x</argname> for
	  ma matriz, a função será aplicada em cada elemento.
	</para>
      </description>
    </function>

    <function name="lower" section="matbuild" output="smatrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Retorna uma matriz triangular inferior de ordem <by r="n" c="n"/>.
	  Os elementos da diagonal e abaixo desta são iguais aos elementos
	  correspondentes de <argname>A</argname> e os demais iguais a zero.
	</para>
	<para context="tex">
	  Retorna uma matriz triangular inferior <math>B</math> onde
	  $B_{ij} = A_{ij}$ se $i \ge j$, e 0 caso contrário.
	</para>
	<para>
	  <seelist>
            <fncref targ="upper"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="lrvar" section="filters" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="int">k</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a variância de longo prazo de <argname>y</argname>,
	  calculada utilizando um núcleo de Bartlett com tamanho de
	  janela igual a <argname>k</argname>. O tamanho padrão da
	  janela (isto é, a parte inteira da raiz cúbica do tamanho
	  da amostra) pode ser selecionado dando valor negativo para
	  <argname>k</argname>.
	</para>
	<para context="tex">
	  Fórmula:
	  \[ \hat{\omega}^2(k) = \frac{1}{T} \sum_{t=k}^{T-k}
	  \left[ \sum_{i=-k}^k w_i (y_t - \bar{X}) (y_{t-i} - \bar{Y})
	  \right] \]
	  com
	  \[ w_i = 1 - \frac{|i|}{k + 1} \]
	</para>
      </description>
    </function>

    <function name="max" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Se o argumento <argname>y</argname> for uma série, retorna,
	  na forma de um escalar, o valor máximo das observações não
	  ausentes na série. Se o argumento for uma lista, retorna uma
	  série onde cada elemento é o valor máximo em cada observação
	  entre as séries listadas.
	</para>
	<para>
	  <seelist>
            <fncref targ="min"/>
            <fncref targ="xmax"/>
            <fncref targ="xmin"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="maxc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna um vetor com os valores máximos das colunas de
	  <argname>X</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="imaxc"/>
            <fncref targ="maxr"/>
            <fncref targ="minc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="maxr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna um vetor com os valores máximos das linhas
	  <argname>X</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="imaxr"/>
            <fncref targ="maxc"/>
            <fncref targ="minr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mcorr" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula a matriz de correlações tratando cada coluna de
	  <argname>X</argname> como sendo uma a variável.
	  <seelist>
            <fncref targ="corr"/>
            <fncref targ="cov"/>
            <fncref targ="mcov"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mcov" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula a matriz de covariâncias tratando cada coluna de
	  <argname>X</argname> como sendo uma variável.
	  <seelist>
            <fncref targ="corr"/>
            <fncref targ="cov"/>
            <fncref targ="mcorr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mcovg" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="vector">u</fnarg>
	<fnarg optional="true" type="vector">w</fnarg>
	<fnarg type="int">p</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma matriz covariograma para uma matriz <argname>
	  X</argname> de ordem <by r="T" c="k"/> (normalmente contendo
	  regressores), um vetor <argname>u</argname> (opcional) com
	  <math>T</math> elementos (normalmente contendo resíduos),
	  um vetor de pesos <argname>w</argname> (optional) com <math>
	  p</math>+1 elementos e uma ordem de defasagem <argname>
	  p</argname>, que deve ser maior ou igual a 0.
	</para>
	<para context="tex">
	  A matriz retornada é dada por
	  \[\sum_{j=-p}^{p} \sum_j w_{|j|} (X_t' u_t
	  u_{t-j} X_{t-j})\]
	</para>
	<para context="notex">
	  A matriz retornada é dada por
	</para>
	<para context="notex">
	  sum_{j=-p}^p sum_j w_{|j|} (X_t' u_t u_{t-j} X_{t-j})
	</para>
	<para>
	  Se <argname>u</argname> for dado como <lit>null</lit> os termos
	  <math>u</math> são omitidos e se
	  <argname>w</argname> for dado como <lit>null</lit> todos o pesos
	  são considerados iguais a 1.
	</para>
      </description>
    </function>

    <function name="mean" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>x</argname> for uma série a função retorna a média
	  amostral (na forma de um escalar), descartando quaisquer observações
	  ausentes.
	</para>
	<para>
	  Se <argname>x</argname> for uma lista a função retorna uma série
	  <math>y</math> tal que <math>y</math><sub>t</sub> é a média dos
	  valores das variáveis da lista na observação <math>t</math>, ou
	  <lit>NA</lit> se existir algum valor ausente em <math>t</math>.
	</para>
      </description>
    </function>

    <function name="meanc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna um vetor com as médias das colunas de <argname>X</argname>.
	  <seelist>
            <fncref targ="meanr"/>
            <fncref targ="sumc"/>
            <fncref targ="sdc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="meanr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna um vetor com as médias das linhas de <argname>X</argname>.
	  <seelist>
            <fncref targ="meanc"/>
            <fncref targ="sumr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="median" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>x</argname> for uma série, a função retorna sua mediana amostral
	  (na forma de um escalar), ignorando quaisquer observações ausentes.
	</para>
	<para>
	  Se <argname>x</argname> for uma lista, a função retorna uma
	  séries <math>y</math> tal que <math>y</math><sub>t</sub> é a
	  mediana dos valores das variáveis da lista na observação
	  <math>t</math>, ou <lit>NA</lit> se existir algum valor ausente
	  em <math>t</math>.
	</para>
      </description>
    </function>

    <function name="mexp" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Calcula a matriz exponencial de <argname>A</argname>
	  utilizando o algoritmo 11.3.1 de <cite key="golub96">Golub e
	  Van Loan (1996)</cite>.
	</para>
	<para context="tex">
	  Calcula a matriz exponencial,
	  \[ e^A = \sum_{k=0}^{\infty} \frac{A^k}{k!}
	  = \frac{I}{0!} + \frac{A}{1!} + \frac{A^2}{2!} + \frac{A^3}{3!}
	  + \cdots\]
	  (Essa série irá necessariamente convergir.) O algoritmo utilizado
	  é o 11.3.1 de <cite key="golub96">Golub e Van Loan
	  (1996)</cite>.
	</para>
      </description>
    </function>

    <function name="mgradient" section="midas" output="matrix">
      <fnargs>
	<fnarg type="int">p</fnarg>
	<fnarg type="vector">theta</fnarg>
	<fnarg type="int">type</fnarg>
      </fnargs>
      <description>
	<para>
	  Analytical derivatives for MIDAS weights.  Let
	  <math>k</math> denote the number of elements in the vector
	  of hyper-parameters, <repl>theta</repl>.  This function
	  returns a <by r="p" c="k"/> matrix holding the gradient of
	  the vector of weights (as calculated by <fncref
	  targ="mweights"/>) with respect to the elements of
	  <repl>theta</repl>. The first argument represents the
	  desired lag order and the last argument specifies the type
	  of parameterization.  See <lit>mweights</lit> for an account
	  of the acceptable <repl>type</repl> values.
	</para>
	<para>
	  <seelist>
            <fncref targ="mweights"/>
	    <fncref targ="mlincomb"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="min" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Se o argumento <argname>y</argname> for uma série, retorna,
	  na forma de um escalar, o valor mínimo das observações não
	  ausentes na série. Se o argumento for uma lista, retorna uma
	  série onde cada elemento é o valor mínimo em cada observação
	  entre as séries listadas.
	</para>
	<para>
	  <seelist>
            <fncref targ="max"/>
            <fncref targ="xmax"/>
            <fncref targ="xmin"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="minc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna um vetor com os valores mínimos das colunas de <argname>X</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="iminc"/>
            <fncref targ="maxc"/>
            <fncref targ="minr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="minr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna um vetor com os valores mínimos das linhas de <argname>X</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="iminr"/>
            <fncref targ="maxr"/>
            <fncref targ="minc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="missing" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="sslist">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma variável binária igual a 1 se <argname>x</argname> for
	  <lit>NA</lit> e 0, caso contrário. Se <argname>x</argname> for uma
	  série, a comparação é feita em cada um de seus elementos. Se
	  <argname>x</argname> for uma lista de séries, a função retorna uma
	  série igual a 1 nas observações nas quais ao menos uma das séries
	  apresente um <lit>NA</lit> e 0, caso contrário.
	</para>
	<para>
	  <seelist>
            <fncref targ="misszero"/>
            <fncref targ="ok"/>
            <fncref targ="zeromiss"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="misszero" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Converte <lit>NA</lit>s em zeros. Se <argname>x</argname> for uma
	  série a conversão será feita elemento por elemento.
	  <seelist>
            <fncref targ="missing"/>
            <fncref targ="ok"/>
            <fncref targ="zeromiss"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mlag" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="scalar-or-vec">p</fnarg>
	<fnarg type="scalar" optional="true">m</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Shifts up or down the rows of <argname>X</argname>.  If
	  <argname>p</argname> is a positive scalar, retorna uma matrix
	  in which the columns of <argname>X</argname> are shifted
	  down by <argname>p</argname> rows and the first
	  <argname>p</argname> rows are filled with the value
	  <argname>m</argname>. If <argname>p</argname> is a negative
	  number, <argname>X</argname> is shifted up and the last rows
	  are filled with the value <argname>m</argname>. If
	  <argname>m</argname> is omitted, it is understood to be
	  zero.
	</para>
	<para context="tex">
	  Shifts up or down the rows of <argname>X</argname>. If $p$
	  is a positive scalar, the returned matrix $Y$ has typical
	  element $Y_{i,j} = X_{i-p,j}$ for $i \ge p$ and zero
	  otherwise. In other words, the columns of
	  <argname>X</argname> are shifted down by
	  <argname>p</argname> rows and the first <argname>p</argname>
	  rows are filled with the value <argname>m</argname>. If
	  <argname>p</argname> is a negative number,
	  <argname>X</argname> is shifted up and the last rows are
	  filled with the value <argname>m</argname>. If
	  <argname>m</argname> is omitted, it is understood to be
	  zero.
	</para>
	<para context="notex">
	  If <argname>p</argname> is a vector, the above operation is
	  carried out for each element in <argname>p</argname>,
	  joining the resulting matrizes horizontally.
	</para>
	<para context="tex">
	  If $p$ is a vector, the above operation is carried out for
	  each element in $p$, joining the resulting matrices
	  horizontally.
	</para>
	<para>
	  See also <fncref targ="lags"/>.
	</para>
      </description>
    </function>

    <function name="mlincomb" section="midas" output="series">
      <fnargs>
	<fnarg type="list">hfvars</fnarg>
	<fnarg type="vector">theta</fnarg>
	<fnarg type="int">type</fnarg>
      </fnargs>
      <description>
	<para>
	  A convenience MIDAS function which combines <fncref
	  targ="lincomb"/> with <fncref targ="mweights"/>.  Given a
	  list <repl>hfvars</repl>, it constructs a series which is a
	  weighted sum of the elements of the list, the weights based
	  on the vector of hyper-parameters <repl>theta</repl> and the
	  type of parameterization: see <lit>mweights</lit> for
	  details. Note that <fncref targ="hflags"/> is generally
	  the best way to create a list suitable as the first argument
	  to this function.
	</para>
	<para>
	  To be explicit, the call
	</para>
	<code>
	  series s = mlincomb(hfvars, theta, 2)
	</code>
	<para>
	  is equivalent to
	</para>
	<code>
	  matrix w = mweights(nelem(hfvars), theta, 2)
	  series s = lincomb(hfvars, w)
	</code>
	<para>
	  but use of <lit>mlincomb</lit> saves on some typing and
	  also some CPU cycles.
	</para>
      </description>
    </function>

    <function name="mnormal" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma matriz com <argname>r</argname> linhas e
	  <argname>c</argname> colunas, preenchida com variáveis
	  pseudo aleatórias com distribuição normal padrão.
	  <seelist>
            <fncref targ="normal"/>
            <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mols" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;V</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a <by r="k" c="n"/> matrix of parameter estimates obtained
	  by MQO regression of the <by r="T" c="n"/> matrix
	  <argname>Y</argname> on the <by r="T" c="k"/> matrix
	  <argname>X</argname>.
	</para>
	<para>
	  If the third argument is not <lit>null</lit>, the <by r="T"
	  c="n"/> matrix <argname>U</argname> will contain the
	  residuals. If the final argument is given and is not
	  <lit>null</lit> then the <by r="k" c="k"/> matrix
	  <argname>V</argname> will contain (a) the matriz de covariâncias
	  of the parameter estimates, if <argname>Y</argname> has just
	  one column, or (b) <math>X'X</math><sup>-1</sup> if
	  <argname>Y</argname> has multiple columns.
	</para>
	<para>
	  By default, estimates are obtained via decomposição de Cholesky, with
	  a fallback to QR decomposition if the columns of
	  <argname>X</argname> are highly collinear.  The use of SVD
	  can be forced via the command <lit>set svd on</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="mpols"/>
            <fncref targ="mrls"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="monthlen" section="calendar" output="int">
      <fnargs>
	<fnarg type="int">mês</fnarg>
	<fnarg type="int">ano</fnarg>
	<fnarg type="int">dias na semana</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o número de dias (relevantes) no mês e ano especificados
	  (no calendário gregoriano proléptico). O argumento <argname>dias
	  na semana</argname>, que pode ser igual a 5, 6 ou 7, indica o
	  número de dias da semana que devem ser considerados (se for
	  escolhido 6 os domingos são omitidos e se for escolhido 5 os
	  sábados e os domingos serão omitidos).
	</para>
      </description>
    </function>

    <function name="movavg" section="filters" output="series">
      <fnargs>
	<fnarg type="series">x</fnarg>
	<fnarg type="scalar">p</fnarg>
	<fnarg type="int" optional="true">control</fnarg>
	<fnarg type="scalar" optional="true">y0</fnarg>
      </fnargs>
      <description>
	<para>
	  Depending on the value of the parameter <argname>p</argname>,
	  returns either a simple or an exponentially weighted
	  moving average of the input series <argname>x</argname>.
	</para>
	<para context="notex">
	  If <argname>p</argname> &gt; 1, a simple
	  <argname>p</argname>-term moving average is computed, that
	  is, the arithmetic mean of <math>x</math> from period
	  <math>t</math> to <math>t-p+1</math>. If a non-zero value is
	  supplied para o optional <argname>control</argname>
	  parameter the MA is centered, otherwise it is
	  <quote>trailing</quote>. The optional <argname>y0</argname>
	  argument is ignored.
	</para>
	<para context="tex">
	  If $p&gt;1$, a simple <argname>p</argname>-term moving
	  average is computed, that is, $\frac{1}{p} \sum_{i=0}^{p-1}
	  x_{t-i}$. If a non-zero value is supplied para o optional
	  <argname>control</argname> parameter the MA is centered,
	  otherwise it is <quote>trailing</quote>. The optional
	  <argname>y0</argname> argument is ignored.
	</para>
	<para context="notex">
	  If <argname>p</argname> is a positive fraction, an
	  exponential moving average is computed:
	</para>
	<para context="notex">
	  <math>y(t) = p*x(t) + (1-p)*y(t-1)</math>
	</para>
	<para context="notex">
	  By default the output series, <math>y</math>, is initialized
	  using the first value of <argname>x</argname>, but the
	  <argname>control</argname> parameter may be used to specify
	  the number of initial observações that should be averaged
	  to produce <math>y(0)</math>. A zero value for
	  <argname>control</argname> indicates that all the
	  observações should be used. Alternatively, an initializer
	  may be specified using the optional <argname>y0</argname>
	  argument; in that case the <argname>control</argname>
	  argument is ignored.
	</para>
	<para context="tex">
	  If $0 &lt; p &lt; 1$, an exponential moving average is
	  computed: \[y_t = p x_t + (1-p)y_{t-1}\]. (This is the formula
	  of <cite key="roberts59">Roberts (1959)</cite>.) By default
	  the output series $y$ is initialized using the first valid
	  value of $x$, but the <argname>control</argname> parameter
	  may be used to specify the number of initial observações
	  that should be averaged to produce $y_0$.  A zero value for
	  <argname>control</argname> indicates that all the
	  observações should be used. Alternatively, an initializer
	  may be specified using the optional <argname>y0</argname>
	  argument; in that case the <argname>control</argname>
	  argument is ignored.
	</para>
      </description>
    </function>

    <function name="mpols" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Works exactly as <fncref targ="mols"/>, except that the calculations
	  are done in multiple precision using the GMP library.
	</para>
	<para>
	  By default GMP uses 256 bits for each floating point number, but
	  you can adjust this using the environment variável
	  <lit>GRETL_MP_BITS</lit>, como por exemplo <lit>GRETL_MP_BITS=1024</lit>.
	</para>
      </description>
    </function>

    <function name="mrandgen" section="probdist" output="matrix">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="scalar">p1</fnarg>
	<fnarg type="scalar" conditional="true">p2</fnarg>
	<fnarg type="scalar" conditional="true">p3</fnarg>
	<fnarg type="int">rows</fnarg>
	<fnarg type="int">cols</fnarg>
      </fnargs>
      <examples>
	<example>matrix mx = mrandgen(u, 0, 100, 50, 1)</example>
	<example>matrix mt14 = mrandgen(t, 14, 20, 20)</example>
      </examples>
      <description>
	<para>
	  Funciona da mesma forma que <fncref targ="randgen"/> exceto pelo
	  fato de retornar uma matriz ao invés de uma série. Os argumentos
	  iniciais para essa função (os números que a distribuição selecionada
	  depende) são descritos por <lit>randgen</lit>, mas eles devem ser
	  seguidos por dois inteiros para especificar o número de linhas e
	  colunas da matriz aleatória desejada.
	</para>
	<para>
	  O primeiro exemplo acima gera um vetor coluna com 50 elementos
	  seguindo uma distribuição uniforme, enquanto que o segundo
	  exemplo especifica uma matriz aleatória de ordem <by r="20" c="20"/>
	  com valores extraídos da distribuição <math>t</math> com 14 graus de
	  liberdade.
	</para>
	<para>
	  <seelist>
            <fncref targ="mnormal"/>
            <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mread" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="string">fname</fnarg>
	<fnarg optional="true" type="bool">import</fnarg>
      </fnargs>
      <description>
	<para>
	  Lê uma matriz armazenada no arquivo chamado <argname>fname
	  </argname>. Se o arquivo possuir a extensão <quote><lit>.gz
	  </lit></quote> é assumido que ele foi comprimido no formato
	  gzip, se tiver a extensão <quote><lit>.bin</lit></quote> é
	  assumido que o arquivo está em formato binário (veja <fncref
	  targ="mwrite"/> para detalhes). Caso contrário assume-se que
	  é um arquivo de texto simples, seguindo as seguintes
	  especificações:
	</para>
	<ilist>
	  <li>
            <para>
	          O arquivo pode começar com qualquer qualquer quantidade
	          de comentários, definidos por linhas iniciadas com o
	          caractere <lit>#</lit>. Essas linhas serão ignoradas.
            </para>
	  </li>
	  <li>
            <para>
              A primeira que não for de comentário deve conter dois
              inteiros, separados por um espaço ou uma tabulação,
              indicando o número de linhas e colunas, respectivamente.
            </para>
	  </li>
	  <li>
            <para>
              As colunas devem estar separadas por espaços ou por
              tabulações.
            </para>
	  </li>
	  <li>
            <para>
              O separador decimal deve ser o ponto
              (<quote><lit>.</lit></quote>).
            </para>
	  </li>
	</ilist>
	<para>
	  Se no primeiro argumento não estiver especificado o caminho
	  completo até o arquivo ele será em vários locais que sejam
	  considerados como sendo <quote>prováveis</quote>. O primeiro
	  deles será o diretório de trabalho em uso <cmdref targ="workdir"/>.
	  Entretanto, se o segundo argumento da função, <argname>import</argname>,
	  for um valor não-nulo o arquivo será procurado no diretório
	  <quote>@dotdir</quote>. Isto ocorre para que essa função seja
	  utilizada em conjunto com as que exportam matrizes presentes
	  no contexto do comando <cmdref targ="foreign"/>. Nesse caso o
	  argumento <argname>fname</argname> deve ser um nome simples,
	  sem que se especique o caminho para o arquivo.
	</para>
	<para>
	  <seelist>
            <fncref targ="bread"/>
            <fncref targ="mwrite"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mreverse" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma matriz contendo as linhas de <argname>X</argname>
	  em ordem reversa. Para obter uma matriz na qual as colunas de
	  <argname>X</argname> apareçam em ordem reversa pode-se utilizar:
	</para>
	<code>
	  matrix Y = mreverse(X')'
	</code>
      </description>
    </function>

    <function name="mrls" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">R</fnarg>
	<fnarg type="cvec">q</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;V</fnarg>
      </fnargs>
      <description>
	<para>
	  Mínimos quadrados restritos: retorna uma matriz <by r="k"
	  c="n"/> de parâmetros estimados obtidos através da regressão
	  via mínimos quadrados da matriz <argname>Y</argname>, de ordem
	  <by r="T" c="n"/>, contra a matriz <argname>X</argname>, de
	  ordem <by r="T" c="k"/>, sujeitos à restrição linear <math>RB
	  </math> = <math>q</math>, onde <math>B</math> representa o
	  vetor de coeficientes empilhados. <argname>R</argname> deve
	  possuir <math>kn</math> colunas. Cada linha dessa matriz
	  representa uma restrição linear. O número de linhas em
	  <argname>q</argname> deve coincidir com o número de linhas em
	  <argname>R</argname>.
	</para>
	<para>
	  Se o quinto argumento não for <lit>null</lit>, a matriz
	  <argname>U</argname> de ordem <by r="T" c="n"/> irá armazenar
	  os resíduos. Se o argumento final for dado e não for <lit>null
	  </lit> então a matriz <argname>V</argname> de ordem <by r="k"
	  c="k"/> irá armazenar a contraparte restrita da matriz <math>X'
	  X</math><sup>-1</sup>. A matriz de variância das estimativas
	  para a equação <math>i</math> pode ser construída multiplicando-se
	  a sub-matriz apropriada de <argname>V</argname> por uma estimativa
	  do erro para esta equação.
	</para>
      </description>
    </function>

    <function name="mshape" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">r</fnarg>
	<fnarg type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Rearranja os elementos de <argname>X</argname> em uma matriz com
	  <argname>r</argname> linhas e <argname>c</argname> colunas. Os elementos
	  de <argname>X</argname> são copiados e escritos na matriz de destino. A
	  cópia tem início na coluna 1, linha 1, depois linha 2 e assim
	  sucessivamente. Se <argname>X</argname> tiver menos que <math>k</math>
	   = <math>rc</math> elementos, estes são repetidos de forma cíclica. Caso
	  contrário, se <argname>X</argname> tiver mais elementos, apenas os
	  primeiros <math>k</math> elementos serão utilizados.
	</para>
	<para>
	  <seelist>
            <fncref targ="cols"/>
            <fncref targ="rows"/>
            <fncref targ="unvech"/>
            <fncref targ="vec"/>
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="msortby" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">j</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma matriz onde as linhas de <argname>X</argname>
	  são reordenadas de forma crescente de acordo com os elementos da
	  coluna <argname>j</argname>. Essa ordenação é estável: linhas que
	  compartilham o mesmo valor na coluna <argname>j</argname> não
	  serão invertidas.
	</para>
      </description>
    </function>

    <function name="muniform" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma matriz com <argname>r</argname> linhas e <argname>c</argname>
	  colunas, preenchida com números pseudo-aleatórios seguindo uma distribuição
	  uniforme (0,1). Observação: o método preferencial para gerar escalares
	  pseudo-aleatórios com distribuição uniforme é através da utilização da
	  função <fncref targ="randgen1"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="mnormal"/>
            <fncref targ="uniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mweights" section="midas" output="matrix">
      <fnargs>
	<fnarg type="int">p</fnarg>
	<fnarg type="vector">theta</fnarg>
	<fnarg type="int">type</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a <math>p</math>-vector of MIDAS weights to be
	  applied to <math>p</math> lags of a high-frequency series,
	  based on the vector <repl>theta</repl> of hyper-parameters.
	</para>
	<para>
	  The <repl>type</repl> argument identifies the type of
	  parameterization, which governs the required number of
	  elements, <math>k</math>, in <repl>theta</repl>: 1 =
	  normalized exponential Almon (<math>k</math> at least 1,
	  typically 2); 2 = normalized beta with zero last
	  (<math>k</math> = 2); 3 = normalized beta with non-zero last
	  lag (<math>k</math> = 3); and 4 = Almon polynomial
	  (<math>k</math> at least 1).
	</para>
	<para>
	  <seelist>
            <fncref targ="mgradient"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mwrite" section="data-utils" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="string">fname</fnarg>
	<fnarg optional="true" type="bool">export</fnarg>
      </fnargs>
      <description>
	<para>
	  Writes the matrix <argname>X</argname> to a file named
	  <argname>fname</argname>. By default this file will be plain
	  text; the first line will hold two integers, separated by a
	  tab character, representando the number of rows and columns;
	  on the following lines the matrix elements appear, in
	  scientific notation, separated by tabs (one line per row).
	  See below for alternative formats.
	</para>
	<para>
	  If a file <argname>fname</argname> already exists, it will be
	  overwritten. The return value is 0 on successful completion;
	  if an error occurs, such as the file being unwritable, the
	  return value will be non-zero.
	</para>
	<para>
	  The output file will be written in the currently set <cmdref
	  targ="workdir"/>, unless the <repl>filename</repl> variável de texto (<quote>string</quote>)
	  contains a full path specification. However, if a non-zero
	  value is given para o <argname>export</argname> argument,
	  the output file will be written into the user's
	  <quote>dot</quote> directory, onde it is accessible by
	  default via the matrix-loading functions offered in the
	  context of the <cmdref targ="foreign"/> command. In this
	  case a plain filename, without any path component, should be
	  given para o second argument.
	</para>
	<para>
	  Matrizes stored via the <lit>mwrite</lit> function in its
	  default form can be easily read by other programs; veja
	  <guideref targ="chap:matrices"/> para detalhes.
	</para>
	<para>
	  Two mutually exclusive inflections of this function are
	  available, as follows:
	</para>
	<ilist>
	  <li>
	    <para>
	      If <argname>fname</argname> has the suffix
	      <quote><lit>.gz</lit></quote> the the file is written
	      with gzip compression.
	    </para>
	  </li>
	  <li>
	    <para>
	      If <argname>fname</argname> has the suffix
	      <quote><lit>.bin</lit></quote> then the file is written
	      in binary format. In this case the first 19 bytes
	      contain the characters <lit>gretl_binary_matrix</lit>,
	      the next 8 bytes contain two 32-bit integers giving the
	      number of rows and columns, and the remainder of the
	      file contains the matrix elements as little-endian
	      <quote>doubles</quote>, in column-major order. If gretl
	      is run on a big-endian system, the binary values are
	      converted to little endian on writing, and converted to
	      big endian on reading.
	    </para>
	  </li>
	</ilist>
	<para>
	  Note that if the matrix file is to be read by a third-party
	  program it is not advisable to use the gzip or binary
	  options. But if the file is intended for reading by gretl
	  the alternative formats save space, and the binary format
	  allows for much faster reading of large matrices. The gzip
	  format is not recommended for very large matrices, since
	  decompression can be quite slow.
	</para>
	<para>
	  <seelist>
            <fncref targ="mread"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mxtab" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma matriz holding the cross tabulation of the values
	  contained in <argname>x</argname> (by row) and
	  <argname>y</argname> (by column). The two arguments should be of
	  the same type (both series or both column vectors), and because
	  of the typical usage of this function, are assumed to contain
	  integer values only.
	</para>
	<para>
	  <seelist>
            <fncref targ="values"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="naalen" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">d</fnarg>
	<fnarg type="series-or-vec" optional="true">cens</fnarg>
      </fnargs>
      <description>
	<para>
	  Given a sample of duration data, <argname>d</argname>,
	  possibly accompanied by a record of censoring status,
	  <argname>cens</argname>, computes the Nelson&ndash;Aalen
	  nonparametric estimator of the hazard function (<cite
	  key="nelson72">Nelson, 1972</cite>; <cite
	  key="aalen78">Aalen, 1978)</cite>.  The returned matrix has
	  three columns holding, respectively, the sorted unique
	  values in <argname>d</argname>, the estimated cumulated
	  hazard function corresponding to the duration value in
	  column 1, and the standard error of the estimator.
	</para>
	<para>
	  If the <argname>cens</argname> series is given, the value 0
	  is taken to indicate an uncensored observation while a value
	  of 1 indicates a right-censored observation (that is, the
	  period of observation of the individual in question has
	  ended before the duration or spell has been recorded as
	  terminated). If <argname>cens</argname> is not given, it is
	  assumed that all observations are uncensored. (Note: the
	  semantics of <argname>cens</argname> may be extended at some
	  point to cover other types of censoring.)
	</para>
	<para>
	  <seelist>
            <fncref targ="kmeier"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="nadarwat" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series">x</fnarg>
	<fnarg type="scalar">h</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o Nadaraya&ndash;Watson nonparametric estimator of
	  the conditional mean of <argname>y</argname> given
	  <argname>x</argname>. It retorna uma série holding the
	  nonparametric estimate of
	  <math>E(y</math><sub>i</sub><math>|x</math><sub>i</sub><math>)</math>
	  for each nonmissing element of the series
	  <argname>x</argname>.
	</para>
	<para context="tex">
	  \[
	  m(x_i) = \frac{ \sum_{j=1}^{n} y_j \cdot K_h(x_i -
	  x_j)} {\sum_{j=1}^{n} K_h(x_i - x_j)}
	  \]
	  onde the kernel function <math>K_h(\cdot)</math> is given
	  by
	  \[
	  K_h(x) = \exp\left(-\frac{x^2}{2h}\right)
	  \]
	  for $|x| &lt; \tau$ and zero otherwise.
	</para>
	<para context="notex">
	  The kernel function <math>K</math> is given
	  by <math>K = exp(-x</math><sup>2</sup><math> / 2h)</math>
	  for <math>|x| &lt; T</math> and zero otherwise.
	</para>
	<para context="tex">
	  The argument <argname>h</argname>, known as the
	  \emph{bandwidth}, is a parameter (a positive real number)
	  given by the user. This is usually a small number: larger
	  values of $h$ make $m(x)$ smoother; a popular choice is
	  $n^{-0.2}$. More details are given in <guideref
	  targ="chap:nonparam"/>.
	</para>
	<para context="notex">
	  The argument <argname>h</argname>, known as the bandwidth,
	  is a parameter (a positive real number) given by the
	  user. This is usually a small number: larger values
	  of <argname>h</argname> make <math>m(x)</math> smoother; a
	  popular choice is <math>n</math><sup>-0.2</sup>. More
	  details are given in <guideref targ="chap:nonparam"/>.
	</para>
	<para context="tex">
	  The scalar $\tau$ is used to prevent numerical problems when
	  the kernel function is evaluated too far away from zero
	  and is called the trim parameter.
	</para>
	<para context="notex">
	  The scalar <math>T</math> is used to prevent numerical
	  problems when the kernel function is evaluated too far away
	  from zero and is called the trim parameter.
	</para>
	<para>
	  The trim parameter can be adjusted via
	  the <lit>nadarwat_trim</lit> setting, as a multiple
	  of <argname>h</argname>. The default value is 4.
	</para>
	<para>
	  The user may provide a negative value para a bandwidth:
	  this is interpreted as conventional syntax to obtain the
	  leave-one-out estimator, that is a variant of the estimator
	  that does not use the <math>i</math>-th observation for
	  evaluating <math>m(x</math><sub>i</sub><math>)</math>. This
	  makes the Nadaraya&ndash;Watson estimator more robust
	  numerically and its usage is normally advised when the
	  estimator is computed for inference purposes. Of course, the
	  bandwidth actually used is the absolute value of
	  <argname>h</argname>.
	</para>
	<para context="tex">
          In formulae, the leave-one-out estimator is
          \[
          m(x_i) = \frac{ \sum_{j \ne i} y_j \cdot K_h(x_i -
          x_j)} {\sum_{j \ne i} K_h(x_i - x_j)}
          \]
	</para>

      </description>
    </function>

    <function name="nelem" section="data-utils" output="int">
      <fnargs>
	<fnarg type="listetc">L</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o número de elementos no argumento que, por sua vez, pode ser uma
	  lista, uma matriz, um pacote (<quote>bundle</quote>) ou um arranjo
	  (<quote>array</quote>). A função não pode ser utilizada em séries.
	</para>
      </description>
    </function>

    <function name="ngetenv" section="strings" output="scalar">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Se uma variável de ambiente de nome <argname>s</argname>
	  estiver definida e possuir um valor numérico a função
	  retorna este valor, caso contrário, retorna NA. Veja
	  também <fncref targ="getenv"/>.
	</para>
      </description>
    </function>

    <function name="nlines" section="strings" output="scalar">
      <fnargs>
	<fnarg type="string">buf</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a quantidade de linhas completas (isto é, linhas que terminam
	  com um caractere de nova linha) em <argname>buf</argname>.
	</para>
    <para>
        Exemplo:
    </para>
    <code>
        string web_page = readfile("http://gretl.sourceforge.net/")
        scalar number = nlines(web_page)
        print number
    </code>
      </description>
    </function>

    <function name="NMmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg optional="true" type="int">maxfeval</fnarg>
      </fnargs>
      <description>
	<para>
	  Numerical maximization via the Nelder&ndash;Mead
	  derivative-free simplex method.  On input the vector
	  <argname>b</argname> should hold the initial values of a set
	  of parameters, and the argument <argname>f</argname> should
	  specify a call to a function that calculates the (scalar)
	  criterion to be maximized, given the current parameter
	  values and any other relevant data. On successful
	  completion, <lit>NMmax</lit> returns the maximized value of
	  the criterion, and <argname>b</argname> holds the parameter
	  values which produce the maximum.
	</para>
	<para>
	  The optional third argument may be used to set the maximum
	  number of function evaluations; if it is omitted or set to
	  zero the maximum defaults to 2000. As a special signal to
	  this function the <argname>maxfeval</argname> value may be
	  set to a negative number. In this case the absolute value is
	  taken, and <lit>NMmax</lit> flags an error if the best value
	  found for the objective function at the maximum number of
	  function evaluations is not a local optimum. Otherwise
	  non-convergence in this sense is not treated as an error.
	</para>
	<para>
	  If the object is in fact minimization, either the function
	  call should return the negative of the criterion or
	  alternatively <lit>NMmax</lit> may be called under the
	  alias <lit>NMmin</lit>.
	</para>
	<para>
	  For more details and examples see the chapter on numerical
	  methods in <guideref targ="chap:numerical"/>.
	  <seelist>
            <fncref targ="simann"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="nobs" section="stats" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o número de observações não ausentes para a variável
	  <argname>y</argname> na amostra corrente selecionada.
	</para>
      </description>
    </function>

    <function name="normal" section="probdist" output="series">
      <fnargs>
	<fnarg type="scalar">&mu;</fnarg>
	<fnarg type="scalar">&sigma;</fnarg>
      </fnargs>
      <description>
	<para>
	  Generates a series of Gaussian pseudo-random variates with
	  mean &mu; and desvio padrão &sigma;. If no arguments
	  are supplied, standard normal variates <math>N</math>(0,1)
	  are produced.  The values are produced using the Ziggurat
	  method <cite key="marsaglia00" p="true">(Marsaglia and
	  Tsang, 2000)</cite>.
	</para>
	<para>
	  <seelist>
            <fncref targ="randgen"/>
            <fncref targ="mnormal"/>
            <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="normtest" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="string" optional="true">method</fnarg>
      </fnargs>
      <description>
	<para>
	  Performs a test for normality of <argname>y</argname>. By
	  default this is the Doornik&ndash;Hansen test but the
	  optional <argname>method</argname> argument can be used
	  to select an alternative: use <lit>swilk</lit> to get
	  the Shapiro&ndash;Wilk test, <lit>jbera</lit> for
	  Jarque&ndash;Bera test, or <lit>lillie</lit> for the
	  Lilliefors test.
	</para>
	<para>
	  The second argument may be given in either quoted or
	  unquoted form. In the latter case, however, if the argument
	  is the name of a string variable the value of the variable
	  is substituted. The following shows three acceptable ways of
	  calling for a Shapiro&ndash;Wilk test:
	</para>
	<code>
	  matrix nt = normtest(y, swilk)
	  matrix nt = normtest(y, "swilk")
	  string testtype = "swilk"
	  matrix nt = normtest(y, testtype)
	</code>
	<para>
	  The returned matrix is <by r="1" c="2"/>; it holds the test
	  statistic and its p-value. See also the <cmdref
	  targ="normtest"/> command.
	</para>
      </description>
    </function>

    <function name="npcorr" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="string" optional="true">method</fnarg>
      </fnargs>
      <description>
	<para>
	  Calculates a measure of correlation between
	  <argname>x</argname> and <argname>y</argname> using a
	  nonparametric method. If given, the third argument should be
	  either <lit>kendall</lit> (for Kendall's tau, version b, the
	  default method) or <lit>spearman</lit> (for Spearman's rho).
	</para>
	<para>
	  The return value is a 3-vector holding the correlation
	  measure plus a test statistic and p-value for the null
	  hypothesis of no correlation. Note that if the sample size
	  is too small the test statistic and/or p-value may be
	  <lit>NaN</lit> (not a number, or missing).
	</para>
	<para>
	  See also <fncref targ="corr"/> for Pearson correlation.
	</para>
      </description>
    </function>

    <function name="npv" section="math" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg type="scalar">r</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o Net Present Value of <argname>x</argname>,
	  considered as a sequence of payments (negative) and receipts
	  (positive), evaluated at annual discount rate
	  <argname>r</argname>, which must be expressed as a decimal
	  fraction, not a percentage (0.05 rather than 5<lit>%</lit>).
	  The first value is taken as dated <quote>now</quote> and is
	  not discounted.  To emulate an NPV function in which the
	  first value is discounted, prepend zero to the input
	  sequence.
	</para>
	<para>
	  Supported data frequencies are annual, quarterly, monthly, and
	  undated (undated data are treated as if annual).
	</para>
	<para>
	  <seelist>
            <fncref targ="irr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="NRmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="fncall" optional="true">g</fnarg>
	<fnarg type="fncall" optional="true">h</fnarg>
      </fnargs>
      <description>
	<para>
	  Numerical maximization via the Newton&ndash;Raphson method.
	  On input the vector <argname>b</argname> should hold the
	  initial values of a set of parameters, and the argument
	  <argname>f</argname> should specify a call to a function
	  that calculates the (scalar) criterion to be maximized,
	  given the current parameter values and any other relevant
	  data. If the object is in fact minimization, this function
	  should return the negative of the criterion.  On successful
	  completion, <lit>NRmax</lit> returns the maximized value of
	  the criterion, and <argname>b</argname> holds the parameter
	  values which produce the maximum.
	</para>
	<para>
	  The optional third and fourth arguments provide means of
	  supplying analytical derivatives and an analytical
	  (negative) Hessian, respectively. The functions referenced
	  by <argname>g</argname> and <argname>h</argname> must take
	  as their first argument a pre-defined matrix that is of the
	  correct size to contain the gradient or Hessian,
	  respectively, given in pointer form. They also must take the
	  parameter vector as an argument (in pointer form or
	  otherwise).  Other arguments are optional. If either or
	  both of the optional arguments are omitted, a numerical
	  approximation is used.
	</para>
	<para>
	  Para maiores detalhes and exemplos see the chapter on numerical
	  methods in <guideref targ="chap:numerical"/>.
	  <seelist>
            <fncref targ="BFGSmax"/>
            <fncref targ="fdjac"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="nullspace" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Computes the right nullspace of <argname>A</argname>, via
	  the singular value decomposition: the result is a matrix
	  <math>B</math> such that the product <math>AB</math> is a
	  zero matrix, except when <argname>A</argname> has full
	  column rank, in which case an empty matrix is
	  returned. Otherwise, if <argname>A</argname> is <by r="m"
	  c="n"/>, <math>B</math> will be <math>n</math> by
	  (<math>n</math> &minus; <math>r</math>), where
	  <math>r</math> is the rank of <argname>A</argname>.
	</para>
	<para context="notex">
	  If <argname>A</argname> is not of full column rank, then
	  the vertical concatenation of <argname>A</argname> and
	  the transpose of <argname>B</argname> produces a full
	  rank matrix.
	</para>
	<para context="tex">
	  Computes the right nullspace of <argname>A</argname>, via the
	  singular value decomposition: the result is a matrix $B$ such
	  that
	  \begin{itemize}
	  \item $AB = [0]$, except when $A$ has full column rank, in which
	  case an empty matrix is returned. Otherwise, if $A$ is $m \times
	  n$, $B$ will be an $n \times (n-r)$ matrix, where $r$ is the
	  rank of $A$.
	  \item If $A$ is not of full column rank, then the vertical
	  concatenation of $A$ and $B'$ produces a full rank matrix.
	  \end{itemize}
	</para>
    <para>
        Example:
    </para>
    <code>
      A = mshape(seq(1,6),2,3)
      B = nullspace(A)
      C = A | B'

      print A B C

      eval A*B
      eval rank(C)
    </code>
    <para>
        Produces
    </para>
    <code>
      ? print A B C
      A (2 x 3)

      1   3   5
      2   4   6

      B (3 x 1)

      -0.5
         1
      -0.5

      C (3 x 3)

         1      3      5
         2      4      6
      -0.5      1   -0.5

      ? eval A*B
      -4.4409e-16
      -4.4409e-16

      ? eval rank(C)
      3
    </code>
    <para>
      <seelist>
        <fncref targ="rank"/>
        <fncref targ="svd"/>
      </seelist>
	</para>
      </description>
    </function>

    <function name="obs" section="data-utils" output="series">
      <description>
	<para>
	  Retorna uma série of consecutive integers, setting 1 at the
	  start of the conjunto de dados. Note that the result is invariant to
	  subsampling. This function is especially useful with
	  conjuntos de dados de séries temporais. Note: you can write <lit>t</lit>
	  instead of <lit>obs</lit> with the same effect.
	</para>
	<para>
	  <seelist>
            <fncref targ="obsnum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="obslabel" section="data-utils" output="string">
      <fnargs>
	<fnarg type="int">t</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o rótulo da observação <argname>t</argname>,
	  onde <argname>t</argname> é número que representa
	  esta observação. A função inversa é dada por
	  <fncref targ="obsnum"/>.
	</para>
      </description>
    </function>

    <function name="obsnum" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>obsnum
	  Retorna o número que corresponde a observação especificada pela
	  variável <math>s</math>. Note que o resultado desta função não é
	  afetado por subamostragenss. Ela é especialmente útil em dados
	  de séries temporais. Por exemplo, o código seguinte
	</para>
	<code>
	  open denmark
	  k = obsnum(1980:1)
	</code>
	<para>
	  fornece <lit>k = 25</lit>, indicando que o primeiro trimestre de
	  1980 é a vigésima quinta observação nos dados <lit>denmark</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="obs"/>
            <fncref targ="obslabel"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ok" section="data-utils" output="seebelow">
      <fnargs>
	<fnarg type="anyfloat-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  If <argname>x</argname> is a scalar, returns 1 if
	  <argname>x</argname> is not <lit>NA</lit>, otherwise 0.  If
	  <argname>x</argname> is a series, retorna uma série with
	  value 1 at observações with non-missing values and zeros
	  elsewhere. If <argname>x</argname> is a list, the output is
	  a series with 0 at observações for which at least one
	  series in the list has a missing value, and 1 otherwise.
	</para>
	<para>
	  If <argname>x</argname> is a matrix the behavior is a little
	  different, since matrizes cannot contain <lit>NA</lit>s: the
	  function retorna uma matrix of the same dimensions as
	  <argname>x</argname>, with 1s in positions corresponding to
	  finite elements of <argname>x</argname> and 0s in positions
	  onde the elements are non-finite (either infinities or
	  not-a-number, as per the IEEE 754 standard).
	</para>
	<para>
	  <seelist>
            <fncref targ="missing"/>
            <fncref targ="misszero"/>
            <fncref targ="zeromiss"/>
	  </seelist>
	  But note that these functions are not aplicável to matrizes.
	</para>
      </description>
    </function>

    <function name="onenorm" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Retorna a 1-norm of the matrix <argname>X</argname>, that is,
	  the maximum across the columns of <argname>X</argname> of the
	  sum of absolute values of the column elements.
	</para>
	<para context="tex">
	  Retorna a 1-norm of the $r \times c$ matrix
	  <argname>X</argname>:
	  \[\| X \|_1 = \max_j \sum_{i=1}^r |X_{ij}| \]
	</para>
	<para>
	  <seelist>
            <fncref targ="infnorm"/>
            <fncref targ="rcond"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ones" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma matriz com <math>r</math> linhas e <math>c</math>
	  colunas preenchida com valores iguais a 1.
	</para>
	<para>
	  <seelist>
            <fncref targ="seq"/>
            <fncref targ="zeros"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="orthdev" section="transforms" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  É aplicável somente se o conjunto de dados corrente tiver uma estrutura
	  de painel. Computes the forward orthogonal deviations for
	  variável <argname>y</argname>.
	</para>
	<para context="tex">
	  É aplicável somente se o conjunto de dados corrente tiver uma estrutura
	  de painel. Computes the forward orthogonal deviations for
	  variável <argname>y</argname>, that is
	  \[ \tilde{y}_{i,t} =
	  \sqrt{ \frac{T_i - t}{T_i - t + 1}} \left( y_{i,t} -
	  \frac{1}{T_i - t} \sum_{s=t+1}^{T_i} y_{i,s} \right) \]
	</para>
	<para>
	  This transformation is sometimes used instead of
	  differencing to remove individual effects from dados em painel.
	  For compatibility with first differences, the deviations are
	  stored one passo à frente of their true temporal location (that
	  is, the value at observation <math>t</math> is the deviation
	  that, strictly speaking, belongs at <math>t</math> &minus;
	  1).  That way one loses the first observation in each time
	  series, not the last.
	</para>
	<para>
	  <seelist>
            <fncref targ="diff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pdf" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <examples>
	<example>f1 = pdf(N, -2.5)</example>
	<example>f2 = pdf(X, 3, y)</example>
	<example>f3 = pdf(W, forma, escala, y)</example>
      </examples>
      <description>
	<para>
	  Calculadora da função densidade de probabilidade. Retorna a
	  densidade em <argname>x</argname> da distribuição identificada
	  pelo código <argname>d</argname>. Veja <fncref targ="cdf"/>
	  para detalhes acerca dos argumentos requeridos. As distribuições
	  suportadas pela função <lit>pdf</lit> são: normal, <math>t</math>
	  de Student, qui-quadrado, <math>F</math>, Gama, Weibull, Erro
	  Generalizado, Binomial e Poisson. Note que para a Binomial e a
	  Poisson o que de fato é calculado é a massa de probabilidade no
	  ponto especificado. Para <math>t</math> de Student, qui-quadrado
	  e <math>F</math> também estão disponiveis as suas variantes
	  não-centrais.
	</para>
	<para>
	  Para a distribuição normal veja também <fncref targ="dnorm"/>.
	</para>
      </description>
    </function>

    <function name="pergm" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg optional="true" type="scalar">bandwidth</fnarg>
      </fnargs>
      <description>
	<para>
	  If only the first argument is given, computes the sample periodogram
	  para a given series or vector. If the second argument is given,
	  computes an estimate of the spectrum of <argname>x</argname> using a
	  Bartlett lag window of the given bandwidth, up to a maximum of half
	  the number of observações (<math>T</math>/2).
	</para>
	<para>
	  Retorna uma matriz with two columns and <math>T</math>/2 rows:
	  the first column holds the frequency, &omega;, from
	  2&pi;/<math>T</math> to &pi;, and the second the
	  corresponding spectral density.
	</para>
      </description>
    </function>

    <function name="pexpand" section="data-utils" output="series">
      <fnargs>
	<fnarg type="vector">v</fnarg>
      </fnargs>
      <description>
	<para>
	  É aplicável somente se o conjunto de dados corrente tiver uma
	  estrutura de painel. Realiza a operação inversa de
	  <fncref targ="pshrink"/>. Isto é, dado um vetor de comprimento
	  igual ao número de indivíduos na amostra (de painel) corrente,
	  retorna uma série na qual cada valor é repetido <math>T</math>
	  vezes, onde <math>T</math> representa o comprimento temporal
	  do painel. A série resultante é dessa forma não variante em
	  relação ao tempo.
	</para>
      </description>
    </function>

    <function name="pmax" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para>
	  É aplicável somente se o conjunto de dados corrente tiver uma
	  estrutura de painel. Retorna uma série contendo o máximo da
	  variável <argname>y</argname> para cada unidade de corte
	  transversal (isso é repetido parar cada período de tempo).
	</para>
	<para>
	  Se o segundo argumento (opcional) for fornecido, as
	  observações onde o valor de <argname>mask</argname>
	  for igual a zero são ignoradas.
	</para>
	<para>
	  <seelist>
            <fncref targ="pmin"/>
            <fncref targ="pmean"/>
            <fncref targ="pnobs"/>
            <fncref targ="psd"/>
            <fncref targ="pxsum"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pmean" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  É aplicável somente se o conjunto de dados corrente tiver uma
	  estrutura de painel. Retorna uma série contendo a média temporal
	  da variável <argname>y</argname> para cada unidade de corte
	  transversal. Os valores são repetidos para cada período e as
	  observações ausentes são ignoradas no cálculo das médias.
	</para>
	<para context="tex">
	  É aplicável somente se o conjunto de dados corrente tiver uma
	  estrutura de painel. Calcula a média temporal de
	  <argname>y</argname> para cada unidade de corte transversal, isto
	  é, \[ \bar{y}_i = \frac{1}{T_i} \sum_{t=1}^{T_i} y_{i,t}\]
	  onde $T_i$ é o número de observações válidas da unidade
	  $i$.
	</para>
	<para>
	  Se o segundo argumento (opcional) for fornecido, as
	  observações onde o valor de <argname>mask</argname>
	  for igual a zero são ignoradas.
	</para>
	<para>
	  <seelist>
            <fncref targ="pmax"/>
            <fncref targ="pmin"/>
            <fncref targ="pnobs"/>
            <fncref targ="psd"/>
            <fncref targ="pxsum"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pmin" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para>
	  É aplicável somente se o conjunto de dados corrente tiver uma
	  estrutura de painel. Retorna uma série contendo o mínimo da
	  variável <argname>y</argname> para cada unidade de corte
	  transversal (isso é repetido para cada período de tempo).
	</para>
	<para>
	  Se o segundo argumento (opcional) for fornecido, as
	  observações onde o valor de <argname>mask</argname>
	  for igual a zero são ignoradas.
	</para>
	<para>
	  <seelist>
            <fncref targ="pmax"/>
            <fncref targ="pmean"/>
            <fncref targ="pnobs"/>
            <fncref targ="psd"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pnobs" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para>
	  É aplicável somente se o conjunto de dados corrente tiver uma
	  estrutura de painel. Retorna uma série contendo o número de
	  observações válidas em <argname>y</argname> para cada unidade
	  de corte transversal (isso é repetido para cada período de tempo).
	</para>
	<para>
	  Se o segundo argumento (opcional) for fornecido, as
	  observações onde o valor de <argname>mask</argname>
	  for igual a zero são ignoradas.
	</para>
	<para>
	  <seelist>
            <fncref targ="pmax"/>
            <fncref targ="pmin"/>
            <fncref targ="pmean"/>
            <fncref targ="psd"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="polroots" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="vector">a</fnarg>
      </fnargs>
      <description>
	<para>
	  Finds the roots of a polynomial.  If the polynomial is of degree
	  <math>p</math>, the vector <argname>a</argname> should contain
	  <math>p</math> + 1 coeficientes in ascending order, &ie; starting
	  with the constant and ending with the coefficient on
	  <math>x</math><sup>p</sup>.
	</para>
	<para>
	  If all the roots are real they are returned in a vetor coluna of
	  length <math>p</math>, otherwise a <by r="p" c="2"/> matrix
	  is returned, the real parts in the first column and the imaginary
	  parts in the second.
	</para>
      </description>
    </function>

    <function name="polyfit" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int">q</fnarg>
      </fnargs>
      <description>
	<para>
	  Fits a polynomial trend of order <argname>q</argname> to the
	  input series <argname>y</argname> using the method of
	  orthogonal polynomials. The series returned holds the
	  fitted values.
	</para>
      </description>
    </function>

    <function name="princomp" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">p</fnarg>
	<fnarg optional="true" type="bool">covmat</fnarg>
      </fnargs>
      <description>
	<para>
	  Let the matrix <argname>X</argname> be <by r="T" c="k"/>,
	  contendo <math>T</math> observações on <math>k</math>
	  variáveis.  The argument <argname>p</argname> must be a
	  positive integer less than or equal to <math>k</math>. This
	  function returns a <by r="T" c="p"/> matrix, <math>P</math>,
	  holding the first <math>p</math> principal components of
	  <argname>X</argname>.
	</para>
	<para>
	  The optional third argument acts as a boolean switch: if it is
	  non-zero the principal components are computed on the basis of
	  the matriz de covariâncias of the columns of <argname>X</argname>
	  (the default is to use the correlation matrix).
	</para>
	<para context="notex">
	  The elements of <math>P</math> are computed as the sum from
	  <math>i</math> to <math>k</math> of
	  <math>Z</math><sub>ti</sub> times
	  <math>v</math><sub>ji</sub>, onde
	  <math>Z</math><sub>ti</sub> is the standardized value of
	  variável <math>i</math> at observation <math>t</math> and
	  <math>v</math><sub>ji</sub> is the <math>j</math>th
	  eigenvector of the correlation (or covariance) matrix of the
	  <math>X</math><sub>i</sub>s, with the eigenvectors ordered
	  by decreasing value of the corresponding autovalores.
	</para>
	<para context="tex">
	  The elements of $P$ are computed as
	  \[ P_{tj} = \sum_{i=1}^{k} Z_{ti} \, v^{(j)}_i \]
	  onde $Z_{ti}$ is the standardized value
	  of variável $i$ at observation $t$, $Z_{ti} = (X_{ti} -
	  \bar{X}_i) / \hat{\sigma}_i$, and $v^{(j)}_i$ is the $j$th
	  eigenvector of the correlation (or covariance) matrix of the
	  $X_i$s, with the eigenvectors ordered by decreasing value
	  of the corresponding autovalores.
	</para>
	<para>
	  <seelist>
            <fncref targ="eigensym"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="prodc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o produto dos elementos das colunas de
	  <argname>X</argname>.
	  <seelist>
            <fncref targ="prodr"/>
            <fncref targ="meanc"/>
            <fncref targ="sdc"/>
            <fncref targ="sumc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="prodr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o produto dos elementos das linhas de
	  <argname>X</argname>.
	  <seelist>
            <fncref targ="prodc"/>
            <fncref targ="meanr"/>
            <fncref targ="sumr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="psd" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  É aplicável somente se o conjunto de dados corrente tiver uma
	  estrutura de painel. Retorna uma série contendo desvio padrão
	  amostral da variável <math>y</math> para cada unidade de corte
	  transversal (sendo os valores repetidos para cada período de
	  tempo). O denominador utilizado o tamanho da amostra em cada
	  unidade menos 1, a menos que o número de observações válidas
	  para dada unidade ser 1 (nesse caso será retornado 0) ou 0
	  (nesse caso será retornado <lit>NA</lit>).
	</para>
	<para context="tex">
	  É aplicável somente se o conjunto de dados corrente tiver uma
	  estrutura de painel. Calcula o desvio padrão amostral da variável
	  <math>y</math> para cada unidade de corte transversal, isto é,
	   \[ \sigma_i = \sqrt{\frac{1}{T_i - 1} \sum_{t=1}^{T_i} (y_{i,t} -
	  \bar{y}_i)^2 } \] A fórmula acima mantém-se para $T_i \ge 2$,
	  onde $T_i$ é o número de observações válidas para a unidade
	  $i$. Se $T_i = 0$ será retornado <lit>NA</lit> e se $T_i = 1$
	  será retornado 0.
	</para>
	<para>
	  Se o segundo argumento (opcional) for fornecido, as
	  observações onde o valor de <argname>mask</argname>
	  for igual a zero são ignoradas.
  </para>
	<para>
	  Observação: essa função torna possível testar se dada variável
	  (como por exemplo, <lit>X</lit>) não varia ao longo do tempo
	  utilizando a condição <lit>max(psd(X)) == 0</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="pmax"/>
            <fncref targ="pmin"/>
            <fncref targ="pmean"/>
            <fncref targ="pnobs"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="psdroot" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="symmat">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Performs a generalized variant of the decomposição de Cholesky of
	  the matrix <argname>A</argname>, which must be positive
	  semidefinite (but which may be singular). If the input matrix is
	  not square an error is flagged, but symmetry is assumed and not
	  tested; only the lower triangle of <argname>A</argname> is read.
	  The result is a lower-triangular matrix <math>L</math> which
	  satisfies <equation status="inline" ascii="A = LL'" tex="$A =
	  LL'$"/>.  Indeterminate elements in the solution are set to
	  zero.
	</para>
	<para>
	  For the case onde <argname>A</argname> is positive definite,
	  see <fncref targ="cholesky"/>.
	</para>
      </description>
    </function>

    <function name="pshrink" section="data-utils" output="matrix">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  É aplicável somente se o conjunto de dados corrente tiver uma
	  estrutura de painel. Retorna um vetor coluna contendo a primeira
	  observação válida da série <argname>y</argname> para cada unidade
	  de corte transversal no painel, ao longo extensão da amostra
	  corrente. Se uma unidade não possuir observações válidas da série
	  de entrada ela será ignorada.
	</para>
	<para>
	  Essa função fornece uma maneira de compactar as séries
	  retornadas por funções como <fncref targ="pmax"/> e
	  <fncref targ="pmean"/>, nas quais um valor pertecente a
	  cada unidade de corte transversal é repetido para cada
	  período de tempo.
	</para>
	<para>
	  Veja <fncref targ="pexpand"/> para a operação inversa.
	</para>
      </description>
    </function>

    <function name="psum" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  É aplicável somente se o conjunto de dados corrente tiver uma
	  estrutura de painel. Retorna uma série contendo a soma ao longo
	  do tempo da variável <argname>y</argname> para cada unidade de
	  corte transversal. Os valores são repetidos para cada período e
	  as observações ausentes são ignoradas no cálculo das somas.
	</para>
	<para context="tex">
	  É aplicável somente se o conjunto de dados corrente tiver
	  uma estrutura de painel. Calcula a soma ao longo do tempo
	  da variável <argname>y</argname> para cada unidade de corte
	  transversal, isto é, \[ S_i = \sum_{t=1}^{T_i} y_{i,t}\]
	  onde $T_i$ é o número de observações válidas da unidade
	  $i$.
	</para>
	<para>
	  Se o segundo argumento (opcional) for fornecido, as
	  observações onde o valor de <argname>mask</argname>
	  for igual a zero são ignoradas.
	</para>
	<para>
	  <seelist>
            <fncref targ="pmax"/>
            <fncref targ="pmean"/>
            <fncref targ="pmin"/>
            <fncref targ="pnobs"/>
            <fncref targ="psd"/>
            <fncref targ="pxsum"/>
            <fncref targ="pshrink"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pvalue" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="char">c</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <examples>
	<example>p1 = pvalue(z, 2.2)</example>
	<example>p2 = pvalue(X, 3, 5.67)</example>
	<example>p2 = pvalue(F, 3, 30, 5.67)</example>
      </examples>
      <description>
	<para>
	  Calculadora de <math>P</math>-valores. Retorna <equation
	  status="inline" ascii="P(X > x)" tex="$P(X > x)$"/>, onde
	  a distribuição de <math>X</math> é especificada pela letra
	  <argname>c</argname>. Entre os argumentos
	  <argname>c</argname> e <argname>x</argname>, zero ou mais
	  argumentos adicionais são necessários para que especifique
	  os parâmetros da distribuição. Veja <fncref targ="cdf"/>
	  para detalhes. As distribuições suportadas pela função
	  <lit>pvalue</lit> são: normal padrão, <math>t</math>,
	  qui-quadrada, <math>F</math>, gama, binomial, Poisson,
	  Weibull e Erro Generalizado.
	</para>
	<para>
	  <seelist>
            <fncref targ="critical"/>
            <fncref targ="invcdf"/>
            <fncref targ="urcpval"/>
            <fncref targ="imhof"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pxnobs" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para>
	  É aplicável somente se o conjunto de dados corrente tiver uma
	  estrutura de painel. Retorna uma série contendo o número de
	  observações válidas de <argname>y</argname> em cada período
	  de tempo (essa operação é repetida para cada unidade de corte transversal).
	</para>
	<para>
	  Se o segundo argumento (opcional) for fornecido, as
	  observações onde o valor de <argname>mask</argname>
	  for igual a zero são ignoradas.
	</para>
	<para>
	  Note que esta função opera em uma dimensão diferente da função
	  <fncref targ="pnobs"/>.
	</para>
      </description>
    </function>

    <function name="pxsum" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  É aplicável somente se o conjunto de dados corrente tiver uma estrutura
	  de painel. Retorna uma série contendo a soma dos valores de
	  <argname>y</argname> para cada unidade de corte transversal em cada
	  período de tempo (sendo os valores repetidos para cada unidade de corte).
	</para>
	<para context="tex">
	  É aplicável somente se o conjunto de dados corrente tiver
	  uma estrutura de painel. Calcula a dos valores da variável
	  <argname>y</argname> em cada período de tempo. Isto é,
	  \[ \tilde{y}_t = \sum_{i=1}^{N} y_{i,t}\] onde $N$ é o
	  número de unidades de corte transversal.
	</para>
	<para>
	  Se o segundo argumento (opcional) for fornecido, as
	  observações onde o valor de <argname>mask</argname>
	  for igual a zero são ignoradas.
	</para>
	<para>
	  Note que esta função opera em uma dimensão diferente da função
	  <fncref targ="psum"/>.
	</para>
      </description>
    </function>

    <function name="qform" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">x</fnarg>
	<fnarg type="symmat">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Computes the quadratic form <equation status="inline"
	  ascii="Y = xAx'" tex="$Y = x A x'$"/>.  Using this function
	  instead of ordinary matrix multiplication guarantees more
	  speed and better accuracy, when <argname>A</argname> is a
	  generic symmetric matrix. However, in the special case when
	  <argname>A</argname> is the identity matrix, the simple
	  expression <lit>x'x</lit> performs much better than
	  <lit>qform(x',I(rows(x))</lit>.
	</para>
	<para context="tex">
	  Computes the quadratic form <equation status="inline"
	  ascii="Y = xAx'" tex="$Y = x A x'$"/>.  Using this function
	  instead of ordinary matrix multiplication guarantees more
	  speed and better accuracy, when <argname>A</argname> is a
	  generic symmetric matrix.  However, in the special case <equation
	  status="inline" ascii="A = I" tex="$A = I$"/>, the simple
	  expression <lit>x'x</lit> performs much better than
	  <lit>qform(x',I(rows(x))</lit>.
	</para>
	<para>
	If <argname>x</argname> and <argname>A</argname> are not
	conformable, or <argname>A</argname> is not symmetric, an error
	is returned.
	</para>
      </description>
    </function>

    <function name="qlrpval" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="scalar">X2</fnarg>
	<fnarg type="int">df</fnarg>
	<fnarg type="scalar">p1</fnarg>
	<fnarg type="scalar">p2</fnarg>
      </fnargs>
      <description>
	<para>
	  <math>P</math>-values para o estatística de teste from the QLR
	  sup-Wald test for a structural break at an unknown point
	  (see <cmdref targ="qlrtest"/>), as per <cite
	  key="hansen97">Bruce Hansen (1997)</cite>.
	</para>
	<para>
	  The first argument, <argname>X2</argname>, denotes the
	  (qui-quadrado form of) the maximum Wald estatística de teste and
	  <argname>df</argname> denotes its graus de liberdade.  The
	  third and fourth arguments represent, as decimal fractions
	  of the overall estimation range, the starting and ending
	  points of the central range of observações over which the
	  successive Wald tests are calculated. Por exemplo if the
	  standard approach of 15 percent trimming is adopted, you
	  would set <argname>p1</argname> to 0.15 and
	  <argname>p2</argname> to 0.85.
	</para>
	<para>
	  <seelist>
            <fncref targ="pvalue"/>
	    <fncref targ="urcpval"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="qnorm" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna os quantis para a distribuição normal padrão. Se
	  <argname>x</argname> não estiver entre 0 e 1, será retornado
	  <lit>NA</lit>.
	  <seelist>
            <fncref targ="cnorm"/>
            <fncref targ="dnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="qrdecomp" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;R</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula a decomposição QR de uma matriz <argname>X</argname> de ordem
	  <by r="m" c="n"/>, isto é, <math>X = QR</math> onde <math>Q</math> é
	  uma matriz ortogonal <by r="m" c="n"/> e <math>R</math> é uma matriz
	  triangular superior <by r="n" c="n"/>. A matriz <math>Q</math> é
	  retornada diretamente, enquanto que <math>R</math> pode ser obtida
	  via utilização do segundo argumento (opcional).
	</para>
	<para>
	  <seelist>
            <fncref targ="eigengen"/>
            <fncref targ="eigensym"/>
            <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="quadtable" section="stats" output="matrix">
      <fnargs>
	<fnarg type="int">n</fnarg>
	<fnarg type="int" optional="true">type</fnarg>
	<fnarg type="scalar" optional="true">a</fnarg>
	<fnarg type="scalar" optional="true">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns an <by r="n" c="2"/> matrix for use with Gaussian
	  quadrature (numerical integration). The first column holds
	  the nodes or abscissae, the second the weights.
	</para>
	<para>
	  The first argument specifies the number of points (rows) to
	  compute. The second argument codes para o type of
	  quadrature: use 1 for Gauss&ndash;Hermite (the default);
	  2 for Gauss&ndash;Legendre; or 3 for Gauss&ndash;Laguerre.
	  The significance of the optional parameters
	  <argname>a</argname> and <argname>b</argname> depends on the
	  selected <argname>type</argname>, as explained below.
	</para>
	<para context="notex">
	  Gaussian quadrature is a method of approximating numerically
	  the definite integral of some function of interest. Let the
	  function be represented as the product
	  <math>f(x)W(x)</math>. The types of quadrature differ in the
	  specification of the component <math>W(x)</math>: in the
	  Hermite case this is exp(&minus;<math>x</math><sup>2</sup>);
	  in the Laguerre case, exp(&minus;<math>x</math>); and in the
	  Legendre case simply <math>W(x)</math> = 1.
	</para>
	<para context="tex">
	  Gaussian quadrature is a method of approximating numerically
	  the definite integral of some function of interest. Let the
	  function be represented as the product $f(x)W(x)$. The types
	  of quadrature differ in the specification of the component
	  $W(x)$: in the Hermite case we have $W(x) = \exp(-x^2)$; in
	  the Laguerre case, $W(x) = \exp(-x)$; and in the Legendre
	  case simply $W(x) = 1$.
	</para>
	<para context="notex">
	  For each specification of <math>W</math>, one can compute a
	  set of nodes, <math>x</math><sub>i</sub>, and weights,
	  <math>w</math><sub>i</sub>, such that the sum from
	  <math>i</math>=1 to <math>n</math> of
	  <math>w</math><sub>i</sub>
	  <math>f</math>(<math>x</math><sub>i</sub>) approximates the
	  desired integral. The method of <cite key="golub69">Golub
	  and Welsch (1969)</cite> is used.
	</para>
	<para context="tex">
	  For each specification of $W(x)$, one can compute a set of
	  nodes, $x_i$, and weights, $w_i$, such that $\sum_{i=1}^n
	  f(x_i) w_i$ approximates the desired integral. The method of
	  <cite key="golub69">Golub and Welsch (1969)</cite> is used.
	</para>
	<para context="notex">
	  When the Gauss&ndash;Legendre type is selected, the
	  optional arguments <argname>a</argname> and
	  <argname>b</argname> can be used to control the lower and
	  upper limits of integration, the default values being
	  &minus;1 and 1. (In Hermite quadrature the
	  limits are fixed at minus and plus infinity, while in
	  the Laguerre case they are fixed at 0 and infinity.)
	</para>
	<para context="tex">
	  When the Gauss&ndash;Legendre type is selected, the optional
	  arguments <argname>a</argname> and <argname>b</argname> can
	  be used to control the lower and upper limits of
	  integration, the default values being $-1$ and 1. (In Hermite
	  quadrature the limits are fixed at $-\infty$ and $+\infty$,
	  while in the Laguerre case they are fixed at 0 and $\infty$.)
	</para>
	<para context="notex">
	  In the Hermite case <argname>a</argname> and
	  <argname>b</argname> play a different role: they can be used
	  to replace the default form of
	  <math>W</math>(<math>x</math>) with the (closely related)
	  normal distribution with mean <argname>a</argname> and
	  desvio padrão <argname>b</argname>. Supplying values of
	  0 and 1 for these parameters, por exemplo, has the effect of
	  making <math>W</math>(<math>x</math>) into the standard
	  normal pdf, which is equivalent to multiplying the default
	  nodes by the square root of two and dividing the weights by
	  the square root of &pi;.
	</para>
	<para context="tex">
	  In the Hermite case <argname>a</argname> and
	  <argname>b</argname> play a different role: they can be used
	  to replace the default form of $W(x)$ with the
	  (closely related) normal distribution with mean
	  <argname>a</argname> and desvio padrão
	  <argname>b</argname>. Supplying values of 0 and 1 for these
	  parameters, por exemplo, has the effect of making
	  $W(x)$ into the standard normal pdf, which is equivalent
	  to multiplying the default $x_i$ values by $\sqrt{2}$
	  and dividing the default $w_i$ by $\sqrt{\pi}$.
	</para>
      </description>
    </function>

    <function name="quantile" section="stats" output="scalar" altout="matrix">
      <fnargs>
	<fnarg type="series-or-mat">y</fnarg>
	<fnarg type="pscalar">p</fnarg>
      </fnargs>
      <description>
	<para>
	  If <argname>y</argname> is a series, returns the
	  <argname>p</argname>-quantile para as series. Por exemplo, when
	  <math>p</math> = 0.5, the median is returned.
	</para>
	<para>
	  If <argname>y</argname> is a matrix, returns a row vector
	  contendo the <argname>p</argname>-quantiles para as columns of
	  <argname>y</argname>; that is, each column is treated as a
	  series.
	</para>
	<para>
	  In addition, for matrix <argname>y</argname> an alternate form
	  of the second argument is supported: <argname>p</argname> may be
	  given as a vector. In that case the return value is an <by r="m"
	  c="n"/> matrix, onde <repl>m</repl> is the number of elements
	  in <argname>p</argname> and <repl>n</repl> is the number of
	  columns in <argname>y</argname>.
	</para>
	<para context="tex">
	  For a series of length $n$, the $p$-quantile, $q$, is defined
	  as:
	  \[q = y_{[k]} + [(n+1) \cdot p - k] (y_{[k+1]} - y_{[k]})\]
	  onde $k$ is the integer part of $(n+1) \cdot p$ and
	  $y_{[i]}$ is the $i$-th element of the series when
	  sorted from smallest to largest.
	</para>
      </description>
    </function>

    <function name="randgen" section="probdist" output="series">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="scalar-or-series">p1</fnarg>
	<fnarg type="scalar-or-series" conditional="true">p2</fnarg>
	<fnarg type="scalar" conditional="true">p3</fnarg>
      </fnargs>
      <examples>
	<example>series x = randgen(u, 0, 100)</example>
	<example>series t14 = randgen(t, 14)</example>
	<example>series y = randgen(B, 0.6, 30)</example>
	<example>series g = randgen(G, 1, 1)</example>
	<example>series P = randgen(P, mu)</example>
      </examples>
      <description>
	<para>
	  Gerador de número aleatório de uso geral. O argumeto
	  <argname>d</argname> é um texto (<quote>string</quote>)
	  (sendo geralmente composto por apenas um caractere) que
	  especifica a distribuição da qual serão extraídos os
	  pseudo-números. Os argumentos <argname>p1</argname> a
	  <argname>p3</argname> especificam os parâmetros da
	  distribuição selecionada, sendo que o número de parâmetros
	  depende da distribuição escolhida. Para distribuições que
	  não a beta-binomial, os parâmetros <argname>p1</argname>
	  e <argname>p2</argname> (se for aplicável) podem estar na
	  forma escalar ou de série. Se forem utilizados na forma
	  escalar a série resultante será identicamente distribuída.
	  Se forem utilizadas séries em <argname>p1</argname> ou
	  <argname>p2</argname> a distribuição será condicional ao
	  valor do parâmetro em cada observação. No caso da
	  beta-binomial todos os parâmetros devem ser escalares.
	</para>
	<para>
	  Especificidades são apresentadas abaixo: o código para
	  cada distribuição é mostrado entre parênteses, seguido
	  da interpretação do argumento <argname>p1</argname> e,
	  quando for aplicável, <argname>p2</argname> e
	  <argname>p3</argname>.
	</para>

	<ilist context="notex">
	  <li>
            <para>
              Uniforme (contínua) (u ou U): mínimo, máximo
            </para>
	  </li>
	  <li>
            <para>
              Uniforme (discreta) (i): mínimo, máximo
            </para>
	  </li>
	  <li>
            <para>
              Normal (z, n ou N): média, desvio padrão
            </para>
	  </li>
	  <li>
            <para>
              t de Student (t): graus de liberdade
            </para>
	  </li>
	  <li>
            <para>
              Qui-quadrado (c, x ou X): graus de liberdade
            </para>
	  </li>
	  <li>
            <para>
              F de Snedecor (f ou F): graus de liberdade (num.), graus de liberdade (den.)
            </para>
	  </li>
	  <li>
            <para>
              Gama (g ou G): forma, escala
            </para>
	  </li>
	  <li>
            <para>
              Binomial (b ou B): probabilidade, quantidade de tentativas
            </para>
	  </li>
	  <li>
            <para>
              Poisson (p ou P): média
            </para>
	  </li>
	  <li>
            <para>
              Weibull (w ou W): forma, escala
            </para>
	  </li>
	  <li>
            <para>
              Erro Generalizado (E): forma
            </para>
	  </li>
	  <li>
            <para>
              Beta (beta): forma1, forma2
            </para>
	  </li>
	  <li>
            <para>
              Beta-Binomial (bb): tentativas, forma1, forma2
            </para>
	  </li>
	</ilist>
	<tabular colspec="lllll">
	  \textbf{Distribuição} &amp; \textsl{d} &amp; \textsl{p1} &amp; \textsl{p2} &amp; \textsl{p3}\\[4pt]
	  Uniforme (contínua) &amp; \texttt{u} ou \texttt{U} &amp; mínimo &amp; máximo &amp; --\\
	  Uniforme (discreta) &amp; \texttt{i} &amp; mínimo &amp; máximo &amp; --\\
	  Normal &amp; \texttt{z}, \texttt{n} ou \texttt{N} &amp; média &amp; desvio padrão &amp; --\\
	  $t$ de Student &amp; \texttt{t} &amp; graus de liberdade &amp; -- &amp; --\\
	  Qui-quadrado &amp; \texttt{c}, \texttt{x} ou \texttt{X} &amp; graus de liberdade &amp; -- &amp; --\\
	  $F$ de Snedecor &amp; \texttt{f} ou \texttt{F} &amp; g.l. (num.) &amp; g.l. (den.) &amp; --\\
	  Gama &amp; \texttt{g} ou \texttt{G} &amp; forma &amp; escala  &amp; --\\
	  Binomial &amp; \texttt{b} ou \texttt{B} &amp; $p$ &amp; $n$  &amp; --\\
	  Poisson &amp; \texttt{p} ou \texttt{P} &amp; média &amp; --  &amp; --\\
	  Weibull &amp; \texttt{w} ou \texttt{W} &amp; forma &amp; escala &amp; --\\
	  Erro Generalizado &amp; \texttt{e} ou \texttt{E} &amp; forma &amp; -- &amp; --\\
	  Beta &amp; \texttt{beta} &amp; forma1 &amp; forma2 &amp; --\\
	  Beta-Binomial &amp; \texttt{bb} &amp; $n$ &amp; forma1 &amp; forma2
	</tabular>
	<para>
	  <seelist>
            <fncref targ="normal"/>
            <fncref targ="uniform"/>
            <fncref targ="mrandgen"/>
            <fncref targ="randgen1"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="randgen1" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="char">d</fnarg>
	<fnarg type="scalar">p1</fnarg>
	<fnarg type="scalar" conditional="true">p2</fnarg>
      </fnargs>
      <examples>
	<example>scalar x = randgen1(z, 0, 1)</example>
	<example>scalar g = randgen1(g, 3, 2.5)</example>
      </examples>
      <description>
	<para>
	  Funciona da mesma forma que <fncref targ="randgen"/> exceto
	  pelo fato de retornar um escalar ao invés de uma série.
	</para>
	<para>
	  O primeiro exemplo acima retorna um valor da distribuição
	  normal padrão, enquanto que o segundo especifica um valor
	  a ser extraído da distribuição Gama com forma 3 e escala 2.5.
	</para>
	<para>
	  <seelist>
            <fncref targ="mrandgen"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="randint" section="probdist" output="int">
      <fnargs>
	<fnarg type="int">min</fnarg>
	<fnarg type="int">max</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna um inteiro pseudo-aleatório no intervalo fechado
	  [<argname>min</argname>, <argname>max</argname>].
	  <seelist>
	    <fncref targ="randgen"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="rank" section="linalg" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o posto de <argname>X</argname>, calculada numericamente
	  via decomposição em valores singulares.
	  <seelist>
            <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ranking" section="stats" output="asinput">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma série ou vetor com os ranks de <math>
	  y</math>. O rank para a observação <math>i</math>
	  é o número de elementos que são menores que <math>
	  y</math><sub>i</sub> mais 1. Se houver números
	  iguais a <math>y</math><sub>i</sub> adiciona-se 0,5.
	  Intuitivamente, pode-se pensar em uma partida de
	  xadrez, onde uma vitória vale 1 ponto e um empate
	  vale 0,5 pontos). É adicionado 1 ao rank de forma
	  que o menor rank possível é 1 ao invés de 0.
	</para>
	<para context="tex">
	  Formalmente tem-se,
	  \[ \mathrm{rank}(y_i) = 1 + \sum_{j \ne i} \left[
	  I(y_j &lt; y_i) + 0.5 \cdot I(y_j = y_i) \right] \]
	  onde $I$ representa a função indicadora.
	</para>
	<para>
	  <seelist>
            <fncref targ="sort"/>
            <fncref targ="sortby"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="rcond" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o reciprocal condition number for <argname>A</argname>
	  with respect to the 1-norm. In many circumstances, this is a better
	  measure of the sensitivity of <argname>A</argname> to numerical
	  operations such as inversion than the determinant.
	</para>
	<para context="notex">
	  The value is computed as the reciprocal of the product, 1-norm
	  of <argname>A</argname> times 1-norm of
	  <argname>A</argname>-inverse.
	</para>
	<para context="tex">
	  Given that <math>A</math> is non-singular, we may define
	  \[\kappa(A) = ||A||_1 \cdot ||A^{-1}||_1\]
	  This function returns $\kappa(A)^{-1}$.
	</para>
	<para>
	  <seelist>
            <fncref targ="det"/>
            <fncref targ="ldet"/>
            <fncref targ="onenorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="readfile" section="strings" output="string">
      <fnargs>
	<fnarg type="string">fname</fnarg>
	<fnarg type="string" optional="true">codeset</fnarg>
      </fnargs>
      <description>
	<para>
	  Se um arquivo com o nome <argname>fname</argname> existir e puder
	  ser lido, a função retorna um texto (<quote>string</quote>) com o
	  conteúdo desse arquivo, caso contrário retorna um erro. Se <argname>
	  fname</argname> não contiver o caminho completo até o arquivo, ele
	  será procurado em algumas localizações <quote>prováveis</quote>,
	  começando pelo <cmdref targ="workdir"/> corrente.
	</para>
	<para>
	  Se <argname>fname</argname> começar com o identificador de um
	  protocolo de internet suportado (<lit>http://</lit>,
	  <lit>ftp://</lit> ou <lit>https://</lit>), libcurl será utilizado
	  para baixar o arquivo. Veja também <fncref targ="curl"/> para
	  baixar arquivos de forma mais elaborada.
	</para>
	<para>
	  Se o texto a ser lido não estiver codificado como UTF-8, Gretl
	  tentará recodificá-lo a partir da codificação corrente se esta
	  não for UTF-8, ou, caso contrário, a partir da codificação
	  ISO-8859-15. Se essa estratégia padrão não funcionar é possível
	  utilizar o segundo argumento (que é opcional) para especificar a
	  codificação. Por exemplo, caso seja desejada a leitura de texto
	  com codificação Microsoft 1251 e esta não seja a configuração local,
	  pode-se fornecer o segundo argumento <lit>"cp1251"</lit>.
	</para>
    <para>
        Exemplos:
    </para>
    <code>
        string web_page = readfile("http://gretl.sourceforge.net/")
        print web_page

        string current_settings = readfile("@dotdir/.gretl2rc")
        print current_settings
    </code>
	<para>
	  Veja também as funções <fncref targ="sscanf"/> e <fncref
	  targ="getline"/>.
	</para>
      </description>
    </function>

    <function name="regsub" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg type="string">match</fnarg>
	<fnarg type="string">repl</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma cópia de <argname>s</argname> onde todas as
	  ocorrências do padrão <argname>match</argname> são
	  substituídas por <argname>repl</argname>. Os argumentos
	  <argname>match</argname> e <argname>repl</argname>
	  são interpretados como expressões regulares no estilo Perl.
	</para>
	<para>
	  Veja também <fncref targ="strsub"/> para substituições simples
	  de textos.
	</para>
      </description>
    </function>

    <function name="remove" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">fname</fnarg>
      </fnargs>
      <description>
	<para>
	  Deleta o arquivo <argname>fname</argname> caso ele exista
	  e seja gravável pelo usuário. Retorna 0 em caso de sucesso
	  e um valor não-nulo se o arquivo não existir ou não puder
	  ser removido.
	</para>
	<para>
	  Se <argname>fname</argname> contiver o caminho completo
	  para o arquivo o Gretl tentará deletá-lo e retornará um
	  erro se ele não existir ou não puder ser apagado por algum
	  motivo (um exemplo seria um arquivo do tipo somente-leitura).
	  Se <argname>fname</argname> não contiver o caminho completo
	  então será assumido que o arquivo está no diretório de
	  trabalho (<cmdref targ="workdir"/>). Se o arquivo não
	  existir ou não for gravável o Gretl não irá procurá-lo em
	  nenhum outro diretório.
	</para>
      </description>
    </function>

    <function name="replace" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
	<fnarg type="scalar-or-vec">find</fnarg>
	<fnarg type="scalar-or-vec">subst</fnarg>
      </fnargs>
      <description>
	<para>
	  Substitui cada elemento de <argname>x</argname> igual ao
	  <math>i</math>-ésimo elemento de <argname>find</argname>
	  pelo correspondente elemento de <argname>subst</argname>.
	</para>
	<para>
	  Se <argname>find</argname> for um escalar, <argname>subst</argname>
	  também deve ser um escalar. Se <argname>find</argname> e
	  <argname>subst</argname> forem vetores, eles precisam ter o mesmo
	  número de elementos. Mas se <argname>find</argname> for um vetor e
	  <argname>subst</argname> um escalar, então todas as ocorrências serão
	  substituídas por <argname>subst</argname>.
	</para>
	<para>
	  Exemplo:
	</para>
	<code>
	  a = {1,2,3;3,4,5}
	  find = {1,3,4}
	  subst = {-1,-8, 0}
	  b = replace(a, find, subst)
	  print a b
	</code>
	<para>
	  produz
	</para>
	<code>
          a (2 x 3)

          1   2   3
          3   4   5

          b (2 x 3)

          -1    2   -8
          -8    0    5
	</code>
      </description>
    </function>

    <function name="resample" section="stats" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
	<fnarg optional="true" type="int">blocksize</fnarg>
      </fnargs>
      <description>
	<para>
	  The initial description of this function pertains to
	  corte transversal or séries temporais data; see below for
	  the case of dados em painel.
	</para>
	<para>
	  Resamples from <argname>x</argname> with replacement.  In
	  the case of a series argument, each value of the returned
	  series, <math>y</math><sub>t</sub>, is drawn from among all
	  the values of <math>x</math><sub>t</sub> with equal
	  probability.  When a matrix argument is given, each row of
	  the returned matrix is drawn from the rows of
	  <argname>x</argname> with equal probability.
	</para>
	<para>
	  O argumento opcional <argname>blocksize</argname>
	  represents the block size for resampling by moving blocks.
	  If this argument is given it should be a positive integer
	  greater than or equal to 2. The effect is that the output is
	  composed by random selection with replacement from among all
	  the possible contiguous sequences of length
	  <argname>blocksize</argname> in the input.  (In the case of
	  matrix input, this means contiguous rows.) If the length of
	  the data is not an integer multiple of the block size, the
	  last selected block is truncated to fit.
	</para>
	<para>
	  If the argument <argname>x</argname> is a series and the
	  conjunto de dados takes the form of a panel, resampling by moving
	  blocks is not supported. The basic form of resampling is
	  supported, but has this specific interpretation: the data
	  are resampled <quote>by individual</quote>. Suppose you have
	  a panel in which 100 individuals are observed over 5
	  periods. Then the returned series will again be composed of
	  100 blocks of 5 observações: each block will be drawn with
	  equal probability from the 100 individual séries temporais, with
	  the séries temporais order preserved.
	</para>
      </description>
    </function>

    <function name="round" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Arredondamento para o número inteiro mais próximo. Note que quando
	  <math>x</math> estiver exatamente entre dois inteiros, o arredondamento é
	  feito de moda a "se afastar de zero", assim, por exemplo, 2.5 é arredondado
	  para 3, mas <lit>round(-3.5)</lit> retorna &minus;4. Esta é uma convenção
	  comum em programas de planilha eletrônica, mas outros programas podem
	  gerar resultados diferentes.
	  <seelist>
            <fncref targ="ceil"/>
            <fncref targ="floor"/>
            <fncref targ="int"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="rownames" section="matbuild" output="int">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="strings-or-list">S</fnarg>
      </fnargs>
      <description>
	<para>
	  Adiciona nomes para as linhas da matriz <argname>M</argname> de
	  ordem <by r="m" c="n"/> . Se <argname>S</argname> for uma lista,
	  os nomes serão os das séries listadas. A lista precisa ter <math>
	  m</math> membros. Se <argname>S</argname> for um arranjo (<quote>
	  array</quote>) de variáveis de texto (<quote>string</quote>), ele
	  precisa ter <math>m</math> elementos. Para manter a compatibilidade
	  com versões anteriores do Gretl, uma única variável de texto também
	  pode ser utilizada como segundo argumento. Nesse caso ela precisa
	  ter <math>m</math> textos separados por espaços.
	</para>
	<para>
	  Retorna o valor 0 se as linhas forem nomeadas com sucesso. Caso contrário
	  será retornado um valor não-nulo. Veja também <fncref targ="colnames"/>.
	</para>
	<para>
	  Exemplo:
	</para>
	<code>
	  matrix M = {1, 2; 2, 1; 4, 1}
	  strings S = array(3)
	  S[1] = "Row1"
	  S[2] = "Row2"
	  S[3] = "Row3"
	  rownames(M, S)
	  print M
	</code>
      </description>
    </function>

    <function name="rows" section="matshape" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o número de linhas da matriz <argname>X</argname>.
	  <seelist>
            <fncref targ="cols"/>
            <fncref targ="mshape"/>
            <fncref targ="unvech"/>
            <fncref targ="vec"/>
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sd" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>x</argname> for uma série a função retorna o
	  desvio padrão amostral, descartando as observações ausentes.
	</para>
	<para>
	  Se <argname>x</argname> for uma lista a função retorna uma
	  série <math>y</math> tal que <math>y</math><sub>t</sub>
	  representa o desvio padrão amostral dos valores das variáveis
	  na lista na observação <math>t</math>, ou <lit>NA</lit> se
	  existirem valores ausentes em <math>t</math>.
	</para>
	<para>
	  <seelist>
            <fncref targ="var"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sdc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="scalar" optional="true">df</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna os desvios padrão das colunas da matriz <argname>X
	  </argname>. Se <argname>df</argname> for positivo ele será
	  utilizado como o divisor para as variâncias das colunas,
	  caso contrário o divisor será igual ao número de linhas em
	  <argname>X</argname> (isto é, não será aplicada a correção
	  de graus de liberdade).
	  <seelist>
            <fncref targ="meanc"/>
            <fncref targ="sumc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sdiff" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-or-list">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula diferenças sazonais: <equation status="inline"
	  ascii="y(t) - y(t-k)"  tex="$y_t - y_{t-k}$"/>, onde
	  <math>k</math> é a periodicidade do conjunto de dados corrente (veja
	  <fncref targ="$pd"/>). Valores iniciais são definidos como
	  <lit>NA</lit>.
	</para>
	<para>
	  Quando uma lista for retornada, as variáveis individuais são automaticamente
	  nomeadas de acordo com o seguinte padrão <lit>sd_</lit><repl>varname</repl>,
	  onde <repl>varname</repl> é o nome da série original. A porção que
	  representa o nome original da série será truncado, caso seja necessário, e
	  ajustado no caso de não ser único no conjunto de nomes assim
	  construído.
	</para>
	<para>
	  <seelist>
            <fncref targ="diff"/>
            <fncref targ="ldiff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="seasonals" section="data-utils" output="list">
      <fnargs>
	<fnarg optional="true" type="int">baseline</fnarg>
	<fnarg optional="true" type="bool">center</fnarg>
      </fnargs>
      <description>
	<para>
	  Aplicável somente se o conjunto de dados tiver uma estrutura de série
	  temporal com periodicidade maior que 1. Retorna uma lista com variáveis
	  dummy que representam os períodos sazonais. As dummies sazonais são
	  nomeadas como <lit>S1</lit>, <lit>S2</lit> e assim por diante.
	</para>
	<para>
	  O argumento opcional <argname>baseline</argname> pode ser utilizado
	  para excluir um período do conjunto de dummies. Por exemplo, se for
	  fornecido um valor igual a 1 em um conjunto de dados trimestrais a
	  lista retornada conterá as dummies apenas para os trimestres 2, 3 e
	  4. Se este argumento for omitido ou for igual a 0 serão geradas as
	  dummies para todos os períodos. É importante notar que o argumento
	  deve ser um número inteiro e menor ou igual a periodicidade dos dados.
	</para>
	<para>
	  O argumento <argname>center</argname>, se for não-nulo, faz com que
	  as dummies sejam centradas, isto é, que sejam subtraídas suas médias
	  populacionais. Por exemplo, com dados trimestrais as dummies sazonais
	  centradas terão valores iguais a &minus;0.25 e 0.75 ao invés de 0 e
	  1.
	</para>
      </description>
    </function>

    <function name="selifc" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="rvec">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Seleciona em <argname>A</argname> apenas as colunas para as
	  quais o elemento correspondente em <argname>b</argname> é
	  não-nulo. <argname>b</argname> deve ser um vetor linha com
	  o mesmo número de colunas de <argname>A</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="selifr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="selifr" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="cvec">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Seleciona em <argname>A</argname> apenas as linhas para as
	  quais o elemento correspondente em <argname>b</argname> é
	  não-nulo. <argname>b</argname> deve ser um vetor coluna com
	  o mesmo número de linhas de <argname>A</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="selifc"/>
            <fncref targ="trimr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="seq" section="matbuild" output="rvec">
      <fnargs>
	<fnarg type="scalar">a</fnarg>
	<fnarg type="scalar">b</fnarg>
	<fnarg optional="true" type="scalar">k</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna um vetor com a sequência crescente de <argname>a</argname>
	  até <argname>b</argname> se o primeiro argumento for menor que o segundo.
	  Se o primeiro argumento for maior que o segundo a sequência será
	  decrescente. Em ambos os casos o incremento/decremento será de 1 unidade.
	</para>
	<para>
	  Se o argumento opcional <argname>k</argname> for dado a função retorna um
	  vetor com a sequência iniciada em <argname>a</argname> e aumentada, caso
	  <argname>a</argname> for menor <argname>b</argname>), em <argname>k
	  </argname> unidades a cada passo. A sequência será finalizada no maior
	  valor possível que seja menor ou igual a <argname>b</argname>. Se o
	  primeiro argumento for maior que o segundo a sequencia será reduzida em
	  <argname>k</argname> unidades e será finalizada no menor valor possível
	  que seja maior ou igual a <argname>b</argname>). O argumento <argname>k
	  </argname> deve ser positivo.
	</para>
	<para>
	  <seelist>
            <fncref targ="ones"/>
            <fncref targ="zeros"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="setnote" section="data-utils" output="int">
      <fnargs>
	<fnarg type="bundle">b</fnarg>
	<fnarg type="string">key</fnarg>
	<fnarg type="string">note</fnarg>
      </fnargs>
      <description>
	<para>
	  Insere uma nota descritiva para o objeto identificado
	  por <argname>key</argname> em um pacote (<quote>bundle
	  </quote>) <argname>b</argname>. Esta nota será apresentada
	  quando o comando <lit>print</lit> for utilizado no pacote.
	  A função retorna 0 em caso de sucesso e um valor não-nulo
	  em caso de falha (por exemplo, se não existir o objeto
	  <argname>key</argname> em <argname>b</argname>).
	</para>
      </description>
    </function>

    <function name="simann" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="int" optional="true">maxit</fnarg>
      </fnargs>
      <description>
	<para>
	  Implements simulated annealing, which may be helpful in
	  improving the initialization for a numerical optimization
	  problem.
	</para>
	<para>
	  On input the first argument holds the initial value of a
	  parameter vector and the second argument specifies a
	  function call which returns the (scalar) value of the
	  maximand. The optional third argument specifies the maximum
	  number of iterations (which defaults to 1024). On successful
	  completion, <lit>simann</lit> returns the final value of the
	  maximand and <argname>b</argname> holds the associated
	  parameter vector.
	</para>
	<para>
	  Para maiores detalhes and an example see the chapter on numerical
	  methods in <guideref targ="chap:numerical"/>.
	  <seelist>
            <fncref targ="BFGSmax"/>
            <fncref targ="NRmax"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sin" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o seno de <argname>x</argname>.
	  <seelist>
            <fncref targ="cos"/>
            <fncref targ="tan"/>
            <fncref targ="atan"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sinh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o seno hiperbólico de <argname>x</argname>.
	</para>
	<para context="tex">
	  \[ \sinh x = \frac{e^x - e^{-x}}{2}  \]
	</para>
	<para>
	  <seelist>
            <fncref targ="asinh"/>
            <fncref targ="cosh"/>
            <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="skewness" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o valor de assimetria para a série <argname>x</argname>,
	  descartando queisquer observações ausentes.
	</para>
      </description>
    </function>

    <function name="sleep" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="int">ns</fnarg>
      </fnargs>
      <description>
	<para>
	  Not of any direct use for econometrics, but can be useful
	  for testing parallelization methods. This function simply
	  causes the current thread to <quote>sleep</quote>&mdash;that
	  is, do nothing&mdash;for <argname>ns</argname> seconds. On
	  wake-up, the function returns 0.
	</para>
      </description>
    </function>

    <function name="sort" section="matshape" output="asinput">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Ordena <argname>x</argname> de forma ascendente, descartando
	  observações com valores ausentes quando <math>x</math> for uma
	  série.
	  <seelist>
            <fncref targ="dsort"/>
            <fncref targ="values"/>
	  </seelist>
	  Especificamente para matrizes veja <fncref targ="msortby"/>.
	</para>
      </description>
    </function>

    <function name="sortby" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y1</fnarg>
	<fnarg type="series">y2</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma série contendo os elementos de <argname>y2</argname>
	  ordenados de acordo com os valores crescente do primeiro argumento
	  <argname>y1</argname>.
	  <seelist>
            <fncref targ="sort"/>
            <fncref targ="ranking"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sprintf" section="strings" output="string">
      <fnargs>
	<fnarg type="string">format</fnarg>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  The returned variável de texto (<quote>string</quote>) is constructed by printing the values of
	  the trailing arguments, indicated by the dots above, under
	  the control of <argname>format</argname>. It is meant to
	  give you great flexibility in creating variável de textos. The
	  <argname>format</argname> is used to specify the precise way
	  in which you want the arguments to be printed.
	</para>
	<para>
	  In general, <argname>format</argname> must be an expression
	  that evaluates to a variável de texto, but in most cases will just be a
	  variável de texto literal (an alphanumeric sequence surrounded by
	  double quotes). Some character sequences in the format have
	  a special meaning: those beginning with the percent
	  character (%) are interpreted as <quote>placeholders</quote>
	  para os items contained in the argument list; moreover,
	  special characters such as the newline character are
	  represented via a combination beginning with a backslash.
	</para>
	<para>
	  Por exemplo, o códgo abaixo
	</para>
	<code>
	  scalar x = sqrt(5)
	  string claim = sprintf("sqrt(%d) is (roughly) %6.4f.\n", 5, x)
	  print claim
	</code>
	<para>
	  produzirá
	</para>
	<code>
	  sqrt(5) is (roughly) 2.2361.
	</code>
	<para>
	  onde <lit>%d</lit> indicates that we want an integer at
	  that place in the output; since it is the leftmost
	  <quote>percent</quote> expression, it is matched to the
	  first argument, that is 5. The second special sequence is
	  <lit>%6.4f</lit>, which stands for a decimal value with 4
	  digits after the decimal separator and at least 6 digits
	  wide. The number of such sequences must match the number
	  of arguments following the format variável de texto.
	</para>
	<para>
	  See the help page para o <cmdref targ="printf"/> command
	  for more details about the syntax you can use in format
	  variável de textos.
	</para>
      </description>
    </function>

    <function name="sqrt" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a raíz quadrada positiva de <argname>x</argname>. Gera
	  <lit>NA</lit> quando utilizada em valores negativos.
	</para>
	<para>
	  Note que se o argumento for uma matriz, a operação será realizada para
	  cada elemento. Além disso, dado que as matrizes não podem conter valores
	  <lit>NA</lit>, a função irá gerar um erro se exitirem valores negativos.
	  Para a <quote>raíz quadrada matricial</quote> veja <fncref targ="cholesky"/>.
	</para>
      </description>
    </function>

    <function name="square" section="transforms" output="list">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg optional="true" type="bool">cross-products</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma lista cotendo os quadrados das variáveis na lista
	  <argname>L</argname>. Seus elementos são nomeados de acordo
	  com o seguinte esquema :<lit>sq_</lit><repl>varname</repl>. Se
	  o segundo argumento (opcional) estiver presente e tiver um valor
	  não-nulo, a lista também incluirá os produtos cruzados dos elementos
	  de <argname>L</argname> que, por sua vez, são nomeados de acordo com
	  o seguinte esquema: <repl>var1</repl><lit>_</lit><repl>var2</repl>.
	  Nesses esquemas os nomes das séries de entrada serão truncados caso
	  seja necessário e os nomes de saída podem ser ajustados em caso de
	  de nomes duplicados na lista retornada.
	</para>
      </description>
    </function>

    <function name="sscanf" section="strings" output="int">
      <fnargs>
	<fnarg type="string">src</fnarg>
	<fnarg type="string">format</fnarg>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Reads values from <argname>src</argname> under the control
	  of <argname>format</argname> and assigns these values to one
	  or more trailing arguments, indicated by the dots above.
	  Retorna o número of values assigned. This is a simplified
	  version of the <lit>sscanf</lit> function in the C
	  programming language.
	</para>
	<para>
	  <repl>src</repl> may be either a literal variável de texto (<quote>string</quote>), enclosed
	  in double quotes, or the name of a predefined variável de texto
	  variável.  <repl>format</repl> is defined similarly to the
	  format variável de texto in <cmdref targ="printf"/> (more on this
	  below). <repl>args</repl> should be a comma-separated list
	  contendo the names of pre-defined variáveis: these are the
	  targets of conversion from <repl>src</repl>.  (For those
	  used to C: one can prefix the names of numerical variáveis
	  with <lit>&amp;</lit> but this is not required.)
	</para>
	<para>
	  Literal text in <repl>format</repl> is matched against
	  <repl>src</repl>.  Conversion specifiers start with
	  <lit>%</lit>, and recognized conversions include
	  <lit>%f</lit>, <lit>%g</lit> or <lit>%lf</lit> for
	  floating-point numbers; <lit>%d</lit> for integers;
	  <lit>%s</lit> for variável de textos; and <lit>%m</lit> for matrizes.
	  You may insert a positive integer after the percent sign:
	  this sets the maximum number of characters to read para a
	  given conversion (or the maximum number of rows in the case
	  of matrix conversion). Alternatively, you can insert a
	  literal <lit>*</lit> after the percent to suppress the
	  conversion (thereby skipping any characters that would
	  otherwise have been converted para o given type).  For
	  example, <lit>%3d</lit> converts the next 3 characters in
	  <repl>source</repl> to an integer, if possible;
	  <lit>%*g</lit> skips as many characters in
	  <repl>source</repl> as could be converted to a single
	  floating-point number.
	</para>
	<para>
	  Matrix conversion works thus: the scanner reads a line of
	  input and counts the (space- or tab-separated) number of
	  numeric fields.  This defines the number of columns in the
	  matrix.  By default, reading then proceeds for as many lines
	  (rows) as contain the same number of numeric columns, but
	  the maximum number of rows to read can be limited as
	  described above.
	</para>
	<para>
	  In addition to <lit>%s</lit> conversion for variável de textos, a
	  simplified version of the C format
	  <lit>%</lit><repl>N</repl><lit>[</lit><repl>chars</repl><lit>]</lit>
	  is available.  In this format <repl>N</repl> is the maximum
	  number of characters to read and <repl>chars</repl> is a set
	  of acceptable characters, enclosed in square brackets:
	  reading stops if <repl>N</repl> is reached or if a character
	  not in <repl>chars</repl> is encountered. The function of
	  <repl>chars</repl> can be reversed by giving a circumflex,
	  <lit>^</lit>, as the first character; in that case reading
	  stops if a character in the given set is found.  (Unlike C,
	  the hyphen does not play a special role in the
	  <repl>chars</repl> set.)
	</para>
	<para>
	  If the source variável de texto does not (fully) match the format, the
	  number of conversions may fall short of the number of
	  arguments given.  This is not in itself an error so far as
	  gretl is concerned.  However, you may wish to check the
	  number of conversions performed; this is given by the
	  return value.
	</para>
	<para>
	  Some exemplos follow:
	</para>
	<code>
	  scalar x
	  scalar y
	  sscanf("123456", "%3d%3d", x, y)

	  sprintf S, "1 2 3 4\n5 6 7 8"
	  S
	  matrix m
	  sscanf(S, "%m", m)
	  print m
	</code>
      </description>
    </function>

    <function name="sst" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a soma dos quadrados dos desvios em relação à média
	  das observações não ausentes na série <argname>y</argname>.
	  <seelist>
            <fncref targ="var"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="stringify" section="strings" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="strings">S</fnarg>
      </fnargs>
      <description>
	<para>
	  Provides a means of defining variável de texto (<quote>string</quote>) values para a series
	  <argname>y</argname>. Two conditions must be satisfied for
	  this to work: the target series must have nothing but
	  integer values, none of them less than 1, and the arranjo (<quote>array</quote>)
	  <argname>S</argname> must have at least <math>n</math>
	  elements onde <math>n</math> is the largest value in
	  <argname>y</argname>.  In addition each element of
	  <argname>S</argname> must be valid UTF-8.
	  <seelist>
            <fncref targ="strvals"/>
	  </seelist>
	</para>
	<para>
	  The value returned is zero on success or a positive error
	  code on error.
	</para>
      </description>
    </function>

    <function name="strlen" section="strings" output="int">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o número de caracteres no texto (<quote>string</quote>)
	  <argname>s</argname>. Note que isso não será necessariamente
	  igual ao número de bytes se alguns caracteres estiverem fora
	  do intervalo de impressão ASCII.
	</para>
    <para>
        Exemplo:
    </para>
    <code>
        string s = "regression"
        scalar number = strlen(s)
        print number
    </code>
      </description>
    </function>

    <function name="strncmp" section="strings" output="int">
      <fnargs>
	<fnarg type="string">s1</fnarg>
	<fnarg type="string">s2</fnarg>
	<fnarg optional="true" type="int">n</fnarg>
      </fnargs>
      <description>
	<para>
	  Compara dois textos (<quote>string</quote>) e retorna um
	  inteiro menor que, igual ou maior que 0 se <argname>s1</argname>
	  se for, respectivamente menor que, igual ou maior que
	  <argname>s2</argname>, até o primeiro caractere <argname>n</argname>.
	  Se <argname>n</argname> for omitido a comparação irá prosseguir
	  até onde for possível.
	</para>
	<para>
	  Caso deseje apenas verificar se dois textos são iguais não é
	  necessário utilizar esta função. Ao invés disso é pode-se usar
	  a seguinte expressão: <lit>if (s1 == s2)...</lit>.
	</para>
      </description>
    </function>

    <function name="strsplit" section="strings" output="string-or-strings">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg optional="true" type="int">i</fnarg>
      </fnargs>
      <description>
	<para>
	  Sem um segundo argumento, retorna o arranjo (<quote>array
	  </quote>) com textos (<quote>string</quote>) resultante da
	  separação de <argname>s</argname> de acordo com os espaços
	  em branco.
	</para>
	<para>
	  Se for fornecido um segundo argumento, retorna o elemento
	  <argname>i</argname> do texto <argname>s</argname>, após ter
	  sido separado por espaços. O índice <argname>i</argname> tem
	  base 1 e irá gerar um erro se <argname>i</argname> for menor
	  que 1. Caso <argname>s</argname> não contiver espaços e <argname>
	  i</argname> for igual a 1, uma cópia do texto será retornada.
	  Se <argname>i</argname> exceder o número de elementos separados
	  por espaços, uma variável de texto vazia será retornada.
	</para>
    <para>
        Exemplos:
    </para>
    <code>
        string basket = "banana apple jackfruit orange"

        strings fruits = strsplit(basket)
        eval fruits[1]
        eval fruits[2]
        eval fruits[3]
        eval fruits[4]

        string favorite = strsplit(basket, 3)
        eval favorite
    </code>
      </description>
    </function>

    <function name="strstr" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s1</fnarg>
	<fnarg type="string">s2</fnarg>
      </fnargs>
      <description>
	<para>
	  Procura em <argname>s1</argname> o texto <argname>s2</argname>.
	  Se o texto for encontrado a função retorna uma cópia da parte
	  de <argname>s1</argname> que começa com <argname>s2</argname>,
	  caso contrário retorna um texto vazio.
	</para>
    <para>
        Exemplo:
    </para>
    <code>
        string s1 = "Gretl is an econometrics package"
        string s2 = strstr(s1, "an")
        print s2
    </code>
      </description>
    </function>

    <function name="strstrip" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma cópia de <argname>s</argname> na qual os espaços
	  em branco do início e do fim do texto são removidos.
	</para>
    <para>
        Exemplo:
    </para>
    <code>
        string s1 = "    A lot of white space.  "
        string s2 = strstrip(s1)
        print s1 s2
    </code>
      </description>
    </function>

    <function name="strsub" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg type="string">find</fnarg>
	<fnarg type="string">subst</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma cópia de <argname>s</argname> na qual todas as
	  ocorrências de <argname>find</argname> são substituídas por
	  <argname>subst</argname>. Veja também <fncref targ="regsub"/>
	  para substituições mais complexas via expressões regulares.
	</para>
    <para>
        Exemplo:
    </para>
    <code>
        string s1 =  "Hello, Gretl!"
        string s2 = strsub(s1, "Gretl", "Hansl")
        print s2
    </code>
      </description>
    </function>

    <function name="strvals" section="strings" output="strings">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  If the series <argname>y</argname> is variável de texto (<quote>string</quote>)-valued,
	  returns an arranjo (<quote>array</quote>) contendo all its distinct values,
	  ordered by the associated numerical values starting
	  at 1. If <argname>y</argname> is not variável de texto-valued an
	  empty variável de textos array is returned.
	  <seelist>
            <fncref targ="stringify"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="substr" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg type="int">start</fnarg>
	<fnarg type="int">end</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma parte do texto <argname>s</argname>
	  começando em <argname>start</argname> e terminando
	  em <argname>end</argname>, inclusive.
	</para>
    <para>
        Exemplos:
    </para>
    <code>
        string s1 = "Hello, Gretl!"
        string s2 = substr(s1, 8, 12)
        print s2

        string s3 = substr("Hello, Gretl!", 8, 12)
        print s3
    </code>
      </description>
    </function>

    <function name="sum" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="smlist">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>x</argname> for uma série, retorna a soma,
	  na forma de um escalar, das observações não ausentes em
	  <argname>x</argname>. Veja também <fncref targ="sumall"/>.
	</para>
	<para>
	  Se <argname>x</argname> for uma matriz, retorna a soma dos
	  elementos da matriz.
	</para>
	<para>
	  Se <argname>x</argname> for uma lista, retorna uma série
	  <math>y</math> na qual <math>y</math><sub>t</sub> é a
	  soma dos valores das variáveis da lista na observação
	  <math>t</math>, ou <lit>NA</lit> se existir qualquer valor
	  ausente em <math>t</math>.
	</para>
      </description>
    </function>

    <function name="sumall" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a soma das observações de <argname>x</argname> dentro
	  da amostra selecionada. Se existir qualquer valor ausente a
	  função retornará <lit>NA</lit>. Use <fncref targ="sum"/>
	  caso deseje que os valores correntes sejam descartados.
	</para>
      </description>
    </function>

    <function name="sumc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna um vetor com a soma das colunas de <argname>X</argname>
	  <seelist>
            <fncref targ="meanc"/>
            <fncref targ="sumr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sumr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna um vetor com a soma das linhas de <argname>X</argname>
	  <seelist>
            <fncref targ="meanr"/>
            <fncref targ="sumc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="svd" section="linalg" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;V</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Performs the singular values decomposition decomposição em valores singulares of the matrix
	  <argname>X</argname>.
	</para>
	<para context="tex">
	  Performs the singular values decomposition decomposição em valores singulares of the $r \times c$
	  matrix $X$:
	  \[ X = U \left[
	  \begin{array}{cccc}
	  \sigma_1 \\
	  &amp; \sigma_2 \\
	  &amp; &amp; \ddots \\
	  &amp; &amp; &amp; \sigma_n ,
	  \end{array}
	  \right] V \]
	  onde $n = \min(r,c)$. $U$ is $r \times
	  n$ and $V$ is $n \times c$, with $U'U = I$ and $VV' = I$.
	</para>
	<para>
	  The singular values are returned in a row vector.  The left
	  and/or right singular vectors <math>U</math> and <math>V</math>
	  may be obtained by supplying non-null values for arguments 2 and
	  3, respectively.  For any matrix <lit>A</lit>, the code
	</para>
	<code>
	  s = svd(A, &amp;U, &amp;V)
	  B = (U .* s) * V
	</code>
	<para>
	  should yield <lit>B</lit> identical to <lit>A</lit> (apart from
	  machine precision).
	</para>
	<para>
	  <seelist>
            <fncref targ="eigengen"/>
            <fncref targ="eigensym"/>
            <fncref targ="qrdecomp"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="tan" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a tangente de <argname>x</argname>.
	  <seelist>
            <fncref targ="atan"/>
            <fncref targ="cos"/>
            <fncref targ="sin"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="tanh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a tangente hiperbólica de <argname>x</argname>.
	</para>
	<para context="tex">
	  \[ \tanh x = \frac{e^{2x} - 1}{e^{2x} + 1}  \]
	</para>
	<para>
	  <seelist>
            <fncref targ="atanh"/>
            <fncref targ="cosh"/>
            <fncref targ="sinh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="toepsolv" section="linalg" output="cvec">
      <fnargs>
	<fnarg type="vector">c</fnarg>
	<fnarg type="vector">r</fnarg>
	<fnarg type="vector">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Solves a Toeplitz system of linear equations, that is
	  <math>Tx = b</math> onde <math>T </math> is a square matrix
	  whose element <math>T</math><sub>i,j</sub> equals
	  <math>c</math><sub>i-j</sub> for
	  <equation status="inline"
	  ascii="i&gt;=j" tex="$i\ge j$"/>
	  and <math>r</math><sub>j-i</sub> for
	  <equation status="inline" ascii="i&lt;=j"
	  tex="$i\le j$"/>.
	  Note that the first elements of <math>c</math> and
	  <math>r</math> must be equal, otherwise an error is
	  returned. Upon successful completion, the function returns
	  the vector <math>x</math>.
	</para>
	<para>
	  The algorithm used here takes advantage of the special
	  structure of the matrix <math>T</math>, which makes it much
	  more efficient than other unspecialized algorithms,
	  especially for large problems. Warning: in certain cases,
	  the function may spuriously issue a singularity error when
	  in fact the matrix <math>T</math> is nonsingular; this
	  problem, however, cannot arise when <math>T</math> is
	  positive definite.
	</para>
      </description>
    </function>

    <function name="tolower" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma cópia de <argname>s</argname> na qual todos os
	  caracteres maiúsculos são convertidos em minúsculos.
	</para>
    <para>
        Exemplos:
    </para>
    <code>
        string s1 = "Hello, Gretl!"
        string s2 = tolower(s1)
        print s2

        string s3 = tolower("Hello, Gretl!")
        print s3
    </code>
      </description>
    </function>

    <function name="toupper" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma cópia de <argname>s</argname> na qual todos os
	  caracteres minúsculos são convertidos em maiúsculos.
	</para>
    <para>
        Exemplos:
    </para>
    <code>
        string s1 = "Hello, Gretl!"
        string s2 = toupper(s1)
        print s2

        string s3 = toupper("Hello, Gretl!")
        print s3
    </code>
      </description>
    </function>

    <function name="tr" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o traço de uma matriz quadrada <argname>A</argname>,
	  isto é, a soma dos elementos de sua diagonal.
	  <seelist>
            <fncref targ="diag"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="transp" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna a transposta de <argname>X</argname>. Observação: esta função é
	  raramente utilizada. Para transpor uma matriz, na maior parte dos casos,
	  pode-se simplesmente utilizar o operador de transposição: <lit>X'</lit>.
	</para>
      </description>
    </function>

    <function name="trimr" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">ttop</fnarg>
	<fnarg type="int">tbot</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma cópia da matriz <argname>X</argname> com <argname>
	  ttop</argname> linhas superiores excluídas e <argname>tbot</argname>
	  linhas inferiores excluídas. Os dois últimos argumentos devem ser
	  não-negativos e sua soma deve ser menor que o total de linhas de
	  <argname>X</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="selifr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="typeof" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">name</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a numeric type-code if <argname>name</argname> is
	  the identifier of a currently defined object: 1 for scalar,
	  2 for series, 3 for matrix, 4 for string, 5 for bundle, 6
	  for array and 7 for list. Otherwise returns 0.  The function
	  <fncref targ="typestr"/> may be used to get the string
	  corresponding to the return value.
	</para>
	<para>
	  This function can also be used to retrieve the type of
	  a bundle member or array element. For example:
	</para>
	<code>
	  matrices M = array(1)
	  eval typestr(typeof(M))
	  eval typestr(typeof(M[1]))
	</code>
	<para>
	  The first <lit>eval</lit> result is <quote>array</quote> and
	  the second is <quote>matrix</quote>.
	</para>
      </description>
    </function>

    <function name="typestr" section="data-utils" output="string">
      <fnargs>
	<fnarg type="int">typecode</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o nome do tipo de dado correspondente a
	  <argname>typecode</argname>. Pode ser utilizada
	  em conjunto com as funções <fncref targ="typeof"/>
	  e <fncref targ="inbundle"/>. O valor retornado pode
	  ser <quote>scalar</quote>, <quote>series</quote>,
	  <quote>matrix</quote>, <quote>string</quote>,
	  <quote>bundle</quote>, <quote>array</quote> ou
	  <quote>null</quote>.
	</para>
      </description>
    </function>

    <function name="uniform" section="probdist" output="series">
      <fnargs>
	<fnarg type="scalar">a</fnarg>
	<fnarg type="scalar">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Cria uma variável pseudo-aleatória uniforme no intervalo (<argname>
	  a</argname>, <argname>b</argname>) ou, se não forem fornecidos
	  argumentos, será utilizado o intervalo (0,1). O algoritmo utilizado
	  por padrão é o <quote>SIMD-oriented Fast Mersenne Twister</quote>
	  desenvolvido por <cite key="saito_matsumoto08">Saito and Matsumoto
	  (2008)</cite>.
	</para>
	<para>
	  <seelist>
            <fncref targ="randgen"/>
            <fncref targ="normal"/>
            <fncref targ="mnormal"/>
            <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="uniq" section="stats" output="cvec">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna um vetor contendo os elementos distintos de <argname>x
	  </argname> de forma não ordenada, mas na ordem em que aparecem
	  em <argname>x</argname>. Veja <fncref targ="values"/> para a
	  variante desta função que retorna os valores ordenados.
	</para>
      </description>
    </function>

    <function name="unvech" section="matbuild" output="smatrix">
      <fnargs>
	<fnarg type="vector">v</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma matriz simétrica de ordem <by r="n" c="n"/>
	  rearranjando os elementos de <math>v</math>. O número de
	  elementos de <math>v</math> deve ser um inteiro triangular,
	  ou seja, um número <math>k</math> tal que exista um inteiro
	  <math>n</math> que tenha a seguinte propriedade: <equation
          status="inline" ascii="k = n(n+1)/2"
          tex="$k = n(n+1)/2$"/>. Esta função é a inversa de
	  <fncref targ="vech"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="mshape"/>
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="upper" section="matbuild" output="smatrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Retorna uma matriz triangular superior de ordem <by r="n" c="n"/>.
	  Os elementos da diagonal e acima desta são iguais aos elementos
	  correspondentes de <argname>A</argname> e os demais iguais a zero.
	</para>
	<para context="tex">
	  Retorna uma matriz triangular superior <math>B</math> de ordem
	  $n\times n$ onde $B_{ij} = A_{ij}$ se $i \le j$, e 0 caso contrário.
	</para>
	<para>
	  <seelist>
            <fncref targ="lower"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="urcpval" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="scalar">tau</fnarg>
	<fnarg type="int">n</fnarg>
	<fnarg type="int">niv</fnarg>
	<fnarg type="int">itv</fnarg>
      </fnargs>
      <description>
	<para>
	  <math>P</math>-valores para a estatística de teste do teste
	  de raízes unitárias de Dickey&ndash;Fuller e do teste de
	  cointegração de Engle&ndash;Granger, conforme <cite
	  key="mackinnon96">James MacKinnon (1996)</cite>.
	</para>
	<para>
	  The arguments are as follows: <argname>tau</argname> denotes
	  the estatística de teste; <argname>n</argname> is the number of
	  observações (or 0 for an asymptotic result);
	  <argname>niv</argname> is the number of potentially
	  cointegrated variáveis when testing for cointegração (or 1
	  for a univariate unit-root test); and <argname>itv</argname>
	  is a code para o model specification: 1 for no constant, 2
	  for constant included, 3 for constant and linear trend, 4
	  for constant and quadratic trend.
	</para>
	<para>
	  Note that if the test regression is <quote>augmented</quote>
	  with lags of the dependent variável, then you should give an
	  <argname>n</argname> value of 0 to get an asymptotic result.
	</para>
	<para>
	  <seelist>
            <fncref targ="pvalue"/>
	    <fncref targ="qlrpval"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="values" section="stats" output="cvec">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna um vetor contendo os elementos distintos de
	  <argname>x</argname> ordenados de forma ascendente. Caso
	  deseje truncar a parte decimal antes de aplicar a função,
	  utilize a expressão <lit>values(int(x))</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="uniq"/>
            <fncref targ="dsort"/>
            <fncref targ="sort"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="var" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  If <argname>x</argname> is a series, returns the (scalar) sample
	  variance, skipping any missing observações.
	</para>
	<para>
	  If <argname>x</argname> is a list, retorna uma série
	  <math>y</math> such that <math>y</math><sub>t</sub> is the
	  sample variance of the values of the variáveis in the list
	  at observation <math>t</math>, or <lit>NA</lit> if there are
	  any valores ausentes at <math>t</math>.
	</para>
	<para>
	  In each case the sum of squared deviations from the mean is
	  divided by (<math>n</math> &minus; 1) for <math>n</math>
	  &gt; 1. Otherwise the variance is given as zero if
	  <math>n</math> = 1, or as <lit>NA</lit> if <math>n</math> =
	  0.
	</para>
	<para>
	  <seelist>
            <fncref targ="sd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="varname" section="strings" output="string">
      <fnargs>
	<fnarg type="int-or-list">v</fnarg>
      </fnargs>
      <description>
	<para>
	  Se for utilizado um inteiro como argumento, a função retorna o
	  nome da variável com número ID igual a <argname>v</argname> ou
	  um erro se esta variável não existir.
	</para>
	<para>
	  Se for utilizado uma lista como argumento, retorna o texto
	  (<quote>string</quote>) contendo os nomes das variáveis na lista,
	  separados por vírgulas. Se for fornecida uma lista vazia será
	  retornado um texto vazio. Para obter um arranjo (<quote>array
	  </quote>) de textos pode-se utilizar <fncref targ="varnames"/>.
	</para>
    <para>
        Exemplo:
    </para>
    <code>
        open broiler.gdt
        string s = varname(7)
        print s
    </code>
      </description>
    </function>

    <function name="varnames" section="strings" output="strings">
      <fnargs>
	<fnarg type="list">L</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna um arranjo (<quote>array</quote>) de textos (<quote>string
	  </quote>) contendo os names das variáveis na lista <argname>L</argname>.
	  Se a lista for vazia será retornado um arranjo vazio.
	</para>
    <para>
        Exemplo:
    </para>
    <code>
        open keane.gdt
        list L = year wage status
        strings S = varnames(L)
        eval S[1]
        eval S[2]
        eval S[3]
    </code>
      </description>
    </function>

    <function name="varnum" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">varname</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o número ID da variável
	  <argname>varname</argname> ou NA
	  se a variável não existir.
	</para>
      </description>
    </function>

    <function name="varsimul" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix">U</fnarg>
	<fnarg type="matrix">y0</fnarg>
      </fnargs>
      <description>
	<para>
	  Simulates a <math>p</math>-order <math>n</math>-variável
	  VAR, that is
	  <equation status="inline"
		    ascii="y(t) = A1 y(t-1) + ... + Ap y(t-p) + u(t)."
		    tex="$y_t = \sum_{i=1}^p A_i y_{t-i} + u_t$."/>
	  The coefficient matrix <argname>A</argname> is composed by
	  stacking the <math>A</math><sub>i</sub> matrizes horizontally;
	  it is <by r="n" c="np"/>, with one row per equation. This
	  corresponds to the first <math>n</math> rows of the matrix
	  <lit>$compan</lit> provided by gretl's <lit>var</lit> and
	  <lit>vecm</lit> commands.
	</para>
	<para>
	  The <math>u_t</math> vectors are contained (as rows) in
	  <argname>U</argname> (<by r="T" c="n"/>). Initial values are in
	  <argname>y0</argname> (<by r="p" c="n"/>).
	</para>
	<para>
	  If the VAR contains deterministic terms and/or exogenous
	  regressors, these can be handled by folding them into the
	  <argname>U</argname> matrix: each row of <argname>U</argname>
	  then becomes
	  <equation status="inline"
		    ascii="u(t) = B'x(t) + e(t)."
		    tex="$u_t = B' x_t + e_t$."/>
	</para>
	<para>
	  The output matrix has <math>T</math> + <math>p</math> rows
	  and <math>n</math> columns; it holds the initial
	  <math>p</math> values of the endogenous variáveis plus
	  <math>T</math> simulated values.
	</para>
	<para>
	  <seelist>
            <fncref targ="$compan"/>
            <cmdref targ="var"/>
            <cmdref targ="vecm"/>
	  </seelist>
	</para>

      </description>
    </function>

    <function name="vec" section="matbuild" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Empilha as colunas de <argname>X</argname> como um vetor coluna.
	  <seelist>
            <fncref targ="mshape"/>
            <fncref targ="unvech"/>
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="vech" section="matbuild" output="cvec">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna em um vetor coluna os elementos de <argname>A</argname>
	  que estão em sua diagonal e acima dela. Normalmente essa função
	  é utilizada em matrizes simétricas. Neste caso a essa operação
	  pode ser revertida através da função <fncref targ="unvech"/>.
	  <seelist>
            <fncref targ="vec"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="weekday" section="calendar" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-series">ano</fnarg>
	<fnarg type="scalar-or-series">mês</fnarg>
	<fnarg type="scalar-or-series">dia</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o dia da semana (domingo = 0, segunda-feira = 1,
	  etc.) para a(s) data(s) especificadas por três argumentos
	  ou <lit>NA</lit> se a data for inválida. Note que os três
	  argumentos devem ser do mesmo tipo, ou seja, devem ser
	  todos do tipo escalar (inteiro) ou todos do tipo séries.
	</para>
      </description>
    </function>

    <function name="wmean" section="stats" output="series">
      <fnargs>
	<fnarg type="list">Y</fnarg>
	<fnarg type="list">W</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma série <math>y</math> tal que
	  <math>y</math><sub>t</sub> é a média ponderada dos
	  valores das variáveis na lista <argname>Y</argname> na
	  observação <math>t</math>, com os respectivos pesos dados pelos
	  valores das variáveis na lista <argname>W</argname> em
	  <math>t</math>. Os pesos podem assim variar
	  no tempo. As listas <argname>Y</argname> e
	  <argname>W</argname> devem ter o mesmo tamanho e os
	  pesos devem ser não-negativos.
	</para>
	<para>
	  <seelist>
            <fncref targ="wsd"/>
            <fncref targ="wvar"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="wsd" section="stats" output="series">
      <fnargs>
	<fnarg type="list">Y</fnarg>
	<fnarg type="list">W</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma série <math>y</math> tal que
	  <math>y</math><sub>t</sub> é o desvio padrão amostral
	  poderado dos valores das variáveis na lista
	  <argname>Y</argname> na observação <math>t</math>, com os
	  respectivos pesos dados pelos valores das variáveis na
	  lista <argname>W</argname> em <math>t</math>. Os pesos
	  podem assim variar no tempo. As listas
	  <argname>Y</argname> e <argname>W</argname> devem ter o
	  mesmo tamanho e os pesos devem ser não-negativos.
	</para>
	<para>
	  <seelist>
            <fncref targ="wmean"/>
            <fncref targ="wvar"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="wvar" section="stats" output="series">
      <fnargs>
	<fnarg type="list">X</fnarg>
	<fnarg type="list">W</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma série <math>y</math> tal que
	  <math>y</math><sub>t</sub> é a variância amostral
	  poderada dos valores das variáveis na lista
	  <argname>Y</argname> na observação <math>t</math>, com os
	  respectivos pesos dados pelos valores das variáveis na
	  lista <argname>W</argname> em <math>t</math>. Os pesos
	  podem assim variar no tempo. As listas
	  <argname>Y</argname> e <argname>W</argname> devem ter o
	  mesmo tamanho e os pesos devem ser não-negativos.
	</para>
	<para context="tex">
	  A variância amostral ponderada é calculada como:
	  \[ s^2_w = \frac{n'}{n'-1} \,
	  \frac{\sum_{i=1}^n w_i(x_i - \bar{x}_w)^2}{\sum_{i=1}^n w_i} \]
	  onde $n'$ é o número de pesos não-nulos e $\bar{x}_w$ é
	  a média ponderada.
	</para>
	<para>
	  <seelist>
            <fncref targ="wmean"/>
            <fncref targ="wsd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="xmax" section="math" output="scalar">
      <fnargs>
	<fnarg type="scalar">x</fnarg>
	<fnarg type="scalar">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o maior valor na comparação entre <argname>x</argname>
	  e <argname>y</argname>. Se algum dos valores for ausente será
	  retornado <lit>NA</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="xmin"/>
            <fncref targ="max"/>
            <fncref targ="min"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="xmin" section="math" output="scalar">
      <fnargs>
	<fnarg type="scalar">x</fnarg>
	<fnarg type="scalar">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna o menor valor na comparação entre <argname>x</argname>
	  e <argname>y</argname>. Se algum dos valores for ausente será
	  retornado <lit>NA</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="xmax"/>
            <fncref targ="max"/>
            <fncref targ="min"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="zeromiss" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Converte zeros para <lit>NA</lit>s. Se <argname>x</argname> for uma
	  série a conversão será feita elemento por elemento.
	  <seelist>
            <fncref targ="missing"/>
            <fncref targ="misszero"/>
            <fncref targ="ok"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="zeros" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Retorna uma matriz nula com <math>r</math> linhas e
	  <math>c</math> colunas.
      <seelist>
        <fncref targ="ones"/>
        <fncref targ="seq"/>
      </seelist>
    </para>
      </description>
    </function>

  </funclist>
</funcref>
