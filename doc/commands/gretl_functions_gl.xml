<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE funcref SYSTEM "gretl_functions.dtd">

<funcref language="galego">

  <funclist name="Accessors" ref="accessors">

    <function name="$ahat" section="access" output="series">
      <description>
	<para>
	  Debe de executarse logo de que o último modelo se estimase con datos de
	  panel de efectos fixos ou de efectos aleatorios. Devolve unha serie que
	  contén as estimacións dos efectos individuais.
	</para>
      </description>
    </function>

    <function name="$aic" section="access" output="scalar">
      <description>
	<para>
	  Se pode calcularse, devolve un escalar co valor do Criterio de
	  Información de Akaike (AIC) do último modelo estimado. Máis detalles
	  sobre o cálculo no <guideref targ="chap:criteria"/>.
	</para>
      </description>
    </function>

    <function name="$bic" section="access" output="scalar">
      <description>
	<para>
	  Se pode calcularse, devolve un escalar co valor do Criterio de
	  Información Bayesiano (BIC) de Schwarz do último modelo estimado.
	  Máis detalles sobre o cálculo no <guideref targ="chap:criteria"/>.
	</para>
      </description>
    </function>

    <function name="$chisq" section="access" output="scalar">
      <description>
	<para>
	  Se pode calcularse, devolve un escalar co valor do estatístico khi-cadrado
	  global da proba de Razón de Verosimilitudes do último modelo estimado.
	</para>
      </description>
    </function>

    <function name="$coeff" section="access" output="matrix" altout="scalar">
      <fnargs>
	<fnarg optional="true" type="coeffname">nome</fnarg>
      </fnargs>
      <description>
	<para>
	  Sen argumentos <lit>$coeff</lit> devolve un vector columna que contén
	  os coeficientes do último modelo estimado. Co argumento opcional de
	  texto <lit>(nome dun regresor)</lit> a función devolve un escalar co
	  valor do parámetro estimado dese regresor.
	  <seelist>
            <fncref targ="$stderr"/>
            <fncref targ="$vcv"/>
	  </seelist>
	</para>
	<para>
	  Exemplo:
	</para>
	<code>
	  open bjg
	  arima 0 1 1 ; 0 1 1 ; lg
	  b = $coeff               # Devolve un vector
	  macoef = $coeff(theta_1) # Devolve un escalar
	</code>
	<para>
	  Se o <quote>modelo</quote> en cuestión é un sistema de ecuacións,
	  o resultado depende das características deste; para VARs e VECMs
	  o resultado devolto é una matriz con unha columna por cada ecuación;
	  noutro caso, é un vector columna que contén os coeficientes da primeira
	  ecuación seguidos polos coeficientes da segunda ecuación e así de
	  maneira sucesiva.
	</para>
      </description>
    </function>

    <function name="$command" section="access" output="string">
      <description>
	<para>
	  Debe de executarse tras estimar un modelo, e devolve a cadea cos caracteres
	  da instrución utilizada (exemplo: <lit>ols</lit> ou <lit>probit</lit>).
	</para>
      </description>
    </function>

    <function name="$compan" section="access" output="matrix">
      <description>
	<para>
	  Debe de executarse logo da estimación dun VAR ou dun VECM, e devolve a
	  matriz compañeira.
	</para>
      </description>
    </function>

    <function name="$datatype" section="access" output="scalar">
      <description>
	<para>
	  Devolve un escalar enteiro que representa o tipo de datos que se están
	  utilizando nese momento: 0 = sen datos; 1 = datos de corte transversal;
	  2 = datos de series temporais; 3 = datos de panel.
	</para>
      </description>
    </function>

    <function name="$depvar" section="access" output="string">
      <description>
	<para>
	  Debe de executarse logo da estimación dun modelo con unha única ecuación,
	  e devolve unha cadea de texto co nome da variable dependente.
	</para>
      </description>
    </function>

    <function name="$df" section="access" output="scalar">
      <description>
	<para>
	  Devolve un escalar cos graos de liberdade do último modelo estimado.
	  Se este consiste nun sistema de ecuacións, o valor devolto é o número de graos
	  de liberdade por cada ecuación. Se os graos de liberdade das diferentes
	  ecuacións non son os mesmos en todas elas, entón o valor devolto se
	  calcula restando o número de observacións menos a media do número de
	  coeficientes das ecuacións (esta media arredóndase ao valor enteiro
	  inmediatamente superior).
	</para>
      </description>
    </function>

    <function name="$diagpval" section="access" output="scalar">
      <description>
	<para>
	  Debe de executarse logo da estimación dun sistema de ecuacións, e devolve
	  un escalar coa probabilidade asociada ao valor do estatístico
	  <fncref targ="$diagtest"/>.
	</para>
      </description>
    </function>

    <function name="$diagtest" section="access" output="scalar">
      <description>
	<para>
	  Debe de executarse logo da estimación dun sistema de ecuacións. Devolve
	  un escalar co valor do estatístico utilizado para probar a hipótese nula
	  de que a matriz de varianzas-covarianzas das perturbacións das ecuacións
	  do sistema, é diagonal. Esta é a proba de Breusch-Pagan, agás cando
	  o estimador é o dun SUR reiterado (sen restricións), pois nese caso é
	  unha proba de Razón de Verosimilitudes. Para obter máis detalles, véxase
	  o <guideref targ="chap:system"/> (tamén <fncref targ="$diagpval"/>).
	</para>
      </description>
    </function>

    <function name="$dotdir" section="access" output="string">
      <description>
	<para>
	  Este accesorio devolve unha cadea de texto coa ruta onde Gretl
	  garda ficheiros temporalmente, por exemplo cando usa a función
	  <fncref targ="mwrite"/> cun terceiro argumento distinto de cero.
	</para>
      </description>
    </function>

    <function name="$dw" section="access" output="scalar">
      <description>
	<para>
	  Devolve (se é posible) un escalar co valor do estatístico de Durbin&ndash;Watson
	  para probar autocorrelación de primeira orde no derradeiro modelo estimado.
	</para>
      </description>
    </function>

    <function name="$dwpval" section="access" output="scalar">
      <description>
	<para>
	  Se pode calcularse, devolve un escalar coa probabilidade asociada ao
	  valor do estatístico de Durbin-Watson do último modelo estimado.
	  Calcúlase utilizando o método Imhof.
	</para>
	<para>
	  Debido á limitada precisión da aritmética das computadoras, o resultado
	  do cálculo da integral do método Imhof pode volverse negativo cando
	  o estatístico de Durbin-Watson está próximo ao seu límite inferior;
	  por iso este accesorio devolve <lit>NA</lit> nesa situación. Dado que
	  calquera outra modalidade de fallo ten como resultado un erro que se
	  sinaliza, posiblemente sexa seguro asumir que un resultado NA indica que
	  a verdadeira probabilidade asociada é <quote>moi pequena</quote>,
	  aínda que non sexa posible cuantificala.
	</para>
      </description>
    </function>

    <function name="$ec" section="access" output="matrix">
      <description>
	<para>
	  Debe de executarse logo da estimación dun VECM, e devolve unha matriz que
	  contén os termos de Corrección de Erros. O número de filas é igual ao
	  número de observacións utilizadas, e o número de columnas é igual á orde
	  de cointegración do sistema.
	</para>
      </description>
    </function>

    <function name="$error" section="access" output="scalar">
      <description>
	<para>
	  Devolve un escalar cun dos códigos internos de fallo do programa. Ese
	  código é un valor non nulo cando ocorre un fallo pero é capturado usando
	  a función <cmdref targ="catch"/>. Cae na conta de que, ao utilizar este
	  accesorio, o código interno de fallo vólvese novamente cero. Se desexas
	  obter a mensaxe de fallo asociada a un <lit>$error</lit> en concreto,
	  é preciso gardar o seu valor nunha variable provisional, por exemplo
	  utilizando o código:
	</para>
	<code>
	  err = $error
	  if (err)
	      printf "Obtívose o fallo %d (%s)\n", err, errmsg(err);
	  endif
	</code>
	<para>
	  <seelist>
            <cmdref targ="catch"/>
            <fncref targ="errmsg"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$ess" section="access" output="scalar">
      <description>
	<para>
	  Se pode calcularse, devolve un escalar coa suma dos erros cadrados do
	  último modelo estimado.
	</para>
      </description>
    </function>

    <function name="$evals" section="access" output="matrix">
      <description>
	<para>
	  Debe de executarse logo da estimación dun VECM, e devolve un vector que
	  contén os autovalores que se utilizan no cálculo da proba da traza para
	  verificar se existe cointegración.
	</para>
      </description>
    </function>

    <function name="$fcast" section="access" output="matrix">
      <description>
	<para>
	  Debe de executarse logo da instrución de predición <cmdref targ="fcast"/>,
	  e devolve unha matriz cos valores previstos. Se o modelo que se utiliza
	  para facer as predicións é un sistema de ecuacións, a matriz está
	  formada por unha columna para cada ecuación; noutro caso, é un vector
	  columna.
	</para>
      </description>
    </function>

    <function name="$fcse" section="access" output="matrix">
      <description>
	<para>
	  Se pode calcularse, debe de executarse logo de procesar a instrución
	  <cmdref targ="fcast"/> e devolve unha matriz cas desviacións padrón
	  das predicións. Se o modelo que se utiliza para facer as predicións é
	  un sistema de ecuacións, a matriz está formada por unha columna para
	  cada ecuación; noutro caso, é un vector columna.
	</para>
      </description>
    </function>

    <function name="$fevd" section="access" output="matrix">
      <description>
	<para>
	  Debe de executarse logo da estimación dun VAR, e devolve unha matriz que
	  contén a descomposición da varianza dos erros de predición (FEVD, na
	  sigla en inglés). Esa matriz ten <math>h</math> filas que indican o
	  número de períodos do horizonte de predición, o cal pode escollerse
	  de forma manual por medio de <lit>set horizon</lit> ou de forma
	  automática en base á frecuencia dos datos.
	</para>
	<para>
	  Para un VAR con <math>p</math> variables, a matriz ten <math>p</math>
	  <sup>2</sup> columnas: as primeiras <math>p</math> columnas conteñen
	  a FEVD para a primeira variable do VAR; as <math>p</math> columnas
	  seguintes conteñen a FEVD para a segunda variable do VAR e así de
	  maneira sucesiva. A fracción (decimal) do erro de predición da variable
	  <math>i</math> causada por unha innovación na variable <math>j</math>
	  vai atoparse entón inspeccionando a columna (<math>i</math> &minus; 1)
	  <math>p</math> + <math>j</math>.
	</para>
	<para>
	  Para unha variante máis flexible desta funcionalidade, consulta a
	  función <fncref targ="fevd"/>.
	</para>
      </description>
    </function>

    <function name="$Fstat" section="access" output="scalar">
      <description>
	<para>
	  Se pode calcularse, devolve un escalar co estatístico F da proba de
	  validez global do último modelo estimado.
	</para>
      </description>
    </function>

    <function name="$gmmcrit" section="access" output="scalar">
      <description>
	<para>
	  Debe de executarse logo dun bloque <lit>gmm</lit> (do Método Xeneralizado
	  dos Momentos), e devolve un escalar co mínimo da función obxectivo.
	</para>
      </description>
    </function>

    <function name="$h" section="access" output="series">
      <description>
	<para>
	  Debe de executarse logo da instrución <lit>garch</lit>, e devolve unha
	  serie coas varianzas condicionais estimadas.
	</para>
      </description>
    </function>

    <function name="$hausman" section="access" output="rvec">
      <description>
	<para>
	  Debe de executarse logo de estimar un modelo por medio de <lit>tsls</lit>
	  ou <lit>panel</lit> coa opción de efectos aleatorios, e devolve un
	  vector fila <by r="1" c="3"/> que contén nesta orde: o valor do
	  estatístico da proba de Hausman, os graos de liberdade que
	  corresponden e a probabilidade asociada ao valor do estatístico.
	</para>
     </description>
    </function>

    <function name="$hqc" section="access" output="scalar">
      <description>
	<para>
	  Se pode calcularse, devolve un escalar co valor do Criterio de
	  Información de Hannan-Quinn para o último modelo estimado. Para
	  detalles sobre o cálculo, consulta o <guideref targ="chap:criteria"/>.
	</para>
      </description>
    </function>

    <function name="$huge" section="access" output="scalar">
      <description>
	<para>
	  Devolve un escalar cun número positivo moi grande. Por defecto é igual
	  a 1.0E100, pero pode cambiarse coa instrución <cmdref targ="set"/>.
	</para>
      </description>
    </function>

    <function name="$jalpha" section="access" output="matrix">
      <description>
	<para>
	  Debe de executarse logo de estimar un VECM, e devolve a matriz de carga.
	  O número de filas desa matriz é igual ao número de variables do VECM,
	  e o número de columnas é igual ao rango de cointegración.
	</para>
      </description>
    </function>

    <function name="$jbeta" section="access" output="matrix">
      <description>
	<para>
	  Debe de executarse logo de estimar un VECM, e devolve a matriz de
	  cointegración. O seu número de filas é igual ao número de variables do
	  VECM (máis o número de variables esóxenas que se restrinxen ao espazo
	  de cointegración, se hai algunha); e o seu número de columnas é igual
	  ao rango de cointegración.
	</para>
      </description>
    </function>

    <function name="$jvbeta" section="access" output="smatrix">
      <description>
	<para>
	  Debe de executarse logo de estimar un VECM, e devolve a matriz estimada de
	  varianzas-covarianzas dos elementos dos vectores de cointegración.
	</para>
	<para>
	  No caso de tratarse dunha estimación sen restricións, o número de filas
	  desa matriz é igual ao número de elementos non restrinxidos do espazo
	  de cointegración, logo da normalización de Phillips. Polo contrario, de
	  tratarse da estimación dun sistema restrinxido por medio da instrución
	  <lit>restrict</lit> coa opción <lit>--full</lit>, obtense unha matriz
	  singular con <math>(n+m)r</math> filas (onde <math>n</math> é o número
	  de variables endóxenas, <math>m</math> o número de variables esóxenas
	  restrinxidas ao espazo de cointegración e <math>r</math> o rango de
	  cointegración).
	</para>
	<para>
	  Exemplo: o código...
	</para>
	<code>
	  open denmark.gdt
	  vecm 2 1 LRM LRY IBO IDE --rc --seasonals -q
	  s0 = $jvbeta

	  restrict --full
	    b[1,1] = 1
	    b[1,2] = -1
	    b[1,3] + b[1,4] = 0
	  end restrict
	  s1 = $jvbeta

	  print s0
	  print s1
	</code>
	<para>
	  ... orixina o seguinte resultado:
	</para>
	<code>
	  s0 (4 x 4)

          0.019751     0.029816  -0.00044837   -0.12227
          0.029816     0.31005   -0.45823      -0.18526
         -0.00044837  -0.45823    1.2169       -0.035437
         -0.12227     -0.18526   -0.035437      0.76062

	  s1 (5 x 5)

	  0.0000       0.0000       0.0000       0.0000       0.0000
	  0.0000       0.0000       0.0000       0.0000       0.0000
	  0.0000       0.0000      0.27398     -0.27398    -0.019059
	  0.0000       0.0000     -0.27398      0.27398     0.019059
	  0.0000       0.0000    -0.019059     0.019059    0.0014180
	</code>
      </description>
    </function>

    <function name="$lang" section="access" output="string">
      <description>
	<para>
	  Devolve unha cadea de texto que representa o idioma que se está usando
	  (se este pode determinarse). A cadea de texto está composta por dúas
	  letras do código de linguaxe ISO 639-1 (por exemplo, <lit>en</lit>
	  para o idioma inglés, <lit>jp</lit> para o xaponés, <lit>el</lit> para
	  o grego) seguidas dun guión baixo máis outras dúas letras do código de
	  país ISO 3166-1. Así, por exemplo, o idioma portugués de Portugal
	  represéntase por <lit>pt_PT</lit> ao tempo que o idioma portugués do
	  Brasil represéntase por <lit>pt_BR</lit>.
	</para>
	<para>
	  Se non é posible determinar o idioma vixente, se devolve o texto
	  <quote><lit>unknown</lit></quote>.
	</para>
      </description>
    </function>

    <function name="$llt" section="access" output="series">
      <description>
	<para>
	  Para unha selección de modelos que se estiman polo método de Máxima
	  Verosimilitude, a función devolve unha serie cos valores do logaritmo
	  da verosimilitude para cada observación. Polo momento esa función só
	  está dispoñible para logit e probit binarios, tobit e heckit.
	</para>
      </description>
    </function>

    <function name="$lnl" section="access" output="scalar">
      <description>
	<para>
	  Devolve un escalar co logaritmo da verosimilitude do último modelo
	  estimado (se fose aplicable).
	</para>
      </description>
    </function>

    <function name="$macheps" section="access" output="scalar">
      <description>
	<para>
	  Devolve un escalar co valor do <quote>épsilon da máquina</quote>,
	  o cal proporciona un límite superior para o erro relativo debido ao
	  arredondamento na aritmética de punto flotante con dobre precisión.
	</para>
      </description>
    </function>

    <function name="$mapfile" section="access" output="string">
      <description>
	<para>
	  Devolve unha cadea de texto co nome do ficheiro que se debe abrir
	  para obter os polígonos do mapa, cando antes se cargaron datos dun
	  ficheiro GeoJSON ou dun ficheiro ESRI de forma; noutro caso,
	  devolve unha cadea baleira. Isto está deseñado para utilizarse coa
	  función <fncref targ="geoplot"/>.
	</para>
      </description>
    </function>

    <function name="$mnlprobs" section="access" output="matrix">
      <description>
	<para>
	  Debe de executarse tras estimar un modelo logit multinomial (unicamente),
	  e devolve unha matriz coas probabilidades estimadas de cada resultado
	  posible, en cada observación da mostra utilizada na estimación do
	  modelo. Cada liña representa unha observación e cada columna un
	  resultado.
	</para>
      </description>
    </function>

    <function name="$model" section="access" output="bundle">
      <description>
	<para>
	  Debe de executarse logo de estimar modelos cunha única ecuación, e
	  devolve un feixe (<quote>bundle</quote>) que contén varias unidades de
	  datos pertencentes ao modelo. Inclúense todos os accesorios habituais
	  dos modelos, que son designados mediante claves iguais aos nomes
	  deses accesorios habituais, sen o signo dólar inicial. Por exemplo,
	  os erros aparecen baixo a clave <lit>uhat</lit> e a suma de erros
	  cadrados baixo <lit>ess</lit>.
	</para>
	<para>
	  Dependendo do estimador, podes dispoñer de información adicional. As
	  claves para tal información é de agardar que sexan explicativas por si
	  mesmas. Para ver o que está dispoñible, podes gardar unha copia do
	  feixe e mostrar o seu contido, como por exemplo co código:
	</para>
	<code>
	  ols y 0 x
	  bundle b = $model
	  print b
	</code>
      </description>
    </function>

    <function name="$mpirank" section="access" output="int">
      <description>
	<para>
	  Cando se prepara Gretl con soporte MPI, e o programa está
	  funcionando en modo MPI, devolve a <quote>xerarquía</quote>
	  en base 0 ou número ID do proceso vixente. Doutro xeito, devolve
	  &minus;1.
	</para>
      </description>
    </function>

    <function name="$mpisize" section="access" output="int">
      <description>
	<para>
	  Cando se prepara Gretl con soporte MPI, e o programa está
	  funcionando en modo MPI, devolve o número de procesos MPI
	  que están funcionando nese momento. Doutro xeito, devolve 0.
	</para>
      </description>
    </function>

    <function name="$ncoeff" section="access" output="int">
      <description>
	<para>
	  Devolve un número enteiro coa cantidade de coeficientes estimados
	  no último modelo.
	</para>
      </description>
    </function>

    <function name="$nobs" section="access" output="int">
      <description>
	<para>
	  Devolve un número enteiro coa cantidade total de observacións que están
	  seleccionadas na mostra vixente. Relacionado: <fncref targ="$tmax"/>.
	</para>
      </description>
    </function>

    <function name="$now" section="access" output="vector">
      <description>
	<para>
	  Devolve un vector con 2 elementos: o primeiro indica o número
	  de segundos transcorridos dende o 01-01-1970 00:00:00 +0000
	  (UTC, ou Tempo Universal Coordinado), o que se utiliza amplamente
	  no mundo da informática para representar o tempo vixente;
	  e o segundo indica a data vixente en formato <quote>básico</quote>
	  ISO 8601, <lit>YYYYMMDD</lit>. Podes utilizar a función 
	  <fncref targ="strftime"/> para procesar o primeiro elemento, e a función
	  <fncref targ="epochday"/> para procesar o segundo elemento.
	</para>
      </description>
    </function>

    <function name="$nvars" section="access" output="int">
      <description>
	<para>
	  Devolve un número enteiro coa cantidade de variables incluídas no
	  conxunto vixente de datos (contando coa constante).
	</para>
      </description>
    </function>

    <function name="$obsdate" section="access" output="series">
      <description>
	<para>
	  Pode executarse cando o conxunto vixente de datos está formado por
	  series temporais con frecuencia decenal, anual, trimestral, mensual,
	  datadas semanalmente ou datadas diariamente. Tamén pode utilizarse con
	  datos de panel se a información temporal está axustada correctamente
	  (consulta a instrución <cmdref targ="setobs"/>). Devolve unha serie
	  formada por números con 8 díxitos co padrón <lit>YYYYMMDD</lit> (o
	  formato de datos <quote>básico</quote> do ISO 8601), que corresponden
	  ao día da observación, ou ao primeiro día da observación no caso dunha
	  frecuencia temporal menor que a diaria.
	</para>
	<para>
	  Estas series poden resultar de utilidade cando se emprega a instrución
	  <cmdref targ="join"/>.
	</para>
      </description>
    </function>

    <function name="$obsmajor" section="access" output="series">
      <description>
	<para>
	  Pode executarse cando as observacións do conxunto vixente de datos
	  teñen unha estrutura maior:menor, como en series temporais trimestrais
	  (ano:trimestre), en series temporais mensuais (ano:mes), datos de
	  horas (día:hora) e datos de panel (individuo:período). Devolve unha
	  serie que mantén a compoñente maior (de menor frecuencia), de cada
	  observación (por exemplo, o ano).
	</para>
	<para>
	  <seelist>
            <fncref targ="$obsminor"/>
            <fncref targ="$obsmicro"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$obsmicro" section="access" output="series">
      <description>
	<para>
	  Pode executarse cando as observacións do conxunto de vixente datos
	  teñen unha estrutura maior:menor:micro, como nas series temporais
	  datadas diariamente (ano:mes:día). Devolve unha serie que contén a
	  compoñente micro (de maior frecuencia) de cada observación (por
	  exemplo, o día).
	</para>
	<para>
	  <seelist>
            <fncref targ="$obsmajor"/>
            <fncref targ="$obsminor"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$obsminor" section="access" output="series">
      <description>
	<para>
	  Pode executarse cando as observacións do conxunto vixente de datos
	  teñen unha estrutura maior:menor, como en series temporais trimestrais
	  (ano:trimestre), series temporais mensuais (ano:mes), datos de horas
	  (día:hora) e datos de panel (individuo:período). Devolve unha serie
	  que contén a compoñente menor (de maior frecuencia) de cada
	  observación (por exemplo, o mes).
	</para>
	<para>
	  No caso de datos datados diariamente, <lit>$obsminor</lit> devolve
	  unha serie co mes de cada observación.
	</para>
	<para>
	  <seelist>
            <fncref targ="$obsmajor"/>
            <fncref targ="$obsmicro"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$parnames" section="access" output="strings">
      <description>
	<para>
	  Logo da estimación dun modelo uniecuacional, devolve un arranxo
	  de cadeas de texto que conteñen os nomes dos parámetros do modelo.
	  O número de nomes coincide co número de elementos que ten o vector
	  <fncref targ="$coeff"/>.
	</para>
	<para>
	  Para os modelos especificados mediante unha lista de regresores,
	  o resultado vai ser o mesmo que o de
	</para>
	<code>
	  varnames($xlist)
	</code>
	<para>
	  (consulta a función<fncref targ="varnames"/>) pero a función
	  <lit>$parnames</lit> é máis xeral; pois tamén funciona para os modelos que
	  non teñen unha lista de regresores
	  (<cmdref targ="nls"/>, <cmdref targ="mle"/>, <cmdref targ="gmm"/>).
	</para>
      </description>
    </function>

    <function name="$pd" section="access" output="int">
      <description>
	<para>
	  Devolve un número enteiro coa frecuencia ou periodicidade dos datos
	  (por exemplo: 4 para datos trimestrais). No caso de datos de panel, o
	  valor devolto é a cantidade de períodos de tempo do conxunto de datos.
	</para>
      </description>
    </function>

    <function name="$pi" section="access" output="scalar">
      <description>
	<para>
	  Devolve un escalar co valor de &pi; con dobre precisión.
	</para>
      </description>
    </function>

    <function name="$pkgdir" section="access" output="string">
      <description>
	<para>
	  Utilidade especial para que utilicen os autores de paquetes de función.
	  Devolve unha cadea de texto baleira agás que se estea executando
	  unha función empaquetada, en cuxo caso devolve a ruta completa
	  (dependendo da plataforma) a onde está instalado o paquete. Por
	  exemplo, o valor devolto podería ser...
	</para>
	<code>
	  /usr/share/gretl/functions/foo
	</code>
	<para>
	  no caso de que este sexa o cartafol no que estea localizado
	  <lit>foo.gfn</lit>. Isto permite que o autor dun paquete de función
	  poda acceder a recursos tales como ficheiros de matrices, que teña
	  incluídos no seu paquete.
	</para>
      </description>
    </function>

    <function name="$pvalue" section="access" output="scalar-or-matrix">
      <description>
	<para>
	  Devolve a probabilidade asociada ao valor do estatístico de proba que
	  foi xerado pola última instrución explícita de proba de hipóteses (por
	  exemplo: <lit>chow</lit>). Consulta o <guideref targ="chap:genr"/>
	  para obter máis detalles.
	</para>
	<para>
	  Xeralmente devolve un escalar, mais nalgúns casos devolve unha
	  matriz (por exemplo, isto ocorre coas probabilidades asociadas aos
	  valores dos estatísticos da traza e do máximo-lambda da proba de
	  cointegración de Johansen). Neste caso, os valores están dispostos na
	  matriz do mesmo xeito que nos resultados presentados.
	</para>
	<para>
	  <seelist>
            <fncref targ="$test"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$qlrbreak" section="access" output="scalar">
      <description>
	<para>
	  Debe de executarse logo da instrución <cmdref targ="qlrtest"/> (que
	  permite facer a proba QLR para o cambio estrutural nun punto
	  descoñecido). Devolve un escalar co número enteiro positivo que indexa
	  a observación na que se maximiza o valor do estatístico de proba.
	</para>
      </description>
    </function>

    <function name="$result" section="access" output="matrix-or-bundle">
      <description>
	<para>
	  Proporciona información reservada, a continuación dalgunhas
	  instrucións que non teñen accesorios específicos. As instrucións
	  en cuestión inclúen <cmdref targ="corr"/>, <cmdref targ="fractint"/>,
	  <cmdref targ="freq"/>, <cmdref targ="hurst"/>,
	  <cmdref targ="summary"/>, <cmdref targ="xtab"/>,
	  <cmdref targ="vif"/> e <cmdref targ="bkw"/> (en cuxos casos, o resultado
	  é unha matriz), ademais de <cmdref targ="pkg"/> (en cuxo caso,
	  gárdase opcionalmente un feixe).
	</para>
      </description>
    </function>

    <function name="$rho" section="access" output="scalar">
      <fnargs>
	<fnarg optional="true" type="scalar">n</fnarg>
      </fnargs>
      <description>
	<para>
	  Sen argumentos, este accesorio devolve o coeficiente de autocorrelación
	  de primeira orde para os erros do último modelo estimado. Agora ben,
	  coa sintaxe <lit>$rho(n)</lit> logo da estimación dun modelo por medio
	  da instrución <lit>ar</lit>, devolve o valor estimado correspondente
	  ao coeficiente &rgr;(<math>n</math>).
	</para>
      </description>
    </function>

    <function name="$rsq" section="access" output="scalar">
      <description>
	<para>
	  Se pode calcularse, devolve un escalar co valor do coeficiente
	  <math>R</math><sup>2</sup> non corrixido do último modelo estimado.
	</para>
      </description>
    </function>

    <function name="$sample" section="access" output="series">
      <description>
	<para>
	  Debe de executarse logo de estimar un modelo dunha soa ecuación. Devolve
	  unha serie con unha variable ficticia que ten valores iguais a: 1 nas
	  observacións utilizadas na estimación, 0 nas observacións da mostra
	  vixente non utilizadas na estimación (posiblemente debido a valores
	  ausentes), e NA nas observacións fóra da mostra vixente seleccionada.
	</para>
	<para>
	  Se desexas calcular estatísticos baseados na mostra que se utiliza
	  para un modelo dado, pode facerse, por exemplo co código:
	</para>
	<code>
	  ols y 0 xlist
	  series sdum = $sample
	  smpl sdum --dummy
	</code>
      </description>
    </function>

    <function name="$sargan" section="access" output="rvec">
      <description>
	<para>
	  Debe de executarse logo da instrución <lit>tsls</lit>. Devolve un vector
	  fila <by r="1" c="3"/> que contén, nesta orde: o valor do estatístico
	  da proba de Sobreidentificación de Sargan, os correspondentes graos
	  de liberdade e a probabilidade asociada ao valor do estatístico. Se o
	  modelo está exactamente identificado, o estatístico non se pode
	  calcular e tratar de facelo provoca un fallo.
	</para>
      </description>
    </function>

    <function name="$seed" section="access" output="scalar">
      <description>
	<para>
	  Devolve un escalar co valor da semente do xerador de números
	  aleatorios de Gretl. Se estableces a semente por ti mesmo, non
	  tes necesidade deste accesorio; pero pode resultar interesante
	  cando a semente se establece automaticamente (baseándose no
	  momento no que comezou a execución do programa).
	</para>
      </description>
    </function>

    <function name="$sigma" section="access" output="scalar-or-matrix">
      <description>
	<para>
	  Se o último modelo estimado foi uniecuacional, devolve un escalar coa
	  Desviación Padrón da regresión (S, ou noutras palabras, a desviación
	  padrón dos erros do modelo coa oportuna corrección dos graos de
	  liberdade). Se o último modelo estimado foi un sistema de ecuacións,
	  devolve unha matriz coas varianzas-covarianzas dos erros das ecuacións
	  do sistema.
	</para>
      </description>
    </function>

    <function name="$stderr" section="access" output="matrix" altout="scalar">
      <fnargs>
	<fnarg optional="true" type="coeffname">nome</fnarg>
      </fnargs>
      <description>
	<para>
	  Cando se utiliza sen argumentos, <lit>$stderr</lit> devolve un vector
	  columna que contén as desviacións padrón dos coeficientes do último
	  modelo estimado. Co argumento opcional <lit>(nome dun regresor)</lit>
	  devolve un escalar co valor do parámetro estimado dese regresor
	  <argname>s</argname>.
	</para>
	<para>
	  Se o <quote>modelo</quote> é un sistema de ecuacións, o resultado
	  depende das características deste: para VARs e VECMs, o valor devolto
	  é unha matriz que contén unha columna por cada ecuación; noutro caso,
	  é un vector columna que contén os coeficientes da primeira ecuación
	  seguidos polos coeficientes da segunda ecuación e así de maneira
	  sucesiva.
	</para>
	<para>
	  <seelist>
            <fncref targ="$coeff"/>
            <fncref targ="$vcv"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$stopwatch" section="access" output="scalar">
      <description>
	<para>
	  Debe de executarse logo da instrución <lit>set stopwatch</lit> que activa
	  a medición de tempo da CPU. Ao usar este accesorio por primeira vez
	  obtense un escalar coa cantidade de segundos de CPU que pasaron dende
	  a instrución <lit>set stopwatch</lit>. Con cada acceso, reiníciase o
	  reloxo, polo que as sucesivas utilizacións de <lit>$stopwatch</lit>
	  xeran cada vez un escalar indicativo dos segundos de CPU dende o acceso previo.
	</para>
      </description>
    </function>

    <function name="$sysA" section="access" output="matrix">
      <description>
	<para>
	  Debe de executarse logo de estimar un sistema de ecuacións simultáneas.
	  Devolve a matriz cos coeficientes das variables endóxenas retardadas
	  (no caso de que existan), na forma estrutural do sistema. Consulta
	  tamén a instrución <cmdref targ="system"/>.
	</para>
      </description>
    </function>

    <function name="$sysB" section="access" output="matrix">
      <description>
	<para>
	  Debe de executarse logo de estimar un sistema de ecuacións simultáneas.
	  Devolve unha matriz cos coeficientes das variables esóxenas, na forma
	  estrutural do sistema. Consulta a instrución
	  <cmdref targ="system"/>.
	</para>
      </description>
    </function>

    <function name="$sysGamma" section="access" output="matrix">
      <description>
	<para>
	  Debe de executarse logo de estimar un sistema de ecuacións simultáneas.
	  Devolve unha matriz cos coeficientes das variables endóxenas
	  contemporáneas, na forma estrutural do sistema. Consulta a instrución
	  <cmdref targ="system"/>.
	</para>
      </description>
    </function>

    <function name="$sysinfo" section="access" output="bundle">
      <description>
	<para>
	  Devolve un feixe (<quote>bundle</quote>) que contén información das
	  capacidades do Gretl e do sistema operativo no que está executándose.
	  Os elementos do feixe indícanse deseguido:
	</para>
	<ilist>
	  <li>
            <para>
              <lit>mpi</lit>: número enteiro igual a 1 se o sistema admite
              MPI (Message Passing Interface), e 0 noutro caso.
            </para>
	  </li>
	  <li>
            <para>
              <lit>omp</lit>: número enteiro igual a 1 se Gretl compilouse
              con soporte para Open MP, e 0 noutro caso.
            </para>
	  </li>
	  <li>
            <para>
              <lit>ncores</lit>: número enteiro que indica o número de
              núcleos físicos de procesador dispoñibles.
            </para>
	  </li>
	  <li>
            <para>
              <lit>nproc</lit>: número enteiro que indica o número
              de procesadores dispoñibles, e que será maior que
              <lit>ncores</lit> se está habilitado o Hyper-threading.
            </para>
	  </li>
	  <li>
            <para>
              <lit>mpimax</lit>: número enteiro que indica o máximo número
              de procesos MPI que poden executarse en paralelo. É igual a
              cero se non se admite MPI; noutro caso, é igual ao valor de
              <lit>nproc</lit> local, agás que se especifique un ficheiro
              de hosts MPI, caso no que é igual á suma do número de
              procesadores ou <quote>slots</quote> ao longo de todas as
              máquinas ás que se fai referencia no ficheiro.
            </para>
	  </li>
	  <li>
            <para>
              <lit>wordlen</lit>: número enteiro igual a 32 ou a 64 en
              sistemas de 32 bit e 64 bit, respectivamente.
            </para>
	  </li>
	  <li>
            <para>
              <lit>os</lit>: cadea de texto que representa o sistema
              operativo, ben <lit>linux</lit>, <lit>osx</lit>,
              <lit>windows</lit> ou <lit>other</lit>.
            </para>
	  </li>
	  <li>
            <para>
              <lit>hostname</lit>: cadea de texto co nome da máquina (ou
              <quote>host</quote>) na que está executándose o proceso vixente
              de Gretl. Se non é posible determinar o nome, prodúcese
              unha volta atrás do <lit>localhost</lit>.
            </para>
	  </li>
	</ilist>
	<para>
	  Fíxate en que podes acceder a elementos individuais do feixe
	  mediante a notación do <quote>punto</quote>, sen necesidade de copiar o
	  feixe enteiro cun nome de usuario específico. Por exemplo co código:
	</para>
	<code>
	  if $sysinfo.os == "linux"
	      # Faga algo que sexa propio do Linux
	  endif
	</code>
      </description>
    </function>

    <function name="$system" section="access" output="bundle">
      <description>
	<para>
	  Debe de seguir á estimación dun sistema de ecuacións, feita
	  coa instrución <cmdref targ="system"/>, con <cmdref targ="var"/> ou
	  con <cmdref targ="vecm"/>; e devolve un feixe que contén moitos
	  apartados de datos que se refiren ao sistema. Inclúense todos
	  os accesorios importantes e habituais do sistema, que se nomean
	  mediante símbolos chave que son idénticos aos nomes habituais
	  dos accesorios, menos o símbolo de dólar inicial. Así, por exemplo,
	  os erros aparecen baixo a chave <lit>uhat</lit> e os coeficientes
	  baixo <lit>coeff</lit>. As chaves para obter información adicional
	  agárdase que deberan explicarse suficientemente por si mesmas.
	  Para comprobar o que tes á túa disposición, podes obter unha copia
	  do feixe e representar o seu contido, como en
	</para>
	<code>
	  var 4 y1 y2 y2
	  bundle b = $system
	  print b
	</code>
	<para>
	  Podes pasar un feixe obtido deste xeito como argumento
	  final (opcional) das funcións <fncref targ="fevd"/> e
	  <fncref targ="irf"/>.
	</para>
      </description>
    </function>

    <function name="$T" section="access" output="int">
      <description>
	<para>
	  Devolve un número enteiro co número de observacións utilizadas na
	  estimación do último modelo.
	</para>
      </description>
    </function>

    <function name="$t1" section="access" output="int">
      <description>
	<para>
	  Devolve un enteiro positivo co número que indexa a primeira
	  observación da mostra vixente seleccionada.
	</para>
      </description>
    </function>

    <function name="$t2" section="access" output="int">
      <description>
	<para>
	  Devolve un enteiro positivo co número que indexa a derradeira
	  observación da mostra vixente seleccionada.
	</para>
      </description>
    </function>

    <function name="$test" section="access" output="scalar-or-matrix">
      <description>
	<para>
	  Devolve o valor do estatístico de proba que foi xerado pola última
	  instrución explícita para unha proba de hipóteses (por exemplo:
	  <lit>chow</lit>). Consulta o <guideref targ="chap:genr"/> para
	  obter máis detalles.
	</para>
	<para>
	  Xeralmente devolve un escalar, mais nalgúns casos devolve unha
	  matriz (por exemplo, iso ocorre cos estatísticos da traza e do
	  máximo-lambda da proba de cointegración de Johansen). Neste caso,
	  os valores están dispostos na matriz do mesmo xeito que nos
	  resultados presentados.
	</para>
	<para>
	  <seelist>
            <fncref targ="$pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$tmax" section="access" output="int">
      <description>
	<para>
	  Devolve un enteiro co máximo valor válido establecido para indicar o
	  final do rango da mostra mediante a instrución <cmdref targ="smpl"/>.
	  Na maioría dos casos, isto vai ser igual ao número de observacións do
	  conxunto de datos; pero nunha función de Hansl, o valor <lit>$tmax</lit>
	  podería ser menor, posto que o acceso habitual aos datos dentro das
	  funcións, limítase ao rango mostral establecido polo solicitante.
	</para>
	<para>
	  Ten en conta que, en xeral, <lit>$tmax</lit> non é igual a
	  <fncref targ="$nobs"/>, que proporciona o número de
	  observacións do rango da mostra vixente.
	</para>
      </description>
    </function>

    <function name="$trsq" section="access" output="scalar">
      <description>
	<para>
	  Devolve o escalar <math>TR</math><sup>2</sup> (o tamaño da mostra
	  multiplicado polo R-cadrado do último modelo), se está dispoñible.
	</para>
      </description>
    </function>

    <function name="$uhat" section="access" output="series">
      <description>
	<para>
	  Devolve unha serie cos erros do último modelo estimado. Isto pode ter
	  diferentes significados dependendo dos estimadores utilizados. Por
	  exemplo, logo da estimación dun modelo ARMA, <lit>$uhat</lit> contén
	  os erros da predición adiantados 1 paso; logo da estimación dun
	  probit, contén os erros xeneralizados.
	</para>
	<para>
	  Cando o <quote>modelo</quote> vixente en cuestión é un sistema de
	  ecuacións (un VAR, un VECM ou un sistema de ecuacións simultáneas),
	  o <lit>$uhat</lit> xera unha matriz cos erros de estimación de cada
	  ecuación, ordenados por columnas.
	</para>
      </description>
    </function>

    <function name="$unit" section="access" output="series">
      <description>
	<para>
	  Só e válido para datos de panel. Devolve unha serie con valor igual a
	  1 en todas as observacións na primeira unidade ou grupo, 2 en todas as
	  observacións na segunda unidade ou grupo, e así de forma sucesiva.
	</para>
      </description>
    </function>

    <function name="$vcv" section="access" output="matrix" altout="scalar">
      <fnargs>
	<fnarg optional="true" type="coeffname">nome1</fnarg>
	<fnarg optional="true" type="coeffname">nome2</fnarg>
      </fnargs>
      <description>
	<para>
	  Cando se utiliza sen argumentos, <lit>$vcv</lit> devolve unha matriz
	  cadrada que contén as varianzas-covarianzas estimadas dos coeficientes
	  do último modelo estimado. Se este último era uniecuacional, pódense
	  indicar os nomes de dous regresores entre parénteses, para así obter
	  un escalar coa covarianza estimada entre <argname>nome1</argname> e
	  <argname>nome2</argname>.
	  <seelist>
            <fncref targ="$coeff"/>
            <fncref targ="$stderr"/>
	  </seelist>
	</para>
	<para>
	  Este accesorio non está dispoñible para VARs ou VECMs. Para modelos
	  dese tipo <fncref targ="$sigma"/> e <fncref targ="$xtxinv"/>.
	</para>
      </description>
    </function>

    <function name="$vecGamma" section="access" output="matrix">
      <description>
	<para>
	  Debe de executarse logo de estimar un VECM e devolve unha matriz na que
	  as matrices Gamma (cos coeficientes das diferenzas retardadas das
	  variables cointegradas) se agrupan unhas ao lado das outras. Cada fila
	  indica unha ecuación; para un VECM con nivel de retardo <math>p</math>
	  existen <math>p</math> &minus; 1 submatrices.
	</para>
      </description>
    </function>

    <function name="$version" section="access" output="scalar">
      <description>
	<para>
	  Devolve un escalar cun valor enteiro que designa a versión de Gretl.
	  A versión actual de Gretl está formada por unha cadea de texto que
	  indica o ano con formato de 4 díxitos seguido dunha letra desde a ata
	  j, que representa as sucesivas actualizacións dentro de cada ano (por
	  exemplo, 2015d). O valor devolto por este accesorio está calculado
	  multiplicando o ano por 10, e sumándolle un número que representa á
	  letra, na orde léxica en base cero. Así, 2015d represéntase mediante
	  20153.
	</para>
	<para>
	  En versións anteriores ao Gretl 2015d, o identificador tiña o seguinte
	  formato: x.y.z (tres números enteiros separados por puntos); nese caso,
	  o valor da función calculábase con <lit>10000*x + 100*y + z</lit>. Por
	  exemplo, a última versión co formato antigo (1.10.2) transcribíase
	  mediante 11002. Deste xeito a orde numérica de <lit>$version</lit> foi
	  preservada aínda despois de mudar o esquema das versións.
	</para>
      </description>
    </function>

    <function name="$vma" section="access" output="matrix">
      <description>
	<para>
	  Debe de executarse logo de estimar un VAR ou un VECM, e devolve unha
	  matriz que contén a representación VMA ata a orde especificada por
	  medio da instrución <lit>set horizon</lit>. Para ter máis detalles,
	  consulta o <guideref targ="chap:var"/>.
	</para>
      </description>
    </function>

    <function name="$windows" section="access" output="int">
      <description>
	<para>
	  Devolve un número enteiro co valor 1 se Gretl está executándose en Windows,
	  e 0 noutro caso. Poñendo como condición un destes valores, podes escribir instrucións
	  <quote>shell </quote> que podan executarse en diferentes sistemas operativos.
	</para>
	<para>
	  Consulta tamén a instrución <cmdref targ="shell"/>.
	</para>
      </description>
    </function>

    <function name="$workdir" section="access" output="string">
      <description>
	<para>
	  Este accesorio devolve unha cadea de texto coa ruta desde a que le e
	  na que escribe Gretl por defecto. Ofrécese unha discusión máis cumprida
	  no manual de Instrucións, na referencia <cmdref targ="workdir"/>. Cae
	  na conta de que o usuario pode determinar esta cadea por medio da
	  instrución <cmdref targ="set"/>.
        </para>
      </description>
    </function>

    <function name="$xlist" section="access" output="list">
      <description>
	<para>
	  Se o último modelo estimado era uniecuacional, o accesorio devolve
	  unha lista cos seus regresores. Se o último modelo era un sistema de
	  ecuacións, devolve unha lista <quote>global</quote> coas variables
	  esóxenas e predeterminadas (na mesma orde na que aparecen co accesorio
	  <fncref targ="$sysB"/>). Se o último modelo era un VAR, devolve unha
	  lista cos regresores esóxenos, se hai algún.
	</para>
      </description>
    </function>

    <function name="$xtxinv" section="access" output="matrix">
      <description>
	<para>
	  Debe de executarse logo da estimación dun VAR ou VECM (unicamente), e
	  devolve a matriz <math>X'X</math><sup>-1</sup>, onde <math>X</math> é
	  a matriz habitual cos regresores utilizados en cada ecuación. Este
	  accesorio non está dispoñible para un VECM estimado con restricións
	  impostas sobre a matriz de cargas (&agr;).
	</para>
      </description>
    </function>

    <function name="$yhat" section="access" output="series">
      <description>
	<para>
	  Devolve unha serie cos valores estimados da variable explicada da última regresión.
	</para>
      </description>
    </function>

    <function name="$ylist" section="access" output="list">
      <description>
	<para>
	  Se o último modelo estimado foi un VAR, un VECM ou un sistema
	  de ecuacións simultáneas, o accesorio devolve unha lista coas
	  variables endóxenas. Se o último modelo estimado foi uniecuacional,
	  o accesorio devolve unha lista cun único elemento, a variable dependente.
	  No caso especial do modelo biprobit, a lista contén dous
	  elementos.
	</para>
      </description>
    </function>

  </funclist>

  <funclist name="Functions proper" ref="functions">

    <function name="abs" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co valor absoluto de <argname>x</argname>.
	</para>
      </description>
    </function>

    <function name="acos" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) cos radiáns do arco
	  coseno de <argname>x</argname>; é dicir, proporciona o arco cuxo coseno é
	  <argname>x</argname> (o argumento debe de estar entre &minus;1 e 1).
	</para>
      </description>
    </function>

    <function name="acosh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co coseno hiperbólico
	  inverso de <argname>x</argname> (solución positiva). Este último
	  debe de ser maior ca 1, pois pola contra a función devolverá NA.
	  <seelist>
            <fncref targ="cosh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="aggregate" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
	<fnarg type="series-or-list">segunvar</fnarg>
	<fnarg type="string" optional="true">nomefunc</fnarg>
      </fnargs>
      <description>
	<para>
	  Na forma máis simple de uso desta función, <argname>x</argname>
	  establécese igual a <lit>null</lit>, <argname>segunvar</argname> é
	  unha serie individual e o terceiro argumento omítese. Nese caso,
	  devólvese unha matriz con dúas columnas que contén: os distintos
	  valores de <argname>segunvar</argname> ordenados de forma crecente
	  na primeira columna, e o número de observacións nas que
	  <argname>segunvar</argname> toma cada un deses valores.
	  Por exemplo...
	</para>
	<code>
	  open data4-1
	  eval aggregate(null, bedrms)
	</code>
	<para>
	  ... amosará que a serie <lit>bedrms</lit> ten os valores
	  3 (en total 5 veces) e 4 (en total 9 veces).
	</para>
	<para>
	  Se <argname>x</argname> e <argname>segunvar</argname> son ambas
	  series individuais, e indicas o terceiro argumento desta
	  función, o valor que se devolve é unha matriz con tres columnas
	  que vai conter respectivamente: os distintos valores de
	  <argname>segunvar</argname> ordenados de forma crecente, o número
	  de observacións nas que <argname>segunvar</argname> toma cada
	  un deses valores, e os valores do estatístico que especifica a
	  función <argname>nomefunc</argname>, calculado para a serie
	  <argname>x</argname>, pero usando tan só aquelas observacións
	  nas que <argname>segunvar</argname> toma o mesmo valor que se
	  especifica na primeira columna da matriz.
	</para>
	<para>
	  De xeito máis xeral, se <argname>segunvar</argname> é unha lista con
	  <math>n</math> elementos, entón as <math>n</math> columnas á
	  esquerda conteñen as combinacións dos distintos valores de cada
	  unha das <math>n</math> series, e a columna de reconto contén
	  o número de observacións nas que se produce cada combinación.
	  Se <argname>x</argname> é unha lista con <math>m</math>
	  elementos, entón as <math>m</math> columnas máis á dereita
	  conteñen os valores do estatístico especificado, para cada unha
	  das variables de <argname>x</argname>, novamente calculadas na
	  submostra indicada na(s) primeira(s) columna(s).
	</para>
	<para>
	  As seguintes opcións de <argname>nomefunc</argname> mantéñense
	  de forma <quote>orixinal</quote>: <fncref targ="sum"/>,
	  <fncref targ="sumall"/>, <fncref targ="mean"/>, <fncref targ="sd"/>,
	  <fncref targ="var"/>, <fncref targ="sst"/>, <fncref targ="skewness"/>,
	  <fncref targ="kurtosis"/>, <fncref targ="min"/>, <fncref targ="max"/>,
	  <fncref targ="median"/>, <fncref targ="nobs"/> e <fncref targ="gini"/>.
	  Cada unha destas funcións utiliza á súa vez unha serie como argumento
	  e devolve un valor escalar; por iso, neste sentido, pode dicirse que
	  de algún xeito <quote>agregan</quote> a serie. Podes utilizar
	  unha función definida polo usuario como <quote>agregador</quote>;
	  nese caso, da mesma forma que as funcións orixinais, esa función
	  debe de ter como argumento unicamente unha serie, e devolver un
	  valor escalar.
	</para>
	<para>
	  Cae na conta de que, a pesar de que <lit>aggregate</lit> fai o
	  reconto de casos de forma automática, a opción <lit>nobs</lit>,
	  non é redundante como función <quote>agregadora</quote>, posto que
	  proporciona o número de observacións válidas (non ausentes) de
	  <argname>x</argname> en cada combinación de <argname>segunvar</argname>.
	</para>
	<para>
	  Como exemplo sinxelo, supón que con <lit>rexion</lit> se definen
	  uns códigos para representar unha distribución xeográfica por rexións,
	  utilizándose para iso enteiros desde 1 ata <math>n</math>, e que
	  con <lit>renda</lit> se representa a renda dos fogares. Entón o
	  código indicado deseguido debe producir unha matriz de orde
	  <by r="n" c="3"/> que contén os códigos das rexións, o reconto de
	  observacións de cada unha, e a renda media dos fogares en cada unha:
	</para>
	<code>
	  matrix m = aggregate(renda, rexion, mean)
	</code>
	<para>
	  Como exemplo de utilización con listas de variables, sexa
	  <lit>xenero</lit> unha variable binaria home/muller, sexa
	  <lit>raza</lit> unha variable categórica con tres valores, e
	  considera o seguinte código:
	</para>
	<code>
	  list BY = xenero raza
	  list X = renda idade
	  matrix m = aggregate(X, BY, sd)
	</code>
	<para>
	  Invocar a función <lit>aggregate</lit> producirá unha matriz de
	  orde <by r="6" c="5"/>. Nas dúas primeiras columnas exprésanse as
	  6 distintas combinacións dos valores de 'xenero' e 'raza'; a columna
	  do medio contén o reconto do número de casos para cada unha desas
	  combinacións; e as dúas columnas máis á dereita conteñen as
	  desviacións padrón mostrais de <lit>renda</lit> e <lit>idade</lit>.
	</para>
	<para>
	  Observa que se <argname>segunvar</argname> é unha lista de variables,
	  algunhas combinacións dos valores de <argname>segunvar</argname> poden
	  non estar presentes nos datos (producíndose un reconto igual a cero).
	  Nese caso, os valores dos estatísticos para <argname>x</argname> se
	  rexistran como <lit>NaN</lit> (é dicir, non son números). Se queres
	  ignorar eses casos, podes usar a función <fncref targ="selifr"/> para
	  escoller só aquelas filas que non teñan reconto igual a cero. A columna
	  a comprobar estará unha posición á dereita da indicada polo número de
	  variables de <argname>segunvar</argname>, polo que pode usarse o código:
	</para>
	<code>
	  matrix m = aggregate(X, BY, sd)
	  scalar c = nelem(BY)
	  m = selifr(m, m[,c+1])
	</code>
      </description>
    </function>

    <function name="argname" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg type="string" optional="true">pordefecto</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>s</argname> é o nome dun parámetro cara a unha función
	  definida previamente polo usuario, devolve unha cadea de texto co nome
	  do argumento correspondente (se este ten un nome a nivel da chamada).
	  Cando o argumento é anónimo, devólvese unha cadea baleira agás que
	  indiques o argumento opcional <argname>pordefecto</argname>, en cuxo
	  caso utilízase o seu valor como alternativa.
	</para>
      </description>
    </function>

    <function name="array" section="data-utils" output="seebelow">
      <fnargs>
	<fnarg type="int">n</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta é a función <quote>xeradora</quote> básica dunha nova variable
	  de tipo arranxo (<quote>array</quote>). Ao usar esta función é
	  necesario que especifiques un tipo (en forma plural) para o arranxo:
	  <lit>strings</lit>, <lit>matrices</lit>, <lit>bundles</lit>,
	  <lit>lists</lit> ou <lit>arrays</lit>. Devolve un arranxo do tipo
	  especificado con <argname>n</argname> elementos <quote>baleiros</quote>
	  (por exemplo, unha cadea de texto (<quote>string</quote>) baleira ou
	  unha matriz nula). Exemplos de utilización:
	</para>
	<code>
	  strings S = array(5)
	  matrices M = array(3)
	</code>
	<para>
	  Consulta tamén <fncref targ="defarray"/>.
	</para>
      </description>
    </function>

    <function name="asin" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) cos radiáns do arco
	  seno de <argname>x</argname>; é dicir, proporciona o arco cuxo seno é
	  <argname>x</argname> (o argumento debe de estar entre &minus;1 e 1).
	</para>
      </description>
    </function>

    <function name="asinh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co seno hiperbólico inverso de <argname>x</argname>.
	  <seelist>
            <fncref targ="sinh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="assert" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="scalar">expr</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta función está dirixida a comprobar e depurar código HANSL.
	  O seu argumento deberá ser unha expresión cuxo valor sexa un
	  escalar. O valor que devolve esta función é ou ben 1 cando o
	  valor do argumento <argname>expr</argname> non é cero
	  (<quote>verdadeiro</quote> booleano ou <quote>éxito</quote>),
	  ou ben 0 se o valor do argumento é cero (<quote>falso</quote>
	  booleano ou <quote>fallo</quote>).
	</para>
	<para>
	  Por defecto, non hai outras consecuencias de que falle unha
	  chamada a <lit>assert</lit>, máis que o feito de que o valor
	  que se devolve é cero. Porén, podes utilizar a instrución
	  <cmdref targ="set"/> para facer que o fallo dunha afirmación
	  teña máis consecuencias. Hai dous niveles:
	</para>
	<code>
	  # Amosar unha mensaxe de aviso, mais continuar coa execución
	  set assert warn
	  # Amosar unha mensaxe de aviso e deter a execución
	  set assert stop
	</code>
	<para>
	  Podes restablecer o funcionamento por defecto mediante
	</para>
	<code>
	  set assert off
	</code>
	<para>
	  A xeito de exemplo sinxelo:
	  Se en certo punto dun guión HANSL, un escalar <lit>x</lit> debera ser
	  non negativo, o seguinte código amosará un erro se este non é o caso:
	</para>
	<code>
	  set assert stop
	  assert(x >= 0)
	</code>
      </description>
    </function>

    <function name="atan" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) cos radiáns do arco tanxente de
	  <argname>x</argname>; é dicir, devolve o arco cuxa tanxente é <argname>x</argname>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="tan"/>
	    <fncref targ="atan2"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="atan2" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">y</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co valor principal
	  da arco tanxente de <argname>y</argname>/<argname>x</argname>,
	  utilizando os signos dos dous argumentos indicados para determinar
	  o cuadrante do resultado. O valor que se devolve está en radiáns,
	  dentro do rango [&minus;&pi;, &pi;].
	</para>
	<para>
	  Se os dous argumentos son de tipos difirentes, o tipo do resultado
	  é o mesmo que o do <quote>maior</quote> dos dous, donde a xerarquía
	  é matriz &gt; serie &gt; escalar. Por exemplo, se <argname>y</argname>
	  é un escalar, e <argname>x</argname> é un vector de dimensión
	  <math>n</math> (ou viceversa), o resultado é un vector de dimensión
	  <math>n</math>. Cae na conta de que os argumentos dunha matriz deben
	  de ser vectores; e de que, se ningún argumento é un escalar, os dous
	  argumentos deben de ser da mesma longura.
	</para>
	<para>
	  <seelist>
            <fncref targ="tan"/>
            <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="atanh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) coa tanxente hiperbólica inversa de <argname>x</argname>.
	  <seelist>
            <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="atof" section="strings" output="scalar">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Función moi relacionada coa da linguaxe de programación C co mesmo nome.
	  Devolve un escalar co resultado de converter a cadea de texto
	  <argname>s</argname> (ou o seu anaco relevante logo de descartar
	  calquera espazo inicial en branco) nun número de punto flotante.
	  A diferenza do que ocorre na linguaxe C, a función <lit>atof</lit>
	  sempre asume que o carácter decimal é o <quote><lit>.</lit></quote>
	  (por cuestións de transportabilidade). Ignóranse todos os caracteres
	  que seguen logo da parte de <argname>s</argname> que se converte en
	  número de punto flotante.
	</para>
	<para>
	  Se, baixo o suposto establecido, non puidera converterse ningún dos
	  caracteres de <argname>s</argname> que queden logo de descartar
	  os espazos en branco, a función devolve <lit>NA</lit>.
	</para>
	<code>
	  # Exemplos:
	  x = atof("1.234") # Devolve x = 1.234
	  x = atof("1,234") # Devolve x = 1
	  x = atof("1.2y")  # Devolve x = 1.2
	  x = atof("y")     # Devolve x = NA
	  x = atof(",234")  # Devolve x = NA
	</code>
	<para>
	  Consulta tamén <fncref targ="sscanf"/> se queres ter maior
	  flexibilidade nas conversións de cadeas de texto en números.
	</para>
      </description>
    </function>

    <function name="bessel" section="math" output="asinput">
      <fnargs>
	<fnarg type="char">tipo</fnarg>
	<fnarg type="scalar">v</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Permite calcular unha das variantes da función de Bessel de clase
	  <argname>v</argname> con argumento <argname>x</argname>. O valor que
	  devolve é do mesmo tipo que este <argname>x</argname>. A clase da
	  función escóllese co primeiro argumento que debe ser <lit>J</lit>,
	  <lit>Y</lit>, <lit>I</lit> ou <lit>K</lit>. Unha boa discusión sobre
	  as funcións de Bessel pode atoparse na Wikipedia, mais aquí
	  ofrécense uns breves comentarios.
	</para>
	<para>
	  Caso <lit>J</lit>: función de Bessel de primeira clase que se asemella
	  a unha onda sinusoidal amortecida. Defínese para <argname>v</argname>
	  real e <argname>x</argname>; pero se <argname>x</argname> fose
	  negativo, entón <argname>v</argname> debe de ser un número enteiro.
	</para>
	<para>
	  Caso <lit>Y</lit>: función de Bessel de segunda clase. Defínese para
	  <argname>v</argname> real e <argname>x</argname>, pero con unha
	  singularidade en <argname>x</argname> = 0.
	</para>
	<para>
	  Caso <lit>I</lit>: función de Bessel modificada de primeira clase que
	  presenta un crecemento exponencial. Os argumentos que poden usarse con
	  ela son os mesmos que no caso <lit>J</lit>.
	</para>
	<para>
	  Caso <lit>K</lit>: función de Bessel modificada de segunda clase que
	  presenta un decrecemento exponencial. Diverxe en <argname>x</argname>
	  = 0, non está definida para valores negativos de <argname>x</argname>,
	  e é simétrica arredor de <argname>v</argname> = 0.
	</para>
      </description>
    </function>

    <function name="BFGSmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="fncall" optional="true">g</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co resultado dunha maximización numérica feita co
	  método de Broyden, Fletcher, Goldfarb e Shanno. O argumento vectorial
	  <argname>b</argname> debe de conter os valores iniciais dun conxunto
	  de parámetros, e o argumento <argname>f</argname> debe de especificar
	  unha chamada á función que vai calcular o criterio obxectivo (escalar)
	  que se quere maximizar, dados os valores vixentes dos parámetros, así
	  como calquera outros datos que sexan relevantes. Se o que pretendes
	  é en realidade minimizar o criterio obxectivo, esta función devolve o
	  valor negativo dese criterio obxectivo. Cando se completa con éxito a
	  súa execución, <lit>BFGSmax</lit> devolve o valor maximizado do
	  criterio obxectivo, e <argname>b</argname> contén finalmente os
	  valores dos parámetros que proporcionan o máximo dese criterio.
	</para>
	<para>
	  O terceiro argumento (opcional) establece unha maneira de proporcionar
	  derivadas analíticas (noutro caso, o gradiente compútase numericamente).
	  A chamada <argname>g</argname> á función gradiente debe de ter como
	  primeiro argumento a unha matriz definida previamente que teña o
	  tamaño axeitado para poder almacenar o gradiente, indicado en forma de
	  punteiro. Así mesmo, tamén precisa ter como argumento (en forma de
	  punteiro ou non) ao vector de parámetros. Outros argumentos son
	  opcionais.
	</para>
	<para>
	  Para máis detalles e exemplos, consulta o
	  <guideref targ="chap:numerical"/>.
	  <seelist>
	          <fncref targ="BFGScmax"/>
            <fncref targ="NRmax"/>
            <fncref targ="fdjac"/>
            <fncref targ="simann"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="BFGSmin" section="numerical" output="scalar">
      <description>
	<para>
	  Un alcume de <fncref targ="BFGSmax"/>. Se invocas a función baixo
	  este nome, execútase facendo unha minimización.
	</para>
      </description>
    </function>

    <function name="BFGScmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="matrix">limites</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="fncall" optional="true">g</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co resultado dunha maximización con restricións por
	  medio do método L-BFGS-B (BFGS con memoria limitada, consulta
	  <cite key="byrd-etal95">Byrd, Lu, Nocedal e Zhu, 1995</cite>). O argumento 
	  vectorial <argname>b</argname> debe de conter os valores iniciais dun
	  conxunto de parámetros, o argumento <argname>limites</argname> debe de
	  conter as restricións aplicadas aos valores dos parámetros (consulta
	  máis abaixo), e o argumento <argname>f</argname> debe de especificar
	  unha chamada á función que vai calcular o criterio obxectivo (escalar)
	  que se quere maximizar, dados os valores vixentes dos parámetros así
	  como calquera outros datos que sexan relevantes. Se o que pretendes
	  realmente é minimizar o criterio obxectivo, esta función debe devolver
	  o valor negativo dese criterio. Ao completar con éxito a súa execución,
	  <lit>BFGScmax</lit> devolve o valor máximo do criterio obxectivo, dadas
	  as restricións de <argname>limites</argname>, e <argname>b</argname>
	  contén finalmente os valores dos parámetros que maximizan o criterio.
	</para>
	<para>
	  A matriz <argname>limites</argname> debe de ter 3 columnas, e un
	  número de filas igual ao número de elementos restrinxidos no vector de
	  parámetros. O primeiro elemento dunha fila dada é o enteiro positivo
	  que indexa o parámetro restrinxido; o segundo e o terceiro elementos
	  son os límites inferior e superior, respectivamente. Os valores
	  <lit>-$huge</lit> e <lit>$huge</lit> deben usarse para indicar que
	  o parámetro non posúe restricións inferiores ou superiores,
	  respectivamente. Por exemplo, a seguinte expresión é a forma de
	  especificar que o segundo elemento do vector de parámetros debe
	  de ser non negativo:
	</para>
	<code>
	  matrix limites = {2, 0, $huge}
	</code>
	<para>
	  O cuarto argumento (opcional) establece unha maneira de proporcionar
	  derivadas analíticas (noutro caso, o gradiente calcúlase numericamente).
	  A chamada <argname>g</argname> á función gradiente debe de ter como
	  primeiro argumento a unha matriz definida previamente que teña o
	  tamaño axeitado para poder almacenar o gradiente, indicado en forma de
	  punteiro. Así mesmo, tamén precisa ter como argumento (en forma de
	  punteiro ou non) ao vector de parámetros. Outros argumentos son
	  opcionais.
	</para>
	<para>
	  Para máis detalles e exemplos, consulta o
	  <guideref targ="chap:numerical"/>.
	  <seelist>
	          <fncref targ="BFGSmax"/>
            <fncref targ="NRmax"/>
            <fncref targ="fdjac"/>
            <fncref targ="simann"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="BFGScmin" section="numerical" output="scalar">
      <description>
	<para>
	  Un alcume de <fncref targ="BFGScmax"/>. Se invocas a función baixo
	  este nome, execútase facendo unha minimización.
	</para>
      </description>
    </function>

    <function name="bincoeff" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">n</fnarg>
	<fnarg type="anyfloat">k</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co coeficiente binomial.
	  Este indica o número de xeitos nos que <argname>k</argname> elementos
	  se poden escoller (sen repetición) de entre <argname>n</argname>
	  elementos, independentemente de como estean ordenados. Isto tamén
	  equivale ao coeficiente do elemento (<math>k</math>+1)-ésimo
	  na expansión polinómica da potencia dun binomio
	  <equation status="inline" ascii="(1+x)^n" tex="$(1+x)^n$"/>.
	</para>
	<para context="tex">
	  Para argumentos enteiros o resultado é $n!/k!(n-k)!$.
	  Pero a función tamén acepta argumentos non enteiros, e
	  a fórmula de arriba xeneralízase como
	  $\frac{\Gamma(n+1)}{\Gamma(k+1) \Gamma(n-k+1)}$.
	</para>
	<para context="notex">
	  Para argumentos enteiros o resultado é <math>n!/k!(n-k)!</math>.
	  Pero esta función tamén acepta argumentos non enteiros,
	  e nese caso a fórmula de arriba
	  se xeneraliza como
	   Γ(<math>n</math>+1)/(Γ(<math>k</math>+1) &times; Γ(<math>n-k</math>+1)).
	</para>
	<para>
	  Cando <argname>k</argname> &gt; <argname>n</argname> ou
	  <argname>k</argname> &lt; 0, non hai unha resposta válida
	  polo que se devolve NA.
	</para>
	<para>
	  Se os dous argumentos son de diferente tipo, o resultado será
	  do tipo do <quote>maior</quote> dos dous (sendo o criterio de
	  ordenación matriz &gt; serie &gt; escalar). Por exemplo, se
	  <argname>n</argname> é un escalar, e <argname>k</argname> é un
	  vector de dimensión <math>r</math> (ou viceversa), o resultado
	  é un vector de dimensión <math>r</math>. Ten en conta que os
	  argumentos matriciais deberán ser vectores. Tamén que, se ningún
	  argumento é un escalar, os dous deberán ser da mesma longura.
	</para>
	<para>
	  Consulta tamén <fncref targ="gammafun"/> e <fncref targ="lngamma"/>.
	</para>
      </description>
    </function>

    <function name="bkfilt" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int" optional="true">f1</fnarg>
	<fnarg type="int" optional="true">f2</fnarg>
	<fnarg type="int" optional="true">k</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha serie co resultado da aplicación do filtro paso-banda
	  de Baxter&ndash;King a unha serie <argname>y</argname>. Os
	  parámetros opcionais <argname>f1</argname> e <argname>f2</argname>
	  representan, de maneira respectiva, os límites inferior e superior
	  do rango de frecuencias que se vai extraer, namentres que
	  <argname>k</argname> representa a orde de aproximación que se vai
	  utilizar.
	</para>
	<para>
	  Se non se proporcionan eses argumentos, entón os valores por defecto
	  van depender da periodicidade do conxunto de datos. Para datos
	  anuais os valores por defecto para <argname>f1</argname>,
	  <argname>f2</argname> e <argname>k</argname> son 2, 8 e 3
	  respectivamente; para datos trimestrais son 6, 32 e 12; e para
	  datos mensuais son 18, 96 e 36. Eses valores escóllense para
	  coincidir coa elección máis común entre os usuarios, que consiste
	  na utilización deste filtro para extraer a compoñente de frecuencia
	  do <quote>ciclo de negocios</quote>. Isto, á súa vez, defínese
	  habitualmente comprendido entre 18 meses e 8 anos. O filtro abarca
	  3 anos de datos, na elección por defecto.
	</para>
	<para>
	  Se <argname>f2</argname> é maior ou igual ao número de observacións
	  dispoñibles, entón execútase a versión <quote>paso-baixo</quote>
	  do filtro, e a serie resultante debe de considerarse como unha
	  estimación da compoñente de tendencia, máis ca da compoñente do
	  ciclo.
	  <seelist>
            <fncref targ="bwfilt"/>
            <fncref targ="hpfilt"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="bkw" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">V</fnarg>
	<fnarg optional="true" type="strings">nomespar</fnarg>
	<fnarg optional="true" type="bool">detallado</fnarg>
      </fnargs>
      <description>
	<para>
	  Executa probas BKW de diagnose de multicolinearidade (consulta
	  <cite key="belsley-etal80">Belsley, Kuh e Welsch (1980)</cite>)
	  dada unha matriz de covarianzas das estimacións dos parámetros,
	  <argname>V</argname>. O segundo argumento (opcional), pode ser
	  un arranxo de cadeas de texto ou unha cadea que conteña nomes
	  separados por comas, e se usa para etiquetar as columnas que
	  amosan as proporcións de varianza; o número de nomes debe de
	  coincidir coa dimensión de <argname>V</argname>. Despois de
	  estimar un modelo en Gretl, podes obter argumentos adecuados para
	  indicar nesta función mediante os accesorios <fncref targ="$vcv"/>
	  e <fncref targ="$parnames"/>.
	</para>
	<para>
	  Por defecto, esta función traballa silandeiramente, devolvendo tan
	  só a táboa BKW en forma de matriz, pero se indicas como terceiro
	  argumento un valor non nulo, a táboa preséntase xunto con algunhas
	  análises.
	</para>
	<para>
	  Tamén dispós desta funcionalidade con formato de instrución mediante
	  <cmdref targ="bkw"/>, e vaise referir automaticamente ao derradeiro
	  modelo, sen requirir ningún argumento.
	</para>
      </description>
    </function>

    <function name="boxcox" section="filters" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">y</fnarg>
	<fnarg type="scalar">d</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve o resultado da transformación de Box&ndash;Cox con
	  parámetro <argname>d</argname> dunha serie positiva
	  <argname>y</argname> (ou das columnas dunha matriz
	  <argname>y</argname>).
	</para>
	<para context="tex">
	  \[ y_t^{(d)} = \left\{ \begin{array}{ll} \frac{y_t^d - 1}{d} &amp;
	  {\rm if}\quad d\neq 0 \\ \log (y_t) &amp; {\rm if}\quad d=0
	  \end{array} \right. \]
	</para>
	<para context="notex">
	  O resultado é (<math>y</math><sup>d</sup> - 1)/<math>d</math>
	  para <math>d</math> distinto de cero, ou log(<math>y</math>) para
	  <math>d</math> = 0.
	</para>
      </description>
    </function>

    <function name="bread" section="data-utils" output="bundle">
      <fnargs>
	<fnarg type="string">nomeficheiro</fnarg>
	<fnarg optional="true" type="bool">importar</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve a lectura dun feixe (bundle) desde un ficheiro especificado
	  polo argumento <argname>nomeficheiro</argname>. Por defecto, asúmese
	  que o feixe está representado en XML; e que se lle aplicou a compresión
	  gzip se <argname>nomeficheiro</argname> ten extensión <lit>.gz</lit>.
	  Pero se a extensión é <lit>.json</lit> ou <lit>.geojson</lit>, asúmese
	  que o contido é de tipo JSON.
	</para>
	<para>
	  No caso XML, o ficheiro debe de conter un elemento
	  <lit>gretl-bundle</lit>, que se use para almacenar cero ou
	  máis elementos <lit>bundled-item</lit>. Por exemplo:
	</para>
	<code>
	  &lt;?xml version="1.0" encoding="UTF-8"?&gt;
	  &lt;gretl-bundle name="temp"&gt;
          &lt;bundled-item key="s" type="string"&gt;moo&lt;/bundled-item&gt;
          &lt;bundled-item key="x" type="scalar"&gt;3&lt;/bundled-item&gt;
	  &lt;/gretl-bundle&gt;
	</code>
	<para>
	  Como cabería agardar, os ficheiros que se len axeitadamente por
	  medio de <lit>bread</lit> xéranse mediante a función asociada
	  <fncref targ="bwrite"/>.
	</para>
	<para>
	  Se o nome do ficheiro non contén a especificación completa do camiño
	  ao cartafol onde está, entón vai procurarse en varias localizacións
	  <quote>probables</quote>, comezando no <cmdref targ="workdir"/> vixente.
	  Porén, cando se proporciona un valor non nulo para o argumento
	  opcional <argname>importar</argname>, o ficheiro vai procurarse no
	  cartafol <quote>punto</quote> do usuario. Neste caso, o argumento
	  <argname>nomeficheiro</argname> deberá ser un nome simple de ficheiro,
	  sen a inclusión do camiño ao cartafol.
	</para>
	<para>
	  Se ocorre algún fallo (por exemplo, se o ficheiro está mal formatado
	  ou é inaccesible), devólvese o fallo por medio do accesorio
	  <fncref targ="$error"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="mread"/>
            <fncref targ="bwrite"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="brename" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="bundle">B</fnarg>
	<fnarg type="string">vellachave</fnarg>
	<fnarg type="string">novachave</fnarg>
      </fnargs>
      <description>
	<para>
	  Se o feixe <argname>B</argname> contén un elemento que teña
	  a chave <argname>vellachave</argname>, esa súa chave trócase
	  a <argname>novachave</argname>; doutro xeito, amósase un fallo.
	  A función devolve un 0 cando se fai correctamente o cambio de nome.
	</para>
	<para>
	  Trocar a chave dun elemento dun feixe non é unha tarefa habitual,
	  mais pode xurdirte esa necesidade no contexto de funcións que
	  operan con feixes, e <lit>brename</lit> resulta ser unha ferramenta
	  eficiente para ese traballo. Exemplo:
	</para>
	<code>
	  # Establecer un feixe que contén unha matriz grande
	  bundle b
	  b.X = mnormal(1000, 1000)
	  if 0
	      # 'Trocar a chave manualmente'
	      Xcopy = b.X
	      delete b.X
	      b.Y = Xcopy
	      delete Xcopy
	  else
	      # fronte a 'Trocala de forma eficiente'
	      brename(b, "X", "Y")
	  endif
	</code>
	<para>
	  O primeiro método esixe que se copie esa gran matriz dúas veces:
	  primeiro fóra do feixe, e logo de novo dentro del baixo unha chave
	  diferente. O método eficiente troca a chave directamente.
	</para>
      </description>
    </function>

    <function name="bwfilt" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int">n</fnarg>
	<fnarg type="scalar">omega</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha serie co que resulta ao aplicar un filtro paso-baixo
	  de Butterworth de orde <argname>n</argname> e frecuencia de
	  corte <argname>omega</argname>, na serie <argname>y</argname>.
	  O corte exprésase en graos e debe de ser maior ou igual a cero,
	  e menor ca 180. Os valores de corte máis pequenos van restrinxir o
	  paso-banda a menores frecuencias, e así producen unha tendencia
	  máis suave. Os valores maiores de <argname>n</argname> producen
	  un corte máis agudo, mais co custo de poder ter inestabilidade
	  numérica.
	</para>
	<para>
	  A inspección preliminar do periodograma da serie de interese é moi
	  útil cando se desexa aplicar esta función. Para obter máis detalles,
	  consulta o <guideref targ="chap:tsfilter"/>.
	  <seelist>
            <fncref targ="bkfilt"/>
            <fncref targ="hpfilt"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="bwrite" section="data-utils" output="int">
      <fnargs>
	<fnarg type="bundle">B</fnarg>
	<fnarg type="string">nomeficheiro</fnarg>
	<fnarg optional="true" type="bool">exportar</fnarg>
      </fnargs>
      <description>
	<para>
	  Escribe o feixe (bundle) <argname>B</argname> nun ficheiro, serializado
	  en XML; ou como JSON, se <argname>nomeficheiro</argname> ten extensión
	  <lit>.json</lit> ou <lit>.geojson</lit>. Consulta <fncref targ="bread"/>
	  para ter unha descrición do formato cando se usa XML. Se xa existe un
	  ficheiro denominado <argname>nomeficheiro</argname>, vaise sobrescribir.
	  Esta función devolve o valor 0 no caso de que conclúa con éxito; se
	  ocorren fallos, tales como a imposibilidade de sobrescribir o ficheiro,
	  a función devolve un valor non nulo.
	</para>
	<para>
	  O ficheiro de saída gárdase no cartafol <cmdref targ="workdir"/>
	  vixente, agás que <argname>nomeficheiro</argname> conteña o camiño
	  completo co cartafol no que vai ser gardado. Agora ben, cando se indica
	  un valor non nulo para o argumento <argname>exportar</argname>,
	  o ficheiro vaise gardar no cartafol <quote>punto</quote> do usuario.
	  Neste caso, o argumento <argname>nomeficheiro</argname> deberá
	  de ser un nome simple de ficheiro, sen a inclusión do camiño ao cartafol.
	</para>
	<para>
	  Dispós da opción de compresión gzip, pero unicamente no caso
	  de que o resultado sexa de tipo XML. Isto vaise aplicar se
	  <argname>nomeficheiro</argname> ten a extensión <lit>.gz</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="bread"/>
            <fncref targ="mwrite"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="carg" section="complex" output="matrix">
      <fnargs>
	<fnarg type="cmatrix">C</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz real de dimensión <by r="m" c="n"/> que contén o
	  <quote>argumento</quote> complexo de cada elemento da matriz complexa
	  <argname>C</argname> de dimensión <by r="m" c="n"/>. O argumento do
	  número complexo <math>z</math> = <math>x</math> + <math>yi</math>
	  tamén pode calcularse mediante <lit>atan2(y, x)</lit>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="cmod"/>
	    <fncref targ="atan2"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cdemean" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="bool" optional="true">tipificar</fnarg>
      </fnargs>
      <description>
	<para>
	  Centra as columnas da matriz <argname>X</argname> a respecto
	  das súas medias. Se o segundo argumento (opcional) ten un valor
	  non nulo, entón os valores centrados divídense ademais polas
	  desviacións padrón de cada columna (que se caculan utilizando
	  <math>n</math> &minus; 1 como divisor, no que <math>n</math>
	  é o número de filas de <argname>X</argname>).
	</para>
	<para>
	  Cae na conta de que <fncref targ="stdize"/> proporciona unha
	  funcionalidade máis flexible.
	</para>
      </description>
    </function>

    <function name="cdf" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <examples>
	<example>p1 = cdf(N, -2.5)</example>
	<example>p2 = cdf(X, 3, 5.67)</example>
	<example>p3 = cdf(D, 0.25, -1, 1)</example>
      </examples>
      <description>
	<para>
	  Calcula o valor da función de distribución acumulativa, e devolve
	  un resultado (do mesmo tipo ca o argumento) coa probabilidade
	  <equation status="inline" ascii="P(X &le; x)" tex="$P(X \le x)$"/>,
	  onde a distribución de <math>X</math> se especifica por medio da letra
	  <argname>d</argname>. Entre os argumentos <argname>d</argname> e
	  <argname>x</argname> pode necesitarse algún argumento adicional
	  escalar para especificar os parámetros da distribución, tal e como
	  se indica a continuación (mais observa que a distribución Normal
	  ten a súa propia función, por conveniencia, <fncref targ="cnorm"/>):
	</para>
	<ilist context="notex">
	  <li>
            <para>
              Normal estándar (d = z, n ou N): sen argumentos extras
            </para>
	  </li>
	  <li>
            <para>
              Normal bivariante (D): coeficiente de correlación
            </para>
	  </li>
	  <li>
            <para>
              Loxística (lgt ou s): sen máis argumentos
            </para>
	  </li>
	  <li>
            <para>
              t de Student (t): graos de liberdade
            </para>
	  </li>
	  <li>
            <para>
              Khi-cadrado (c, x ou X): graos de liberdade
            </para>
	  </li>
	  <li>
            <para>
              F de Snedecor (f ou F): graos de liberdade (num.), graos de liberdade (den.)
            </para>
	  </li>
	  <li>
            <para>
              Gamma (g ou G): forma, escala
            </para>
	  </li>
	  <li>
            <para>
              Beta (beta): 2 parámetros de forma
            </para>
	  </li>
	  <li>
            <para>
              Binomial (b ou B): probabilidade, cantidade de ensaios
            </para>
	  </li>
	  <li>
            <para>
              Poisson (p ou P): media
            </para>
	  </li>
	  <li>
            <para>
              Exponencial (exp): escala
            </para>
	  </li>
	  <li>
            <para>
              Weibull (w ou W): forma, escala
            </para>
	  </li>
	  <li>
            <para>
              Laplace (l ou L): media; escala
            </para>
	  </li>
	  <li>
            <para>
              Erro Xeneralizado (E): forma
            </para>
	  </li>
	  <li>
	    <para>
	      Khi-cadrado non central (ncX): graos de liberdade, parámetro de non centralidade
	    </para>
	  </li>
	  <li>
	    <para>
	      F non central (ncF): graos de liberdade (num.), graos de liberdade (den.),
	      parámetro de non centralidade
	    </para>
	  </li>
	  <li>
	    <para>
	      t non central (nct): graos de liberdade, parámetro de non centralidade
	    </para>
	  </li>
	</ilist>
	<tabular colspec="lllll">
	  \textit{Distribución} &amp; \textsl{d} &amp;
	  \textit{Arg} 2 &amp; \textit{Arg} 3 &amp; \textit{Arg} 4 \\[4pt]
	  Normal estándar &amp; \texttt{z}, \texttt{n} ou \texttt{N} &amp;
	  -- &amp; -- &amp; --\\
	  Normal bivariante &amp; \texttt{D} &amp;
	  $\rho$ &amp; -- &amp; --\\
	  Loxística &amp; \texttt{lgt} &amp;
	  -- &amp; -- &amp; --\\
	  $t$ de Student (central) &amp; \texttt{t} &amp;
	  gl &amp; -- &amp; --\\
	  Khi-cadrado &amp; \texttt{c}, \texttt{x} ou \texttt{X} &amp;
	  gl &amp; -- &amp; --\\
	  $F$ de Snedecor &amp; \texttt{f} ou \texttt{F} &amp;
	  gl (num.) &amp; gl (den.) &amp; --\\
	  Gamma &amp; \texttt{g} ou \texttt{G} &amp;
	  forma &amp; escala &amp; --\\
	  Binomial &amp; \texttt{b} ou \texttt{B} &amp;
	  probabilidade &amp; ensaios &amp; --\\
	  Poisson &amp; \texttt{p} ou \texttt{P} &amp;
	  media &amp; -- &amp; --\\
	  Exponencial &amp; \texttt{exp} &amp;
	  escala &amp; -- &amp; --\\
	  Weibull &amp; \texttt{w} ou \texttt{W} &amp;
	  forma &amp; escala &amp; --\\
	  Laplace &amp; \texttt{l} ou \texttt{L} &amp;
	  media &amp; escala &amp; --\\
	  Erro Xeneralizado &amp; \texttt{E} &amp;
	  forma &amp; -- &amp; --\\
	  $\chi^2$ non central &amp; \texttt{ncX} &amp;
	  gl &amp; non centralidade &amp; --\\
	  $F$ non central &amp; \texttt{ncF} &amp;
	  gl (num.) &amp; gl (den.) &amp; non centralidade\\
	  $t$ non central &amp; \texttt{nct} &amp;
	  gl &amp; non centralidade &amp; --\\
	</tabular>
	<para>
	  Cae na conta de que, na maioría dos casos, existen alcumes para axudar
	  a memorizar os códigos. O caso da normal bivariante é especial: a
	  sintaxe é <lit>x = cdf(D, rho, z1, z2)</lit> onde <lit>rho</lit>
	  é o coeficiente de correlación entre as variables <lit>z1</lit>
	  e <lit>z2</lit>.
	</para>
	<para context="tex">
	  A disposición de parámetros que usa o Gretl para a variable
	  aleatoria Gamma implica que a súa función de densidade pode escribirse
	  \[
	  f(x; k, \theta) = \frac{x^{k-1}}{\theta^k} \frac{e^{-x/\theta}}{\Gamma(k)}
	  \]
	  onde $k&gt;0$ é o parámetro de forma, e $\theta&gt;0$ é o parámetro
	  de escala.
	</para>
	<para>
	  <seelist>
            <fncref targ="pdf"/>
            <fncref targ="critical"/>
            <fncref targ="invcdf"/>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cdiv" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">Y</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta é unha función herdada, anterior ao soporte
	  orixinal de Gretl para matrices complexas.
	</para>
	<para>
	  Devolve unha matriz co resultado de dividir números complexos. Os dous
	  argumentos deben comporse do mesmo número de filas, <math>n</math>, e
	  dunha ou dúas columnas. A primeira columna contén a parte real, e a
	  segunda (se existe) contén a parte imaxinaria. O resultado que se
	  devolve é unha matriz de orde <by r="n" c="2"/> ou, no caso de non
	  existir a parte imaxinaria, un vector con <math>n</math> filas.
	  <seelist>
            <fncref targ="cmult"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cdummify" section="transforms" output="list">
      <fnargs>
	<fnarg type="list">L</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta función devolve unha lista na que cada serie do argumento
	  <argname>L</argname> que teña o atributo <quote>codificado</quote>,
	  substitúese por un conxunto de variables ficticias que representan
	  cada un dos seus valores codificados, pero omitindo o valor
	  máis pequeno. Se o argumento <argname>L</argname> non contén
	  ningunha serie codificada, o valor que se devolve vai ser idéntico
	  a <argname>L</argname>.
	</para>
	<para>
	  No caso de que se xeren, as variables ficticias noméanse co
	  padrón <lit>D</lit><repl>varname</repl><lit>_</lit><repl>vi</repl>,
	  no que <repl>vi</repl> indica o <repl>i</repl><sup>-ésimo</sup>
	  valor representado da variable que se codifica. No caso de que
	  algúns dos valores sexan negativos, vaise inserir <quote>m</quote>
	  antes do valor (absoluto) de
	  <repl>vi</repl>.
	</para>
	<para>
	  Por exemplo, supón que <argname>L</argname> contén unha serie
	  codificada chamada <lit>C1</lit> cos valores &minus;9, &minus;7,
	  0, 1 e 2. Entón, as variables ficticias xeradas van ser
	  <lit>DC1_m7</lit> (que codifica cando C1 = &minus;7),
	  <lit>DC1_0</lit> (que codifica cando C1 = 0), etcétera.
	</para>
	<para>
	  <seelist>
            <fncref targ="dummify"/>
	    <fncref targ="getinfo"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ceil" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Función tope: devolve un resultado (do tipo do argumento) co menor
	  enteiro que sexa maior ou igual a <argname>x</argname>.
	  <seelist>
            <fncref targ="floor"/>
            <fncref targ="int"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cholesky" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="pdmat">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza a descomposición de Cholesky de <argname>A</argname>.
	  Cando <argname>A</argname> sexa unha matriz real, deberá ser
	  simétrica e definida positiva; nese caso, o resultado será
	  unha matriz triangular inferior <math>L</math> que verificará
	  <equation status="inline" ascii="A = LL'" tex="$A = LL'$"/>.
	  Cando <argname>A</argname> sexa complexa, deberá ser
	  Hermitiana e definida positiva; e o resultado será unha matriz
	  complexa triangular inferior de xeito que
	  <equation status="inline" ascii="A = LL^H" tex="$A = LL^{\mathrm H}$"/>.
	</para>
	<para>
	  Para o caso real, consulta tamén <fncref targ="psdroot"/> e
	  <fncref targ="Lsolve"/>.
	</para>
      </description>
    </function>

    <function name="chowlin" section="transforms" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="int">factorx</fnarg>
	<fnarg type="matrix" optional="true">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Non se recomenda seguir utilizando esta función; en troques,
	  utiliza <fncref targ="tdisagg"/>.
	</para>
	<para>
	  Devolve unha matriz como resultado de expandir os datos de
	  entrada, <argname>Y</argname>, a unha frecuencia maior, co método
	  de <cite key="chowlin71">Chow e Lin (1971)</cite>. Asúmese que as
	  columnas de <argname>Y</argname> representan series de datos.
	  A matriz que se devolve ten o mesmo número de columnas que
	  <argname>Y</argname> e <argname>factorx</argname> veces o seu
	  número de filas. Tamén se asume que cada valor de baixa frecuencia
	  debe tratarse como a media de <argname>factorx</argname> valores
	  de alta frecuencia.
	</para>
	<para>
	  O valor de <argname>factorx</argname> debe ser igual a 3 para expandir
	  datos trimestrais a mensuais, 4 para facelo de anuais a trimestrais, ou
	  12 de anuais a mensuais. Podes usar o terceiro argumento (opcional)
	  para prover unha matriz de covariables cun obxectivo de maior frecuencia.
	</para>
	<para>
	  Os regresores que se utilizan por defecto son unha constante e
	  unha tendencia. Cando se proporciona <argname>X</argname>, as
	  súas columnas utilízanse como regresores adicionais. A función
	  devolve un fallo se o número de filas de <argname>X</argname> non
	  é igual a <argname>factorx</argname> veces o número de filas de
	  <argname>Y</argname>.
	</para>
      </description>
    </function>

    <function name="cmod" section="complex" output="matrix">
      <fnargs>
	<fnarg type="cmatrix">C</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz real de dimensión <by r="m" c="n"/>
	  que contén o módulo complexo de cada elemento da matriz
	  complexa <argname>C</argname> de dimensión
	  <by r="m" c="n"/>. O módulo do número complexo
	  <math>z</math> = <math>x</math> + <math>yi</math> é igual á raíz
	  cadrada de <math>x</math><sup>2</sup> + <math>y</math><sup>2</sup>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="carg"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cmult" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">Y</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta é unha función herdada, anterior ao soporte
	  orixinal de Gretl para matrices complexas.
	</para>
	<para>
	  Devolve unha matriz co resultado de multiplicar números complexos. Os dous
	  argumentos deben comporse do mesmo número de filas, <math>n</math>, e
	  dunha ou dúas columnas. A primeira columna contén a parte real e a
	  segunda (se existe) contén a parte imaxinaria. O resultado que se
	  devolve é unha matriz de orde <by r="n" c="2"/> ou, no caso de non
	  existir a parte imaxinaria, un vector con <math>n</math> filas.
	  <seelist>
            <fncref targ="cdiv"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cnorm" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve a función de distribución acumulativa para unha Normal
	  estándar.
	  <seelist>
            <fncref targ="dnorm"/>
            <fncref targ="qnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cnumber" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co número de condición dunha matriz
	  <argname>X</argname> de orde <by r="n" c="k"/>, conforme se define
	  en <cite key="belsley-etal80"> Belsley, Kuh e Welsch (1980)</cite>.
	  Se as columnas de <argname>X</argname> son mutuamente ortogonais,
	  o número de condición de <argname>X</argname> é a unidade. Pola
	  contra, un valor grande do número de condición enténdese como un
	  indicio de alto grao de multicolinearidade; habitualmente considérase
	  que o valor é <quote>grande</quote> se é maior ou igual a 50 (ou,
	  algunhas veces, a 30).
	</para>
	<para>
	  Os pasos para facer os cálculos son: (1) conformar unha matriz
	  <math>Z</math> cuxas columnas sexan o resultado de dividir cada
	  columna de <argname>X</argname> pola súa respectiva norma
	  euclidiana; (2) construír a matriz <math>Z'Z</math> e obter os seus
	  autovalores; e (3) calcular a raíz cadrada da razón entre o maior
	  e o menor autovalor.
	</para>
	<para>
	  <seelist>
            <fncref targ="rcond"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cnameget" section="strings" output="string-or-strings">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="int" optional="true">col</fnarg>
      </fnargs>
      <description>
	<para>
	  Se indicas o argumento <argname>col</argname>, devolve unha cadea
	  de texto co nome da columna <argname>col</argname> da matriz
	  <argname>M</argname>. Se as columnas de <argname>M</argname>
	  non teñen nome, entón devólvese unha cadea baleira; e se
	  <argname>col</argname> está fóra dos límites do número de columnas
	  desta matriz, amósase un fallo.
	</para>
	<para>
	  Se non indicas o segundo argumento, devolve un arranxo de cadeas
	  de texto que contén os nomes das columnas de <argname>M</argname>,
	  ou un arranxo baleiro se <argname>M</argname> non ten asignados
	  nomes de columnas.
	</para>
	<para>
	  Exemplo:
	</para>
	<code>
	  matrix A = { 11, 23, 13 ; 54, 15, 46 }
	  cnameset(A, "Col_A Col_B Col_C")
	  string name = cnameget(A, 3)
	  print name
	</code>
	<para>
	  <seelist>
            <fncref targ="cnameset"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cnameset" section="matbuild" output="scalar">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="strings-or-list">S</fnarg>
      </fnargs>
      <description>
	<para>
	  Engade nomes ás columnas da matriz de orde <by r="T" c="k"/>,
	  <argname>M</argname>. Cando <argname>S</argname> é unha lista,
	  os nomes son os das series listadas (é preciso que esa lista teña
	  <math>k</math>elementos). Cando <argname>S</argname> é un arranxo
	  de cadeas de texto, deberá de ter <math>k</math> elementos. Para
	  manter a compatibilidade con versións anteriores de Gretl, podes
	  tamén utilizar unha única cadea de texto como segundo argumento.
	  Nese caso, esta cadea precisa ter <math>k</math> subcadeas separadas
	  por espazos.
	</para>
	<para>
	  Devolve o valor 0 se as columnas son nomeadas con éxito; noutro caso,
	  devolve un valor non nulo. Consulta tamén <fncref targ="rnameset"/>.
	</para>
	<para>
	  Exemplo:
	</para>
	<code>
	  matrix M = {1, 2; 2, 1; 4, 1}
	  strings S = array(2)
	  S[1] = "Col1"
	  S[2] = "Col2"
	  cnameset(M, S)
	  print M
	</code>
      </description>
    </function>

    <function name="cols" section="matshape" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un enteiro co número de columnas da matriz <argname>X</argname>.
	  <seelist>
            <fncref targ="mshape"/>
            <fncref targ="rows"/>
            <fncref targ="unvech"/>
            <fncref targ="vec"/>
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="complex" section="complex" output="cmatrix">
      <fnargs>
	<fnarg type="scalar-or-matrix">A</fnarg>
	<fnarg optional="true" type="scalar-or-matrix">B</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz complexa, na que tómase <argname>A</argname>
	  para ofrecer a parte real e <argname>B</argname> para a parte
	  imaxinaria. Se <argname>A</argname> é de dimensión <by r="m" c="n"/>
	  e <argname>B</argname> é un escalar, o resultado é unha matriz
	  <by r="m" c="n"/> cunha parte imaxinaria constante (e de xeito
	  similar no caso recíproco, mais cunha parte real constante). Se
	  ambos argumentos son matrices, deben de ter as mesmas dimensións.
	  Se omites o segundo argumento, a parte imaxinaria establécese por
	  defecto como cero.
	  <seelist><fncref targ="cswitch"/></seelist>
	</para>
      </description>
    </function>

    <function name="conj" section="complex" output="cmatrix">
      <fnargs>
	<fnarg type="cmatrix">C</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz complexa de dimensión <by r="m" c="n"/>
	  que contén o conxugado complexo de cada elemento da matriz
	  complexa <argname>C</argname> de dimensión <by r="m" c="n"/>.
	  O conxugado dun número complexo
	  <math>z</math> = <math>x</math> + <math>yi</math> é igual a
	  <math>x</math> &minus; <math>yi</math>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="carg"/>
	    <fncref targ="cmod"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="conv2d" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix">B</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz co cálculo da convolución bidimensional (2D)
	  de dúas matrices <argname>A</argname> e <argname>B</argname>.
	  Se <argname>A</argname> é de orde <by r="r" c="c"/>, e
	  <argname>B</argname> é de orde <by r="m" c="n"/>, entón
	  a matriz que se devolve vai ter <math>r+m-1</math> filas
	  e <math>c+n-1</math> columnas.
	</para>
	<para context="tex">
	    A convolución 2D de <argname>A</argname> e
	    <argname>B</argname> defínese como
	    \[
	    C_{i,j} =
	    \sum_{k=1}^r\sum_{l=1}^c A_{k,l} B_{i-k+1,j-l+1},
	    \]
	    onde as sumas admiten só aqueles valores de $k$ e de $l$ para
	    os que os subíndices de $B$ están dentro dos límites definidos.
	</para>
	<para>
	  <seelist>
            <fncref targ="fft"/>
            <fncref targ="filter"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="corr" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y1</fnarg>
	<fnarg type="series-or-vec">y2</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co valor do coeficiente de correlación entre
	  <argname>y1</argname> e <argname>y2</argname>. Os argumentos deben
	  de ser dúas series ou dous vectores do mesmo tamaño.
	  <seelist>
            <fncref targ="cov"/>
            <fncref targ="mcov"/>
            <fncref targ="mcorr"/>
            <fncref targ="npcorr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="corrgm" section="stats" output="matrix">
      <fnargs>
	<fnarg type="smlist">x</fnarg>
	<fnarg type="int">p</fnarg>
	<fnarg optional="true" type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Cando se proporcionan só os dous primeiros argumentos, a función
	  devolve unha matriz co correlograma de <argname>x</argname> para
	  os retardos dende 1 ata <argname>p</argname>. Se <math>k</math> é o
	  número de elementos de <argname>x</argname> (igual a 1 se
	  <argname>x</argname> é unha serie, igual ao número de columnas se
	  <argname>x</argname> é unha matriz, ou igual ao número de elementos
	  se <argname>x</argname> é unha lista), o valor que se devolve é unha
	  matriz con <argname>p</argname> filas e 2<math>k</math> columnas,
	  na que as <math>k</math> primeiras columnas conteñen as respectivas
	  autocorrelacións, e as restantes conteñen as respectivas autocorrelacións
	  parciais.
	</para>
	<para>
	  Cando se indica o terceiro argumento, esta función calcula o
	  correlograma cruzado dende <math>+</math><argname>p</argname>
	  ata <math>-</math><argname>p</argname> para cada un dos <math>k</math>
	  elementos de <argname>x</argname> e <argname>y</argname>. A matriz
	  que se devolve componse de 2<math>p</math> + 1 filas e <math>k</math>
	  columnas. Se <argname>x</argname> é unha serie ou unha lista, e
	  <argname>y</argname> é un vector, este último é preciso que teña
	  tantas filas coma o número total de observacións que hai na mostra
	  seleccionada en vigor.
	</para>
      </description>
    </function>

    <function name="cos" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co coseno de <argname>x</argname>.
	  <seelist>
            <fncref targ="sin"/>
            <fncref targ="tan"/>
            <fncref targ="atan"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cosh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co coseno hiperbólico de <argname>x</argname>.
	</para>
	<para context="tex">
	  \[ \cosh x = \frac{e^x + e^{-x}}{2}  \]
	</para>
	<para>
	  <seelist>
            <fncref targ="acosh"/>
            <fncref targ="sinh"/>
            <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cov" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y1</fnarg>
	<fnarg type="series-or-vec">y2</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar coa covarianza entre <argname>y1</argname> e
	  <argname>y2</argname>. Os argumentos deben de ser dúas series,
	  ou ben dous vectores da mesma longura.
	  <seelist>
            <fncref targ="corr"/>
            <fncref targ="mcov"/>
            <fncref targ="mcorr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="critical" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="char">c</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">p</fnarg>
      </fnargs>
      <examples>
	<example>c1 = critical(t, 20, 0.025)</example>
	<example>c2 = critical(F, 4, 48, 0.05)</example>
      </examples>
      <description>
	<para>
	  Permite calcular valores críticos, e devolve un resultado do mesmo tipo
	  que o introducido. O valor <math>x</math> que se devolve vai cumprir
	  <equation status="inline" ascii="P(X &gt; x) = p" tex="$P(X \gt x) = p$"/>,
	  onde a distribución de <math>X</math> determínase pola letra
	  <argname>c</argname>. Entre os argumentos <argname>d</argname> e
	  <argname>x</argname>, pode necesitarse algún outro adicional (escalar)
	  para indicar os parámetros da distribución. Isto faise deste xeito:
	</para>
	<ilist context="notex">
	  <li>
            <para>
              Normal estándar (c = z, n ou N): sen argumentos extras
            </para>
	  </li>
	  <li>
            <para>
              t de Student (t): graos de liberdade
            </para>
	  </li>
	  <li>
            <para>
              Khi-cadrado (c, x ou X): graos de liberdade
            </para>
	  </li>
	  <li>
            <para>
              F de Snedecor (f ou F): graos de liberdade (num.), graos de liberdade (den.)
            </para>
	  </li>
	  <li>
            <para>
              Binomial (b ou B): probabilidade, cantidade de ensaios
            </para>
	  </li>
	  <li>
            <para>
              Poisson (p ou P): media
            </para>
	  </li>
	  <li>
            <para>
              Laplace (l ou L): media; escala
            </para>
	  </li>
	  <li>
            <para>
              Erro Xeneralizado (E): forma
            </para>
	  </li>
	</ilist>
	<tabular colspec="llll">
	  \textit{Distribución} &amp; \textsl{c} &amp;
	  \textit{Arg} 2 &amp; \textit{Arg} 3 \\[4pt]
	  Normal estándar &amp; \texttt{z}, \texttt{n} ou \texttt{N} &amp;
	  -- &amp; -- \\
	  $t$ de Student (central) &amp; \texttt{t} &amp;
	  graos de liberdade &amp; -- \\
	  Khi-cadrado &amp; \texttt{c}, \texttt{x} ou \texttt{X} &amp;
	  graos de liberdade &amp; -- \\
	  $F$ de Snedecor &amp; \texttt{f} ou \texttt{F} &amp;
	  graos de liberdade (num.) &amp; graos de liberdade (den.) \\
	  Binomial &amp; \texttt{b} ou \texttt{B} &amp;
	  $p$ &amp; $n$ \\
	  Poisson &amp; \texttt{p} ou \texttt{P} &amp;
	  $\lambda$ &amp; -- \\
	  Laplace &amp; \texttt{l} ou \texttt{L} &amp;
	  media &amp; escala \\
	  Erro Xeneralizado &amp; \texttt{E} &amp;
	  forma &amp; -- \\
	</tabular>
	<para>
	  <seelist>
            <fncref targ="cdf"/>
            <fncref targ="invcdf"/>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cswitch" section="complex" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="scalar">xeito</fnarg>
      </fnargs>
      <description>
	<para>
	  Reinterpreta unha matriz real como se contivese valores complexos,
	  ou viceversa. A acción concreta depende de <argname>xeito</argname>
	  (que deberá ter un valor de 1, 2, 3 ou 4), como se explica deseguido:
	</para>
	<para>
	  Xeito 1: O argumento <argname>A</argname> debe ser unha matriz
	  real cun número par de columnas. A función devolve unha matriz coa
	  metade das columnas, con valores complexos formados utilizando as
	  columnas impares de <argname>A</argname> para as partes reais, e
	  as columnas pares para as partes imaxinarias.
	</para>
	<para>
	  Xeito 2: Permite facer a operación inversa á do xeito 1. O argumento
	  <argname>A</argname> debe ser unha matriz complexa, e o resultado
	  que se devolve é unha matriz real que terá o dobre de columnas que
	  as de <argname>A</argname>.
	</para>
	<para>
	  Xeito 3: O argumento <argname>A</argname> debe ser unha matriz
	  real cun número par de filas. A función devolve unha matriz coa
	  metade das filas, con valores complexos formados utilizando as
	  filas impares de <argname>A</argname> para as partes reais, e
	  as filas pares para as partes imaxinarias.
	</para>
	<para>
	  Xeito 4: Permite facer a operación inversa á do xeito 3. O argumento
	  <argname>A</argname> debe ser unha matriz complexa, e o resultado
	  que se devolve é unha matriz real que terá o dobre de filas que as de
	  <argname>A</argname>.
	</para>
	<para>
	  <seelist><fncref targ="complex"/></seelist>
	</para>
      </description>
    </function>

    <function name="ctrans" section="complex" output="cmatrix">
      <fnargs>
	<fnarg type="cmatrix">C</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz complexa de dimensión <by r="n" c="m"/> que
	  contén a trasposta conxugada da matriz complexa <argname>C</argname>
	  de dimensión <by r="m" c="n"/>. O operador <lit>&apos;</lit> (traspoñer)
	  fai tamén a transposición conxugada de matrices complexas. Podes
	  utilizar a función <fncref targ="transp"/> con matrices complexas,
	  pero iso vai realizar a transposición <quote>directa</quote>
	  (non a conxugada).
	</para>
      </description>
    </function>

    <function name="cum" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Acumula <argname>x</argname> (isto é, crea unha suma móbil). Cando
	  <argname>x</argname> é unha serie, produce unha serie <math>y</math>
	  na que cada un dos seus elementos é igual á suma dos valores de
	  <argname>x</argname> ata a observación correspondente. O punto de
	  partida para a acumulación é a primeira observación non ausente da
	  mostra vixente seleccionada. Cando <argname>x</argname> é unha
	  matriz, os seus elementos acumúlanse por columnas.
	</para>
	<para context="tex">
	  Acumula <argname>x</argname>. Cando <math>x</math> é unha serie,
	  produce unha serie y_t = \sum_{s=m}^t x_s$, na que o punto de partida
	  <math>m</math> para a acumulación, é a primeira observación
	  non ausente da mostra provisionalmente seleccionada. Ao atopar valores
	  ausentes en <math>x</math>, os valores subseguintes de <math>y</math>
	  defínense como valores ausentes. Cando <argname>x</argname> é unha
	  matriz, os elementos acumúlanse por columnas.
	</para>
	<para>
	  <seelist>
            <fncref targ="diff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="curl" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="bundleref">&amp;b</fnarg>
      </fnargs>
      <description>
	<para>
	  Ofrece un medio bastante flexible de obter un <quote>buffer</quote> de
	  texto que contén datos dun servidor de internet, utilizando a biblioteca
	  'libcurl'. Ao escribila, o argumento de tipo feixe <argname>b</argname>,
	  debe de conter unha cadea de texto chamada <lit>URL</lit> que indica
	  o enderezo completo do recurso no 'host' de destino. Outros elementos
	  opcionais preséntanse deseguido:
	</para>
	<ilist>
	  <li>
	    <para>
	      <quote><lit>header</lit></quote>: unha cadea de texto que
	      especifica un 'header' HTTP que vai enviarse ao 'host'.
	    </para>
	  </li>
	  <li>
	    <para>
	      <quote><lit>postdata</lit></quote>: unha cadea de texto que
	      contén os datos que van enviarse ao 'host'.
	    </para>
	  </li>
	</ilist>
	<para>
	  Os campos <lit>header</lit> e <lit>postdata</lit> destínanse
	  para usarse cunha solicitude HTTP do tipo <lit>POST</lit>. Se
	  está presente <lit>postdata</lit>, vai implícito o método
	  <lit>POST</lit>; noutro caso, vai implícito o método <lit>GET</lit>.
	  (Mais observa que para sinxelas solicitudes <lit>GET</lit>, a
	  función <fncref targ="readfile"/> ofrece unha interface máis
	  simple.)
	</para>
	<para>
	  Recoñécese outro elemento opcional do feixe: se está presente
	  un escalar chamado <lit>include</lit> e ten un valor non nulo, isto
	  enténdese como unha solicitude para incluír o 'header' recibido do
	  'host', no corpo do resultado.
	</para>
	<para>
	  Ao completarse a solicitude, o texto recibido do servidor
	  engádese ao feixe coa chave
	  <quote><lit>output</lit></quote>.
	</para>
	<para>
	  A función vai fallar se hai unha equivocación ao formular a solicitude
	  (por exemplo, se non existe unha <lit>URL</lit> na entrada); noutro caso,
	  vai devolver o valor 0 se a solicitude prospera, ou un valor non
	  nulo se non o fai. Neste último caso, engádese a mensaxe de
	  fallo da biblioteca 'curl' ao feixe, co identificador 
	  <quote><lit>errmsg</lit></quote>. Cae na conta, porén, que
	  <quote>éxito</quote> neste senso non significa necesariamente
	  que obtés os datos que desexabas; en realidade significa tan só 
	  que se recibiu algunha resposta do servidor. Debes comprobar o
	  contido do <quote>buffer</quote> de saída (que de feito pode ser
	  unha mensaxe tal como <quote>Páxina non atopada</quote>).
	</para>
	<para>
	  Aquí temos un exemplo de como utilizar esta función: para baixar
	  algúns datos da web da US Bureau of Labor Statistics, que require
	  o envío dunha consulta JSON. Observa o uso de <fcnref targ="sprintf"/>
	  para inserir comiñas nos datos <lit>POST</lit>.
	</para>
	<code>
	  bundle req
	  req.URL = "http://api.bls.gov/publicAPI/v1/timeseries/data/"
	  req.include = 1
	  req.header = "Content-Type: application/json"
	  string s = sprintf("{\"seriesid\":[\"LEU0254555900\"]}")
	  req.postdata = s
	  err = curl(&amp;req)
	  if err == 0
	      s = req.output
	      string line
	      loop while getline(s, line)
	          printf "%s\n", line
	      endloop
	  endif
	</code>
	<para>
	  Consulta tamén as funcións <fncref targ="jsonget"/> e
	  <fncref targ="xmlget"/> para ver xeitos de procesamento
	  de datos recibidos no formato JSON e XML, respectivamente.
	</para>
      </description>
    </function>

    <function name="dayspan" section="calendar" output="int">
      <fnargs>
	<fnarg type="int">d1</fnarg>
	<fnarg type="int">d2</fnarg>
	<fnarg type="int">duracsemana</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un número enteiro co número de días (relevantes) entre os
	  días de época <argname>d1</argname> e <argname>d2</argname>, ambos
	  incluídos, considerando a duración de semana indicada polo argumento
	  <argname>duracsemana</argname>. Este debe de ser igual a 5, 6 ou 7
	  (indicando o valor 6 que non se contan os domingos, e o 5 que non se
	  contan nin os sábados nin os domingos).
	</para>
	<para>
	  Para obter os días de época no formato máis familiar das datas,
	  consulta <fncref targ="epochday"/>. Relacionado con isto, consulta
	  <fncref targ="smplspan"/>.
	</para>
      </description>
    </function>

    <function name="defarray" section="data-utils" output="seebelow">
      <fnargs>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Permite definir <emphasis>cumpridamente</emphasis> unha variable
	  de tipo arranxo (<quote>array</quote>), proporcionando un ou máis
	  elementos. Ao utilizar esta función debes especificar o tipo de
	  arranxo (en forma plural): <lit>strings</lit>, <lit>matrices</lit>,
	  <lit>bundles</lit> ou <lit>lists</lit>. Cada un dos argumentos debe
	  de ser un obxecto do mesmo tipo que o tipo especificado na definición
	  do arranxo. No caso de completarse con éxito, a función devolve como
	  resultado un arranxo con <math>n</math> elementos, onde <math>n</math>
	  é igual ao número de argumentos.
	</para>
	<code>
	  strings S = defarray("foo", "bar", "baz")
	  matrices M = defarray(I(3), X'X, A*B, P[1:])
	</code>
	<para>
	  Consulta tamén <fncref targ="array"/>.
	</para>
      </description>
    </function>

    <function name="defbundle" section="data-utils" output="bundle">
      <fnargs>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Te permite a carga inicial dunha variable de tipo feixe
	  <emphasis>extensamente</emphasis>, proporcionando cero ou
	  máis parellas co formato <repl>chave</repl>, <repl>elemento</repl>.
	  Se contamos os argumentos desde 1, cada argumento numerado
	  impar debe de avaliar unha cadea de texto (chave), e cada
	  argumento numerado par debe de avaliar un obxecto dun tipo
	  que poida incluírse nun feixe.
	</para>
	<para>
	  Un par de exemplos sinxelos:
	</para>
	<code>
	  bundle b1 = defbundle("s", "Sample string", "m", I(3))
	  bundle b2 = defbundle("yn", normal(), "x", 5)
	</code>
	<para>
	  O primeiro exemplo xera un feixe cuxos elementos son unha cadea
	  de texto e unha matriz; o segundo, un feixe cun elemento que é
	  unha serie e outro que é escalar. Ten en conta que non podes
	  especificar un tipo para cada argumento cando utilizas esta función,
	  entón debes de aceptar o tipo <quote>natural</quote> de argumento
	  en cuestión. Se queres engadir unha serie cun valor constante de 5
	  a un feixe chamado <lit>b1</lit> sería necesario facer algo como
	  o seguinte (despois de definir <lit>b1</lit>):
	</para>
	<code>
	  series b1.s5 = 5
	</code>
	<para>
	  Se non indicas ningún argumento para esta función, iso
	  equivale a xerar un feixe baleiro (ou a baleirar un
	  feixe existente do seu contido), como poderías facer
	  mediante
	</para>
	<code>
	  bundle b = null
	</code>
	<subhead>Variantes de sintaxe</subhead>
	<para>
	  Dispós de dúas formas alternativas de sintaxe para definir feixes.
	  En ambos casos, a palabra chave <lit>defbundle</lit> substitúese
	  por un carácter de barra baixa. Na primeira variante, os elementos
	  separados por comas teñen a forma <lit>chave=valor</lit>, onde a
	  chave se entende que debe ser unha cadea de texto literal e non
	  require que a poñas entre comiñas. Este é un exemplo:
	</para>
	<code>
	  bundle b = _(x=5, strval="Algunha cadea", m=I(3))
	</code>
	<para>
	  Esta forma resulta particularmente conveniente para producir un feixe
	  anónimo improvisadamente como argumento dunha función, como en
	</para>
	<code>
	  b = regls(ys, LX, _(lfrac=0.35, stdize=0))
	</code>
	<para>
	  onde a función <lit>regls</lit> ten un argumento opcional de tipo
	  feixe que contén varios parámetros.
	</para>
	<para>
	  A segunda variante está pensada para o caso no que queiras empaquetar
	  varios obxectos xa existentes nun feixe: simplemente indica os seus
	  nomes sen comiñas:
	</para>
	<code>
	  bundle b = _(x, y, z)
	</code>
	<para>
	  Neste caso, o obxecto <lit>x</lit> se copia nun feixe coa chave
	  <quote><lit>x</lit></quote>. De xeito similar faise tanto para
	  <lit>y</lit> como para <lit>z</lit>.
	</para>
	<para>
	  Estas formas alternativas implican teclear menos que na versión
	  cumprida de <lit>defbundle()</lit>, e probablemente moitas veces
	  son máis convenientes, pero ten en conta que son menos flexibles.
	  Só na versión cumprida podes manexar as chaves indicándoas como
	  variables de cadea de texto en troques de cadeas literais.
	</para>
      </description>
    </function>

    <function name="deflist" section="data-utils" output="list">
      <fnargs>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Xera unha lista (de series xa definidas) dados un ou máis argumentos
	  apropiados. Cada argumento debe de ser, unha serie xa definida
	  (indicada polo seu nome ou o número enteiro ID), unha lista xa definida,
	  ou unha expresión que se corresponda cunha lista (incluíndo un vector que
	  poda interpretarse como un conxunto de números ID de series).
	</para>
	<para>
	  Un aspecto a ter en conta é que esta función simplemente encadea
	  os seus argumentos para producir a lista que devolve. Cando se
	  pretende que o valor que devolva non conteña duplicados (que non
	  se refira a ningunha serie máis dunha vez), depende do solicitante
	  asegurarse de que se satisfaga ese requirimento.
	</para>
      </description>
    </function>

    <function name="deseas" section="filters" output="series">
      <fnargs>
	<fnarg type="series">x</fnarg>
	<fnarg optional="true" type="char">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Precisa que estean instalados o TRAMO/SEATS e/ou X-12-ARIMA. Devolve
	  unha versión desestacionalizada (axustada estacionalmente) da serie
	  <argname>x</argname>, que debe de ser unha serie temporal mensual
	  ou trimestral. Para utilizar o X-12-ARIMA indica <lit>X</lit> como
	  segundo argumento; e para usar o TRAMO/SEATS indica <lit>T</lit>.
	  Se omites o segundo argumento, Gretl utiliza o X-12-ARIMA.
	</para>
	<para>
	  Observa que, cando a serie de entrada non ten unha compoñente
	  estacional detectable, a execución da función vai fallar. Cae na conta
	  tamén de que tanto o TRAMO/SEATS como o X-12-ARIMA ofrecen un gran
	  número de opcións; agora ben, a función <lit>deseas</lit> as utiliza
	  con todas as súas opcións nos seus valores por defecto. En ambos
	  os dous programas, os factores estacionais calcúlanse baseados nun
	  modelo ARIMA seleccionado automaticamente. Unha das diferenzas entre
	  os dous que pode levar a resultados bastante distintos, é que o
	  TRAMO/SEATS realiza un axuste previo das observacións con valores
	  atípicos, mentres que o X-12-ARIMA non o fai.
	</para>
      </description>
    </function>

    <function name="det" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co valor do determinante de <argname>A</argname>,
	  calculado mediante a descomposición LU. Se o que realmente queres é o
	  logaritmo natural do determinante, debes en troques invocar <fncref targ="ldet"/>.
	  <seelist>
            <fncref targ="rcond"/>
            <fncref targ="cnumber"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="diag" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector columna cos valores da diagonal principal de
	  <argname>X</argname>. Advirte que se <argname>X</argname> é unha
	  matriz de orde <by r="m" c="n"/>, o número de elementos do vector
	  resultante é igual a min(<math>m</math>, <math>n</math>).
	  <seelist>
            <fncref targ="tr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="diagcat" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix">B</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz coa suma directa de <argname>A</argname> e
	  <argname>B</argname>; é dicir, unha matriz que abrangue a
	  <argname>A</argname> no recanto superior esquerdo e a
	  <argname>B</argname> no recanto inferior dereito. Se
	  <argname>A</argname> e <argname>B</argname> son ambas
	  cadradas, a matriz resultante é diagonal por bloques.
	</para>
      </description>
    </function>

    <function name="diff" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="smlist">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do mesmo tipo que o argumento) coas primeiras
	  diferenzas. Se <argname>y</argname> é unha serie ou unha lista de series,
	  os valores iniciais son <lit>NA</lit>; se <argname>y</argname> é unha
	  matriz, a diferenciación faise por columnas e os valores iniciais son 0.
	</para>
	<para>
	  Cando esta función devolve unha lista, cada unha das variables
	  da mesma noméase de xeito automático conforme ao padrón
	  <lit>d_</lit><repl>varname</repl>, onde <repl>varname</repl>
	  substitúese polo nome da serie orixinal. De ser necesario, o nome
	  vai tronzarse; e mesmo axustarase no caso de que o conxunto de
	  nomes que se constrúe así, dea lugar a que algún deles non sexa
	  único.
	</para>
	<para>
	  <seelist>
            <fncref targ="cum"/>
            <fncref targ="ldiff"/>
            <fncref targ="sdiff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="digamma" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devolve un resultado (do tipo do argumento) co valor da función
	  digamma (ou Psi) de <argname>x</argname>, é dicir, a derivada do
	  logaritmo da función Gamma.
	</para>
	<para context="tex">
	  Devolve un resultado co valor da función digamma (ou Psi) de $x$, é
	  dicir $\frac{d}{dx}\, \mbox{ln } \Gamma(x)$.
	</para>
      </description>
    </function>

    <function name="dnorm" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do mesmo tipo que o argumento) co valor da
	  densidade da distribución de probabilidade Normal estándar en
	  <argname>x</argname>. Para obter a densidade dunha distribución Normal
	  non estándar en <math>x</math>, transforma tipificando <math>x</math>
	  en <math>z</math>, aplícalle a isto a función <lit>dnorm</lit> e
	  multiplica o resultado polo Jacobiano da transformación <math>z</math>,
	  é dicir , 1/&sigma;, conforme se ilustra deseguido:
	</para>
	<code>
	  mu = 100
	  sigma = 5
	  x = 109
	  fx = (1/sigma) * dnorm((x-mu)/sigma)
	</code>
	<para>
	  <seelist>
            <fncref targ="cnorm"/>
            <fncref targ="qnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="dropcoll" section="transforms" output="list">
      <fnargs>
	<fnarg type="list">X</fnarg>
	<fnarg optional="true" type="scalar">epsilon</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha lista cos mesmos elementos que <argname>X</argname>,
	  mais excluíndo as series que causan multicolinearidade perfecta. En
	  consecuencia, se todas as series que hai en <argname>X</argname>
	  son linearmente independentes, a lista que resulta é simplemente
	  unha copia de <argname>X</argname>.
	</para>
	<para>
	  O algoritmo usa a descomposición QR (transformación de Householder),
	  polo que está suxeito a erro de precisión finita. Co obxecto de
	  calibrar a sensibilidade do algoritmo, podes especificar un segundo
	  parámetro (opcional) <argname>epsilon</argname> para facer a proba
	  de multicolinearidade máis ou menos estrita, segundo desexes. Por
	  defecto, o valor para <argname>epsilon</argname> é 1.0e-8, pero
	  axustando <argname>epsilon</argname> dándolle valores maiores,
	  elévase a probabilidade de que se descarte unha das series.
	</para>
	<para>
	  O exemplo
	</para>
	<code>
	  nulldata 20
	  set seed 9876
	  series foo = normal()
	  series bar = normal()
	  series foobar = foo + bar
	  list X = foo bar foobar
	  list Y = dropcoll(X)
	  list print X
	  list print Y
	  # Indica un épsilon cun valor moi pequeno
	  list Y = dropcoll(X, 1.0e-30)
	  list print Y
	</code>
	<para>
	  produce
	</para>
	<code>
	  ? list print X
	  foo bar foobar
	  ? list print Y
	  foo bar
	  ? list Y = dropcoll(X, 1.0e-30)
	  Substituíuse a lista Y
	  ? list print Y
	  foo bar foobar
	</code>
      </description>
    </function>

    <function name="dsort" section="matshape" output="asinput">
      <fnargs>
	<fnarg type="series-vec-or-strings">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Ordena <argname>x</argname> de forma decrecente, descartando
	  observacións con valores ausentes cando <argname>x</argname> é
	  unha serie.
	  <seelist>
            <fncref targ="sort"/>
            <fncref targ="values"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="dummify" section="transforms" output="list">
      <fnargs>
	<fnarg type="series">x</fnarg>
	<fnarg optional="true" type="scalar">omitval</fnarg>
      </fnargs>
      <description>
	<para>
	  O argumento <argname>x</argname> debe de ser unha serie discreta. Esta
	  función devolve unha lista cun conxunto de variables ficticias, unha
	  para cada un dos diferentes valores da serie. Por defecto, o menor
	  valor trátase como a categoría omitida e non vai representarse
	  explicitamente.
	</para>
	<para>
	  O segundo argumento (opcional) indica o valor de <argname>x</argname>
	  que debe de tratarse como categoría omitida. Cando se indica un único
	  argumento, o efecto é equivalente ao de utilizar a instrución:
	  <lit>dummify(x, min(x))</lit>. Para producir un conxunto completo de
	  variables ficticias, é dicir, sen omitir ningunha categoría, podes
	  usar <lit>dummify(x, NA)</lit>.
	</para>
	<para>
	  As variables que se xeran noméanse automaticamente de acordo co
	  seguinte padrón:
	  <lit>D</lit><repl>nomevariable</repl><lit>_</lit><repl>i</repl> onde
	  <repl>nomevariable</repl> indica o nome da serie orixinal e <repl>i</repl>
	  é un índice enteiro positivo. De ser necesario, a porción orixinal do
	  nome vai tronzarse, e mesmo axustarase no caso de que o conxunto de
	  nomes que se constrúe así, dea lugar a que algún deles non sexa
	  único.
	</para>
      </description>
    </function>

    <function name="easterday" section="calendar" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Poñendo un ano como argumento <argname>x</argname>, devolve un
	  resultado do mesmo tipo ca este, coa data do domingo de Pascua dese
	  ano no calendario gregoriano, co formato <math>mes + día/100</math>.
	  Con esta convención, observa que o 10 de abril é 4,1; de aí que 4,2
	  represente o día 20 de abril e non o día 2 de abril (que é 4,02). Exemplo:
	</para>
	<code>
	  scalar e = easterday(2014)
	  scalar m = floor(e)
	  scalar d = round(100*(e-m))
	</code>
      </description>
    </function>

    <function name="ecdf" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Calcula a función de distribución acumulativa (CDF) empírica de
	  <argname>y</argname>. O resultado devólvese en formato de matriz
	  con dúas columnas: a primeira contén os valores únicos ordenados de
	  <argname>y</argname>; e a segunda contén a frecuencia relativa 
	  acumulada, é dicir o número de casos nos que o seu valor é menor ou
	  igual ao valor correspondente da primeira columna, dividido polo
	  número total de observacións.
	</para>
	<para context="tex">
	  Calcula a función de distribución acumulativa (CDF) empírica de
	  <argname>y</argname>. O resultado devólvese en formato de matriz
	  con dúas columnas: a primeira contén os valores únicos ordenados de
	  <argname>y</argname>; e a segunda contén a frecuencia relativa acumulada
	  \[ F(y) =
	  \frac{1}{n} \sum_{i=1}^n I(y_i \leq y)
	  \]
	  onde $n$ é o número total de observacións, e $I()$ denota a función
	  indicadora.
	</para>
      </description>
    </function>

    <function name="eigen" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
	<fnarg type="matrixref" optional="true">&amp;V</fnarg>
	<fnarg type="matrixref" optional="true">&amp;W</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula os autovalores (e opcionalmente os autovectores
	  dereitos e/ou esquerdos) da matriz <argname>A</argname> de
	  dimensión <by r="n" c="n"/>, que pode ser real ou complexa.
	  Os autovalores devólvense nun vector columna complexo.
	</para>
	<para>
	  Se queres recuperar os autovectores dereitos (como no caso dunha
	  matriz complexa de dimensión <by r="n" c="n"/>), indica o nome
	  dunha matriz xa existente, precedido por <lit>&amp;</lit> para
	  indicar a <quote>dirección</quote> da matriz en cuestión, como
	  segundo argumento. Doutro xeito, podes omitir este argumento.
	</para>
	<para>
	  Para recuperar os autovectores esquerdos (de novo, como nunha
	  matriz complexa), indica a dirección dunha matriz como terceiro
	  argumento. Cae na conta de que, se queres os autovectores esquerdos
	  pero non os dereitos, debes usar a palabra chave <lit>null</lit>
	  como marcador para o segundo argumento.
	</para>
	<para>
	  <seelist>
            <fncref targ="eigensym"/>
            <fncref targ="eigsolve"/>
            <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="eigengen" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  <emphasis>Esta é unha función herdada, anterior ao soporte
	  orixinal de Gretl para matrices complexas. Non debes usala
	  nos novos guións que escribas en linguaxe 'hansl'. Utiliza
	  </emphasis> <fncref targ="eigen"/> <emphasis> en troques.</emphasis>
	</para>
	<para>
	  Calcula os autovalores e, opcionalmente, os autovectores da matriz
	  <argname>A</argname> de orde <by r="n" c="n"/>. Cando todos os
	  autovalores son reais, devólvese unha matriz <by r="n" c="1"/>. Noutro
	  caso, o resultado é unha matriz <by r="n" c="2"/>, cunha primeira
	  columna que contén os elementos reais, e unha segunda columna cos
	  elementos imaxinarios. Non se garante que os autovalores se vaian
	  clasificar en ningunha orde en particular.
	</para>
	<para>
	  Hai dúas opcións para o segundo argumento: que se trate do nome
	  dunha matriz xa existente precedida por <lit>&amp;</lit> (para
	  indicar o <quote>enderezo</quote> da matriz en cuestión), en cuxo
	  caso nesta matriz gárdase un resultado auxiliar; ou que se trate
	  da palabra chave <lit>null</lit>, en cuxo caso non se produce o
	  resultado auxiliar.
	</para>
	<para>
	  Cando o segundo argumento non é nulo, vaise sobrescribir a matriz
	  especificada co resultado auxiliar (e non é necesario que a matriz
	  existente teña a dimensión adecuada para recibir o resultado). O
	  resultado na matriz <argname>U</argname> organízase do seguinte xeito:
	</para>
	<ilist>
	  <li>
            <para>
              Se o <math>i</math>-ésimo autovalor é real, a
              <math>i</math>-ésima columna de <math>U</math> vai
              conter o autovector correspondente;
            </para>
	  </li>
	  <li>
            <para>
              Se o <math>i</math>-ésimo autovalor é complexo, a
              <math>i</math>-ésima columna de <math>U</math> vai
              conter a parte real do autovector correspondente, e a
              seguinte columna a parte imaxinaria. O autovector do autovalor
              conxugado é o conxugado do autovector.
            </para>
	  </li>
	</ilist>
	<para>
	  Noutras palabras, os autovectores gárdanse na mesma orde ca os
	  autovalores; agora ben, os autovectores reais ocupan unha columna,
	  no entanto os autovectores complexos ocupan dúas (e a parte real
	  gárdase primeiro). Aínda así, o número total de columnas é
	  <math>n</math>, pois o autovector conxugado ignórase.
	</para>
	<para>
	  <seelist>
            <fncref targ="eigensym"/>
            <fncref targ="eigsolve"/>
            <fncref targ="qrdecomp"/>
            <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="eigensym" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="symmat">A</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Funciona da mesma forma que a función <fncref targ="eigen"/>,
	  agás que o argumento <argname>A</argname> debe de ser simétrico
	  (polo que, neste caso, pódense acurtar os cálculos), e os
	  autovalores devólvense en orde ascendente. Se desexas obter os
	  autovalores en orde descendente (e ter os autovectores reordenados
	  en consecuencia), podes facer o seguinte:
	</para>
	<code>
	  matrix U
	  e = eigensym(A, &amp;U)
	  Tmp = msortby((-e' | U)',1)'
	  e = -Tmp[1,]'
	  U = Tmp[2:,]
	  # Agora os autovalores de maior a menor
	  print e U
	</code>
	<para>
	  Aviso: Se o que te interesa é a descomposición espectral
	  dunha matriz da forma <math>X'X</math>, é preferible calcular
	  o argumento a través do operador <lit>X'X</lit>, en lugar de
	  utilizar a sintaxe máis xeral <lit>X'*X</lit>. A primeira
	  expresión utiliza un algoritmo especializado que ofrece maior
	  eficiencia dende o punto de vista do cómputo, e garante que o
	  resultado vai ser exactamente simétrico.
	</para>
      </description>
    </function>

    <function name="eigsolve" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="symmat">A</fnarg>
	<fnarg type="symmat">B</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Resolve o problema do autovalor xeneralizado de tipo
	  |<math>A</math> &minus; &lgr;<math>B</math>| = 0, onde ambas
	  <math>A</math> e <math>B</math> son matrices simétricas, e
	  <math>B</math> defínese positiva. Devólvese directamente unha matriz
	  cos autovalores ordenados de forma ascendente. Cando utilizas o
	  terceiro argumento (opcional), este debe de ser o nome dunha matriz xa
	  existente, precedida por <lit>&amp;</lit>. Neste caso, os autovectores
	  xeneralizados escríbense nesta matriz que se indica.
	</para>
      </description>
    </function>

    <function name="epochday" section="calendar" output="scalar-or-series">
      <fnargs>
	<fnarg type="scalar-or-series">ano</fnarg>
	<fnarg type="scalar-or-series">mes</fnarg>
	<fnarg type="scalar-or-series">día</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar ou unha serie, co número do día especificado polo
	  ano, mes e día, nesa orde, na época actual. O número do día é igual
	  a 1 para o día 1 de xaneiro do ano 1 despois de Cristo, no calendario
	  Gregoriano proléptico, e a 733786 para a data 01-01-2010. Se algún
	  dos argumentos é unha serie, o valor que se devolve tamén terá a
	  forma dunha serie; noutro caso, devólvese un escalar.
	</para>
	<para>
	  Por defecto, os valores dos argumentos <argname>ano</argname>,
	  <argname>mes</argname> e <argname>día</argname> se
	  presupón que se están indicando de acordo co calendario Gregoriano,
    mais se o ano ten un valor negativo, a interpretación muda á do
    calendario Xuliano.
	</para>
	<para>
	  Tamén admítese unha petición alternativa: se indicas un único
	  argumento, vaise considerar que é unha data (ou unha serie de
	  datas) en formato numérico ISO 8601 <quote>básico</quote>,
	  <lit>YYYYMMDD</lit>. Deste xeito, as seguintes dúas peticións
	  producen o mesmo resultado, en concreto 700115.
	</para>
	<code>
	  eval epochday(1917, 11, 7)
	  eval epochday(19171107)
	</code>
	<para>
	  Para a inversa desta función consulta <fncref targ="isodate"/>, e
	  tamén <fncref targ="juldate"/> (para o calendario Xuliano).
	</para>
      </description>
    </function>

    <function name="errmsg" section="strings" output="string">
      <fnargs>
	<fnarg type="int">errno</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha cadea de texto coa mensaxe de fallo do Gretl asociada
	  a <argname>errno</argname>, que debe de ser un número enteiro.
	  Consulta tamén <fncref targ="$error"/>.
	</para>
      </description>
    </function>

    <function name="errorif" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="bool">condicion</fnarg>
	<fnarg type="string">mensaxe</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta función só se aplica no contexto dunha función definida polo
	  usuario. Se a <argname>condicion</argname> se valora como non nula,
	  iso implica que a execución da función vixente remate coa presentación
	  dunha mensaxe condicionada a que se produza un fallo; entón o
	  argumento <argname>mensaxe</argname> vaise presentar como parte
	  da mensaxe de fallo que se amosa ao chamar á función.
	</para>
	<para>
	  O valor que se devolve con esta función (1) é simplemente nominal.
	</para>
      </description>
    </function>

    <function name="exists" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">nome</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar non nulo se <argname>nome</argname> é o nome que
	  identifica un obxecto que xa se definiu, sexa un escalar, unha serie,
	  unha matriz, unha lista, unha cadea de texto, un feixe ou un arranxo.
	  Noutro caso devolve 0. Consulta tamén <fncref targ="typeof"/>.
	</para>
      </description>
    </function>

    <function name="exp" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) con <math>e</math><sup>x</sup>.
	  Cae na conta de que con argumento matricial, aplícase elemento a elemento.
	  Para a función exponencial matricial consulta <fncref targ="mexp"/>.
	</para>
      </description>
    </function>

    <function name="fcstats" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="series-list-or-mat">f</fnarg>
      </fnargs>
      <description>
	<para>
	  Xera unha matriz que contén varios estatísticos que serven
	  para avaliar a <argname>f</argname> como predición dos datos
	  observados <argname>y</argname>.
	</para>
	<para>
	  Cando <argname>f</argname> é unha serie ou un vector, o resultado
	  é un vector columna. Cando <argname>f</argname> é unha lista con
	  <math>k</math> elementos ou unha matriz de dimensión <by r="T" c="k"/>,
	  o resultado ten <math>k</math> columnas nas que cada unha contén
	  os estatísticos do termo correspondente (serie da lista ou columna
	  da matriz) como predición de <argname>y</argname>.
	</para>
	<para>
	  En tódolos casos, a dimensión <quote>vertical</quote> dos datos
	  introducidos (o longo da mostra vixente para unha serie ou lista,
	  e o número de filas para unha matriz) debe de coincidir entre os dous
	  argumentos.
	</para>
	<para>
	  As filas da matriz que se devolve son como se indica deseguido:
	</para>
	<code>
	  1  Media dos erros
	  2  Raíz do erro cadrado medio
	  3  Media dos valores absolutos dos erros
	  4  Media dos erros relativos, en porcentaxe
	  5  Media dos valores absolutos dos erros relativos, en porcentaxe
	  6  U de Theil
	  7  Proporción de nesgo, UM
	  8  Proporción de regresión, UR
	  9  Proporción de perturbación, UD
	</code>
	<para>
	  Para obter máis detalles sobre o cálculo deses estatísticos e da
	  interpretación dos valores de <math>U</math>, consulta o
	  <guideref targ="chap:forecast"/>.
	</para>
      </description>
    </function>

    <function name="fdjac" section="numerical" output="matrix">
      <fnargs>
	<fnarg type="cvec">b</fnarg>
	<fnarg type="fncall">chamaf</fnarg>
	<fnarg optional="true" type="scalar">h</fnarg>
      </fnargs>
      <description>
	<para>
	  Permite calcular unha aproximación numérica ao Jacobiano
	  asociado ao <math>n</math>-vector <argname>b</argname>,
	  así como a función de transformación especificada polo
	  argumento <argname>chamaf</argname>. Ao apelar a esta función
	  debes de utilizar <argname>b</argname> como primeiro argumento
	  da mesma (ben directamente ou en forma de punteiro), seguido
	  de calquera argumento adicional que poda necesitarse; e como
	  resultado debérase producir unha matriz <by r="m" c="1"/>.
	  Cando se executa con éxito, <lit>fdjac</lit> vai devolver
	  unha matriz <by r="m" c="n"/> que contén o Jacobiano.
	</para>
	<para>
	  Podes utilizar o terceiro argumento (opcional) para determinar o
	  tamaño da medida <math>h</math> que se usa no mecanismo de
	  aproximación (mira máis abaixo). Cando omites este argumento, o
	  tamaño da medida determínase automaticamente.
	</para>
	<para>
	  Aquí tes un exemplo do seu uso:
	</para>
	<code>
	  matrix J = fdjac(theta, mifunc(&amp;theta, X))
	</code>
	<para>
	  A función pode utilizar tres métodos distintos: diferenza simple cara
	  adiante, diferenza bilateral ou extrapolación de 4-nodos de Richardson.
	  Estas correspóndense respectivamente con:
	</para>
	<para context="tex">
	  \[ J_0 = \frac{f(x + h) - f(x)}{h} \]
	</para>
	<para context="tex">
	  \[ J_1 = \frac{f(x + h) - f(x - h)}{2h} \]
	</para>
	<para context="tex">
	  \[ J_2 = \frac{8(f(x+h) - f(x-h)) - (f(x+2h) - f(x-2h))}{12h} \]
	</para>
	<para context="notex">
	  <math>J</math><sub>0</sub> = <math>(f(x+h) - f(x))/h</math>
	</para>
	<para context="notex">
	  <math>J</math><sub>1</sub> = <math>(f(x+h) - f(x-h))/2h</math>
	</para>
	<para context="notex">
	  <math>J</math><sub>2</sub>  = <math>[8(f(x+h) - f(x-h)) -
	  (f(x+2h) - f(x-2h))] /12h</math>
	</para>
	<para>
	  Estas tres alternativas xeralmente proporcionan unha conciliación
	  entre precisión e velocidade. Podes elixir entre os distintos
	  métodos mediante a instrución <cmdref targ="set"/>: especifica o
	  valor 0, 1 ou 2 para a variable <lit>fdjac_quality</lit>. O valor
	  por defecto é 0.
	</para>
	<para>
	  Para máis detalles e exemplos, consulta o
	  <guideref targ="chap:numerical"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="BFGSmax"/>
	          <fncref targ="numhess"/>
            <cmdref targ="set"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="feval" section="data-utils" output="seebelow">
      <fnargs>
	<fnarg type="string">nomefuncion</fnarg>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Fundamentalmente útil para os creadores de funcións. O primeiro
	  argumento debe de ser o nome dunha función, e os argumentos
	  restantes (un ou varios) deben ser os argumentos aos que se lle
	  aplica a función en cuestión. Isto permite tratar á propia función
	  identificada mediante <argname>nomefuncion</argname> como unha
	  variable. O valor que se devolve é calquera cousa que produza a
	  función indicada, dados os argumentos especificados.
	</para>
	<para>
	  O exemplo de abaixo, ilustra algúns dos seus posibles usos.
	</para>
	<code>
	  function scalar utilidade (scalar c, scalar sigma)
	      return (c^(1-sigma)-1)/(1-sigma)
	  end function

	  strings S = defarray("log", "utilidade")

	  # Chamada a unha función integrada de 1 argumento
	  x = feval(S[1], 2.5)
	  # Chamada a unha función definida polo usuario
	  x = feval(S[2], 5, 0.5)
	  # Chamada a unha función integrada de 2 argumentos
	  func = "zeros"
	  m = feval(func, 5-2, sqrt(4))
	  print m
	  # Chamada a unha función integrada de 3 argumentos
	  x = feval("monthlen", 12, 1980, 5)
	</code>
	<para>
	  Existe unha feble semellanza entre a función <lit>feval</lit> e
	  <fncref targ="genseries"/>: ámbalas dúas funcións volven variable
	  a un elemento sintáctico que habitualmente se fixa ao tempo no
	  que se redacta un guión.
	</para>
      </description>
    </function>

    <function name="fevd" section="stats" output="matrix">
      <fnargs>
	<fnarg type="int">efecto</fnarg>
	<fnarg type="int">motivo</fnarg>
	<fnarg type="bundle" optional="true">sys</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta función proporciona unha alternativa máis flexible ca o
	  accesorio <fncref targ="$fevd"/> para obter unha matriz
	  de descomposición da varianza do erro de predición (FEVD),
	  logo de estimar un VAR ou un VECM. Se falta o argumento final
	  (opcional), só está dispoñible cando o último modelo estimado
	  foi un VAR ou un VECM. Como alternativa, podes gardar nun
	  feixe a información sobre estes tipos de sistemas, mediante o
	  accesorio <fncref targ="$system"/>, e posteriormente pasarlle
	  a función <lit>fevd</lit>.
	</para>
	<para>
	  Os argumentos da función, <argname>efecto</argname> e
	  <argname>motivo</argname>, teñen a forma de índices enteiros
	  positivos das variables endóxenas do sistema, tomando o 0 para
	  representar <quote>todas</quote>. O seguinte fragmento de código,
	  ilustra o seu uso. No primeiro exemplo, a matriz <lit>fe1</lit>
	  contén as partes da FEVD para <lit>y1</lit> debidas a cada
	  parte de <lit>y1</lit>, <lit>y2</lit> e <lit>y3</lit> (polo tanto,
	  as filas suman 1 en total). No segundo, <lit>fe2</lit> contén
	  a contribución de <lit>y2</lit> á varianza do erro de predición
	  das tres variables (entón, as filas non suman 1 en total).
	  No terceiro caso, o que se devolve é un vector columna que
	  amosa a <quote>parte propia</quote> da FEVD de
	  <lit>y1</lit>.
	</para>
	<code>
	  var 4 y1 y2 y3
	  bundle vb = $system
	  matrix fe1 = fevd(1, 0, vb)
	  matrix fe2 = fevd(0, 2, vb)
	  matrix fe3 = fevd(1, 1, vb)
	</code>
	<para>
	  O número de períodos (filas) sobre os que se traza a
	  descomposición, determínase automaticamente en base á
	  frecuencia dos datos, pero podes ignorar isto mediante o
	  argumento <lit>horizon</lit> da instrución <cmdref targ="set"/>,
    como en <lit>set horizon 10</lit>.
	</para>
	<para>
	  <seelist><fncref targ="irf"/></seelist>
	</para>
      </description>
    </function>

    <function name="fft" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  <emphasis>Esta é unha función herdada, anterior ao soporte
	  orixinal de Gretl para matrices complexas. Non debes usala nos
	  novos guións que escribas en linguaxe 'hansl'. Utiliza </emphasis>
	  <fncref targ="fft2"/> <emphasis>en troques.</emphasis>
	</para>
	<para>
	  Devolve unha matriz coa transformación de Fourier real discreta. Se a
	  matriz <argname>X</argname> do argumento ten <math>n</math> columnas,
	  a que se devolve ten 2<math>n</math> columnas, onde as partes reais
	  gárdanse nas columnas impares e as partes complexas nas pares.
	</para>
	<para>
	  Cando necesites aplicar a transformación de Fourier sobre varios
	  vectores co mesmo número de elementos, resulta numericamente máis
	  eficiente agrupar os vectores nunha matriz ca executar <lit>fft</lit>
	  para cada un por separado.
	  <seelist>
            <fncref targ="ffti"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="fft2" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz co resultado da transformación discreta de
	  Fourier. A matriz <argname>X</argname> do argumento pode ser
	  real ou complexa. O resultado é unha matriz complexa que ten
	  a mesma dimensión ca <argname>X</argname>.
	</para>
	<para>
	  Se fora necesario calcular a transformación de Fourier sobre
	  varios vectores co mesmo número de elementos, é numericamente
	  máis eficiente agrupalos nunha matriz, en troques de executar
	  <lit>fft2</lit> para cada vector por separado.
	  <seelist>
            <fncref targ="ffti"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ffti" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz con <math>n</math> columnas, co resultado da
	  transformación inversa de Fourier discreta. Asúmese que a matriz
	  <argname>X</argname> consta de <math>n</math> vectores columna
	  complexos. Por compatibilidade anterior, o argumento podes indicalo
	  como unha matriz real con 2<math>n</math> columnas, nas que as columnas
	  impares conteñen a parte real, e as pares conteñen a parte imaxinaria.
	</para>
	<para>
	  Cando necesites aplicar a transformación inversa de Fourier sobre
	  varios vectores co mesmo número de elementos, resulta numericamente máis
	  eficiente agrupar os vectores nunha matriz ca executar <lit>ffti</lit>
	  para cada un por separado.
	  <seelist>
            <fncref targ="fft2"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="filter" section="filters" output="seebelow">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
	<fnarg optional="true" type="scalar-or-vec">a</fnarg>
	<fnarg optional="true" type="scalar-or-vec">b</fnarg>
	<fnarg optional="true" type="scalar">y0</fnarg>
	<fnarg optional="true" type="scalar-or-vec">x0</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve o resultado de aplicar un filtro semellante a un ARMA, ao
	  argumento <argname>x</argname>. A transformación pode escribirse como
	</para>
	<para context="tex">
	  \[ y_t = \sum_{i=0}^q a_i x_{t-i} + \sum_{i=1}^p b_i y_{t-i} \]
	</para>
	<para context="notex">
	  <math>y</math><sub>t</sub> =
	  <math>a</math><sub>0</sub> <math>x</math><sub>t</sub> +
	  <math>a</math><sub>1</sub> <math>x</math><sub>t-1</sub> +
	  ...
	  <math>a</math><sub>q</sub> <math>x</math><sub>t-q</sub> +
	  <math>b</math><sub>1</sub> <math>y</math><sub>t-1</sub> +
	  ...
	  <math>b</math><sub>p</sub><math>y</math><sub>t-p</sub>
	</para>
	<para>
	  Se o argumento <argname>x</argname> é unha serie, o resultado que se
	  devolve tamén é unha serie. Noutro caso, se <argname>x</argname> é
	  unha matriz con <math>T</math> filas e <math>k</math> columnas, o
	  que se devolve é a matriz do mesmo tamaño que resulta de aplicar o
	  filtro columna por columna.
	</para>
	<para>
	  Os argumentos <argname>a</argname> e <argname>b</argname> son
	  opcionais. Poden ser escalares, vectores ou a palabra chave
	  <lit>null</lit>.
	</para>
	<para>
	  Cando <argname>a</argname> é un escalar, vaise utilizar como
	  <math>a</math><sub>0</sub> e iso implicará que <math>q=0</math>.
	  Cando é un vector con <math>q+1</math> elementos, vai conter
	  os coeficientes dende <math>a</math><sub>0</sub> ata
	  <math>a</math><sub>q</sub>. Cando <argname>a</argname> é
	  <lit>null</lit> ou se omite, isto é equivalente a definir
	  <math>a</math><sub>0</sub> <math>=1</math> e
	  <math>q=0</math>.
	</para>
	<para>
	  Cando <argname>b</argname> é un escalar, vaise utilizar como
	  <math>b</math><sub>1</sub> e implicará que <math>p=1</math>.
	  Cando é un vector con <math>p</math> elementos, vai conter
	  os coeficientes dende <math>b</math><sub>1</sub> ata
	  <math>b</math><sub>p</sub>. Cando <argname>b</argname> é
	  <lit>null</lit> ou se omite, isto é equivalente a definir
	  <math>B(L)=1</math>.
	</para>
	<para>
	  O argumento escalar opcional <argname>y0</argname> utilízase para
	  representar todos os valores de <math>y</math> anteriores ao comezo
	  da mostra (úsase só cando <math>p &gt; 0</math>). Cando se omite,
	  enténdese que é igual a 0. De forma similar, podes usar o argumento
	  opcional <argname>x0</argname> para especificar un ou máis valores
	  de <math>x</math> anteriores ao comezo da mostra (información só
	  relevante cando <math>q &gt; 0</math>). Doutro xeito, asúmese que os
	  valores de <argname>x</argname> anteriores ao comezo da mostra son 0.
	</para>
	<para>
	  <seelist>
            <fncref targ="bkfilt"/>
            <fncref targ="bwfilt"/>
            <fncref targ="fracdiff"/>
            <fncref targ="hpfilt"/>
            <fncref targ="movavg"/>
            <fncref targ="varsimul"/>
	  </seelist>
	</para>
	<para>
	  Exemplo:
	</para>
	<code>
	  nulldata 5
	  y = filter(index, 0.5, -0.9, 1)
	  print index y --byobs
	  x = seq(1,5)' ~ (1 | zeros(4,1))
	  w = filter(x, 0.5, -0.9, 1)
	  print x w
	</code>
	<para>
	  produce
	</para>
	<code>
          index            y

          1            1     -0.40000
          2            2      1.36000
          3            3      0.27600
          4            4      1.75160
          5            5      0.92356

          x (5 x 2)

          1   1
          2   0
          3   0
          4   0
          5   0

          w (5 x 2)

          -0.40000     -0.40000
           1.3600       0.36000
           0.27600     -0.32400
           1.7516       0.29160
           0.92356     -0.26244
	</code>
      </description>
    </function>

    <function name="firstobs" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="bool" optional="true">namostra</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve o número enteiro positivo que indexa a primeira observación
	  non ausente da serie <argname>y</argname>. Por defecto, analízase
	  todo o rango da mostra, de xeito que, se está activa algunha forma
	  de submostraxe, o valor que se devolve pode ser menor ca o valor
	  devolto polo accesorio <fncref targ="$t1"/>. Pero se indicas un
	  valor non nulo en <argname>namostra</argname>, só vai terse en
	  conta o rango da mostra vixente.
	  <seelist>
            <fncref targ="lastobs"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="fixname" section="strings" output="string">
      <fnargs>
	<fnarg type="string">nomesobrio</fnarg>
	<fnarg type="bool" optional="true">underscore</fnarg>
      </fnargs>
      <description>
	<para>
	  En principio, esta función está ideada para utilizarse en conxunto coa instrución
	  <cmdref targ="join"/>. Devolve unha cadea co resultado da conversión
	  de <argname>nomesobrio</argname> nun identificador válido de Gretl;
	  debe iniciarse cunha letra, debe de conter só letras ASCII, díxitos
	  e/ou guión baixo, e non debe de ter máis ca 31 caracteres. As regras
	  que se utilizan na conversión son:
	</para>
	<para>
	  1. Quitar, do inicio do nome, calquera carácter que non sexa unha letra.
	</para>
	<para>
	  2. Ata que se acada o límite dos 31 caracteres ou ata que se esgota o
	  indicado no argumento: transcribe os caracteres <quote>legais</quote>,
	  substitúe un ou varios espazos consecutivos por un guión baixo
	  (agás que o carácter anterior transcrito sexa un guión baixo,
	  pois entón elimínase o espazo), e omite os outros tipos de caracteres
	  <quote>ilegais</quote>.
	</para>
	<para>
	  Se estás convencido de que a entrada non é demasiado longa (entón
	  susceptible de ser tronzada), podes querer substituír secuencias
	  de un ou máis caracteres ilícitos mediante un guión baixo
	  (en troques de só eliminalos) pois isto podería xerar un identificador
	  máis lexible. Para acadar este efecto, proporciona un valor non
	  nulo para o segundo argumento (opcional). Mais isto non é
	  recomendable no contexto da instrución <cmdref targ="join"/>,
	  posto que o nome <quote>fixado</quote> automaticamente non
	  vai utilizar guións baixos deste xeito.
	</para>
      </description>
    </function>

    <function name="flatten" section="data-utils" output="seebelow">
      <fnargs>
	<fnarg type="matrices-or-strings">A</fnarg>
	<fnarg optional="true" type="bool">alt</fnarg>
      </fnargs>
      <description>
	<para>
	  <quote>Achanza</quote> ben un arranxo de matrices nunha única
	  matriz, ou ben un arranxo de cadeas de texto nunha única cadea.
	</para>
	<para>
	  Os argumentos indícanse entre parénteses. Con matrices, por defecto,
	  concaténanse horizontalmente as matrices de <argname>A</argname>;
	  pero cando indicas un valor non nulo para <argname>alt</argname>,
	  a concatenación faise verticalmente. En calquera caso, amósase un
	  fallo se as matrices non son conformables para realizar esta
	  operación. Consulta <fncref targ="msplitby"/> para a operación
	  inversa.
	</para>
	<para>
	  No caso de cadeas de texto, o resultado por defecto mantén as
	  cadeas de <argname>A</argname>, ordenadas unha en cada liña.
	  Se indicas un valor non nulo para <argname>alt</argname>, as
	  cadeas sepáranse mediante espazos en troques de novas liñas.
	</para>
      </description>
    </function>

    <function name="floor" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co valor do maior enteiro
	  que é menor ou igual que <argname>x</argname>. Cae na conta de que
	  <fncref targ="int"/> e <lit>floor</lit> teñen efectos distintos
	  con argumentos negativos:<lit>int(-3.5)</lit> xera &minus;3,
	  namentres <lit>floor(-3.5)</lit> xera &minus;4.
	</para>
      </description>
    </function>

    <function name="fracdiff" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="scalar">d</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devolve unha serie coa diferenza fraccionaria de orde
	  <argname>d</argname> da serie <argname>y</argname>.
	</para>
	<para context="tex">
          \[
          \Delta^d y_t = y_t - \sum_{i=1}^{\infty} \psi_i y_{t-i}
          \]
	  onde
          \[\psi_i = \frac{\Gamma(i-d)}{\Gamma(-d) \Gamma(i+1)}\]
	</para>
	<para>
	  Observa que, en teoría, a diferenciación fraccionaria supón un filtro
	  infinitamente longo. Os valores de <math>y</math><sub>t</sub>
	  anteriores á mostra, na práctica asúmese que son iguais a cero.
	</para>
	<para>
	  Podes utilizar valores negativos para <argname>d</argname>, e nese
	  caso a función realiza a integración fraccionaria.
	</para>
      </description>
    </function>

    <function name="fzero" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="fncall">fcall</fnarg>
	<fnarg optional="true" type="scalar-or-vec">inicio</fnarg>
	<fnarg optional="true" type="scalar">toler</fnarg>
      </fnargs>
      <description>
	<para>
	  Trata de atopar unha raíz simple dunha función continua <math>f</math>
	  (normalmente non linear) &mdash;é dicir, un valor da variable escalar
	  <math>x</math> que fai que <math>f</math>(<math>x</math>) = 0.
	  O argumento <argname>fcall</argname> debe de proporcionar unha
	  chamada á función en cuestión;<argname>fcall</argname> pode
	  incluír un número arbitrario de argumentos, pero o primeiro
	  debe de ser un escalar que represente o papel de <math>x</math>.
	  Cando se complete a función con éxito, vaise devolver o valor
	  da raíz.
	</para>
	<para>
	  O método utilizado é o de <cite key="ridders79">Ridders (1979)</cite>.
	  Isto require un intervalo inicial
	  &lbr;<math>x</math><sub>0</sub>, <math>x</math><sub>1</sub>&rbr;
	  tal que ambos os dous valores <math>x</math> pertenzan
	  ao dominio da función, e que os respectivos valores da
	  función sexan de signo contrario. Probablemente, vas
	  obter mellores resultados se es capaz de proporcionar,
	  mediante o segundo argumento, un vector bidimensional
	  que conteña puntos finais axeitados para o intervalo. Se
	  isto falla, podes proporcionar un único valor escalar, e
	  <lit>fzero</lit> tratará de atopar unha parella. Se omites
	  o segundo argumento, o valor de <math>x</math><sub>0</sub>
	  se inicia cun pequeno número positivo, e logo vaise procurar
	  un valor axeitado para <math>x</math><sub>1</sub>.
	</para>
	<para>
	  Podes usar o argumento <argname>toler</argname> (opcional)
	  para axustar a máxima diferenza absoluta que resulte aceptable
	  entre <math>f</math>(<math>x</math>) e cero, sendo esta igual a
	  1.0e&minus;14 por defecto.
	</para>
	<para>
	  Por defecto, esta función traballa silandeiramente, pero podes
	  amosar a evolución do método iterativo executando a instrución
	  <quote><lit>set max_verbose on</lit></quote> antes de chamar
	  a <lit>fzero</lit>.
	</para>
	<para>
	  Deseguido indícanse algúns exemplos sinxelos:
	</para>
	<code>
	  # Aproximar 'pi' atopando o valor que anula a
	  # función sin() no intervalo de 2.8 a 3.2
	  x = fzero(sin(x), {2.8, 3.2})
	  printf "\nx = %.12f vs pi = %.12f\n\n", x, $pi

	  # Aproximar a 'constante Omega' comezando en x = 0.5
	  function scalar f(scalar x)
	      return log(x) + x
	  end function
	  x = fzero(f(x), 0.5)
	  printf "x = %.12f f(x) = %.15f\n", x, f(x)
	</code>
      </description>
    </function>

    <function name="gammafun" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co valor da función Gamma de <argname>x</argname>.
	</para>
	<para>
	  Consulta tamén <fncref targ="bincoeff"/> e <fncref targ="lngamma"/>.
	</para>
      </description>
    </function>

    <function name="genseries" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="string">nomevar</fnarg>
	<fnarg type="series">rhs</fnarg>
      </fnargs>
      <description>
	<para>
	  Proporciónalle ao guionista un procedemento adecuado para xerar
	  series cuxos nomes non se coñecen a priori; e/ou de crear series e
	  engadilas a unha lista por medio dunha única operación (devolve
	  un escalar).
	</para>
	<para>
	  O primeiro argumento proporciona o nome da serie que se vai crear
	  (ou modificar); e pode ser un texto literal, unha cadea de texto ou
	  unha expresión cuxo resultado sexa unha cadea de texto. O segundo
	  argumento, <argname>rhs</argname> (<quote>lado dereito</quote> en
	  inglés), define a serie orixinal: isto pode ser o nome dunha serie
	  existente ou unha expresión cuxo resultado sexa unha serie, no
	  xeito no que aparece habitualmente do lado dereito do símbolo de
	  igualdade cando se definen series.
	</para>
	<para>
	  O valor que devolve esta función é un escalar co número ID da serie
	  no conxunto de datos, que é axeitado para incluír a serie nunha lista
	  (ou &minus;1 no caso de fallar a execución da función).
	</para>
	<para>
	  Por exemplo, supón que queres engadir <math>n</math> series
	  aleatorias con distribución de probabilidade Normal ao conxunto de
	  datos, e colocalas nunha lista. O seguinte código fai iso:
	</para>
	<code>
	  nulldata 10
	  list Normais = null
	  scalar n = 3
	  loop i = 1 .. n
	      Normais += genseries(sprintf("norm%d", i), normal())
	  endloop
	</code>
	<para>
	  Ao rematar a execución, a lista <lit>Normais</lit> vai conter as
	  series <lit>norm1</lit>, <lit>norm2</lit> e <lit>norm3</lit>.
	</para>
	<para>
	  A aqueles que atopedes útil a función <lit>genseries</lit>, pode que
	  vos interese explorar a función <fncref targ="feval"/>.
	</para>
      </description>
    </function>

    <function name="geoplot" section="data-utils" output="none">
      <fnargs>
	<fnarg type="string">ficheiromap</fnarg>
	<fnarg optional="true" type="series">carga</fnarg>
	<fnarg optional="true" type="bundle">opcions</fnarg>
      </fnargs>
      <description>
	<para>
	  Solicita a produción dun mapa, cando se dispón de datos xeográficos
	  axeitados. Na maioría dos casos o argumento <argname>mapfile</argname>
	  debe proporcionarse como <fncref targ="$mapfile"/>,
	  o que indica un accesorio co que se vai recuperar o nome do ficheiro
	  que sexa relevante, de tipo GeoJSON ou de tipo ESRI de forma. O
	  argumento opcional <argname>carga</argname> utilízase para indicar
	  o nome dunha serie coa que se colorean as rexións do mapa. E o
	  argumento final de tipo feixe (bundle) te permite que podas establecer
	  numerosas opcións.
	</para>
	<para>
	  Podes consultar <doc>geoplot.pdf</doc> coa documentación sobre a función,
	  para obter detalles e exemplos completos. Aí se explican todos os axustes
	  que se poden configurar mediante o argumento <argname>opcions</argname>.
	</para>
      </description>
    </function>

    <function name="getenv" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Cando xa está definida unha variable de entorno co nome do argumento
	  <argname>s</argname>, a función devolve o valor desa variable como
	  cadea de texto; noutro caso, devolve unha cadea de texto baleira.
	  Consulta tamén <fncref targ="ngetenv"/>.
	</para>
      </description>
    </function>

    <function name="getinfo" section="data-utils" output="bundle">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve información sobre a serie especificada, que podes indicala
	  mediante o seu nome ou o seu número ID. O feixe que se devolve
	  contén tódolos atributos que se poden establecer por medio da
	  instrución <cmdref targ="setinfo"/>. E tamén contén información
	  adicional relevante para series que se xeraron como transformacións
	  de datos primarios (mediante retardos, logaritmos, etc.); isto inclúe
	  a palabra da instrución de Gretl para a transformación coa 
	  clave <quote>transform</quote>, e o nome da serie asociada primaria
	  coa clave <quote>parent</quote>. Para as series retardadas, podes
	  atopar o número específico de retardos baixo a clave
	  <quote>lag</quote>.
	</para>
	<para>
	  Aquí tes un exemplo do seu uso:
	</para>
	<code>
	  open data9-7
	  lags QNC
	  bundle b = getinfo(QNC_2)
	  print b
	</code>
	<para>
	  Ao executar o anterior, podemos ver:
	</para>
	<code>
	  has_string_table = 0
	  lag = 2
	  parent = QNC
	  name = QNC_2
	  graph_name =
	  coded = 0
	  discrete = 0
	  transform = lags
	  description = = QNC(t - 2)
	</code>
	<para>
	  Para comprobar se a serie 5 dun conxunto de datos é un termo retardado,
	  podes facer este tipo de cousas:
	</para>
	<code>
	  if getinfo(5).lag != 0
	     printf "A serie 5 é un retardo de %s\n", getinfo(5).parent
	  endif
	</code>
	<para>
	  Ten en conta que podes utilizar a notación co punto para acceder aos
	  elementos dun feixe, mesmo cando o feixe é <quote>anónimo</quote>
	  (non gardado co seu propio nome).
	</para>
      </description>
    </function>

    <function name="getkeys" section="data-utils" output="strings">
      <fnargs>
	<fnarg type="bundle">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un arranxo das cadeas de texto que conteñen as chaves que
	  identifican o contido de <argname>b</argname>. Se o feixe está
	  baleiro, devólvese un arranxo baleiro.
	</para>
      </description>
    </function>

    <function name="getline" section="strings" output="scalar">
      <fnargs>
	<fnarg type="string">orixe</fnarg>
	<fnarg type="string">destino</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta función le filas consecutivas de <argname>orixe</argname>,
	  que debe de ser unha cadea de texto xa definida. Con cada chamada á
	  función escríbese unha liña de texto en <argname>destino</argname>
	  (que tamén debe de ser unha cadea de texto) sen o carácter de nova
	  liña. O valor que se devolve é un escalar igual a 1, cando existe
	  algo por ler (incluídas filas en branco), ou igual a 0 se todas as
	  filas de <argname>orixe</argname> xa se leron.
	</para>
	<para>
	  A continuación preséntase un exemplo no que o contido dun ficheiro de
	  texto divídese en filas:
	</para>
	<code>
	  string s = readfile("data.txt")
	  string line
	  scalar i = 1
	  loop while getline(s, line)
	      printf "line %d = '%s'\n", i++, line
	  endloop
	</code>
	<para>
	  No exemplo pódese asegurar que, cando remate o bucle, o texto de
	  <argname>orixe</argname> está xa esgotado. Se non desexas esgotalo
	  todo, podes facer unha chamada normal a <lit>getline</lit>, seguida
	  dunha nova chamada de <quote>limpeza</quote>, trocando o argumento
	  <argname>destino</argname> por <lit>null</lit> (ou deixalo en branco),
	  co que se reinicia a lectura de <argname>orixe</argname>, como en
	</para>
	<code>
	  getline(s, line) # Obtén unha única fila
	  getline(s, null) # Reinicia a lectura
	</code>
	<para>
	  Ten en conta que, aínda que avanza a posición de lectura cada vez que
	  se executa <lit>getline</lit>, o argumento <argname>orixe</argname>
	  non se altera con esa función; só cambia <argname>destino</argname>.
	</para>
      </description>
    </function>

    <function name="ghk" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">C</fnarg>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix">B</fnarg>
	<fnarg type="matrix">U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;dP</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula a aproximación GHK (Geweke, Hajivassiliou, Keane) á función
	  de distribución Normal multivariante; podes consultar, por exemplo,
	  <cite key="geweke91">Geweke (1991)</cite>. O valor que se devolve é
	  un vector <by r="n" c="1"/> de probabilidades.
	</para>
	<para>
	  O argumento matricial <argname>C</argname> (<by r="m" c="m"/>) debe de
	  achegar o factor de Cholesky (matriz triangular inferior) da matriz de
	  covarianzas de <math>m</math> variables Normais. Os argumentos
	  matriciais <argname>A</argname> e <argname>B</argname> deben de ser
	  ambos <by r="n" c="m"/>; e indicar respectivamente os límites inferior
	  e superior que se aplican ás variables en cada unha das <math>n</math>
	  observacións. Onde as variables non teñan límites, iso débese indicar
	  usando a constante <fncref targ="$huge"/> ou o seu negativo.
	</para>
	<para>
	  A matriz <argname>U</argname> debe de ser <by r="m" c="r"/>, onde
	  <math>r</math> indica o número de extraccións pseudoaleatorias dunha
	  distribución Uniforme. Para crear <argname>U</argname> son adecuadas
	  as funcións <fncref targ="muniform"/> e <fncref targ="halton"/>.
	</para>
	<para>
	  Debaixo ilústrase isto cun exemplo relativamente simple, no que as
	  probabilidades multivariantes poden calcularse analiticamente.
	  As series <lit>P</lit> e <lit>Q</lit> deben de ser numericamente
	  moi semellantes unha á outra, denotando como <lit>P</lit> á
	  probabilidade <quote>verdadeira</quote> e como <lit>Q</lit> á súa
	  aproximación GHK:
	</para>
	<code>
	  nulldata 20
	  series inf1 = -2*uniform()
	  series sup1 = 2*uniform()
	  series inf2 = -2*uniform()
	  series sup2 = 2*uniform()

	  scalar rho = 0.25
	  matrix V = {1, rho; rho, 1}

	  series P = cdf(D, rho, inf1, inf2) - cdf(D, rho, sup1, inf2) \
	  - cdf(D, rho, inf1, sup2) + cdf(D, rho, sup1, sup2)

	  C = cholesky(V)
	  U = halton(2, 100)

	  series Q = ghk(C, {inf1, inf2}, {sup1, sup2}, U)
	</code>
	<para>
	  O argumento opcional <argname>dP</argname> úsase para obter a matriz
	  <by r="n" c="k"/> de derivadas analíticas das probabilidades, onde <math>k</math>
	  equivale a 2<math>m</math> + <math>m</math>(<math>m</math> + 1)/2.
	  As primeiras <math>m</math> columnas van conter as derivadas
	  con respecto a os límites inferiores; as <math>m</math> seguintes
	  van recoller as derivadas con respecto a os límites superiores;
	  e as restantes columnas van recoller as derivadas con respecto
	  a os elementos singulares da matriz <math>C</math>, na orde que
	  sigue a semivectorización <quote>vech</quote> dunha matriz simétrica.
	</para>
      </description>
    </function>

    <function name="gini" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co índice de desigualdade de Gini para a serie ou
	  vector (non negativos) <argname>y</argname>. Un valor de Gini igual a
	  cero indica igualdade perfecta. O máximo valor de Gini para unha serie
	  con <math>n</math> elementos é (<math>n</math> &minus; 1)/<math>n</math>,
	  o que acontece cando unicamente un elemento ten un valor positivo;
	  polo tanto, un valor de Gini igual a 1.0 é o límite que se acada cando
	  unha serie moi longa ten máxima desigualdade.
	</para>
      </description>
    </function>

    <function name="ginv" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve a matriz <math>A</math><sup>+</sup>, a matriz pseudoinversa
	  de Moore&ndash;Penrose ou inversa xeneralizada de <argname>A</argname>,
	  calculada por medio da descomposición en valores singulares.
	</para>
	<para context="notex">
	  Esta matriz posúe as seguintes propiedades: <math>A</math>
	  <math>A</math><sup>+</sup> <math>A</math> = <math>A</math>
	  e <math>A</math><sup>+</sup> <math>A</math>
	  <math>A</math><sup>+</sup> = <math>A</math><sup>+</sup>.
	  Ademais diso, os produtos <math>A</math> <math>A</math><sup>+</sup>
	  e <math>A</math><sup>+</sup> <math>A</math> son simétricos por
	  construción.
	</para>
	<para context="tex">
	  Esta matriz posúe as seguintes propiedades:
	  \begin{eqnarray*}
	  A A^+ A &amp; = &amp; A \\
	  A^+ A A^+ &amp; = &amp; A^+
	  \end{eqnarray*}
	  Ademais diso, os produtos $A A^+$ e $A^+ A$ son
	  simétricos por construción.
	</para>
	<para>
	  <seelist>
            <fncref targ="inv"/>
            <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="GSSmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg optional="true" type="scalar">toler</fnarg>
      </fnargs>
      <description>
	<para>
	  Maximización unidimensional mediante o método Golden Section Search
	  (GSS). A matriz <argname>b</argname> do argumento debe de ser un
	  vector de 3 elementos. Ao definila, o primeiro elemento ignórase, mentres
	  que o segundo e terceiro elementos establecen os límites inferior e
	  superior da procura. O argumento <argname>fncall</argname> deberá de
	  especificar unha chamada á función que devolve o valor do concepto a
	  maximizar; o termo 1 de <argname>b</argname> (que deberá conter o valor
	  vixente do parámetro que se axusta cando se invoca a función) debe de
	  indicarse como primeiro argumento; calquera outro argumento requirido
	  pode ir entón a continuación. A función en cuestión deberá de ser
	  unimodal (non debe de ter outro máximo local que non sexa o máximo
	  global) no rango estipulado, pois do contrario non se asegura que GSS
	  atope o máximo.
	</para>
	<para>
	  Ao completarse con éxito, <lit>GSSmax</lit> devolverá o valor
	  óptimo do concepto que se quere maximizar, mentres que
	  <argname>b</argname> conterá o valor óptimo do parámetro
	  xunto cos límites da súa xanela de valores.
	</para>
	<para>
	  O terceiro argumento (opcional) pode utilizarse para establecer
	  a tolerancia para acadar a converxencia; é dicir, a amplitude
	  máxima admisible da xanela final de valores do parámetro.
	  Se non indicas este argumento, utilízase o valor 0.0001.
	</para>
	<para>
	  Se o teu obxectivo realmente é acadar un mínimo, podes
	  ben trocar a función considerando o negativo do criterio,
	  ou ben, alternativamente, podes invocar a función
	  <lit>GSSmax</lit>baixo o alcume <lit>GSSmin</lit>.
	</para>
	<para>
	  Aquí tes un exemplo sinxelo de utilización:
	</para>
	<code>
	  function scalar trigfunc (scalar theta)
	      return 4 * sin(theta) * (1 + cos(theta))
	  end function

	  matrix m = {0, 0, $pi/2}
	  eval GSSmax(&amp;m, trigfunc(m[1]))
	  printf "\n%10.7f", m
	</code>
      </description>
    </function>

    <function name="GSSmin" section="numerical" output="scalar">
      <description>
	<para>
	  Un alcume de <fncref targ="GSSmax"/>. Se invocas a función baixo
	  este nome, execútase facendo unha minimización.
	</para>
      </description>
    </function>

    <function name="halton" section="stats" output="matrix">
      <fnargs>
	<fnarg type="int">m</fnarg>
	<fnarg type="int">r</fnarg>
	<fnarg optional="true" type="int">desfasam</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz <by r="m" c="r"/> que contén <math>m</math>
	  secuencias de Halton de lonxitude <math>r</math>, onde o valor de
	  <math>m</math> está limitado a un máximo de 40. As secuencias
	  constrúense utilizando os primeiros <math>m</math> números primos.
	  Por defecto, descártanse os primeiros 10 elementos de cada unha das
	  secuencias, aínda que podes axustar isto por medio do argumento
	  opcional <argname>desfasam</argname>, que debe de ser un número
	  enteiro non negativo. Para obter máis detalles podes consultar
	  <cite key="halton64">Halton e Smith (1964)</cite>.
	</para>
      </description>
    </function>

    <function name="hdprod" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">Y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve a matriz que resulta do produto directo horizontal de dúas
	  matrices. Os dous argumentos deben de ter o mesmo número de filas,
	  <math>r</math>. O valor que se devolve é unha matriz que ten
	  <math>r</math> filas, e na que a <math>i</math>-ésima fila é o
	  produto de Kronecker das respectivas filas das matrices
	  <argname>X</argname> e <argname>Y</argname>.
	</para>
	<para context="tex">
	  Noutras palabras, se $X$ é unha matriz $r \times k$, $Y$ é
	  unha matriz $r \times m$ e $Z$ é a matriz resultante do
	  produto directo horizontal de $X$ times $Y$, entón $Z$ vai
	  ter $r$ filas e $k\cdot m$ columnas; máis aínda,
	  \[
	  Z_{in} = X_{ij} Y_{il}
	  \]
	  onde $n = (j-1) m + l$.
	</para>
	<para>
	  Esta operación chámase <quote>produto directo horizontal</quote>
	  de acordo coa forma na que se pon en funcionamento, e se aplica
	  na linguaxe de programación GAUSS. A súa equivalente na álxebra
	  matricial estándar podería denominarse produto horizontal (row-wise)
	  de Khatri-Rao.
	</para>
	<para>
	  Exemplo: o código...
	</para>
	<code>
	  A = {1,2,3; 4,5,6}
	  B = {0,1; -1,1}
	  C = hdprod(A, B)
	</code>
	<para>
	  produce a seguinte matriz:
	</para>
	<code>
          0    1    0    2    0    3
         -4    4   -5    5   -6    6
	</code>
      </description>
    </function>

    <function name="hfdiff" section="midas" output="list">
      <fnargs>
	<fnarg type="list">hfvars</fnarg>
	<fnarg type="scalar">multiplicador</fnarg>
      </fnargs>
      <description>
	<para>
	  Dada unha <cmdref targ="MIDAS_list"/>, a función devolve outra lista
	  da mesma lonxitude que contén as primeiras diferenzas de alta
	  frecuencia. O segundo argumento é opcional e, por defecto, igual a 1:
	  podes utilizalo para multiplicar as diferenzas por algunha constante.
	</para>
      </description>
    </function>

    <function name="hfldiff" section="midas" output="list">
      <fnargs>
	<fnarg type="list">hfvars</fnarg>
	<fnarg type="scalar">multiplicador</fnarg>
      </fnargs>
      <description>
	<para>
	  Dada unha <cmdref targ="MIDAS_list"/>, a función devolve outra lista
	  da mesma lonxitude que contén as diferenzas logarítmicas de alta
	  frecuencia. O segundo argumento é opcional e, por defecto, igual a 1:
	  pode utilizarse para multiplicar as diferenzas por algunha constante;
	  por exemplo, poderías darlle o valor 100 para obter aproximadamente
	  as variacións porcentuais.
	</para>
      </description>
    </function>

    <function name="hflags" section="midas" output="list">
      <fnargs>
	<fnarg type="int">retardomin</fnarg>
	<fnarg type="int">retardomax</fnarg>
	<fnarg type="list">hfvars</fnarg>
      </fnargs>
      <description>
	<para>
	  Dada unha <cmdref targ="MIDAS_list"/>, <repl>hfvars</repl>, a función
	  devolve outra lista cos retardos de alta frecuencia desde
	  <repl>retardomin</repl> ata <repl>retardomax</repl>. Debes utilizar valores
	  positivos para indicar os retardos, e negativos para indicar os
	  adiantos. Por exemplo, se <repl>retardomin</repl> é &minus;3, e
	  <repl>retardomax</repl> é 5, entón a lista que se vai devolver conterá
	  9 series: 3 adiantos, o valor actual e 5 retardos.
	</para>
	<para>
	  Cae na conta de que o retardo 0 de alta frecuencia correspóndese co
	  primeiro período de alta frecuencia, dentro dun período de baixa
	  frecuencia; por exemplo, correspondería co primeiro mes dentro dun
	  trimestre ou co primeiro día dentro dun mes.
	</para>
      </description>
    </function>

    <function name="hflist" section="midas" output="list">
      <fnargs>
	<fnarg type="vector">x</fnarg>
	<fnarg type="int">m</fnarg>
	<fnarg type="string">prefixo</fnarg>
      </fnargs>
      <description>
  <para>
	  Produce unha <cmdref targ="MIDAS_list"/> de <repl>m</repl> series
	  a partir do vector <repl>x</repl>, onde <repl>m</repl> indica a
	  razón entre a frecuencia (maior) das observacións da variable
	  <repl>x</repl>, e a frecuencia base (menor) do conxunto vixente
	  de datos. O valor de <repl>m</repl> debe de ser maior ou igual a 3, e
	  o tamaño de <repl>x</repl> debe de ser igual a <repl>m</repl> veces
	  o tamaño do rango da mostra vixente.
  </para>
  <para>
	  Os nomes das series da lista que se devolve, constrúense a partir do
	  <repl>prefixo</repl> indicado (que debe de ser unha cadea de texto,
	  dunha lonxitude máxima de 24 caracteres ASCII, e válida como
	  identificador de Gretl), á que se engade un ou máis díxitos que
	  representan o subperíodo da observación. Se algún deses nomes repite
	  o de algún obxecto xa existente, amósase un fallo.
  </para>
      </description>
    </function>

    <function name="hpfilt" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="scalar" optional="true">lambda</fnarg>
	<fnarg type="bool" optional="true">unha-parte</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha serie que recolle a compoñente cíclica do filtro de
	  Hodrick&ndash;Prescott aplicado á serie <argname>y</argname>. Se
	  non se indica o parámetro de suavizado <argname>lambda</argname>, o
	  Gretl usa valores por defecto baseados na periodicidade dos datos;
	  concretamente, o parámetro é igual a 100 veces o cadrado da
	  periodicidade (100 para datos anuais, 1600 para datos trimestrais, etc).
	</para>
	<para>
	  Por defecto, o filtro é o da habitual versión de dúas partes
	  (pasado e futuro), pero se indicas o terceiro argumento (opcional)
	  mediante un valor non nulo, calcúlase a variante dunha soa
	  parte (sen ollada cara adiante) do xeito no que se indica en
	  <cite key="stock-watson1999">Stock e Watson (1999)</cite>.
	</para>
	<para>
	  O uso máis habitual do filtro HP é para a eliminación da tendencia,
	  pero se estás interesado na propia tendencia, é doado de obtela
	  mediante subtracción, como no exemplo seguinte:
	</para>
	<code>
	  series hptrend = y - hfilt(y)
	</code>
	<para>
	  <seelist>
            <fncref targ="bkfilt"/>
            <fncref targ="bwfilt"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="hyp2f1" section="math" output="scalar-or-matrix">
      <fnargs>
	<fnarg type="scalar">a</fnarg>
	<fnarg type="scalar">b</fnarg>
	<fnarg type="scalar">c</fnarg>
	<fnarg type="scalar-or-matrix">x</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devolve o valor da función hiperxeométrica de Gauss para o
	  argumento real <argname>x</argname>.
	</para>
	<para context="tex">
	  Devolve o valor da función hiperxeométrica de Gauss
    <math>{}_2F_1(a,b;c;z) = \sum_{n=0}^\infty \frac{(a)_n (b)_n}{(c)_n} \frac{z^n}{n!}.</math>
    para o argumento real
	  <argname>x</argname>.
	</para>
	<para>
	  Cando <argname>x</argname> é un escalar, o valor que se devolve
	  vai ser un escalar; doutro xeito, vai ser unha matriz coa mesma
	  dimensión ca <argname>x</argname>.
	</para>
      </description>
    </function>

    <function name="I" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="int">n</fnarg>
	<fnarg optional="true" type="int">m</fnarg>
      </fnargs>
      <description>
	<para>
	  Se omites <argname>m</argname>, devolve unha matriz identidade
	  de orde <argname>n</argname>. Doutro xeito, devolve unha matriz
	  <by r="n" c="m"/> que contén uns na diagonal principal e ceros
	  no resto da matriz.
	</para>
      </description>
    </function>

    <function name="Im" section="complex" output="matrix">
      <fnargs>
	<fnarg type="cmatrix">C</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz real coa mesma dimensión que <argname>C</argname>,
	  que contén a parte imaxinaria da matriz do argumento. Consulta
	  tamén <fncref targ="Re"/>.
	</para>
      </description>
    </function>

    <function name="imaxc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector fila que indica, para cada columna da matriz
	  <argname>X</argname>, cal é a fila que ten o valor máis grande.
	</para>
	<para>
	  <seelist>
            <fncref targ="imaxr"/>
            <fncref targ="iminc"/>
            <fncref targ="maxc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="imaxr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector columna que indica, para cada fila da matriz
	  <argname>X</argname>, cal é a columna que ten o valor máis grande.
	</para>
	<para>
	  <seelist>
            <fncref targ="imaxc"/>
            <fncref targ="iminr"/>
            <fncref targ="maxr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="imhof" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="scalar">x</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Calcula a Prob(<math>u'Au</math> &lt; <math>x</math>) para unha forma
	  cuadrática de variables Normais estándar, <math>u</math>, usando o
	  procedemento desenvolvido por <cite key="imhof61">Imhof (1961)</cite>.
	</para>
	<para context="tex">
	  Calcula a ${\rm Prob}(u'Au &lt; x)$ para unha forma cuadrática de
	  variables Normais estándar, $u$, usando o procedemento desenvolvido
	  por <cite key="imhof61">Imhof (1961)</cite>.
	</para>
	<para>
	  Se o primeiro argumento <argname>M</argname> é unha matriz cadrada,
	  tómase para que represente a <math>A</math>. Se é un vector columna,
	  tómanse os seus elementos como se fosen os autovalores calculados
	  previamente de <math>A</math>, e noutro caso preséntase un fallo.
	</para>
	<para>
	  <seelist>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="iminc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector fila que indica, para cada columna da matriz
	  <argname>X</argname>, cal é a fila que ten o valor máis pequeno.
	</para>
	<para>
	  <seelist>
            <fncref targ="iminr"/>
            <fncref targ="imaxc"/>
            <fncref targ="minc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="iminr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector columna que indica, para cada fila da matriz
	  <argname>X</argname>, cal é a columna que ten o valor máis pequeno.
	</para>
	<para>
	  <seelist>
            <fncref targ="iminc"/>
            <fncref targ="imaxr"/>
            <fncref targ="minr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="inbundle" section="data-utils" output="int">
      <fnargs>
	<fnarg type="bundle">b</fnarg>
	<fnarg type="string">chave</fnarg>
      </fnargs>
      <description>
	<para>
	  Comproba se o feixe ('bundle') <argname>b</argname>
	  contén un elemento co nome <argname>chave</argname>. Devolve un enteiro
	  co código do tipo de elemento: 0 no caso de non achalo e, no caso de
	  atopalo, 1 para un escalar, 2 para unha serie, 3 para unha matriz, 4 para
	  unha cadea de texto, 5 para un feixe, 6 para un arranxo e 7 para unha lista.
	  En base ao valor do seu código, a función <fncref targ="typestr"/> pódese
	  usar para obter a cadea de texto que expresa o tipo de elemento que é.
	</para>
      </description>
    </function>

    <function name="infnorm" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devolve un escalar coa norma-infinito da matriz <argname>X</argname>,
	  é dicir, o máximo valor que se obtén ao sumar os valores absolutos
	  dos elementos da matriz <argname>X</argname> que hai en cada fila.
	</para>
	<para context="tex">
	  Devolve un escalar coa norma-$\infty$ da matriz $r\times c$,
	  <argname>X</argname>, concretamente
          \[\| X \|_{\infty} = \max_i \sum_{j=1}^c |X_{ij}|\]
	</para>
	<para>
	  <seelist>
            <fncref targ="onenorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="inlist" section="data-utils" output="int">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un enteiro positivo coa posición de <argname>y</argname> na
	  lista <argname>L</argname>, ou 0 se <argname>y</argname> non está
	  presente en <argname>L</argname>.
	</para>
	<para>
	  O segundo argumento podes indicalo tanto co nome da serie como co
	  enteiro positivo que identifica a serie (ID). Cando sabes que existe
	  unha serie cun nome concreto (por exemplo, <lit>foo</lit>), podes
	  executar esta función da seguinte forma:
	</para>
  <code>
	  pos = inlist(L, foo)
  </code>
  <para>
	  Coa expresión anterior estás pedindo: <quote>Indícame cun enteiro a
	  posición da serie <lit>foo</lit> na lista <lit>L</lit> (ou 0 se non
	  está incluída nesa lista)</quote>. De calquera xeito, se non tes
	  certeza de que exista unha serie cun nome concreto, debes indicar
	  ese nome entre comiñas desta forma:
	</para>
	<code>
	  pos = inlist(L, "foo")
  </code>
  <para>
	  Neste caso, o que estás solicitando é: <quote>Se existe unha serie
	  chamada <lit>foo</lit> na lista <lit>L</lit>, indícame a súa posición;
	  no caso de que non exista, devolve un 0.</quote>
	</para>
      </description>
    </function>

    <function name="instring" section="strings" output="int">
      <fnargs>
	<fnarg type="string">s1</fnarg>
	<fnarg type="string">s2</fnarg>
      </fnargs>
      <description>
	<para>
	  Este é un booleano relativo de <fncref targ="strstr"/>:
	  devolve 1 se <argname>s1</argname> contén
	  <argname>s2</argname>, e 0 noutro caso. Deste xeito,
	  a expresión condicional
	</para>
	<code>
	  if instring("gatada", "gata")
	</code>
	<para>
	  é equivalente loxicamente (pero máis eficiente) ca
	</para>
	<code>
	  if strlen(strstr("gatada", "gata")) &gt; 0
	</code>
      </description>
    </function>

    <function name="instrings" section="strings" output="matrix">
      <fnargs>
	<fnarg type="strings">S</fnarg>
	<fnarg type="string">cotexo</fnarg>
      </fnargs>
      <description>
	<para>
	  Comproba se os elementos do arranxo de cadeas de texto
	  <argname>S</argname> son iguais a <argname>cotexo</argname>.
	  Devolve un vector columna de longura igual ao número de
	  coincidencias que se producen, e que contén a posición que
	  ocupa cada coincidencia dentro do arranxo (ou ben unha matriz
	  baldeira en caso de non haber coincidencias).
	</para>
	<para>
	  Exemplo:
	</para>
	<code>
	  strings S = defarray("A", "B", "C", "B")
	  eval instrings(S, "B")
	  2
	  4
	</code>
      </description>
    </function>

    <function name="int" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) coa parte enteira de
	  <argname>x</argname>, tronzando a parte decimal. Ten en conta que
	  <lit>int</lit> e <fncref targ="floor"/> producen distintos efectos
	  con argumentos negativos: <lit>int(-3.5)</lit> xera &minus;3,
	  namentres <lit>floor(-3.5)</lit> xera &minus;4.
	  <seelist>
            <fncref targ="ceil"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="inv" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve a matriz inversa de <argname>A</argname>. Cando esta última
	  é unha matriz singular ou non cadrada, prodúcese unha mensaxe de fallo
	  e non se devolve nada. Cae na conta de que Gretl comproba
	  automaticamente a estrutura de <argname>A</argname>, e utiliza o
	  procedemento numérico máis eficiente para realizar a inversión.
	</para>
	<para>
	  Os tipos de matriz que Gretl comproba automaticamente son:
	  identidade, diagonal, simétrica definida positiva, simétrica definida
	  non positiva, e triangular.
	</para>
	<para>
	  Nota: En boa lóxica, só debes utilizar esta función cando tratas de
	  aplicar a inversa de <argname>A</argname> máis dunha vez. Cando
	  unicamente necesitas calcular, por exemplo, unha expresión da forma
	  <math>A</math><sup>-1</sup><math>B</math>, é preferible que
	  utilices os operadores de <quote>división</quote>: <lit>\</lit> e
	  <lit>/</lit>. Para obter máis detalles, podes consultar o
	  <guideref targ="chap:matrices"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="ginv"/>
            <fncref targ="invpd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="invcdf" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">u</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula a inversa da función de distribución acumulativa.
	  Para unha distribución continua devolve un resultado (do tipo
	  do argumento) co valor de <math>x</math> que cumpre
	  <equation status="inline" ascii="P(X &le; x) = u" tex="$P(X \le x) = u$"/>,
	  con <argname>u</argname> dentro do intervalo entre 0 e 1.
	  Para unha distribución discreta (Binomial ou Poisson), devolve
	  o valor máis pequeno de <math>x</math> para o que se cumpre
	  <equation status="inline" ascii="P(X &le; x) &ge; u" tex="$P(X \le x) \ge u$"/>.
	</para>
	<para>
	  A distribución de <math>X</math> especifícase por medio da letra
	  <argname>d</argname>. Entre os argumentos <argname>d</argname> e
	  <argname>u</argname>, podes necesitar algún argumento adicional
	  escalar para especificar os parámetros da distribución de que se
	  trate. Isto faise da forma que se indica a continuación:
	</para>
	<ilist context="notex">
	  <li>
            <para>
              Normal estándar (c = z, n ou N): sen argumentos extras
            </para>
	  </li>
	  <li>
            <para>
              Gamma (g ou G): forma, escala
            </para>
	  </li>
	  <li>
            <para>
              t de Student (t): graos de liberdade
            </para>
	  </li>
	  <li>
            <para>
              Khi-cadrado (c, x ou X): graos de liberdade
            </para>
	  </li>
	  <li>
            <para>
              F de Snedecor (f ou F): graos de liberdade (num.), graos de liberdade (den.)
            </para>
	  </li>
	  <li>
            <para>
              Binomial (b ou B): probabilidade, cantidade de ensaios
            </para>
	  </li>
	  <li>
            <para>
              Poisson (p ou P): media
            </para>
	  </li>
	  <li>
            <para>
              Laplace (l ou L): media, escala
            </para>
	  </li>
	  <li>
            <para>
              Erro Xeneralizado (E): forma
            </para>
	  </li>
	  <li>
	    <para>
	      Khi-cadrado non central (ncX): graos de liberdade, parámetro de non centralidade
	    </para>
	  </li>
	  <li>
	    <para>
	      F non central (ncF): graos de liberdade (num.), graos de liberdade (den.),
	      parámetro de non centralidade
	    </para>
	  </li>
	  <li>
	    <para>
	      t non central (nct): graos de liberdade, parámetro de non centralidade
	    </para>
	  </li>
	</ilist>
	<tabular colspec="lllll">
	  \textit{Distribución} &amp; \textsl{d} &amp;
	  \textit{Arg} 2 &amp; \textit{Arg} 3 &amp; \textit{Arg} 4 \\[4pt]
	  Normal estándar &amp; \texttt{z}, \texttt{n} ou \texttt{N} &amp;
	  -- &amp; -- &amp; --\\
	  Gamma &amp; \texttt{g} ou \texttt{G} &amp;
	  forma &amp; escala &amp; --\\
	  $t$ de Student (central) &amp; \texttt{t} &amp;
	  gl &amp; -- &amp; --\\
	  Khi-cadrado &amp; \texttt{c}, \texttt{x} ou \texttt{X} &amp;
	  gl &amp; -- &amp; --\\
	  $F$ de Snedecor &amp; \texttt{f} ou \texttt{F} &amp;
	  gl (num.) &amp; gl (den.) &amp; --\\
	  Binomial &amp; \texttt{b} ou \texttt{B} &amp;
	  $p$ &amp; $n$  &amp; --\\
	  Poisson &amp; \texttt{p} ou \texttt{P} &amp;
    $\lambda$ &amp; --  &amp; --\\
	  Laplace &amp; \texttt{l} ou \texttt{L} &amp;
    media &amp; escala  &amp; -- \\
	  Erro Xeneralizado &amp; \texttt{E} &amp;
	  forma &amp; -- &amp; --\\
	  $\chi^2$ non central &amp; \texttt{ncX} &amp;
	  gl &amp; non centralidade &amp; --\\
	  $F$ non central &amp; \texttt{ncF} &amp;
	  gl (num.) &amp; gl (den.) &amp; non centralidade\\
	  $t$ non central &amp; \texttt{nct} &amp;
	  gl &amp; non centralidade &amp; --\\
	</tabular>
	<para>
	  <seelist>
            <fncref targ="cdf"/>
            <fncref targ="critical"/>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="invmills" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) coa razón inversa de
	  Mills en <argname>x</argname>, é dicir, a razón entre a densidade
	  Normal estándar e o complementario da función de distribución
	  Normal estándar, ambas avaliadas en <argname>x</argname>.
	</para>
	<para>
	  Esta función utiliza un algoritmo axeitado que proporciona unha
	  precisión moito mellor que a que se acada facendo os cálculos con
	  <fncref targ="dnorm"/> e <fncref targ="cnorm"/>; agora ben, a
	  diferenza entre os dous métodos é considerable só para valores
	  moi negativos de <argname>x</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="cdf"/>
            <fncref targ="cnorm"/>
            <fncref targ="dnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="invpd" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="pdmat">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve a matriz cadrada resultante de inverter a matriz simétrica
	  definida positiva <argname>A</argname>. Para matrices moi grandes,
	  esta función é lixeiramente máis rápida ca <fncref targ="inv"/> posto
	  que con ela non se comproba se a matriz é simétrica. Por esta razón,
	  a función debe de utilizarse con prudencia.
	</para>
	<para>
	  Nota: Se pretendes inverter unha matriz da forma <math>X'X</math>,
	  onde <math>X</math> é unha matriz moi grande, é preferible que a
	  calcules por medio do operador principal <lit>X'X</lit> en lugar
	  de usar a sintaxe máis xeral <lit>X'*X</lit>. A primeira expresión
	  utiliza un algoritmo especializado que ten unha dobre vantaxe:
	  resulta máis eficiente desde o punto de vista do cómputo; e vai
	  garantir que a matriz resultante estea libre, por construción, dos
	  artefactos de precisión de máquina que puideran convertela en
	  numericamente non simétrica.
	</para>
      </description>
    </function>

    <function name="irf" section="stats" output="matrix">
      <fnargs>
	<fnarg type="int">efecto</fnarg>
	<fnarg type="int">motivo</fnarg>
	<fnarg type="pscalar" optional="true">alpha</fnarg>
	<fnarg type="bundle" optional="true">sys</fnarg>
      </fnargs>
      <description>
	<para>
	  Sen o argumento final (opcional), esta función só está
	  dispoñible cando o último modelo estimado foi un VAR ou un
	  VECM. Como alternativa, podes gardar nun feixe a información
	  sobre un VAR ou un VECM co accesorio <fncref targ="$system"/>,
	  e posteriormente pasarlle a función <lit>irf</lit>.
	</para>
	<para>
	  Como resultado, devolve unha matriz que contén
	  a resposta estimada da variable <argname>efecto</argname> ante un
	  impulso na variable <argname>motivo</argname> de magnitude igual
	  á súa desviación padrón. Estas dúas variables identifícanse
	  tendo en conta as súas posicións na especificación do modelo: por
	  exemplo, cando indicas os argumentos <argname>efecto</argname>
	  e <argname>motivo</argname> cos valores 1 e 3, respectivamente, a
	  matriz que se devolve proporciona a resposta da primeira variable
	  do sistema, ante un impulso da terceira variable.
	</para>
	<para>
	  Se indicas o terceiro argumento <argname>alpha</argname> (opcional),
	  a matriz que te devolve a función ten tres columnas: a primeira coa
	  estimación por punto das respostas, e as outras cos límites inferior e
	  superior do intervalo con confianza (1 &minus; &agr;) para as mesmas,
	  obtidas mediante autosuficiencia (<quote>bootstrapping</quote>).
	  Se <argname>alpha</argname> = 0.1, a confianza será do 90 por cento.
	  Cando <argname>alpha</argname> se omite ou se iguala a cero, tan só
	  se proporciona a estimación por punto.
	</para>
	<para>
	  O número de períodos (filas) sobre os que se traza a resposta se
	  determina automaticamente dependendo da frecuencia dos datos; mais
	  iso pode axustarse por medio da instrución <cmdref targ="set"/>,
	  como por exemplo con <lit>set horizon 10</lit>.
	</para>
	<para>
	  <seelist><fncref targ="fevd"/></seelist>
	</para>
      </description>
    </function>

    <function name="irr" section="math" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar coa Taxa Interna de Rendemento (TIR) para
	  <argname>x</argname>, considerada como unha secuencia de pagos
	  (negativos) e ingresos (positivos).
	  <seelist>
            <fncref targ="npv"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="iscomplex" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="string">nome</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve 1 cando <argname>nome</argname> é a denominación dunha
	  matriz complexa, 0 se é a denominación dunha matriz real, ou
	  <lit>NA</lit> noutro caso.
	</para>
      </description>
    </function>

    <function name="isconst" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="int" optional="true">codigo-panel</fnarg>
      </fnargs>
      <description>
	<para>
	  Sen o segundo argumento (opcional), devolve o número enteiro igual
	  a 1 cando <argname>y</argname> teña un valor constante ao longo da
	  mostra vixente seleccionada (ou ao longo de toda a súa extensión se
	  <argname>y</argname> é un vector); noutro caso, devolve o enteiro 0.
	</para>
	<para>
	  O segundo argumento só se acepta cando <argname>y</argname> é unha
	  serie, e o conxunto vixente de datos é un panel. Neste caso, un valor
	  de <argname>codigo-panel</argname> igual a 0 solicita que a función
	  verifique se a serie non varía co paso do tempo; e un valor igual a
	  1 fai que a función verifique se a serie non varía transversalmente
	  (é dicir, se o valor de <argname>y</argname> en cada período de
	  tempo, é o mesmo para todos os grupos).
	</para>
	<para>
	  Se <argname>y</argname> é unha serie, as observacións con valores
	  ausentes ignóranse durante a verificación da invariabilidade da serie.
	</para>
      </description>
    </function>

    <function name="isdiscrete" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">nome</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>nome</argname> é unha cadea que identifica unha serie xa
	  definida, e se está marcada como de tipo discreto, a función devolve
	  un enteiro igual a1; noutro caso, devolve 0. Se <argname>nome</argname>
	  non identifica unha serie, a función devolve <lit>NA</lit>.
	</para>
      </description>
    </function>

    <function name="isdummy" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Se todos os valores contidos en <argname>x</argname> son iguais a 0 ou
	  a 1 (ou ausentes), devolve un enteiro co reconto de uns; senón, devolve 0.
	</para>
      </description>
    </function>

    <function name="isnan" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-matrix">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Dado un argumento escalar, devolve 1 se <argname>x</argname> non é un
	  número, <quote>Not a Number</quote> (NaN); noutro caso, devolve 0. Dada
	  unha matriz como argumento, devolve outra matriz da mesma dimensión
	  que contén valores iguais a 1 nas posicións nas que os elementos que lles
	  corresponden da matriz de entrada son NaN, e 0 nas demais posicións.
	</para>
      </description>
    </function>

    <function name="isoconv" section="calendar" output="scalar">
      <fnargs>
	<fnarg type="series">data</fnarg>
	<fnarg type="seriesref">&amp;ano</fnarg>
	<fnarg type="seriesref">&amp;mes</fnarg>
	<fnarg type="seriesref" optional="true">&amp;día</fnarg>
      </fnargs>
      <description>
	<para>
	  Dada a serie <argname>data</argname> que contén datas no formato
	  ISO 8601 <quote>básico</quote> (<lit>YYYYMMDD</lit>), esta función
	  converte as compoñentes de ano, mes e (opcionalmente) día en novas
	  series designadas polo segundo e seguintes argumentos. Un exemplo
	  da súa aplicación, asumindo que a serie <lit>datas</lit> contén valores
	  axeitados de 8 díxitos, sería:
	</para>
	<code>
	  series y, m, d
	  isoconv(datas, &amp;y, &amp;m, &amp;d)
	</code>
	<para>
	  Esta función devolve o escalar 0 no caso de completarse con éxito,
	  e un escalar non nulo en caso de fallo.
	</para>
      </description>
    </function>

    <function name="isocountry" section="strings" output="asinput">
      <fnargs>
	<fnarg type="string-or-strings">orixe</fnarg>
	<fnarg type="int" optional="true">resultado</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta función está relacionada coas catro notacións para países
	  que están incluídas no estándar ISO 3166; en concreto
	</para>
	<nlist>
	  <li><para>
	    Nome de país
	  </para></li>
	  <li><para>
	    Código alfa-2 (dúas letras maiúsculas)
	  </para></li>
	  <li><para>
	    Código alfa-3 (tres letras maiúsculas)
	  </para></li>
	  <li><para>
	    Código numérico (3 díxitos)
	  </para></li>
	</nlist>
	<para>
	  Cando indicas un país con algunha desas formas, o resultado é a
	  súa representación na forma (da 1 á 4) que escollas mediante o
	  argumento opcional <argname>resultado</argname>. Se omites ese
	  argumento, a conversión por defecto faise do xeito seguinte:
	  cando o argumento <argname>orixe</argname> é un nome dun país,
	  o resultado é o código de 2 letras do país; noutro caso, o resultado
	  é o nome do país. Debaixo ilústranse varias solicitudes válidas con
	  formato interactivo.
	</para>
	<code>
	  ? eval isocountry("Bolivia")
	  BO
	  ? eval isocountry("Bolivia", 3)
	  BOL
	  ? eval isocountry("GB")
	  United Kingdom of Great Britain and Northern Ireland
	  ? eval isocountry("GB", 3)
	  GBR
	  ? strings S = defarray("ES", "DE", "SD")
	  ? strings C = isocountry(S)
	  ? print C
	  Arranxo de strings, longura 3
	  [1] "Spain"
	  [2] "Germany"
	  [3] "Sudan"
	  ? matrix m = {4, 840}
	  ? C = isocountry(m)
	  ? print C
	  Arranxo de strings, longura 2
	  [1] "Afghanistan"
	  [2] "United States of America"
	</code>
	<para>
	  Cando <argname>orixe</argname> ten a forma 4 (código numérico),
	  isto pode indicarse mediante unha cadea de texto ou un arranxo de
	  cadeas (por exemplo, <quote>032</quote> para Argentina) ou con
	  formato numérico. No derradeiro caso, <argname>orixe</argname>
	  pode indicarse como unha serie ou como un vector, pero vaise amosar
	  un fallo se algún dos números está fóra do rango de 0 a 999.
	</para>
	<para>
	  En todos os casos (mesmo cando escollas o formato 4 de resultados)
	  devólvese unha cadea de texto ou un arranxo de cadeas; se necesitas os
	  valores numéricos, podes obtelos usando a función <fncref targ="atof"/>.
	  Cando <argname>orixe</argname> non coincide con ningunha entrada
	  da táboa ISO 3166, o resultado é unha cadea baleira, e nese caso
	  amósase unha advertencia.
	</para>
      </description>
    </function>

    <function name="isodate" section="calendar" output="seebelow">
      <fnargs>
	<fnarg type="scalar-or-series">ed</fnarg>
	<fnarg type="bool" optional="true">como-cadea</fnarg>
      </fnargs>
      <description>
	<para>
	  O argumento <argname>ed</argname> interprétase como un día de
	  época (que tomará o valor 1 para o primeiro día de xaneiro do ano 1
	  despois de Cristo, no calendario Gregoriano proléptico). O valor que
	  se devolve por defecto é un número de 8 díxitos do mesmo tipo ca
	  <argname>ed</argname>, ou unha serie composta por números desa
	  clase. Séguese o padrón <lit>YYYYMMDD</lit> (formato ISO 8601
	  <quote>básico</quote>) para proporcionar a data no calendario
	  Gregoriano que se corresponde ao dia na época actual.
	</para>
	<para>
	  Cando <argname>ed</argname> é unicamente un escalar e o segundo
	  argumento <argname>como-cadea</argname> (opcional) é non nulo, a
	  función non devolve un valor numérico senón unha cadea de texto
	  que segue o padrón <lit>YYYY-MM-DD</lit> (formato ISO 8601
	  <quote>estendido</quote>).
	</para>
	<para>
	  Con relación á función inversa consulta <fncref targ="epochday"/>.
	  Consulta tamén <fncref targ="juldate"/>.
	</para>
      </description>
    </function>

    <function name="isoweek" section="calendar" output="seebelow">
      <fnargs>
	<fnarg type="scalar-or-series">ano</fnarg>
	<fnarg type="scalar-or-series">mes</fnarg>
	<fnarg type="scalar-or-series">día</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve o número de semana (en formato ISO 8601) que se corresponde
	  coa(s) data(s) especificada(s) polos tres argumentos, ou <lit>NA</lit>
	  se a data non é válida. Cae na conta de que os tres argumentos deben
	  de ser todos do mesmo tipo, ben escalares (enteiros) ou ben series.
	</para>
	<para>
	  As semanas en formato ISO numéranse de 01 a 53. Os máis dos
	  anos teñen 52 semanas, pero unha media de 71 de 400 anos teñen
	  53 semanas. A semana 01, segundo a definición ISO 8601, é a semana
	  que contén o primeiro xoves do ano no calendario Gregoriano.
	  Para obter unha explicación completa, consulta
	  <url>https://en.wikipedia.org/wiki/ISO_week_date</url>.
	</para>
      </description>
    </function>

    <function name="iwishart" section="stats" output="matrix">
      <fnargs>
	<fnarg type="symmat">S</fnarg>
	<fnarg type="int">v</fnarg>
      </fnargs>
      <description>
	<para>
	  Dada <argname>S</argname> (unha matriz de orde <by r="p" c="p"/>
	  definida positiva), esta función devolve unha matriz xerada a partir
	  dunha realización da distribución Inversa de Wishart con
	  <argname>v</argname> graos de liberdade. O resultado que se devolve
	  tamén é unha matriz <by r="p" c="p"/>. Utilízase o algoritmo de
	  <cite key="odell-feiveson66">Odell e Feiveson (1966)</cite>.
	</para>
      </description>
    </function>

    <function name="jsonget" section="data-utils" output="string">
      <fnargs>
	<fnarg type="string">buf</fnarg>
	<fnarg type="string">ruta</fnarg>
	<fnarg optional="true" type="scalarref">nler</fnarg>
      </fnargs>
      <description>
	<para>
	  Como argumento <argname>buf</argname> deberás utilizar
	  un búfer JSON, tal como pode recuperarse dun sitio web
	  adecuado por medio da función <fncref targ="curl"/>; e como
	  argumento <argname>ruta</argname> deberás usar unha
	  especificación de tipo JsonPath.
	</para>
	<para>
	  Esta función devolve unha cadea de texto que representa os datos que
	  se atopan no búfer na ruta especificada. Se admiten os tipos de datos
	  <quote>double</quote> (punto flotante), <quote>int</quote> (enteiro)
	  e cadea de texto. No caso de enteiros ou de puntos flotantes,
	  devólvese a súa representación como cadeas de texto (usando para os
	  segundos, <quote>C</quote> local). Se o obxecto ao que se refire
	  a <argname>ruta</argname> é un arranxo, os seus elementos
	  imprímense na cadea de texto devolta, un por cada fila.
	</para>
	<para>
	  Por defecto, amósase un fallo se <argname>ruta</argname>
	  non coincide no búfer JSON; pero este comportamento
	  modifícase se indicas o terceiro argumento (opcional) pois, neste
	  caso, o argumento recupera un reconto das coincidencias, devolvéndose
	  unha cadea baleira se non hai ningunha. Chamada de exemplo:
	</para>
	<code>
	  ngot = 0
	  ret = jsonget(jbuf, "$.some.thing", &amp;ngot)
	</code>
	<para>
	  Agora ben, aínda vaise amosar un fallo no caso de facer unha solicitude
	  mal configurada.
	</para>
	<para>
	  Podes atopar unha exposición fidedigna da sintaxe JsonPath en
	  <url>http://goessner.net/articles/JsonPath/</url>. De calquera
	  xeito, observa que o sostemento de <lit>jsonget</lit> o fornece
	  <lit>json-glib</lit>, que non necesariamente soporta tódolos
	  elementos de JsonPath. E ademais, a funcionalidade concreta
	  que desenvolve <lit>json-glib</lit> pode ser moi diferente,
	  dependendo da versión que teñas no teu sistema. Podes consultar
	  <url>http://developer.gnome.org/json-glib/</url> se necesitas
	  ter máis detalles.
	</para>
	<para>
	  Dito isto, os seguintes operadores deberan de estar dispoñibles
	  para <lit>jsonget</lit>:
	</para>
	  <ilist>
	    <li>
              <para>
		nodo raíz, por medio do carácter <lit>$</lit>
              </para>
	    </li>
	    <li>
              <para>
		operador descendente recursivo: <lit>..</lit>
              </para>
	    </li>
	    <li>
              <para>
		operador comodín: <lit>*</lit>
              </para>
	    </li>
	    <li>
              <para>
		operador subíndice: <lit>[]</lit>
              </para>
	    </li>
	    <li>
              <para>
		operador de notación de conxunto, por exemplo <lit>[i,j]</lit>
              </para>
	    </li>
	    <li>
              <para>
		operador de tronzado: <lit>[inicio:fin:paso]</lit>
              </para>
	    </li>
	  </ilist>
      </description>
    </function>

    <function name="jsongetb" section="data-utils" output="bundle">
      <fnargs>
	<fnarg type="string">buf</fnarg>
	<fnarg type="string" optional="true">ruta</fnarg>
      </fnargs>
      <description>
	<para>
	  Como argumento <argname>buf</argname> deberás utilizar un búfer
	  JSON, tal como pode recuperarse dun sitio web adecuado por medio
	  da función <fncref targ="curl"/>. A especificación e o efecto do
	  argumento opcional <argname>ruta</argname> descríbese
	  máis abaixo.
	</para>
	<para>
	  O que se devolve é un feixe (bundle) cuxa estrutura basicamente
	  reflicte a da entrada: os obxectos JSON tórnanse feixes de Gretl,
	  e os arranxos JSON tórnanse arranxos de Gretl; cada un deles
	  pode conter cadeas de texto, feixes ou arranxos. Os nodos de
	  <quote>valor</quote> JSON tórnanse compoñentes de feixes ou
	  elementos de arranxos; no último caso, os valores numéricos se
	  converten en cadeas de texto utilizando <lit>sprintf</lit>. Cae na
	  conta de que, aínda que a especificación JSON permite arranxos de
	  tipo mixto, estes non se poden manexar mediante <lit>jsongetb</lit>
	  dado que os arranxos de Gretl deben ser de tipo único.
	</para>
	<para>
	  Podes usar o argumento <argname>ruta</argname> para limitar
	  os elementos JSON incluídos no feixe que se devolve. Ten en
	  conta que isto non é un <quote>JsonPath</quote> tal como se
	  describe na axuda para <fncref targ="jsonget"/>; isto é unha
	  sinxela composición suxeita á seguinte especificación:
	</para>
	<ilist>
	  <li>
	    <para>
	      <argname>ruta</argname> é unha formación de elementos separados
	      por unha barra, onde esta barra (<quote>/</quote>) indica o
	      desprazamento a un nivel <quote>máis baixo</quote> na árbore
	      JSON representada por <argname>buf</argname>. Permítese unha
	      barra inicial pero non é necesaria, pois implicitamente a ruta
	      sempre comeza na raíz. Non debes de incluír caracteres estraños
	      para espazos en branco.
	    </para>
	  </li>
	  <li>
	    <para>
	      Cada elemento que se separa con unha barra debe de ter
	      unha das seguintes formas: (a) un nome unicamente, en
	      cuxo caso só se vai incluír un elemento JSON cuxo nome
	      coincida no nivel estrutural indicado; ou (b) <quote>*</quote>
	      (asterisco), en cuxo caso vanse incluír todos aqueles
	      elementos do nivel indicado; ou (c) un arranxo de nomes
	      separados con comas e contornados entre chaves
	      (<quote>{</quote> e <quote>}</quote>), en cuxo caso só
	      se van incluír os elementos JSON cuxos nomes coincidan
	      con un dos nomes indicados.
	    </para>
	  </li>
	</ilist>
	<para>
	  Consulta tamén a función orientada a cadeas <fncref targ="jsonget"/>;
	  pois, dependendo da túa intención, unha destas funcións pódeche ser
	  de máis axuda que a outra.
	</para>
      </description>
    </function>

    <function name="juldate" section="calendar" output="seebelow">
      <fnargs>
	<fnarg type="scalar-or-series">ed</fnarg>
	<fnarg type="bool" optional="true">como-cadea</fnarg>
      </fnargs>
      <description>
	<para>
	  O argumento <argname>ed</argname> interprétase como un día de
	  época (que tomará o valor 1 para o primeiro día de xaneiro do ano 1
	  despois de Cristo, no calendario Gregoriano proléptico). O valor que
	  se devolve por defecto é un número de 8 díxitos do mesmo tipo ca
	  <argname>ed</argname>, ou unha serie composta por números desa
	  clase. Séguese o padrón <lit>YYYYMMDD</lit> (formato ISO 8601
	  <quote>básico</quote>) para proporcionar a data no calendario Xuliano
	  que se corresponde co dia na época actual.
	</para>
	<para>
	  Cando <argname>ed</argname> é unicamente un escalar, e o segundo
	  argumento <argname>como-cadea</argname> (opcional) é non nulo, a
	  función non devolve un valor numérico senón unha cadea de texto
	  que segue o padrón <lit>YYYY-MM-DD</lit> (formato ISO 8601
	  <quote>estendido</quote>).
	</para>
	<para>
	  Consulta tamén <fncref targ="isodate"/>.
	</para>
      </description>
    </function>

    <function name="kdensity" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-list-or-mat">x</fnarg>
	<fnarg type="scalar" optional="true">escala</fnarg>
	<fnarg type="bool" optional="true">control</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula unha estimación (ou un conxunto de estimacións) da densidade
	  kernel para o argumento <argname>x</argname>, que pode ser unha serie
	  única, unha lista ou unha matriz con máis dunha columna. A matriz
	  que se devolve ten <math>k</math> + 1 columnas, sendo <math>k</math>
	  o número de elementos (series ou columnas) de <argname>x</argname>.
	  A primeira columna inclúe un conxunto de abscisas equidistantes, e
	  o resto das columnas inclúen a densidade (ou densidades) estimada
	  correspondente a cada unha delas.
	</para>
	<para>
	  O parámetro <argname>escala</argname> (opcional) podes usalo para
	  axustar o grao de suavizado en relación ao valor por defecto que é
	  1.0 (valores maiores producen un resultado máis suave). O parámetro
	  <argname>control</argname> (opcional) actúa como un booleano: 0
	  (valor por defecto) significa que se utiliza o kernel gaussiano;
	  un valor non nulo troca ao kernel de Epanechnikov.
	</para>
	<para>
	  Podes obter un gráfico dos resultados utilizando a instrución
	  <cmdref targ="gnuplot"/>, como se indica abaixo. Cae na conta de que
	  a columna que contén as abscisas debe ir ao final para representar
	  a gráfica.
	</para>
	<code>
	  matrix d = kdensity(x)
	  # Se x ten un único elemento
	  gnuplot 2 1 --matrix=d --with-lines --fit=none
	  # Se x ten dous elementos
	  gnuplot 2 3 1 --matrix=d --with-lines --fit=none
	</code>
      </description>
    </function>

    <function name="kdsmooth" section="sspace" output="scalar">
      <fnargs>
	<fnarg type="bundleref">&amp;Mod</fnarg>
	<fnarg type="bool" optional="true">MSE</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza o suavizado das perturbacións dun feixe de Kalman,
	  configurado previamente mediante a instrución <fncref targ="ksetup"/>;
	  e devolve o escalar 0 cando se completa con éxito, ou o escalar 1
	  cando se atopan problemas numéricos.
	</para>
	<para>
	  Cando se completa con éxito a operación, as perturbacións suavizadas
	  van estar dispoñibles como <lit>Mod.smdist</lit>.
	</para>
	<para>
	  O argumento <argname>MSE</argname> (opcional) determina o contido
	  da chave <lit>Mod.smdisterr</lit>. Cando é 0 ou se omite, esta
	  matriz vai estar composta polas desviacións padrón incondicionais
	  das perturbacións suavizadas, que habitualmente se utilizan para
	  calcular os denominados <emphasis>erros auxiliares</emphasis>.
	  Mais, en caso contrario, <lit>Mod.smdisterr</lit> vai conter as
	  raíces das desviacións cadradas medias entre os erros auxiliares
	  e os seus valores verdadeiros.
	</para>
	<para>
	  Para obter máis detalles, consulta o <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="ksetup"/>
            <fncref targ="kfilter"/>
            <fncref targ="ksmooth"/>
            <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="kfilter" section="sspace" output="scalar">
      <fnargs>
	<fnarg type="bundleref">&amp;Mod</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza o filtrado cara adiante dun feixe de Kalman configurado
	  previamente mediante a instrución <fncref targ="ksetup"/>, e
	  devolve o escalar 0 cando se completa con éxito, ou o escalar 1
	  cando se atopan problemas numéricos.
	</para>
	<para>
	  Cando se completa con éxito, os erros de predición adiantados un paso
	  van estar dispoñibles como <lit>Mod.prederr</lit>, e a secuencia das
	  súas matrices de covarianzas como <lit>Mod.pevar</lit>. Por outra
	  banda, <lit>Mod.llt</lit> permitirá que teñas acceso a un
	  <math>T</math>-vector que vai conter o logaritmo da verosimilitude
	  de cada observación.
	</para>
	<para>
	  Para obter máis detalles, consulta o <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="kdsmooth"/>
            <fncref targ="ksetup"/>
            <fncref targ="ksmooth"/>
            <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="kmeier" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">d</fnarg>
	<fnarg type="series-or-vec" optional="true">cens</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz co cálculo do estimador non paramétrico
	  de Kaplan&ndash;Meier da función de supervivencia
	  (<cite key="kaplan-meier">Kaplan e Meier, 1958</cite>), dada unha
	  mostra <argname>d</argname> de datos de duración, posiblemente
	  acompañada dun rexistro de estado de censura, <argname>cens</argname>.
	  A matriz que se devolve ten tres columnas que conteñen,
	  respectivamente: os valores únicos ordenados en <argname>d</argname>,
	  a estimación da función de supervivencia que se corresponde cos
	  valores de duración da columna 1, e a desviación padrón (para mostras
	  grandes) do estimador, calculados por medio do método de
	  <cite key="greenwood26">Greenwood (1926)</cite>.
	</para>
	<para>
	  Cando indicas a serie <argname>cens</argname>, utilízase o valor 0
	  para sinalar que unha observación non está censurada, namentres
	  que o valor 1 indica que unha observación está censurada do lado
	  dereito (é dicir, o período de observación do individuo en cuestión
	  concluíu antes da duración, ou o período rexistrouse como rematado).
	  Cando non indicas <argname>cens</argname>, asúmese que todas as
	  observacións son non censuradas. (Aviso: a semántica de
	  <argname>cens</argname> pode estenderse nalgún punto para cubrir
	  outros tipos de censura.)
	</para>
	<para>
	  <seelist>
            <fncref targ="naalen"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="kpsscrit" section="stats" output="matrix">
      <fnargs>
	<fnarg type="scalar">T</fnarg>
	<fnarg type="bool">tendenc</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector fila que contén os valores críticos aos niveis de
	  10, 5 e 1 por cento da proba KPSS para a estacionariedade dunha
	  serie temporal. O argumento <argname>T</argname> debe de indicar o
	  número de observacións, e o argumento <argname>tendenc</argname> debe de
	  ser igual a 1 se a proba inclúe unha constante (ou 0 noutro caso).
	</para>
	<para>
	  Os valores críticos que se ofrecen están baseados en superficies
	  de resposta estimadas do xeito que está establecido por
	  <cite key="sephton95">Sephton (Economics Letters,1995)</cite>.
	  Consulta tamén a instrución <cmdref targ="kps"/>.
 	</para>
      </description>
    </function>

    <function name="ksetup" section="sspace" output="bundle">
      <fnargs>
	<fnarg type="smlist">Y</fnarg>
	<fnarg type="scalar-or-matrix">H</fnarg>
	<fnarg type="scalar-or-matrix">F</fnarg>
	<fnarg type="scalar-or-matrix">Q</fnarg>
	<fnarg optional="true" type="matrix">C</fnarg>
      </fnargs>
      <description>
	<para>
	  Configura un feixe de Kalman, é dicir, un obxecto que contén toda
	  a información necesaria para definir un modelo de espazo dos estados
	  linear, da forma
	  <equation status="display"
		    tex="\[y_t=H'\alpha_t\]"
		    ascii="y(t) = H'a(t)"
		    graphic="kalman1"/>
	  e coa ecuación de transición de estado
	  <equation status="display"
		    tex="\[\alpha_{t+1}=F \alpha_t + u_t\]"
		    ascii="a(t+1) = F a(t) + u(t)"
		    graphic="kalman2"/>
	  na que Var<math>(u) = Q</math>.
	</para>
	<para>
	  Os obxectos que creas mediante esta función podes utilizalos máis
	  adiante, coa intervención das seguintes funcións específicas:
	  <fncref targ="kfilter"/> para facer filtrado, <fncref targ="ksmooth"/>
	  e <fncref targ="kdsmooth"/> para suavizado, e <fncref targ="ksimul"/>
	  para facer simulacións.
	</para>
	<para>
	  En realidade, o tipo de modelos que Gretl pode manexar é moito máis
	  amplo ca o implicado na anterior representación: é posible dispoñer
	  de modelos variantes no tempo, de modelos con precedentes difusos
	  e con variable esóxena na ecuación de medida, e de modelos con
	  innovacións con correlacións cruzadas. Para obter máis detalles,
	  consulta o <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="kdsmooth"/>
            <fncref targ="kfilter"/>
            <fncref targ="ksmooth"/>
            <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ksimul" section="sspace" output="scalar">
      <fnargs>
	<fnarg type="bundleref">&amp;Mod</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar. Utiliza un feixe de tipo Kalman previamente
	  definido coa función <fncref targ="ksetup"/> para simular datos.
	</para>
	<para>
	  Para obter máis detalles, consulta o <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="ksetup"/>
            <fncref targ="kfilter"/>
            <fncref targ="ksmooth"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ksmooth" section="sspace" output="matrix">
      <fnargs>
	<fnarg type="bundleref">&amp;Mod</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza un suavizado de punto fixo (cara atrás) dun feixe de
	  Kalman previamente configurado mediante <fncref targ="ksetup"/>;
	  e devolve un 0 cando se executa con éxito, ou un 1 cando se atopan
	  problemas de tipo numérico.
	</para>
	<para>
	  Cando se completa con éxito, vas ter á túa disposición o estado xa
	  suavizado como <lit>Mod.state</lit>, e a secuencia das súas matrices
	  de varianzas-covarianzas como <lit>Mod.stvar</lit>. Para obter máis
	  detalles, consulta o <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="ksetup"/>
            <fncref targ="kdsmooth"/>
            <fncref targ="kfilter"/>
            <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="kurtosis" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve o exceso de curtose da serie <argname>x</argname>,
	  descartando calquera observación ausente.
	</para>
      </description>
    </function>

    <function name="lags" section="transforms" output="list-or-mat">
      <fnargs>
	<fnarg type="scalar-or-vec">p</fnarg>
	<fnarg type="series-list-or-mat">y</fnarg>
	<fnarg type="bool" optional="true">xretardo</fnarg>
      </fnargs>
      <description>
	<para>
	  Cando o primeiro argumento é un escalar, xera os retardos do 1 ao
	  <argname>p</argname> da serie <argname>y</argname>. Cando
	  <argname>y</argname> é unha lista, xera eses retardos para todas as
	  series que contén esa lista. Cando <argname>y</argname> é unha matriz,
	  xera eses retardos para todas as columnas da matriz. No caso de que
	  <argname>p</argname> = 0, e <argname>y</argname> sexa unha serie
	  ou unha lista, o retardo máximo toma por defecto a periodicidade dos
	  datos; aparte diso <argname>p</argname> deberá de ser positivo.
	</para>
	<para>
	  Cando o primeiro argumento é un vector, os retardos xerados son os
	  que están especificados nese vector. Neste caso, un uso habitual
	  podería ser o de poñer, por exemplo, <argname>p</argname> como
	  <lit>seq(3,7)</lit>, daquela omitindo o primeiro e segundo retardos.
	  Así e todo, tamén é correcto indicar un vector con saltos como en
	  <lit>{3,5,7}</lit>, aínda que os retardos deberán indicarse sempre
	  en orde ascendente.
	</para>
	<para>
	  No caso de que o resultado sexa unha lista, noméanse automaticamente as
	  variables xeradas co padrón <repl>nomevar</repl><lit>_</lit><repl>i</repl>,
	  no que <repl>nomevar</repl> estará indicando o nome da serie orixinal,
	  e <repl>i</repl> expresará o retardo concreto de cada caso. A parte
	  orixinal do nome vaise tronzar cando así resulte necesario, e mesmo
	  poderá axustarse oportunamente para garantir que resulte único dentro
	  do conxunto de nomes que así se vaian construír.
	</para>
	<para>
	  Cando o segundo argumento <argname>y</argname> é unha lista ou unha
	  matriz con máis dunha columna, e o nivel de retardo é maior ca 1, a
	  disposición por defecto dos elementos na lista que se devolve é por orde
	  de variable: primeiro devólvense todos os retardos da primeira serie
	  ou columna contida nese argumento, seguidos de todos os da segunda, e
	  así de forma sucesiva. O terceiro argumento (opcional) podes usalo para
	  cambiar isto: se <argname>xretardo</argname> é non nulo, entón os elementos
	  ordénanse por retardo: o primeiro retardo de todas as series ou columnas,
	  logo o segundo retardo de todas as series ou columnas, etc.
	</para>
	<para>
	  Consulta tamén <fncref targ="mlag"/> para a utilización con matrices.
	</para>
      </description>
    </function>

    <function name="lastobs" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="bool" optional="true">namostra</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve o número enteiro positivo que indexa a última observación
	  non ausente da serie <argname>y</argname>. Por defecto, analízase
	  todo o rango da mostra, de xeito que, se está activa algunha forma
	  de submostraxe, o valor que se devolve pode ser maior ca o valor
	  devolto polo accesorio <fncref targ="$t2"/>. Pero se indicas un
	  valor non nulo en <argname>namostra</argname>, só vai terse en
	  conta o rango da mostra vixente.
	  <seelist>
            <fncref targ="firstobs"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ldet" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co logaritmo natural do determinante de
	  <math>A</math>, calculado por medio da descomposición LU.
	  Cae na conta de que isto é máis eficiente que invocar
	  <fncref targ="det"/> e tomar o logaritmo do resultado. Alén diso,
	  nalgúns casos <lit>ldet</lit> é capaz de devolver un resultado
	  válido mesmo cando o determinante de <math>A</math> é
	  numericamente <quote>infinito</quote> (excedendo o número
	  máximo de dobre precisión da librería de C).
	  <seelist>
            <fncref targ="rcond"/>
            <fncref targ="cnumber"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ldiff" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-or-list">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) coas primeiras diferenzas
	  do logaritmo deste; os valores iniciais considéranse <lit>NA</lit>.
	</para>
	<para>
	  Cando se devolve unha lista, as variables individuais noméanse de
	  forma automática seguindo o padrón <lit>ld_</lit><repl>varname</repl>,
	  no que <repl>varname</repl> indica o nome da serie orixinal. A parte
	  orixinal do nome vai tronzarse cando así resulte necesario, e mesmo
	  poderá axustarse para garantir que sexa único dentro do conxunto de
	  nomes que así se vaian construír.
	</para>
	<para>
	  <seelist>
            <fncref targ="diff"/>
            <fncref targ="sdiff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="lincomb" section="transforms" output="series">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg type="vector">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha nova serie calculada como unha combinación linear das
	  series da lista <argname>L</argname>. Os coeficientes veñen dados
	  polo vector <argname>b</argname>, cuxo tamaño debe de ser igual ao
	  número de series que hai en <argname>L</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="wmean"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="linearize" section="filters" output="series">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Para executalo é preciso ter instalado o TRAMO. Devolve unha serie
	  que é unha versión <quote>linearizada</quote> do argumento; é dicir,
	  unha serie na que calquera valor ausente substitúese por valores
	  interpolados, e na que as observacións anómalas axústanse. Para iso
	  utilízase un mecanismo completamente automático do TRAMO. Para obter
	  máis detalles, consulta a documentación do TRAMO.
	</para>
	<para>
	  Cae na conta de que, se a serie do argumento non posúe valores
	  ausentes nin observacións que o TRAMO considere anómalas, esta
	  función devolve unha copia da serie orixinal.
	</para>
      </description>
    </function>

    <function name="ljungbox" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int">p</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co cálculo do estatístico Q de Ljung&ndash;Box
	  para a serie <argname>y</argname>, utilizando o nivel de retardo
	  <argname>p</argname>, ao longo da mostra seleccionada nese momento.
	  O nivel de retardo debe de ser maior ou igual a 1, e menor ca o número
	  de observacións dispoñibles.
	</para>
	<para>
	  Ese valor do estatístico podes cotexalo coa distribución Khi-cadrado
	  con <argname>p</argname> graos de liberdade, para verificar a
	  hipótese nula de que a serie <argname>y</argname> non ten
	  autocorrelación.
	  <seelist>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="lngamma" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co logaritmo da función Gamma de <argname>x</argname>.
	</para>
	<para>
	  Consulta tamén <fncref targ="bincoeff"/> e <fncref targ="gammafun"/>.
	</para>
      </description>
    </function>

    <function name="loess" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series">x</fnarg>
	<fnarg optional="true" type="int">d</fnarg>
	<fnarg optional="true" type="scalar">q</fnarg>
	<fnarg optional="true" type="bool">robusta</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza unha regresión polinómica ponderada localmente, e devolve
	  unha serie que contén os valores previstos de <argname>y</argname>
	  para cada valor non ausente de <argname>x</argname>. O método que
	  se utiliza é do tipo que está descrito por
	  <cite key="cleveland79">William Cleveland (1979)</cite>.
	</para>
	<para>
	  Os argumentos <argname>d</argname> e <argname>q</argname> (opcionais)
	  permiten especificar: a orde do polinomio de <argname>x</argname>
	  e que proporción dos puntos de datos se van utilizar na estimación
	  local, respectivamente. Os valores que se lles supoñen por defecto
	  son <argname>d</argname> = 1 e <argname>q</argname> = 0.5; e outros
	  valores admisibles para <argname>d</argname> son 0 e 2. Cando
	  establezas <argname>d</argname> = 0, vas reducir a regresión local
	  a unha forma de media móbil. O valor de <argname>q</argname> debe
	  de ser maior ca 0, e non pode ser maior ca 1; os valores máis grandes
	  producen un resultado final máis suavizado.
	</para>
	<para>
	  Cando se especifica un valor non nulo para o argumento
	  <argname>robusta</argname>, as regresións locais reitéranse dúas veces,
	  con modificacións nas ponderacións en base aos erros da iteración
	  previa, e de xeito que teñan menos influenza as observacións anómalas.
	</para>
	<para>
	  Revisa tamén a función <fncref targ="nadarwat"/> e, por engadido,
	  consulta o <guideref targ="chap:nonparam"/> para obter máis detalles
	  sobre métodos non paramétricos.
	</para>
      </description>
    </function>

    <function name="log" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co logaritmo natural de
	  <argname>x</argname>, xerando <lit>NA</lit> se este non é positivo.
	  Aviso: <lit>ln</lit> é un pseudónimo admisible para <lit>log</lit>.
	</para>
	<para>
	  Cando se devolve unha lista, as variables individuais noméanse de
	  forma automática seguindo o padrón <lit>l_</lit><repl>varname</repl>,
	  no que <repl>varname</repl> indica o nome da serie orixinal. A parte
	  orixinal do nome vai tronzarse cando así resulte necesario, e mesmo
	  poderá axustarse para garantir que sexa único dentro do conxunto de
	  nomes que así se vaian construír.
	</para>
	<para>
	  Observa que, no caso de que o argumento sexa unha matriz, a función
	  opera elemento a elemento. Para a función logarítmica matricial,
	  consulta <fncref targ="mlog"/>.
	</para>
      </description>
    </function>

    <function name="log10" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co logaritmo en base 10 de
	  <argname>x</argname>, xerando <lit>NA</lit> se este non é positivo.
	</para>
      </description>
    </function>

    <function name="log2" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co logaritmo en base 2 de
	  <argname>x</argname>, xerando <lit>NA</lit> se este non é positivo.
	</para>
      </description>
    </function>

    <function name="logistic" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para context="tex">
	  Devolve un resultado (do mesmo tipo do argumento <argname>x</argname>)
	  coa función FDA loxística deste; isto é, $\Lambda(x) = 1/(1+e^{-x})$. Se
	  <argname>x</argname> é unha matriz, a función aplícase a cada elemento.
	</para>
	<para context="notex">
	  Devolve un resultado (do mesmo tipo do argumento <argname>x</argname>)
	  coa función FDA loxística deste; é dicir,
	  1/(1+<math>e</math><sup>&minus;x</sup>). Se <argname>x</argname>
	  é unha matriz, a función aplícase a cada elemento.
	</para>
      </description>
    </function>

    <function name="lower" section="matbuild" output="smatrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devolve unha matriz triangular inferior de orde <by r="n" c="n"/>: os
	  elementos da diagonal principal e de debaixo desta son iguais aos elementos
	  correspondentes de <argname>A</argname>, e os demais son iguais a cero.
	</para>
	<para context="tex">
	  Devolve <math>B</math>, unha matriz triangular inferior $n\times n$,
	  na que para cada $B_{ij} = A_{ij}$ se $i \ge j$, e 0 noutro caso.
	</para>
	<para>
	  <seelist>
            <fncref targ="upper"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="lrcovar" section="filters" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="bool" optional="true">senmedia</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz coas varianzas e covarianzas de longo prazo
	  das columnas da matriz <argname>A</argname>. Primeiro, aos datos
	  se lles resta a media, agás que se asigne un cero ao segundo
	  argumento (opcional). Podes escoller o tipo de kernel e o parámetro
	  de tronzado do retardo (o tamaño da xanela), antes de chamar a
	  esta función mediante as opcións relacionadas co HAC que ofrece
	  a instrución <cmdref targ="set"/>, tales como <lit>hac_kernel</lit>,
	  <lit>hac_lag</lit>, ou <lit>hac_prewhiten</lit>. Consulta tamén
	  a sección sobre datos de series de tempo e matrices de covarianzas
	  HAC no <guideref targ="chap:robust_vcv"/>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="lrvar"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="lrvar" section="filters" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="int" optional="true">k</fnarg>
	<fnarg type="scalar" optional="true">mu</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar coa varianza de longo prazo do argumento
	  <argname>y</argname>, calculada usando un núcleo (<quote>kernel</quote>) de
	  Bartlett con tamaño de xanela igual a <argname>k</argname>. Se omites o
	  segundo argumento (ou lle asignas un valor negativo), o tamaño da xanela
	  establécese por defecto igual á parte enteira da raíz cúbica do tamaño da mostra.
	</para>
	<para context="tex">
	  Fórmula:
	  \[ \hat{\omega}^2(k) = \frac{1}{T} \sum_{t=k}^{T-k}
	  \left[ \sum_{i=-k}^k w_i (y_t - \mu) (y_{t-i} - \bar{Y})
	  \right] \]
	  con
	  \[ w_i = 1 - \frac{|i|}{k + 1} \]
	</para>
	<para>
	  Para o cálculo da varianza, a serie <argname>y</argname> se
	  centra con respecto ao parámetro opcional <argname>mu</argname>;
	  e cando este se omite ou é <lit>NA</lit>, utilízase a media
	  mostral.
	</para>
	<para>
	  Para unha contrapartida multivariante, consulta <fncref targ="lrcovar"/>.
	</para>
      </description>
    </function>

    <function name="Lsolve" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">L</fnarg>
	<fnarg type="matrix">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Resolve <math>x</math> en <math>Ax = b</math>, onde
	  <argname>L</argname> é o factor de Cholesky triangular
	  inferior da matriz definida positiva <math>A</math>, que
	  cumpre <math>LL' = A</math>. Podes obter un axeitado factor
	  <argname>L</argname> utilizando a función <fncref targ="cholesky"/>
	  con <math>A</math> como argumento.
	</para>
	<para>
	  Os seguintes dous cálculos deberan de producir o mesmo resultado
	  (dependendo da precisión da máquina), pero a primeira variante
	  permite volver a utilizar un factor de Cholesky calculado previamente,
	  e polo tanto debera de ser substancialmente máis rápido se estás
	  solucionando de xeito repetido para unha mesma <math>A</math>,
	  e distintos valores de <math>b</math>. O aumento da velocidade será
	  maior, canto maior sexa a dimensión de columnas de <math>A</math>.
	</para>
	<code>
	  # Variante 1
	  matrix L = cholesky(A)
	  matrix x = Lsolve(L, b)
	  # Variante 2
	  matrix x = A \ b
	</code>
      </description>
    </function>

    <function name="max" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Se o argumento <argname>y</argname> é unha serie, a función devolve
	  un escalar co valor máximo desa serie (nas observacións non ausentes).
	  Se o argumento é unha lista, devolve unha serie na que cada un dos seus
	  valores indica o máximo de entre as series listadas, para cada
	  observación.
	</para>
	<para>
	  <seelist>
            <fncref targ="min"/>
            <fncref targ="xmax"/>
            <fncref targ="xmin"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="maxc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector fila que contén os valores máximos de cada columna
	  da matriz <argname>X</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="imaxc"/>
            <fncref targ="maxr"/>
            <fncref targ="minc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="maxr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector columna que contén os valores máximos de cada fila
	  da matriz <argname>X</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="imaxc"/>
            <fncref targ="maxc"/>
            <fncref targ="minr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mcorr" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula unha matriz de correlacións (de Pearson), tratando cada columna
	  da matriz argumento <argname>X</argname> como se fose unha variable.
	  <seelist>
            <fncref targ="corr"/>
            <fncref targ="cov"/>
            <fncref targ="mcov"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mcov" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int" optional="true">dfcorr</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula unha matriz de varianzas-covarianzas, tratando cada columna da
	  matriz argumento <argname>X</argname> como se fose unha variable.
	  O divisor é <math>n</math> &minus; 1, no que <math>n</math> é o
	  número de filas de <argname>X</argname>; agás que o argumento
	  <argname>dfcorr</argname> (opcional) sexa 0, en cuxo caso se utiliza
	  <math>n</math>.
	</para>
	<para>
	  <seelist>
            <fncref targ="corr"/>
            <fncref targ="cov"/>
            <fncref targ="mcorr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mcovg" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="vector">u</fnarg>
	<fnarg optional="true" type="vector">w</fnarg>
	<fnarg type="int">p</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve a matriz covariograma para outra matriz <argname>X</argname>
	  de orde <by r="T" c="k"/> (que xeralmente contén regresores), un
	  vector <argname>u</argname> de orde <math>T</math> (opcional,
	  que adoita conter os erros), un vector <argname>w</argname> de orde
	  <math>p</math>+1 (opcional, que contén unhas ponderacións), e un
	  número enteiro <argname>p</argname> que indica o nivel de retardo
	  e debe de ser maior ou igual a 0.
	</para>
	<para context="tex">
	  A matriz que se devolve ven dada por
	  \[\sum_{j=-p}^{p} \sum_j w_{|j|} (X_t u_t
	  u_{t-j} X_{t-j}')\]
	</para>
	<para context="notex">
	  A matriz que se devolve é a suma para <math>j</math> dende
	  <math>-p</math> ata <math>p</math> de
	  <math>w(|j|) * X(t)X(t-j)' * u(t)u(t-j)</math>, onde <math>X(t)'</math> é
	  a <math>t</math>-ésima fila de <argname>X</argname>.
	</para>
	<para>
	  Se <argname>u</argname> ven indicado como <lit>nulo</lit>,
	  os termos <math>u</math> omítense, e se
	  <argname>w</argname> ven indicado como <lit>nulo</lit>,
	  todas as ponderacións asúmese que son 1.0.
	</para>
	<para>
	  Por exemplo, o seguinte anaco de código
	</para>
	<code>
	  set seed 123
	  X    = mnormal(6,2)
	  Retardo  = mlag(X,1)
	  Adianto = mlag(X,-1)
	  print X Retardo Adianto
	  eval X'X
	  eval mcovg(X, , , 0)
	  eval X'(X + Retardo + Adianto)
	  eval mcovg(X, , , 1)
	</code>
	<para>
	  produce este resultado:
	</para>
	<code>
	  ? print X Retardo Adianto
	  X (6 x 2)

	    -0.76587      -1.0600
	    -0.43188      0.30687
	    -0.82656      0.40681
	     0.39246      0.75479
	     0.36875       2.5498
	     0.28855     -0.55251

	  Retardo (6 x 2)

	      0.0000       0.0000
	    -0.76587      -1.0600
	    -0.43188      0.30687
	    -0.82656      0.40681
	     0.39246      0.75479
	     0.36875       2.5498

	  Adianto (6 x 2)

	    -0.43188      0.30687
	    -0.82656      0.40681
	     0.39246      0.75479
	     0.36875       2.5498
	     0.28855     -0.55251
	      0.0000       0.0000

	  ? eval X'X
	      1.8295       1.4201
	      1.4201       8.7596

	  ? eval mcovg(X,,, 0)
	      1.8295       1.4201
	      1.4201       8.7596

	  ? eval X'(X + Retardo + Adianto)
	      3.0585       2.5603
	      2.5603       10.004

	  ? eval mcovg(X,,, 1)
	      3.0585       2.5603
	      2.5603       10.004
	</code>
      </description>
    </function>

    <function name="mean" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>x</argname> é unha serie, a función devolve un escalar
	  coa súa media na mostra, ignorando calquera observación ausente.
	</para>
	<para>
	  Se <argname>x</argname> é unha lista, a función devolve unha serie
	  <math>y</math> tal que <math>y</math><sub>t</sub> indica a media
	  dos valores das variables desa lista na observación <math>t</math>,
	  ou <lit>NA</lit> no caso de que exista algún valor ausente en
	  <math>t</math>.
	</para>
      </description>
    </function>

    <function name="meanc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector fila coa media de cada columna de <argname>X</argname>.
	  <seelist>
            <fncref targ="meanr"/>
            <fncref targ="sumc"/>
            <fncref targ="sdc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="meanr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector columna coa media de cada fila de <argname>X</argname>.
	  <seelist>
            <fncref targ="meanc"/>
            <fncref targ="sumr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="median" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>x</argname> é unha serie, a función devolve un escalar
	  coa súa mediana na mostra, ignorando calquera observación ausente.
	</para>
	<para>
	  Se <argname>x</argname> é unha lista, a función devolve unha serie
	  <math>y</math> tal que <math>y</math><sub>t</sub> indica a mediana
	  dos valores das variables desa lista na observación <math>t</math>,
	  ou <lit>NA</lit> no caso de que exista algún valor ausente en
	  <math>t</math>.
	</para>
      </description>
    </function>

    <function name="mexp" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Calcula a matriz exponencial dunha matriz cadrada <argname>A</argname>.
	  Se <argname>A</argname> é unha matriz real, utilízase para elo o
	  algoritmo 11.3.1 de <cite key="golub96">Golub e Van Loan (1996)</cite>.
	  Se <argname>A</argname> é unha matriz complexa, o algoritmo utiliza
	  a descomposición en autovalores e <argname>A</argname> debe ser
	  diagonalizable.
	</para>
	<para context="tex">
	  Calcula e devolve a matriz exponencial dunha matriz cadrada,
	  \[ e^A = \sum_{k=0}^{\infty} \frac{A^k}{k!}
	  = \frac{I}{0!} + \frac{A}{1!} + \frac{A^2}{2!} + \frac{A^3}{3!}
	  + \cdots\]
	  (A serie que está implícita nesta expresión seguramente vai converxer.)
	  Se <argname>A</argname> é unha matriz real, utilízase para elo o
	  algoritmo 11.3.1 de <cite key="golub96">Golub e Van Loan (1996)</cite>.
	  Se <argname>A</argname> é unha matriz complexa, o algoritmo utiliza
	  a descomposición en autovalores e <argname>A</argname> debe ser
	  diagonalizable.
	</para>
	<para>
	  Consulta tamén <fncref targ="mlog"/>.
	</para>
      </description>
    </function>

    <function name="mgradient" section="midas" output="matrix">
      <fnargs>
	<fnarg type="int">p</fnarg>
	<fnarg type="vector">theta</fnarg>
	<fnarg type="int-or-string">tipo</fnarg>
      </fnargs>
      <description>
	<para>
	  Derivadas analíticas para as ponderacións dun MIDAS. Denotando como
	  <math>k</math> ao número de elementos que compoñen o vector
	  <repl>theta</repl> de hiperparámetros, esta función devolve unha
	  matriz de orde <by r="p" c="k"/>, que contén o gradiente do vector de
	  ponderacións (tal como o calcula a función <fncref targ="mweights"/>)
	  con respecto a os elementos de <repl>theta</repl>. O primeiro
	  argumento representa o nivel de retardo desexado, e o derradeiro
	  argumento especifica o tipo de disposición de parámetros. Consulta
	  a función <lit>mweights</lit> para ter unha relación dos valores
	  admisibles para <repl>tipo</repl>.
	</para>
	<para>
	  <seelist>
            <fncref targ="mweights"/>
	    <fncref targ="mlincomb"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="min" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Cando o argumento <argname>y</argname> é unha serie, devolve un
	  escalar co valor mínimo das observacións non ausentes da serie.
	  Cando o argumento é unha lista, devolve unha serie na que cada
	  elemento é o valor mínimo de entre as series listadas, en cada
	  observación.
	</para>
	<para>
	  <seelist>
            <fncref targ="max"/>
            <fncref targ="xmax"/>
            <fncref targ="xmin"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="minc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector fila co valor mínimo de cada columna de <argname>X</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="iminc"/>
            <fncref targ="maxc"/>
            <fncref targ="minr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="minr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector columna co valor mínimo de cada fila de <argname>X</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="iminr"/>
            <fncref targ="maxr"/>
            <fncref targ="minc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="missing" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="sslist">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha variable binaria (do mesmo tipo que o argumento) que
	  toma o valor 1 cando <argname>x</argname> é <lit>NA</lit>. Cando
	  <argname>x</argname> é unha serie, faise a comprobación para cada
	  elemento. Cando <argname>x</argname> é unha lista de series, devolve
	  unha serie que toma o valor 1 nas observacións nas que ao menos unha
	  das series presenta un valor ausente, e o valor 0 noutro caso.
	</para>
	<para>
	  <seelist>
            <fncref targ="misszero"/>
            <fncref targ="ok"/>
            <fncref targ="zeromiss"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="misszero" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado do tipo do argumento, mudando os <lit>NA</lit>s
	  en ceros. Se <argname>x</argname> é unha serie, múdase cada elemento.
	  <seelist>
            <fncref targ="missing"/>
            <fncref targ="ok"/>
            <fncref targ="zeromiss"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mlag" section="transforms" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="scalar-or-vec">p</fnarg>
	<fnarg type="scalar" optional="true">m</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Move cara arriba ou abaixo as filas da matriz <argname>X</argname>.
	  Cando <argname>p</argname> é un escalar positivo, a función devolve
	  unha matriz semellante a <argname>X</argname>, pero cos valores de
	  cada columna desprazados <argname>p</argname> filas cara abaixo,
	  e coas primeiras <argname>p</argname> filas cubertas co valor
	  <argname>m</argname>. Cando <argname>p</argname> é un número
	  negativo, a matriz que se devolve seméllase a <argname>X</argname>,
	  pero cos valores de cada columna desprazados cara arriba, e as últimas
	  filas cubertas co valor <argname>m</argname>. Se omites
	  <argname>m</argname>, enténdese que é igual a cero.
	</para>
	<para context="tex">
	  Move cara arriba ou abaixo as filas da matriz <argname>X</argname>.
	  Cando $p$ é un escalar positivo, a función devolve unha matriz
	  $Y$ cuxo elemento característico é $Y_{i,j} = X_{i-p,j}$ para $i \ge p$,
	  e cero noutro caso. Noutras palabras, devolve unha matriz semellante
	  a <argname>X</argname>, pero cos valores de cada columna desprazados
	  <argname>p</argname> filas cara abaixo, e coas primeiras
	  <argname>p</argname> filas cubertas co valor <argname>m</argname>.
	  Cando <argname>p</argname> é un número negativo, a matriz que se
	  devolve seméllase a <argname>X</argname>, pero cos valores de cada
	  columna desprazados cara arriba, e as últimas filas cubertas co valor
	  <argname>m</argname>. Se omites <argname>m</argname>, enténdese que
	  é igual a cero.
	</para>
	<para context="notex">
	  Se <argname>p</argname> é un vector, a operación indicada no parágrafo
	  anterior realízase con cada un dos elementos de <argname>p</argname>,
	  xuntando horizontalmente as matrices resultantes.
	</para>
	<para context="tex">
	  Se $p$ é un vector, a operación indicada no parágrafo anterior
	  realízase con cada un dos elementos de $p$, xuntando horizontalmente
	  as matrices resultantes.
	</para>
	<para>
	  Consulta tamén <fncref targ="lags"/>.
	</para>
      </description>
    </function>

    <function name="mlincomb" section="midas" output="series">
      <fnargs>
	<fnarg type="list">hfvars</fnarg>
	<fnarg type="vector">theta</fnarg>
	<fnarg type="int-or-string">tipo</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta é unha función MIDAS moi oportuna que combina as funcións
	  <fncref targ="lincomb"/> e <fncref targ="mweights"/>. Dada a lista
	  <repl>hfvars</repl>, elabora unha serie que é unha suma ponderada
	  dos elementos desa lista. As ponderacións baséanse no vector
	  <repl>theta</repl> de hiperparámetros e no tipo de disposición de
	  parámetros: consulta a función <lit>mweights</lit> para obter máis
	  detalles. Cae na conta de que <fncref targ="hflags"/> xeralmente
	  é o mellor xeito de crear unha lista apropiada para que sexa o
	  primeiro argumento desta función.
	</para>
	<para>
	  Para ser máis explícitos, a expresión
	</para>
	<code>
	  series s = mlincomb(hfvars, theta, 2)
	</code>
	<para>
	  é equivalente a
	</para>
	<code>
	  matrix w = mweights(nelem(hfvars), theta, 2)
	  series s = lincomb(hfvars, w)
	</code>
	<para>
	  pero utilizar a función <lit>mlincomb</lit>, permite economizar algo
	  ao teclear e tamén nalgúns ciclos de uso de CPU.
	</para>
      </description>
    </function>

    <function name="mlog" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz co logaritmo matricial de <argname>A</argname>.
	  O algoritmo que se usa baséase na descomposición en autovalores, polo
	  que necesita que a matriz <argname>A</argname> sexa diagonalizable.
	  Consulta tamén <fncref targ="mexp"/>.
	</para>
      </description>
    </function>

    <function name="mnormal" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg optional="true" type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz feita con valores xerados de forma pseudoaleatoria
	  mediante variables con distribución Normal estándar, e que vai ter
	  <argname>r</argname> filas e <argname>c</argname> columnas. Se o omites,
	  o número de columnas establécese en 1 (vector columna), por defecto.
	  <seelist>
            <fncref targ="normal"/>
            <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mols" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;V</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz <by r="k" c="n"/> de estimacións de parámetros
	  obtidos mediante a regresión de Mínimos Cadrados Ordinarios da matriz
	  <argname>Y</argname> de orde <by r="T" c="n"/> sobre a matriz
	  <argname>X</argname> de orde <by r="T" c="k"/>.
	</para>
	<para>
	  Cando se indica o terceiro argumento, e non é <lit>null</lit>, a
	  función vai xerar unha nova matriz <argname>U</argname> de orde
	  <by r="T" c="n"/>, que contén os erros. Cando se indica o último
	  argumento, e non é <lit>null</lit>, a matriz <argname>V</argname>
	  que se xera vai ser de orde <by r="k" c="k"/>, e contén (a) a matriz
	  de covarianzas dos estimadores dos parámetros, se <argname>Y</argname>
	  ten só unha columna, ou (b) a matriz <math>X'X</math><sup>-1</sup>
	  se <argname>Y</argname> ten varias columnas.
	</para>
	<para>
	  Por defecto, as estimacións obtéñense por medio da descomposición de
	  Cholesky, cun último recurso á descomposición QR se as columnas de
	  <argname>X</argname> teñen alto grao de multicolinearidade. Podes forzar
	  o uso da descomposición SVD mediante a instrución <lit>set svd on</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="mpols"/>
            <fncref targ="mrls"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="monthlen" section="calendar" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-series">mes</fnarg>
	<fnarg type="scalar-or-series">ano</fnarg>
	<fnarg type="int">duracsemana</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do mesmo tipo que o argumento) que expresa
	  cantos días (relevantes) ten un mes dun ano (no calendario Gregoriano
	  proléptico). O argumento <argname>duracsemana</argname>, que debe
	  de ser igual a 5, 6 ou 7, indica o número de días da semana que se
	  deben contar (co valor 6 non se contan os domingos, e con 5 non se
	  contan nin os sábados nin os domingos).
	</para>
	<para>
	  O valor que se devolva vai ser un escalar se son escalares tanto
	  <argname>mes</argname> coma <argname>ano</argname>; noutro caso
	  vai ser unha serie.
	</para>
	<para>
	  Por exemplo, se tes aberto un conxunto de datos mensuais, a expresión
	</para>
	<code>
	  series wd = monthlen($obsminor, $obsmajor, 5)
	</code>
	<para>
	  devolverá unha serie que vai conter o número de días laborables
	  de cada un dos meses da mostra.
	</para>
      </description>
    </function>

    <function name="movavg" section="filters" output="series">
      <fnargs>
	<fnarg type="series">x</fnarg>
	<fnarg type="scalar">p</fnarg>
	<fnarg type="int" optional="true">control</fnarg>
	<fnarg type="scalar" optional="true">y0</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha serie que é unha media móbil de <argname>x</argname>
	  e, dependendo do valor do parámetro <argname>p</argname>, resultará
	  unha media móbil simple ou ponderada exponencialmente.
	</para>
	<para context="notex">
	  Cando <argname>p</argname> &gt; 1, a función calcula unha media
	  móbil simple de <argname>p</argname> elementos; é dicir, calcula
	  a media aritmética de <math>x</math> desde o período <math>t</math>
	  ata o período <math>t-p+1</math>. Cando indicas un valor non nulo
	  para o argumento <argname>control</argname> (opcional), a media
	  móbil <quote>céntrase</quote>; noutro caso, <quote>retárdase</quote>.
	  O outro argumento <argname>y0</argname> non se vai ter en
	  conta.
	</para>
	<para context="tex">
	  Cando $p&gt;1$, a función calcula unha media móbil simple de
	  <argname>p</argname> elementos; é dicir, calcula
	  $\frac{1}{p} \sum_{i=0}^{p-1} x_{t-i}$. Cando indicas un valor non
	  nulo para o argumento <argname>control</argname> (opcional), a media
	  móbil <quote>céntrase</quote>; noutro caso, <quote>retárdase</quote>.
	  O outro argumento <argname>y0</argname> non se vai ter en conta.
	</para>
	<para context="notex">
	  Cando <argname>p</argname> é un fracción decimal entre 0 e 1, a
	  función calcula unha media móbil exponencial:
	</para>
	<para context="notex">
	  <math>y(t) = p*x(t) + (1-p)*y(t-1)</math>
	</para>
	<para context="notex">
	  Por defecto, a serie <math>y</math> que se devolve, iníciase
	  utilizando o primeiro valor válido de <argname>x</argname>. Pero
	  podes utilizar o parámetro <argname>control</argname> para
	  especificar un número de observacións iniciais, de forma que
	  a súa media tomarase como <math>y(0)</math>; un valor de cero para
	  <argname>control</argname> indica que deben de tomarse todas as
	  observacións para calcular ese valor. Outra posibilidade consiste
	  en que podes especificar o valor inicial utilizando o argumento
	  opcional <argname>y0</argname>; nese caso, o argumento
	  <argname>control</argname> non vai terse en conta.
	</para>
	<para context="tex">
	  Cando $0 &lt; p &lt; 1$, a función calcula unha media móbil
	  exponencial: \[y_t = p x_t + (1-p)y_{t-1}\]. Esta é a fórmula de
	  <cite key="roberts59">Roberts (1959)</cite>. Por defecto, a serie
	  $y$ que se devolve, iníciase utilizando o primeiro valor válido de
	  $x$. Pero podes utilizar o parámetro <argname>control</argname>
	  para especificar un número de observacións iniciais, de forma que
	  a súa media tomarase como $y_0$; un valor de cero para
	  <argname>control</argname> expresa que deben de tomarse todas as
	  observacións para calcular ese valor. Outra posibilidade consiste
	  en que podes especificar o valor inicial utilizando o argumento
	  opcional <argname>y0</argname>; nese caso, o argumento
	  <argname>control</argname> non vai terse en conta.
	</para>
      </description>
    </function>

    <function name="mpiallred" section="mpi" output="int">
      <fnargs>
	<fnarg type="objectref">&amp;object</fnarg>
	<fnarg type="string">op</fnarg>
      </fnargs>
      <description>
	<para>
	  Só dispoñible cando Gretl está en modo MPI (consulta
	  <mnu targ="gretlMPI">gretl + MPI</mnu>); deberán invocalo todos
	  os procesos. Esta función opera igual que <fncref targ="mpireduce"/>
	  agás polo feito de que todos os procesos (non só o proceso principal)
	  reciben unha copia do obxecto <quote>reducido</quote> en troques
	  do orixinal. Polo tanto, isto é equivalente ao que fai a función
	  <lit>mpireduce</lit> seguida por unha chamada á función
	  <fncref targ="mpibcast"/>, pero máis eficiente.
	</para>
      </description>
    </function>

    <function name="mpibarrier" section="mpi" output="int">
      <description>
	<para>
	  Só dispoñible cando Gretl está en modo MPI (consulta
	  <mnu targ="gretlMPI">gretl + MPI</mnu>); non require
	  argumentos. Forza a sincronización dos procesos MPI: ningún
	  proceso pode continuar máis alá da barreira ata que a acaden
	  todos eles.
	</para>
	<code>
	  # Ningún pasa ata que todos cheguen aquí
	  mpibarrier()
	</code>
      </description>
    </function>

    <function name="mpibcast" section="mpi" output="int">
      <fnargs>
	<fnarg type="objectref">&amp;obxecto</fnarg>
	<fnarg type="int" optional="true">raíz</fnarg>
      </fnargs>
      <description>
	<para>
	  Só dispoñible cando Gretl está en modo MPI (consulta
	  <mnu targ="gretlMPI">gretl + MPI</mnu>); deberán invocalo todos
	  os procesos. Difunde o argumento <argname>obxecto</argname>,
	  que deberás indicar en forma punteiro, a todos os procesos. O
	  obxecto en cuestión (unha matriz, un feixe, un escalar, un arranxo
	  unha cadea de texto ou unha lista) debe indicarse en todos os
	  procesos anteriores á difusión. Ningún proceso pode continuar
	  despois dunha chamada a <lit>mpibcast</lit> ata que todos os
	  procesos o consigan executar con éxito.
	</para>
	<para>
	  Por defecto, enténdese que a <quote>raíz</quote> ou orixe da
	  difusión é o proceso MPI con rango 0; pero podes axustar isto
	  por medio do segundo argumento (opcional), que deberá ser un
	  número enteiro entre 0 e o número de procesos MPI menos 1.
	</para>
	<para>
	  Deseguido temos un exemplo sinxelo. Cando se complete con
	  éxito, cada proceso vai ter unha copia da matriz <lit>X</lit>
	  definida no rango 0.
	</para>
	<code>
	  matrix X
	  if $mpirank == 0
	      X = mnormal(T, k)
	  endif
	  mpibcast(&amp;X)
	</code>
      </description>
    </function>

    <function name="mpirecv" section="mpi" output="object">
      <fnargs>
	<fnarg type="int">src</fnarg>
      </fnargs>
      <description>
	<para>
	  Só dispoñible cando Gretl está en modo MPI (consulta
	  <mnu targ="gretlMPI">gretl + MPI</mnu>). Para maior aclaración,
	  consulta a función <fncref targ="mpisend"/>, coa que <lit>mpirecv</lit>
	  deberá sempre emparellarse. O argumento <argname>src</argname>
	  especifica a xerarquía do proceso do que se vai recibir o obxecto,
	  no rango que vai desde 0 ata o número de procesos MPI
	  menos 1.
	</para>
      </description>
    </function>

    <function name="mpireduce" section="mpi" output="int">
      <fnargs>
	<fnarg type="objectref">&amp;obxecto</fnarg>
	<fnarg type="string">op</fnarg>
	<fnarg type="int" optional="true">raíz</fnarg>
      </fnargs>
      <description>
	<para>
	  Só dispoñible cando Gretl está en modo MPI (consulta
	  <mnu targ="gretlMPI">gretl + MPI</mnu>); deberán invocalo todos
	  os procesos. Esta función reúne obxectos (escalares, matrices ou
	  arranxos) cun nome determinado indicados en forma de punteiro,
	  de todos os procesos, e os <quote>reduce</quote> a un único
	  obxecto no nodo raíz.
	</para>
	<para>
	  O argumento <lit>op</lit> especifica a operación ou método
	  de redución. Os métodos admitidos para os escalares son
	  <lit>sum</lit> (suma), <lit>prod</lit> (produto), <lit>max</lit>
	  (máximo) e <lit>min</lit> (mínimo). Para as matrices, os métodos
	  son <lit>sum</lit>, <lit>prod</lit> (produto de Hadamard),
	  <lit>hcat</lit> (concatenación horizontal) e <lit>vcat</lit>
	  (concatenación vertical). Para os arranxos só se admite
	  <lit>acat</lit> (concatenación).
	</para>
	<para>
	  Por defecto, enténdese que a <quote>raíz</quote> ou meta da
	  redución é o proceso MPI con rango 0; pero podes axustar isto
	  por medio do terceiro argumento (opcional), que deberá ser un
	  enteiro entre 0 e o número de procesos MPI menos 1.
	</para>
	<para>
	  Deseguido temos un exemplo. Cando se complete con éxito o antedito,
	  o proceso raíz vai ter unha matriz <lit>X</lit> que será a suma das
	  matrices <lit>X</lit> de todos os procesos.
	</para>
	<code>
	  matrix X
	  X = mnormal(T, k)
	  mpireduce(&amp;X, sum)
	</code>
      </description>
    </function>

    <function name="mpiscatter" section="mpi" output="int">
      <fnargs>
	<fnarg type="matrixref">&amp;M</fnarg>
	<fnarg type="string">op</fnarg>
	<fnarg type="int" optional="true">raíz</fnarg>
      </fnargs>
      <description>
	<para>
	  Só dispoñible cando Gretl está en modo MPI (consulta
	  <mnu targ="gretlMPI">gretl + MPI</mnu>); deberán invocalo
	  todos os procesos. Esta función distribúe anacos dunha matriz
	  do proceso raíz, a todos os procesos. Debes anunciar a matriz en
	  todos os procesos que preceden a invocar a <lit>mpiscatter</lit>,
	  e debes indicalo en forma de punteiro.
	</para>
	<para>
	  O argumento <lit>op</lit> debe ser, ou ben <lit>byrows</lit> ou
	  ben <lit>bycols</lit>. Denotemos con <math>q</math> ao cociente
	  entre o número de filas da matriz que se vai dispersar, e o número
	  de procesos. No caso <lit>byrows</lit>, o proceso raíz vai enviar
	  as primeiras <math>q</math> filas ao proceso 0; as seguintes
	  <math>q</math> ao proceso 1, etcétera. Se queda un remanente
	  do reparto de filas, engádese á derradeira asignación. O caso
	  <lit>bycols</lit> é exactamente análogo pero o reparto da matriz
	  faise por columnas.
	</para>
	<para>
	  A continuación temos un exemplo. Se temos 4 procesos, cada un
	  (incluído o raíz) vai ter unha porción <by r="2500" c="10"/>
	  da <lit>X</lit> orixinal, tal como se atopaba no proceso raíz.
	  Se quixeras manter a matriz completa no proceso raíz, é
	  necesario que fagas unha copia da mesma antes de invocar a
	  <lit>mpiscatter</lit>.
	</para>
	<code>
	  matrix X
	  if $mpirank == 0
	      X = mnormal(10000, 10)
	  endif
	  mpiscatter(&amp;X, byrows)
	</code>
      </description>
    </function>

    <function name="mpisend" section="mpi" output="int">
      <fnargs>
	<fnarg type="object">obxecto</fnarg>
	<fnarg type="int">destino</fnarg>
      </fnargs>
      <description>
	<para>
	  Só dispoñible cando Gretl está en modo MPI (consulta
	  <mnu targ="gretlMPI">gretl + MPI</mnu>). Envía o obxecto indicado
	  (unha matriz, un feixe, un arranxo, un escalar, unha cadea de texto
	  ou unha lista) desde o proceso vixente cara ao identificado polo
	  enteiro <argname>destino</argname> (desde 0 ata o número de
	  procesos MPI menos 1).
	</para>
	<para>
	  Unha chamada a esta función debe sempre estar emparellada cunha
	  chamada a <fncref targ="mpirecv"/> no proceso <argname>destino</argname>,
	  como no seguinte exemplo no que se envía unha matriz desde o
	  rango 2 ata o rango 3.
	</para>
	<code>
	  if $mpirank == 2
	      matrix C = cholesky(A)
	      mpisend(C, 3)
	  elif $mpirank == 3
	      matrix C = mpirecv(2)
	  endif
	</code>
      </description>
    </function>

    <function name="mpols" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Funciona igual que <fncref targ="mols"/>, devolvendo unha matriz, agás
	  que os cálculos fanse con alta precisión utilizando a biblioteca GMP.
	</para>
	<para>
	  Por defecto, GMP utiliza 256 bits para cada número de punto flotante,
	  pero podes axustar isto utilizando a variable de contexto
	  <lit>GRETL_MP_BITS</lit>; por exemplo, <lit>GRETL_MP_BITS=1024</lit>.
	</para>
      </description>
    </function>

    <function name="mrandgen" section="probdist" output="matrix">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="scalar-or-matrix">p1</fnarg>
	<fnarg type="scalar-or-matrix" conditional="true">p2</fnarg>
	<fnarg type="scalar" conditional="true">p3</fnarg>
	<fnarg type="int">filas</fnarg>
	<fnarg type="int">columnas</fnarg>
      </fnargs>
      <examples>
	<example>matrix mx = mrandgen(u, 0, 100, 50, 1)</example>
	<example>matrix mt14 = mrandgen(t, 14, 20, 20)</example>
      </examples>
      <description>
	<para>
	  Funciona da mesma forma que a función <fncref targ="randgen"/> agás
	  polo feito de que devolve unha matriz en troques dunha serie. Os
	  argumentos iniciais (cuxo número depende da distribución escollida)
	  para esta función xa se describen para <lit>randgen</lit>, pero deben
	  de estar seguidos por dous números enteiros para especificar o número
	  de filas e de columnas que vai ter a matriz aleatoria desexada.
	  Se indicas <argname>p1</argname> ou <argname>p2</argname>
	  en forma matricial, deben ter un número de elementos que sexa
	  igual ao produto de <argname>filas</argname> por
	  <argname>columnas</argname>.
	</para>
	<para>
	  O primeiro dos exemplos precedentes crea un vector columna con 50
	  elementos, a partir dunha distribución Uniforme. O segundo exemplo
	  crea unha matriz aleatoria de orde <by r="20" c="20"/>, con valores
	  xerados da distribución <math>t</math> con 14 graos de liberdade.
	</para>
	<para>
	  <seelist>
            <fncref targ="mnormal"/>
            <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mread" section="data-utils" output="matrix">
      <fnargs>
	<fnarg type="string">nomeficheiro</fnarg>
	<fnarg optional="true" type="bool">importar</fnarg>
      </fnargs>
      <description>
	<para>
	  Le unha matriz gardada no ficheiro chamado
	  <argname>nomeficheiro</argname>. Isto está pensado principalmente
	  para ler ficheiros cun formato específico, como se describe máis
	  abaixo; pero tamén podes usalo con ficheiros xenéricos de texto
	  delimitado. Para este último tipo de uso, consulta máis abaixo a
	  sección titulada <quote>Ficheiros con texto delimitado</quote>.
	</para>
	<para>
	  Se o ficheiro posúe a extensión <quote><lit>.gz</lit></quote> asúmese
	  que se aplicou a compresión gzip ao gardar os datos. Se ten a
	  extensión <quote><lit>.bin</lit></quote> asúmese que o ficheiro
	  está en formato binario (consulta a función <fncref targ="mwrite"/>
	  para ter máis detalles). Noutro caso, se o nome do ficheiro inclúe
	  o sufixo <quote><lit>.mat</lit></quote>, asúmese que o ficheiro
	  ten un formato de texto simple, de acordo coas seguintes
	  especificacións:
	</para>
	<ilist>
	  <li>
            <para>
	          O ficheiro comeza con ningún ou con un número calquera de
	          comentarios, definidos por liñas que comezan co carácter
	          cancelo, <lit>#</lit>; estas liñas van ignorarse.
            </para>
	  </li>
	  <li>
            <para>
              A primeira liña que non sexa un comentario contén dous
              enteiros, separados por un carácter de tabulación, para
              indicar o número de filas e de columnas, respectivamente.
            </para>
	  </li>
	  <li>
            <para>
              As columnas se separan mediante tabulacións.
            </para>
	  </li>
	  <li>
            <para>
              O separador decimal é o carácter punto,
              <quote><lit>.</lit></quote>.
            </para>
	  </li>
	</ilist>
	<para>
	  Se no primeiro argumento non está especificado o camiño completo
	  ata o ficheiro, vaise procurar en algunhas localizacións que se
	  consideren <quote>probables</quote>, empezando polo cartafol de
	  traballo establecido nese momento en <cmdref targ="workdir"/>. Non
	  obstante, cando se indica un valor non nulo para o segundo argumento
	  <argname>importar</argname> (opcional) da función, o ficheiro
	  procúrase no cartafol <quote>punto</quote> do usuario. Isto ten a
	  intención de que se use esta función xunto coas que exportan matrices,
	  e que se ofrecen no contexto da instrución <cmdref targ="foreign"/>.
	  Nese caso, o argumento <argname>nomeficheiro</argname> debe de ser un nome
	  de ficheiro simple, sen indicar o camiño ata o ficheiro.
	</para>
	<subhead>Ficheiros con texto delimitado</subhead>
	<para>
	  Se o nome do ficheiro que se vai ler ten a extensión
	  <quote><lit>.csv</lit></quote>, as regras que administran a lectura
	  do ficheiro segundo o seu formato son diferentes, e máis laxas.
	  Neste caso, o conxunto de datos presentes <emphasis>non</emphasis>
	  debe estar precedido por unha liña que especifique o número de
	  filas e de columnas. Gretl vai tratar de determinar o delimitador
	  utilizado (coma, espazo, ou punto e coma), e fará o que poda para
	  importar a matriz, permitindo o uso da coma como separador decimal,
	  se é necesario. Cae na conta de que o delimitador non debe ser o
	  carácter do tabulador, polo risco de confundir ese tipo de ficheiros
	  cos que teñen o formato <quote>orixinal</quote> de Gretl.
	</para>
	<para>
	  <seelist>
            <fncref targ="bread"/>
            <fncref targ="mwrite"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mreverse" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="bool" optional="true">porcolumna</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz que contén as filas de <argname>X</argname>
	  en orde inversa; ou as columnas en orde inversa se o segundo
	  argumento ten un valor non nulo.
	</para>
      </description>
    </function>

    <function name="mrls" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">R</fnarg>
	<fnarg type="cvec">q</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;V</fnarg>
      </fnargs>
      <description>
	<para>
	  Mínimos cadrados restrinxidos: Xera a matriz de orde <by r="k" c="n"/>
	  cos parámetros estimados mediante a regresión de mínimos cadrados da
	  matriz <argname>Y</argname> de orde <by r="T" c="n"/>, sobre a matriz
	  <argname>X</argname> de orde <by r="T" c="k"/>, suxeita ao conxunto
	  de restricións lineais dos parámetros <math>RB </math> = <math>q</math>,
	  onde <math>B</math> representa o vector que formarían os parámetros
	  encastelados uns sobre os outros. <argname>R</argname> debe de ter
	  <math>kn</math> columnas, e cada liña dela indica os coeficientes dunha
	  das restricións lineais. O número de filas de <argname>q</argname>
	  debe de coincidir co número de filas de <argname>R</argname>.
	</para>
	<para>
	  Se o quinto argumento da función non é <lit>null</lit>, entón a
	  matriz <argname>U</argname> de orde <by r="T" c="n"/> vai conter
	  os erros. Cando proporcionas un argumento final que non é
	  <lit>null</lit>, entón a matriz <argname>V</argname> de orde
	  <by r="k" c="k"/> vai gardar a contrapartida restrinxida da matriz
	  <math>X'X</math><sup>-1</sup>. Podes construír a matriz de
	  varianzas-covarianzas dos estimadores da ecuación <math>i</math>
	  multiplicando a submatriz apropiada de <argname>V</argname> por
	  unha estimación da varianza da perturbación desa
	  ecuación.
	</para>
      </description>
    </function>

    <function name="mshape" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">r</fnarg>
	<fnarg optional="true" type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Reordena os elementos da matriz <argname>X</argname> nunha nova matriz
	  que ten <argname>r</argname> filas e <argname>c</argname> columnas. Os
	  elementos lense e gárdanse comezando polo da primeira columna e primeira fila
	  de <argname>X</argname>, e seguindo cos das seguintes filas ata acabar
	  cos desa columna; e logo coas demais columnas. Se <argname>X</argname>
	  ten menos elementos ca <math>k</math>= <math>rc</math>, estes vanse
	  repetir de forma cíclica. Noutro caso, se <argname>X</argname> ten
	  máis elementos, só se utilizan os primeiros <math>k</math> elementos.
	</para>
	<para>
	  Se omites o terceiro argumento, por defecto <argname>c</argname>
	  establécese igual a 1 se <argname>X</argname> é <by r="1" c="1"/>;
	  noutro caso, establécese igual a <math>N</math>/<argname>r</argname>
	  onde <math>N</math> representa o número total de elementos que
	  hai en <argname>X</argname>. Porén, cando <math>N</math> non é
	  un múltiplo enteiro de <argname>r</argname> se presenta un
	  erro.
	</para>
	<para>
	  <seelist>
            <fncref targ="cols"/>
            <fncref targ="rows"/>
            <fncref targ="unvech"/>
            <fncref targ="vec"/>
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="msortby" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">j</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz coas mesmas filas da matriz do argumento
	  <argname>X</argname> reordenadas de forma crecente de acordo cos
	  elementos da columna <argname>j</argname>. Esta orde é estable: as
	  filas que comparten o mesmo valor na columna <argname>j</argname>
	  non se intercambian.
	</para>
      </description>
    </function>

    <function name="msplitby" section="matshape" output="matrices">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="vector">v</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un arranxo de matrices, como resultado de separar as
	  filas de <argname>X</argname> verticalmente, baixo o control
	  do vector <argname>v</argname>. Este vector debe ser de longura
	  igual á dimensión en filas de <argname>X</argname>, e debe
	  constar de valores enteiros con 1 como valor mínimo, e un máximo
	  igual ao número de matrices que terá o arranxo desexado. Cada
	  elemento de <argname>v</argname> indica a que fila do arranxo
	  de matrices se debe asignar cada fila da matriz
	  <argname>X</argname>.
	</para>
	<para>
	  No seguinte exemplo separamos as filas dunha matriz
	  <by r="3" c="3"/> nun arranxo de tres matrices: as dúas primeiras
	  filas asígnanse á primeira matriz; a segunda matriz déixase baleira;
	  e a terceira matriz inclúe a terceira fila de <argname>X</argname>.
	</para>
	<code>
	  matrix X = {1,2,3; 4,5,6; 7,8,9}
	  matrices M = msplitby(X, {1,1,3})
	  print M
	</code>
	<para>
	  A orde de impresión depara
	</para>
	<code>
	  Arranxo de matrices, longura 3
	  [1] 2 x 3
	  [2] null
	  [3] 1 x 3
	</code>
	<para>
	  Consulta a función <fncref targ="flatten"/> para a operación inversa.
	</para>
      </description>
    </function>

    <function name="muniform" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg optional="true" type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz feita con números xerados de forma pseudoaleatoria
	  mediante variables con distribución Uniforme (0,1), e que vai ter
	  <argname>r</argname> filas e <argname>c</argname> columnas. Se o omites,
	  o número de columnas establécese en 1 (vector columna), por defecto.
	  Aviso: O método predilecto para xerar números pseudoaleatorios con
	  distribución Uniforme é o que usa a función <fncref targ="randgen1"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="mnormal"/>
            <fncref targ="uniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mweights" section="midas" output="matrix">
      <fnargs>
	<fnarg type="int">p</fnarg>
	<fnarg type="vector">theta</fnarg>
	<fnarg type="int-or-string">tipo</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector de orde <math>p</math> coas ponderacións MIDAS
	  que se aplican aos <math>p</math> retardos dunha serie de alta
	  frecuencia, baseado no vector <repl>theta</repl> de hiperparámetros.
	</para>
	<para>
	  O argumento <repl>tipo</repl> identifica o tipo de disposición de
	  parámetros que vai regular o número <math>k</math> de elementos
	  que se solicitan para <repl>theta</repl>: 1 = para Almon exponencial
	  normalizada (<math>k</math> debe de ser cando menos igual a1,
	  habitualmente 2); 2 = para Beta normalizada co retardo final nulo
	  (<math>k</math> = 2); 3 = para Beta normalizada co retardo final
	  non nulo (<math>k</math> = 3); e 4 = para Almon polinómico
	  (<math>k</math> debe de ser cando menos igual a 1). Ten en conta
	  que, no caso de Beta normalizada, os dous primeiros elementos de
	  <repl>theta</repl> deben de ser positivos.
	</para>
	<para>
	  Podes indicar o <repl>tipo</repl> como un código enteiro, tal e
	  como se amosa máis abaixo, ou mediante unha das seguintes cadeas
	  de texto (respectivamente): <lit>nealmon</lit>, <lit>beta0</lit>,
	  <lit>betan</lit> ou <lit>almonp</lit>. Se utilizas unha cadea de
	  texto, esta deberá de estar situada entre comiñas. Por exemplo,
	  as dúas seguintes expresións son equivalentes:
	</para>
	<code>
	  W = mweights(8, theta, 2)
	  W = mweights(8, theta, "beta0")
	</code>
	<para>
	  <seelist>
            <fncref targ="mgradient"/>
	    <fncref targ="mlincomb"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mwrite" section="data-utils" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="string">nomeficheiro</fnarg>
	<fnarg optional="true" type="bool">exportar</fnarg>
      </fnargs>
      <description>
	<para>
	  Escribe a matriz do argumento <argname>X</argname> nun ficheiro co
	  nome <argname>nomeficheiro</argname>. Por defecto, este ficheiro
	  vai ser de texto plano e, na primeira liña, vai conter dous números
	  enteiros que representan o número de filas e de columnas separados
	  (respectivamente) por un carácter de tabulación. Nas seguintes filas,
	  os elementos da matriz amósanse con notación científica, separados
	  por tabulacións (unha liña por fila). Para evitar confusións á hora
	  da súa lectura, os ficheiros que se escriban neste formato deben
	  ser nomeados co sufixo <quote><lit>.mat</lit></quote>. Para formatos
	  alternativos, mira máis abaixo.
	</para>
	<para>
	  Cando xa existe un ficheiro chamado <argname>nomeficheiro</argname>, vaise
	  sobrescribir. A execución da función devolve un enteiro igual a 0 se
	  non se completa con éxito; e devolve un enteiro que non é cero cando
	  acontece un fallo (por exemplo, se non pode sobrescribirse o ficheiro).
	</para>
	<para>
	  O ficheiro cos resultados vai escribirse no cartafol establecido
	  como vixente, <cmdref targ="workdir"/>, agás que a cadea de texto
	  do argumento <repl>nomeficheiro</repl> especifique o cartafol co
	  camiño completo. Non obstante, se indicas un valor non nulo para o
	  argumento <argname>exportar</argname>, o ficheiro cos resultados vai
	  escribirse no cartafol <quote>punto</quote> do usuario, onde estará
	  accesible por defecto por medio das funcións para cargar matrices
	  que se ofrecen no contexto da instrución <cmdref targ="foreign"/>.
	  Neste caso, debes de indicar un simple nome de ficheiro para o
	  segundo argumento, sen a parte que expresa o camiño ao cartafol.
	</para>
	<para>
	  As matrices gardadas mediante a forma que ten por defecto a función
	  <lit>mwrite</lit>, poden lerse doadamente con outros programas.
	  Consulta o <guideref targ="chap:matrices"/> para obter máis detalles.
	</para>
	<para>
	  Tres matizacións, que se exclúen mutuamente, desta función están
	  dispoñibles como se indica deseguido:
	</para>
	<ilist>
	  <li>
	    <para>
	      Se o argumento <argname>nomeficheiro</argname> ten a extensión
	      <quote><lit>.gz</lit></quote>, entón o ficheiro gárdase co formato
	      descrito máis arriba, pero usando a compresión gzip.
	    </para>
	  </li>
	  <li>
	    <para>
	      Se o argumento <argname>nomeficheiro</argname> ten a extensión
	      <quote><lit>.bin</lit></quote>, entón a matriz gárdase con
	      formato binario. Neste caso, os primeiros 19 bytes conteñen
	      os caracteres <lit>gretl_binary_matrix</lit>; os seguintes
	      8 bytes conteñen dous enteiros de 32 bits que proporcionan
	      o número de filas e de columnas; e o que resta do ficheiro
	      contén os elementos da matriz ordenados por columnas, en
	      formato <quote>little-endian doubles</quote>. Cando executas
	      Gretl nun sistema <quote>big-endian</quote>, os valores
	      binarios convértense a <quote>little-endian</quote> ao
	      escribilos, e a <quote>big-endian</quote> aos ler.
	    </para>
	  </li>
	  <li>
	    <para>
	      Se o argumento <argname>nomeficheiro</argname> ten a extensión
	      <quote><lit>.csv</lit></quote>, entón a matriz gárdase con
	      formato de separación con comas, sen a liña de encabezamento
	      que indique o número de filas e de columnas que a seguen.
	      Isto podería facer máis doado o tratamento con programas de
	      terceiros, pero non se recomenda cando se pretende ler o
	      ficheiro cos elementos da matriz por medio de Gretl.
	    </para>
	  </li>
	</ilist>
	<para>
	  Cae na conta de que, se vas ler o ficheiro coa matriz utilizando
	  outro software alleo, non resulta aconsellable que utilices as
	  opcións gzip nin binario. Pero se o queres para que o lea Gretl,
	  estes dous formatos alternativos permiten aforrar espazo; e co
	  formato binario logras unha lectura máis rápida de matrices
	  grandes. O formato gzip non é recomendable para matrices moi
	  grandes porque a descompresión pode ser bastante lenta.
	</para>
	<para>
	  <seelist>
            <fncref targ="mread"/>
	  </seelist>
	  Para escribir unha matriz nun ficheiro, como conxunto de datos,
	  consulta <cmdref targ="store"/>.
	</para>
      </description>
    </function>

    <function name="mxtab" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz que inclúe a tabulación cruzada dos valores
	  contidos en <argname>x</argname> (por filas) e <argname>y</argname>
	  (por columnas). Os dous argumentos desta función deben de ser
	  do mesmo tipo (ambas series ou ambos vectores columna) e, a causa
	  da utilización típica desta función, asúmese que contén unicamente
	  valores enteiros.
	</para>
	<para>
	  <seelist>
            <fncref targ="values"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="naalen" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">d</fnarg>
	<fnarg type="series-or-vec" optional="true">cens</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve o cálculo do estimador non paramétrico de Nelson&ndash;Aalen
	  da función de risco (<cite key="nelson72">Nelson, 1972</cite>;
	  <cite key="aalen78">Aalen, 1978</cite>), dada unha mostra
	  <argname>d</argname> de datos de duración, que posiblemente estea
	  acompañada dun rexistro de estado de censura, <argname>cens</argname>.
	  A matriz que devolve a función ten tres columnas que conteñen,
	  respectivamente: os valores únicos ordenados en
	  <argname>d</argname>, a estimación da función de risco acumulado
	  que se corresponde cos valores de duración da columna 1, e a desviación
	  padrón do estimador.
	</para>
	<para>
	  Cando indicas a serie <argname>cens</argname>, utilízase o valor 0
	  para sinalar que unha observación non está censurada, namentres
	  que o valor 1 indica que unha observación está censurada do lado
	  dereito (é dicir, o período de observación do individuo en cuestión
	  concluíu antes da duración ou o período rexistrouse como rematado).
	  Cando non indicas <argname>cens</argname>, asúmese que todas as
	  observacións son non censuradas. (Aviso: a semántica de
	  <argname>cens</argname> pode estenderse nalgún punto para cubrir
	  outros tipos de censura.)
	</para>
	<para>
	  <seelist>
            <fncref targ="kmeier"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="nadarwat" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series">x</fnarg>
	<fnarg type="scalar" optional="true">h</fnarg>
	<fnarg type="bool" optional="true">LOO</fnarg>
	<fnarg type="scalar" optional="true">recorte</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula unha serie coa estimación non paramétrica da media
	  condicional de <argname>y</argname> dado <argname>x</argname>,
	  de Nadaraya-Watson. A serie que devolve a función contén
	  <math>m(x</math><sub>i</sub><math>)</math>, os valores das estimacións
	  de <math>E(y</math><sub>i</sub><math>|x</math><sub>i</sub><math>)</math>
	  para cada un dos elementos non ausentes da serie
	  <argname>x</argname>.
	</para>
	<para context="tex">
	  \[ m(x_i) = \frac{ \sum_{j=1}^{n} y_j \cdot K_h(x_i - x_j)}
	  {\sum_{j=1}^{n} K_h(x_i - x_j)} \]
	  onde a función kernel <math>K_h(\cdot)</math> ven dada por
	  \[ K_h(x) = \exp\left(-\frac{x^2}{2h}\right) \]
	  para $|x| &lt; \tau$, e cero noutro caso.
	  ($\tau$ = Parámetro de recorte.)
	</para>
	<para context="notex">
	  A función núcleo (kernel) empregada por este estimador dada por
	  <math>K = exp(-x</math><sup>2</sup><math>/2h)</math> cando
	  <math>|x|&lt;T</math>, e é igual a cero noutro caso.
	  (<math>T</math> = Parámetro de recorte.)
	</para>
	<para>
	  Os tres argumentos opcionais modulan o comportamento do
	  estimador tal como se describe máis abaixo.
	</para>
	<subhead>Ancho de banda</subhead>
	<para>
	  Podes usar o argumento <argname>h</argname> para controlar o ancho
	  de banda (<quote>bandwidth</quote>), mediante un número real positivo.
	  Habitualmente este é un número pequeno, pois valores máis grandes de
	  <argname>h</argname> fan que <math>m(x)</math> sexa máis suave. Unha
	  escolla popular é facer que <argname>h</argname> sexa proporcional a
	  <math>n</math><sup>-0.2</sup>. Se omites <argname>h</argname> ou o
	  igualas a cero, o ancho de banda establécese por defecto cun valor
	  determinado polos datos, utilizando a proporcionalidade que se acaba de
	  mencionar, pero introducindo a dispersión dos datos de <argname>x</argname>
	  tal como a mide o rango inter-cuartil ou a desviación padrón; consulta
	  o <guideref targ="chap:nonparam"/> para obter máis detalles.
	</para>
	<subhead>Deixar-unha-fóra</subhead>
	<para>
	  <quote>Deixar-unha-fóra</quote> é unha variante do algoritmo,
	  que omite a observación <math>i</math>-ésima cando se avalía
	  <math>m(x</math><sub>i</sub><math>)</math>. Isto fai que o
	  estimador de Nadaraya&ndash;Watson sexa numericamente máis
	  robusto, e por iso recoméndase habitualmente utilizalo cando o
	  estimador se calcula con intención de facer inferencias. Esta
	  variante non está permitida por defecto, pero actívase cando se
	  indica un valor non nulo para o argumento <argname>LOO</argname>.
	</para>
	<para context="tex">
          Nas fórmulas, este estimador é
          \[
          m(x_i) = \frac{ \sum_{j \ne i} y_j \cdot K_h(x_i - x_j)}
          {\sum_{j \ne i} K_h(x_i - x_j)}
          \]
	</para>
	<subhead>Recorte</subhead>
	<para>
	  Podes usar o argumento <argname>recorte</argname> para controlar
	  o grao de <quote>recorte</quote> que se impón para previr
	  problemas numéricos, cando a función 'kernel' se está a avalíar
	  demasiado lonxe do cero. Este parámetro exprésase como un
	  múltiplo de <argname>h</argname>, sendo 4 o valor por defecto.
	  Nalgúns casos, pode ser preferible utilizar un valor maior ca 4.
	  De novo, consulta o <guideref targ="chap:nonparam"/> para
	  obter máis detalles.
	</para>
	<para>
	  Consulta tamén <fncref targ="loess"/>.
	</para>
      </description>
    </function>

    <function name="nelem" section="data-utils" output="int">
      <fnargs>
	<fnarg type="listetc">L</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un enteiro co número de elementos que hai no argumento;
	  este pode ser unha lista, unha matriz, un feixe ou un arranxo
	  (pero non unha serie).
	</para>
      </description>
    </function>

    <function name="ngetenv" section="strings" output="scalar">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co valor numérico dunha variable de contexto que
	  ten o nome do argumento <argname>s</argname>, se esa variable está
	  definida e se ten un valor numérico; noutro caso devolve NA.
	  Consulta tamén <fncref targ="getenv"/>.
	</para>
      </description>
    </function>

    <function name="nlines" section="strings" output="scalar">
      <fnargs>
	<fnarg type="string">buf</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar coa cantidade de filas completas (é dicir, filas
	  que rematan co carácter de nova liña) en <argname>buf</argname>.
	</para>
    <para>
        Exemplo:
    </para>
    <code>
        string web_page = readfile("http://gretl.sourceforge.net/")
        scalar number = nlines(web_page)
        print number
    </code>
      </description>
    </function>

    <function name="NMmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg optional="true" type="int">maxavalfunc</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co resultado dunha maximización numérica feita co
	  método do simplex sen derivadas de Nelder&ndash;Mead. O argumento
	  <argname>b</argname> debe de conter os valores iniciais dun conxunto
	  de parámetros, e o argumento <argname>f</argname> debe de especificar
	  unha chamada á función que vai calcular o criterio obxectivo (escalar)
	  que se quere maximizar, dados os valores vixentes dos parámetros, así
	  como calquera outros datos que sexan relevantes. Cando se completa
	  con éxito a súa execución, <lit>NMmax</lit> devolve o valor maximizado
	  do criterio obxectivo, e <argname>b</argname> contén finalmente os
	  valores dos parámetros que producen o máximo.
	</para>
	<para>
	  Podes utilizar o terceiro argumento (opcional) para indicar o número
	  máximo de avaliacións da función; se o omites ou o estableces igual
	  a cero, o máximo tómase por defecto igual a 2000. Como indicación
	  especial para esta función, podes poñer un valor negativo para o
	  argumento <argname>maxavalfunc</argname>. Nese caso, tómase o seu
	  valor absoluto e <lit>NMmax</lit> amosa un fallo se o mellor valor
	  atopado para a función obxectivo despois de realizar o máximo número
	  de avaliacións da función, non é un óptimo local. Por outra parte,
	  neste senso a non converxencia non se trata coma un fallo.
	</para>
	<para>
	  Se o teu obxectivo realmente é acadar un mínimo, podes
	  ben trocar a función considerando o negativo do criterio,
	  ou ben, alternativamente, podes invocar a función
	  <lit>NMmax</lit>baixo o alcume <lit>NMmin</lit>..
	</para>
	<para>
	  Para máis detalles e exemplos, consulta o
	  <guideref targ="chap:numerical"/>.
	  <seelist>
            <fncref targ="simann"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="NMmin" section="numerical" output="scalar">
      <description>
	<para>
	  Un alcume de <fncref targ="NMmax"/>. Se invocas a función baixo
	  este nome, execútase facendo unha minimización.
	</para>
      </description>
    </function>

    <function name="nobs" section="stats" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve o número de observacións non ausentes da variable
	  <argname>y</argname> na mostra vixente seleccionada.
	</para>
      </description>
    </function>

    <function name="normal" section="probdist" output="series">
      <fnargs>
	<fnarg type="scalar">&mu;</fnarg>
	<fnarg type="scalar">&sigma;</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha serie xerada cunha variable pseudoaleatoria gaussiana
	  de media &mu; e desviación padrón &sigma;. Se non indicas ningún
	  argumento, os valores que se devolven son os dunha variable con
	  distribución de probabilidade Normal estándar, <math>N</math>(0,1).
	  Os valores prodúcense utilizando o método Ziggurat
	  (<cite key="marsaglia00" p="true">Marsaglia e Tsang, 2000</cite>).
	</para>
	<para>
	  <seelist>
            <fncref targ="randgen"/>
            <fncref targ="mnormal"/>
            <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="normtest" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="string" optional="true">método</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector fila cos resultados de realizar unha proba de
	  Normalidade sobre <argname>y</argname>. A función fai por defecto
	  a proba de Doornik&ndash;Hansen, pero podes utilizar o argumento
	  <argname>método</argname> (opcional) para escoller unha alternativa.
	  Indica: <lit>swilk</lit> para executar a proba de Shapiro&ndash;Wilk,
	  <lit>jbera</lit> para realizar a proba de Jarque&ndash;Bera, ou
	  <lit>lillie</lit> para efectuar a proba de Lilliefors.
	</para>
	<para>
	  Podes indicar o segundo argumento con formato entre comiñas ou sen
	  elas. Neste último caso, tamén podes indicar unha cadea de texto cuxo
	  valor sexa o nome dun dos métodos, polo que se vai substituír cando se
	  executa. A continuación amósanse tres xeitos aceptables de executar
	  a proba de Shapiro&ndash;Wilk:
	</para>
	<code>
	  matrix nt = normtest(y, swilk)
	  matrix nt = normtest(y, "swilk")
	  string testtype = "swilk"
	  matrix nt = normtest(y, testtype)
	</code>
	<para>
	  O vector fila que se devolve é de orde <by r="1" c="2"/>; contén
	  o valor do estatístico de proba solicitado e a probabilidade asociada
	  a ese valor. Consulta tamén a instrución <cmdref targ="normtest"/>.
	</para>
      </description>
    </function>

    <function name="npcorr" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="string" optional="true">método</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector fila cos cálculos dunha medida de correlación entre
	  <argname>x</argname> e <argname>y</argname>, utilizando un método
	  non paramétrico. Se indicas o terceiro argumento, este debe de ser
	  <lit>kendall</lit> (para o método por defecto, o tau de Kendall,
	  versión b) ou ben <lit>spearman</lit> (para o rho de Spearman).
	</para>
	<para>
	  O resultado que se devolve é un vector fila con 3 valores que indican:
	  a medición da correlación, o valor do estatístico de proba da hipótese
	  nula de incorrelación, e a probabilidade asociada a ese valor. Advirte
	  que, se o tamaño da mostra é moi pequeno, o estatístico de proba e/ou
	  a probabilidade pode ser <lit>NaN</lit> (non é número, ou ausente).
	</para>
	<para>
	  Consulta tamén <fncref targ="corr"/> para a correlación de Pearson.
	</para>
      </description>
    </function>

    <function name="npv" section="math" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg type="scalar">r</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co Valor Actual Neto de <argname>x</argname>,
	  considerado este como unha secuencia de pagos (negativos) e ingresos
	  (positivos), avaliados a unha taxa de desconto anual que debes de
	  indicar no argumento <argname>r</argname> como fracción decimal entre
	  0 e 1, non como porcentaxe (por exemplo 0.05, e non 5<lit>%</lit>).
	  O primeiro valor da serie/vector do primeiro argumento considérase
	  que está datado <quote>agora</quote>, e non se desconta. Para imitar
	  unha función VAN na que se desconte o primeiro valor, engade un cero
	  ao principio da serie/vector do primeiro argumento.
	</para>
	<para>
	  O tipo de frecuencia dos datos que admite esta función pode ser anual,
	  trimestral, mensual e sen data (este tipo trátase como se fora anual).
	</para>
	<para>
	  <seelist>
            <fncref targ="irr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="NRmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="fncall" optional="true">g</fnarg>
	<fnarg type="fncall" optional="true">h</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co resultado dunha maximización numérica feita co
	  método de Newton&ndash;Raphson. O argumento <argname>b</argname>
	  debe de conter os valores iniciais do conxunto de parámetros, e o
	  argumento <argname>f</argname> debe de indicar unha chamada á función
	  que vai calcular o criterio obxectivo (escalar) que queres maximizar,
	  dados os valores vixentes dos parámetros, así como calquera outro dato
	  relevante. Se o que queres realmente é minimizar o criterio obxectivo,
	  esta función debera de devolver o valor negativo do mesmo. Cando se
	  completa con éxito a súa execución, <lit>NRmax</lit> devolve o valor
	  maximizado do criterio obxectivo, e <argname>b</argname> vai conter
	  os valores dos parámetros que proporcionan o máximo dese criterio.
	</para>
	<para>
	  O terceiro e cuarto argumentos (opcionais) proporcionan xeitos de
	  indicar, respectivamente, as derivadas analíticas e unha matriz
	  hessiana analítica (negativa). As funcións ás que se refiren estes
	  argumentos <argname>g</argname> e <argname>h</argname>
	  deben de ter, como primeiro elemento, unha matriz definida con
	  anterioridade que sexa do rango correcto para poder conter o vector
	  gradiente ou a matriz hessiana, indicados en forma de punteiro.
	  Ademais, outro dos seus elementos, debe de ser o vector de parámetros
	  (en forma de punteiro ou non). Outro tipo de elementos son opcionais.
	  Se omites calquera dos argumentos opcionais (ou os dous), utilízase
	  unha aproximación numérica.
	</para>
	<para>
	  Para máis detalles e exemplos, consulta o
	  <guideref targ="chap:numerical"/>.
	  <seelist>
            <fncref targ="BFGSmax"/>
            <fncref targ="fdjac"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="NRmin" section="numerical" output="scalar">
      <description>
	<para>
	  Un alcume de <fncref targ="NRmax"/>. Se invocas a función baixo
	  este nome, execútase facendo unha minimización.
	</para>
      </description>
    </function>

    <function name="nullspace" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devolve unha matriz co cálculo do espazo nulo á dereita correspondente
	  á matriz <argname>A</argname>, feito mediante a descomposición en
	  valores singulares: o resultado é unha matriz <math>B</math> que fai
	  que o produto <math>AB</math> sexa unha matriz nula. Como excepción,
	  se a matriz <argname>A</argname> ten rango completo por columnas, o
	  resultado que se devolve é unha matriz baleira. Por outra banda, se
	  <argname>A</argname> é de orde <by r="m" c="n"/>, entón <math>B</math>
	  vai ser <math>n</math> por (<math>n</math> &minus; <math>r</math>),
	  onde <math>r</math> é o rango de <argname>A</argname>.
	</para>
	<para context="notex">
	  Se <argname>A</argname> non ten rango completo por columnas,
	  entón ao concatenar verticalmente a matriz <argname>A</argname> e
	  a matriz trasposta de <argname>B</argname>, xérase unha matriz con
	  rango completo.
	</para>
	<para context="tex">
	  Devolve unha matriz co cálculo do espazo nulo á dereita correspondente
	  á matriz <argname>A</argname>, feito mediante a descomposición en
	  valores singulares: o resultado é unha matriz $B$ que fai que
	  \begin{itemize}
	  \item $AB = [0]$. Como excepción, se a matriz $A$ ten rango completo
	  por columnas, o resultado que se devolve é unha matriz baleira. Por
	  outra banda, se $A$ é de orde $m \times n$, entón $B$ vai ser unha
	  matriz de orde $n \times (n-r)$, onde $r$ é o rango $A$.
	  \item Se $A$ non ten rango completo por columnas, entón ao concatenar
	  verticalmente $A$ e $B'$, xérase unha matriz con rango completo.
	  \end{itemize}
	</para>
    <para>
        Exemplo:
    </para>
    <code>
      A = mshape(seq(1,6),2,3)
      B = nullspace(A)
      C = A | B'

      print A B C

      eval A*B
      eval rank(C)
    </code>
    <para>
        produce...
    </para>
    <code>
      ? print A B C
      A (2 x 3)

      1   3   5
      2   4   6

      B (3 x 1)

      -0.5
         1
      -0.5

      C (3 x 3)

         1      3      5
         2      4      6
      -0.5      1   -0.5

      ? eval A*B
      -4.4409e-16
      -4.4409e-16

      ? eval rank(C)
      3
    </code>
    <para>
      <seelist>
        <fncref targ="rank"/>
        <fncref targ="svd"/>
      </seelist>
	</para>
      </description>
    </function>

    <function name="numhess" section="numerical" output="matrix">
      <fnargs>
	<fnarg type="cvec">b</fnarg>
	<fnarg type="fncall">fcall</fnarg>
	<fnarg optional="true" type="scalar">d</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula unha aproximación numérica á matriz hessiana asociada
	  ao vector <math>n</math>-dimensional <argname>b</argname>,
	  e á función obxectivo que se especifique mediante o argumento
	  <argname>fcall</argname>. A chamada á función debe de ter
	  <argname>b</argname> como primeiro argumento (ben directamente
	  ou ben en forma de punteiro), seguido de calquera argumento
	  adicional que poida ser necesario, e debe devolver como
	  resultado un escalar. Ao completarse con éxito <lit>numhess</lit>
	  devolve unha matriz <by r="n" c="n"/> que contén a hessiana,
	  e que é exactamente simétrica por construción.
	</para>
	<para>
	  O método utiliza a extrapolación de Richardson, con catro pasos.
	  Podes usar o terceiro argumento (opcional) para establecer a
	  fracción <math>d</math> do valor do parámetro que se utiliza
	  para determinar o tamaño do paso inicial. Cando omites este
	  argumento, por defecto vai ser <math>d</math> = 0.01.
	</para>
	<para>
	  Aquí tes un exemplo do seu uso:
	</para>
	<code>
	  matrix H = numhess(theta, myfunc(&amp;theta, X))
	</code>
	<para>
	  <seelist>
            <fncref targ="BFGSmax"/>
	          <fncref targ="fdjac"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="obs" section="data-utils" output="series">
      <description>
	<para>
	  Devolve unha serie de números enteiros consecutivos, correspondendo o
	  1 co comezo do conxunto de datos. Ten en conta que o resultado non vai
	  depender de que teñas escollida unha submostra. Esta función é útil
	  especialmente con conxuntos de datos de series temporais. Advertencia:
	  Podes escribir <lit>t</lit> en vez de <lit>obs</lit>, co mesmo efecto.
	</para>
	<para>
	  <seelist>
            <fncref targ="obsnum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="obslabel" section="data-utils" output="string">
      <fnargs>
	<fnarg type="int">t</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve o marcador da observación <argname>t</argname>, sendo
	  <argname>t</argname> un número enteiro positivo que representa
	  a esa observación. A operación inversa pódese facer mediante a
	  función <fncref targ="obsnum"/>.
	</para>
      </description>
    </function>

    <function name="obsnum" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve o número enteiro que indica a observación que se corresponde
	  coa cadea do argumento <math>s</math>. Ten en conta que o resultado non
	  vai depender de que teñas escollida unha submostra. Esta función é útil
	  con conxuntos de datos de series temporais. Por exemplo, o seguinte código ...
	</para>
	<code>
	  open denmark
	  k = obsnum(1980:1)
	</code>
	<para>
	  ... xera <lit>k = 25</lit>, indicando que o primeiro trimestre de 1980
	  é a vixésimo quinta observación da base de datos <lit>denmark</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="obs"/>
            <fncref targ="obslabel"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ok" section="data-utils" output="seebelow">
      <fnargs>
	<fnarg type="anyfloat-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Cando o argumento <argname>x</argname> é un escalar, esta función
	  devolve 1 se <argname>x</argname> non é <lit>NA</lit>, e 0 noutro
	  caso. Cando <argname>x</argname> é unha serie, devolve outra serie que
	  toma o valor 1 nas observacións nas que o argumento non ten valores
	  ausentes, e toma o valor cero nos demais. Se <argname>x</argname> é
	  unha lista, o resultado é unha serie con 0 nas observacións nas que
	  ao menos unha serie da lista ten un valor ausente, e 1 noutro caso.
	</para>
	<para>
	  Cando o argumento <argname>x</argname> é unha matriz,
	  a función devolve outra matriz da mesma dimensión que
	  <argname>x</argname>, co valor 1 nas posicións que se corresponden
	  con elementos finitos de <argname>x</argname>, e co valor 0 nas
	  posicións nas que os elementos non son finitos (ou ben infinitos, ou ben
	  <quote>non números</quote>, para o estándar IEEE 754).
	</para>
	<para>
	  <seelist>
            <fncref targ="missing"/>
            <fncref targ="misszero"/>
            <fncref targ="zeromiss"/>
	  </seelist>
	  Pero ten en conta que estas funcións non son aplicables a matrices.
	</para>
      </description>
    </function>

    <function name="onenorm" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devolve un escalar coa norma 1 da matriz <argname>X</argname>,
	  é dicir, o máximo dos resultados de sumar os valores absolutos dos
	  elementos de <argname>X</argname> por columnas.
	</para>
	<para context="tex">
	  Devolve un escalar coa norma 1 da matriz
	  <argname>X</argname> de orde $r \times c$:
	  \[\| X \|_1 = \max_j \sum_{i=1}^r |X_{ij}| \]
	</para>
	<para>
	  <seelist>
            <fncref targ="infnorm"/>
            <fncref targ="rcond"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ones" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg optional="true" type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz con <math>r</math> filas e <math>c</math>
	  columnas, cuberta con valores iguais a 1. Se o omites, o número
	  de columnas establécese en 1 (vector columna), por defecto.
	</para>
	<para>
	  <seelist>
            <fncref targ="seq"/>
            <fncref targ="zeros"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="orthdev" section="transforms" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Aplícase tan só se o conxunto vixente de datos ten unha estrutura
	  de panel, e devolve unha serie co cálculo das desviacións ortogonais
	  adiantadas para a variable <argname>y</argname>.
	</para>
	<para context="tex">
	  Aplícase tan só se o conxunto vixente de datos ten unha estrutura
	  de panel, e devolve unha serie co cálculo das desviacións ortogonais
	  adiantadas para a variable <argname>y</argname>, é dicir
	  \[ \tilde{y}_{i,t} =
	  \sqrt{ \frac{T_i - t}{T_i - t + 1}} \left( y_{i,t} -
	  \frac{1}{T_i - t} \sum_{s=t+1}^{T_i} y_{i,s} \right) \]
	</para>
	<para>
	  Algunhas veces se utiliza esta transformación en troques da
	  diferenciación para eliminar os efectos individuais dos datos de
	  panel. Por compatibilidade coas primeiras diferenzas, as desviacións
	  gárdanse adiantadas un paso da súa localización temporal verdadeira
	  (é dicir, o valor na observación <math>t</math> é a desviación que,
	  expresándoo de maneira estrita, pertence a <math>t</math> &minus; 1).
	  Deste xeito, pérdese a primeira observación en cada serie temporal,
	  non a derradeira.
	</para>
	<para>
	  <seelist>
            <fncref targ="diff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pdf" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <examples>
	<example>f1 = pdf(N, -2.5)</example>
	<example>f2 = pdf(X, 3, y)</example>
	<example>f3 = pdf(W, forma, escala, y)</example>
      </examples>
      <description>
	<para>
	  Calcula o valor da función de densidade de probabilidade, e devolve
	  un resultado (do mesmo tipo ca o argumento) coa densidade en
	  <argname>x</argname> da distribución identificada polo código
	  <argname>d</argname>. Consulta <fncref targ="cdf"/> para obter máis
	  detalles acerca dos argumentos (escalares) esixidos. Esta función
	  <lit>pdf</lit> acepta as distribucións: Normal, <math>t</math> de
	  Student, Khi-cadrado, <math>F</math>, Gamma, Beta, Exponencial, Weibull,
	  Laplace, Erro Xeneralizado, Binomial e Poisson. Cae na conta de que
	  para a Binomial e a Poisson, o que se calcula de feito é a masa de
	  probabilidade no punto especificado. Para <math>t</math> de Student,
	  Khi-cadrado e <math>F</math> tamén están dispoñibles as súas
	  variantes non centrales.
	</para>
	<para>
	  Para a distribución Normal, consulta tamén <fncref targ="dnorm"/>.
	</para>
      </description>
    </function>

    <function name="pergm" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg optional="true" type="scalar">anchobanda</fnarg>
      </fnargs>
      <description>
	<para>
	  Se só indicas a serie ou vector do primeiro argumento, calcúlase o seu
	  periodograma na mostra. Se indicas o escalar do segundo argumento,
	  calcula a estimación do espectro de <argname>x</argname> cunha xanela
	  de retardos de Bartlett cun ancho de banda igual a ese escalar, ata un
	  máximo igual á metade do número de observacións (<math>T</math>/2).
	</para>
	<para>
	  Devolve unha matriz con <math>T</math>/2 filas e dúas columnas: a
	  primeira destas ten a frecuencia (&omega;) desde 2&pi;/<math>T</math>
	  ata &pi;, e a segunda das columnas contén a densidade espectral
	  correspondente.
	</para>
      </description>
    </function>

    <function name="pexpand" section="data-utils" output="series">
      <fnargs>
	<fnarg type="vector">v</fnarg>
      </fnargs>
      <description>
	<para>
	  Aplícase tan só se o conxunto vixente de datos ten unha estrutura
	  de panel, e realiza a operación inversa de <fncref targ="pshrink"/>.
	  É dicir, dado un vector que ten unha lonxitude igual ao número de
	  elementos da mostra (de panel) vixente seleccionada, esta
	  función devolve unha serie na cal cada valor do argumento repítese
	  <math>T</math> veces, onde <math>T</math> expresa a lonxitude
	  temporal do panel. Deste xeito, a serie resultante é invariante en
	  relación ao tempo.
	</para>
      </description>
    </function>

    <function name="pmax" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">máscara</fnarg>
      </fnargs>
      <description>
	<para>
	  Aplícase tan só se o conxunto vixente de datos ten unha estrutura de
	  panel, e devolve unha serie que contén cada un dos valores máximos
	  da variable <argname>y</argname> en cada unidade de corte transversal
	  (repetíndoo nos períodos temporais de cada unha destas).
	</para>
	<para>
	  Cando indicas o segundo argumento (opcional), vanse ignorar aquelas
	  observacións nas que o valor de <argname>máscara</argname> sexa igual a
	  cero.
	</para>
	<para>
	  <seelist>
            <fncref targ="pmin"/>
            <fncref targ="pmean"/>
            <fncref targ="pnobs"/>
            <fncref targ="psd"/>
            <fncref targ="pxsum"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pmean" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">máscara</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Aplícase tan só se o conxunto vixente de datos ten unha estrutura de
	  panel, e devolve unha serie que contén cada unha das medias temporais
	  da variable <argname>y</argname> en cada unidade de corte transversal
	  (repetindo cada valor nos períodos temporais de cada unha destas).
	  As observacións ausentes ignóranse no cálculo das medias.
	</para>
	<para context="tex">
	  Aplícase tan só se o conxunto vixente de datos ten unha estrutura de
	  panel, e devolve unha serie que contén cada unha das medias temporais
	  da variable <argname>y</argname> en cada unidade de corte transversal,
	  é dicir, \[ \bar{y}_i = \frac{1}{T_i} \sum_{t=1}^{T_i} y_{i,t}\]
	  onde $T_i$ representa o número de observacións válidas da unidade
	  $i$.
	</para>
	<para>
	  Cando indicas o segundo argumento (opcional), vanse ignorar aquelas
	  observacións nas que o valor de <argname>máscara</argname> sexa igual a
	  cero.
	</para>
	<para>
	  <seelist>
            <fncref targ="pmax"/>
            <fncref targ="pmin"/>
            <fncref targ="pnobs"/>
            <fncref targ="psd"/>
            <fncref targ="pxsum"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pmin" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">máscara</fnarg>
      </fnargs>
      <description>
	<para>
	  Aplícase tan só se o conxunto vixente de datos ten unha estrutura de
	  panel, e devolve unha serie que contén cada un dos valores mínimos
	  da variable <argname>y</argname> en cada unidade de corte transversal
	  (repetindo cada valor nos períodos temporais de cada unha destas).
	</para>
	<para>
	  Cando indicas o segundo argumento (opcional), vanse ignorar aquelas
	  observacións nas que o valor de <argname>máscara</argname> sexa igual a
	  cero.
	</para>
	<para>
	  <seelist>
            <fncref targ="pmax"/>
            <fncref targ="pmean"/>
            <fncref targ="pnobs"/>
            <fncref targ="psd"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pnobs" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">máscara</fnarg>
      </fnargs>
      <description>
	<para>
	  Aplícase tan só se o conxunto vixente de datos ten unha estrutura de
	  panel, e devolve unha serie que contén o número de observacións
	  válidas da variable <argname>y</argname> en cada unidade de corte
	  transversal (repetíndoo nos períodos temporais de cada unha destas).
	</para>
	<para>
	  Cando indicas o segundo argumento (opcional), vanse ignorar aquelas
	  observacións nas que o valor de <argname>máscara</argname> sexa igual a
	  cero.
	</para>
	<para>
	  <seelist>
            <fncref targ="pmax"/>
            <fncref targ="pmin"/>
            <fncref targ="pmean"/>
            <fncref targ="psd"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="polroots" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="vector">a</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz coas raíces dun polinomio. Se o polinomio é
	  de grao <math>p</math>, o vector <argname>a</argname> debe de
	  conter <math>p</math> + 1 coeficientes en orde ascendente; é
	  dicir, comezando coa constante e finalizando co coeficiente de
	  <math>x</math><sup>p</sup>.
	</para>
	<para>
	  Se todas as raíces son reais, vanse devolver nun vector columna de
	  dimensión <math>p</math>; noutro caso, devólvese unha matriz de orde
	  <by r="p" c="2"/>, coas partes reais na primeira columna e as partes
	  imaxinarias na segunda.
	</para>
      </description>
    </function>

    <function name="polyfit" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int">q</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha serie, axustando unha tendencia polinómica de orde
	  <argname>q</argname> á serie do argumento <argname>y</argname>,
	  utilizando o método de polinomios ortogonais. A serie que se xera
	  contén os valores axustados.
	</para>
      </description>
    </function>

    <function name="princomp" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">p</fnarg>
	<fnarg optional="true" type="bool">matrizcov</fnarg>
      </fnargs>
      <description>
	<para>
	  Sexa <argname>X</argname> unha matriz de orde <by r="T" c="k"/>,
	  que contén <math>T</math> observacións sobre <math>k</math>
	  variables. O argumento <argname>p</argname> debe de ser un número
	  enteiro positivo menor que ou igual a <math>k</math>. Esta función
	  devolve unha matriz <math>P</math>, de orde <by r="T" c="p"/>,
	  que contén as <math>p</math> primeiras compoñentes principais de
	  <argname>X</argname>.
	</para>
	<para>
	  O terceiro argumento (opcional) opera coma un conmutador booleano:
	  se non é cero, as compoñentes principais calcúlanse en base á matriz
	  de varianzas-covarianzas das columnas de <argname>X</argname>
	  (por defecto utilízase a matriz de correlacións).
	</para>
	<para context="notex">
	  Os elementos da matriz <math>P</math> que se devolve, calcúlanse
	  como a suma desde <math>i</math> ata <math>k</math> de
	  <math>Z</math><sub>ti</sub> veces <math>v</math><sub>ji</sub>,
	  onde <math>Z</math><sub>ti</sub> representa o valor
	  estandarizado (ou simplemente o valor centrado, se utilizas a matriz
	  de covarianzas) da variable <math>i</math> na observación
	  <math>t</math>, e <math>v</math><sub>ji</sub> representa o
	  <math>j</math>-ésimo autovector da matriz de correlacións (ou a
	  matriz de covarianzas) entre as <math>X</math><sub>i</sub>s, cos
	  autovectores ordenados de acordo cos valores decrecentes dos
	  autovalores correspondentes.
	</para>
	<para context="tex">
	  Os elementos da matriz $P$ que se devolve, calcúlanse como
	  \[ P_{tj} = \sum_{i=1}^{k} Z_{ti} \, v^{(j)}_i \]
	  onde $Z_{ti}$ representa o valor estandarizado (ou simplemente
	  o valor centrado, se utilizas a matriz de covarianzas) da variable $i$
	  na observación $t$, $Z_{ti} = (X_{ti} - \bar{X}_i) / \hat{\sigma}_i$,
	  e $v^{(j)_i}$ representa o $j$-ésimo autovector da matriz de
	  correlacións (ou de covarianzas) dos $X_i$s, cos autovectores
	  ordenados de acordo cos valores decrecentes dos autovalores
	  correspondentes.
	</para>
	<para>
	  <seelist>
            <fncref targ="eigensym"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="prodc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector fila co produto dos elementos das columnas de
	  <argname>X</argname>.
	  <seelist>
            <fncref targ="prodr"/>
            <fncref targ="meanc"/>
            <fncref targ="sdc"/>
            <fncref targ="sumc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="prodr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector columna co produto dos elementos das filas de
	  <argname>X</argname>.
	  <seelist>
            <fncref targ="prodc"/>
            <fncref targ="meanr"/>
            <fncref targ="sumr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="psd" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">máscara</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Aplícase tan só se o conxunto vixente de datos ten unha estrutura de
	  panel, e devolve unha serie que contén a desviación padrón (na mostra)
	  da variable <math>y</math> en cada unidade de corte transversal
	  (repetindo cada valor nos períodos temporais de cada unha destas).
	  O denominador que se utiliza é o tamaño da mostra en cada unidade
	  menos 1, agás que só haxa 1 única observación válida para unha
	  unidade dada (pois neste caso devólvese 0) ou que non haxa ningunha
	  (neste caso devólvese <lit>NA</lit>).
	</para>
	<para context="tex">
	  Aplícase tan só se o conxunto vixente de datos ten unha estrutura de
	  panel, e devolve unha serie que contén a desviación padrón (na mostra)
	  da variable <math>y</math> en cada unidade de corte transversal, é dicir,
	  \[ \sigma_i = \sqrt{\frac{1}{T_i - 1} \sum_{t=1}^{T_i} (y_{i,t} -
	  \bar{y}_i)^2 } \]. Esta fórmula aplícase cando $T_i \ge 2$, onde
	  $T_i$ representa o número de observacións válidas para a unidade
	  $i$; se $T_i = 0$ devólvese <lit>NA</lit>, e se $T_i = 1$
	  devólvese 0.
	</para>
	<para>
	  Cando indicas o segundo argumento (opcional), vanse ignorar aquelas
	  observacións nas que o valor de <argname>máscara</argname> sexa igual a
	  cero.
  </para>
	<para>
	  Nota: Esta función permite comprobar se unha variable calquera
	  (por exemplo, <lit>X</lit>) é invariante ao longo do tempo,
	  por medio da condición <lit>max(psd(X)) == 0</lit>.
	</para>
	<para>
		<seelist>
            <fncref targ="pmax"/>
            <fncref targ="pmin"/>
            <fncref targ="pmean"/>
            <fncref targ="pnobs"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="psdroot" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="symmat">A</fnarg>
	<fnarg type="bool" optional="true">probapsd</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve a matriz cadrada que resulta de aplicarlle á matriz simétrica
	  <argname>A</argname> do argumento, unha variante xeneralizada da
	  descomposición de Cholesky. A matriz do argumento debe de ser
	  semidefinida positiva (aínda que pode ser singular) pero, se non é
	  cadrada, amósase unha mensaxe de fallo. A simetría asúmese e non se
	  comproba; só se le o triángulo inferior de <argname>A</argname>.
	  O resultado é unha matriz triangular inferior, <math>L</math>, que
	  cumpre <equation status="inline" ascii="A = LL'" tex="$A = LL'$"/>.
	  Os elementos indeterminados da solución establécense como iguais a cero.
	</para>
	<para>
	  Para forzar a comprobación de que <argname>A</argname> é semidefinida
	  positiva, indica un valor non nulo para o segundo argumento (opcional).
	  Nese caso, amósase un fallo se o máximo valor absoluto de
	  <equation status="inline" ascii="A &minus; LL'" tex="$A - LL'$"/>
	  pasa de 1.0e-8. Este tipo de comprobación tamén podes facela
	  manualmente:
	</para>
	<code>
	  L = psdroot(A)
	  chk = maxc(maxr(abs(A - L*L')))
	</code>
	<para>
	  Para o caso no que a matriz <argname>A</argname> é definida positiva,
	  consulta <fncref targ="cholesky"/>.
	</para>
      </description>
    </function>

    <function name="pshrink" section="data-utils" output="matrix">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Aplícase tan só se o conxunto vixente de datos ten unha estrutura de
	  panel, e devolve un vector que contén cada unha das primeiras
	  observacións válidas da serie <argname>y</argname> en cada unidade
	  de corte transversal do panel, ao longo do rango da mostra vixente.
	  Se a serie ten algunha unidade sen observacións válidas, esa
	  unidade ignórase.
	</para>
	<para>
	  Esta función te proporciona un xeito de compactar as series que
	  te van devolver algunhas funcións tales como <fncref targ="pmax"/>
	  e <fncref targ="pmean"/>, nas que se repite un mesmo valor nos
	  diferentes períodos de tempo dunha mesma unidade de corte
	  transversal.
	</para>
	<para>
	  Consulta <fncref targ="pexpand"/> para a operación inversa.
	</para>
      </description>
    </function>

    <function name="psum" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">máscara</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Aplícase tan só se o conxunto vixente de datos ten unha estrutura de
	  panel, e devolve unha serie na que cada valor é a suma da variable
	  <argname>y</argname> nos distintos períodos temporais de cada unidade
	  de corte transversal. En cada unha destas, a suma así calculada se
	  repite para cada período temporal. As observacións ausentes ignóranse
	  no cálculo das sumas.
	</para>
	<para context="tex">
	  Aplícase tan só se o conxunto vixente de datos ten unha estrutura de
	  panel, e devolve unha serie na que cada valor é a suma da variable
	  <argname>y</argname> nos distintos períodos temporais de cada unidade
	  de corte transversal, é dicir, \[ S_i = \sum_{t=1}^{T_i} y_{i,t}\]
	  onde $T_i$ indica o número de observacións válidas da unidade $i$.
	</para>
	<para>
	  Cando indicas o segundo argumento (opcional), vanse ignorar aquelas
	  observacións nas que o valor de <argname>máscara</argname> sexa igual a
	  cero.
	</para>
	<para>
	  <seelist>
            <fncref targ="pmax"/>
            <fncref targ="pmean"/>
            <fncref targ="pmin"/>
            <fncref targ="pnobs"/>
            <fncref targ="psd"/>
            <fncref targ="pxsum"/>
            <fncref targ="pshrink"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pvalue" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="char">c</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <examples>
	<example>p1 = pvalue(z, 2.2)</example>
	<example>p2 = pvalue(X, 3, 5.67)</example>
	<example>p2 = pvalue(F, 3, 30, 5.67)</example>
      </examples>
      <description>
	<para>
	  Calcula valores <math>P</math> de probabilidade, e devolve un
	  resultado (do mesmo tipo ca o argumento) coa probabilidade
	  <equation status="inline" ascii="P(X > x)" tex="$P(X > x)$"/>, onde
	  a distribución de probabilidade de <math>X</math> indícase coa letra
	  <argname>c</argname>. Entre os argumentos <argname>d</argname> e
	  <argname>p</argname>, podes necesitar algún argumento adicional
	  escalar para especificar os parámetros da distribución de que se
	  trate. Para máis detalles, consulta <fncref targ="cdf"/>. As
	  distribucións soportadas pola función <lit>pvalue</lit> son:
	  Normal estándar, <math>t</math>, Khi-cadrado, <math>F</math>, Gamma,
	  Binomial, Poisson, Exponencial, Weibull, Laplace e Erro Xeneralizado.
	</para>
	<para>
	  <seelist>
            <fncref targ="critical"/>
            <fncref targ="invcdf"/>
            <fncref targ="urcpval"/>
            <fncref targ="imhof"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pxnobs" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">máscara</fnarg>
      </fnargs>
      <description>
	<para>
	  Aplícase tan só se o conxunto vixente de datos ten unha estrutura de
	  panel, e devolve unha serie que contén o número de observacións
	  válidas de <argname>y</argname> en cada período de tempo (o valor
	  calculado repítese en cada unha das unidades de corte transversal).
	</para>
	<para>
	  Cando indicas o segundo argumento (opcional), vanse ignorar aquelas
	  observacións nas que o valor de <argname>máscara</argname> sexa igual a
	  cero.
	</para>
	<para>
	  Cae na conta de que esta función opera na outra dimensión do panel,
	  diferente á da función <fncref targ="pnobs"/>.
	</para>
      </description>
    </function>

    <function name="pxsum" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">máscara</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Aplícase tan só se o conxunto vixente de datos ten estrutura de panel,
	  e devolve unha serie na que cada valor é a suma de <argname>y</argname>
	  nas distintas unidades de corte transversal de cada período temporal.
	  As sumas así calculadas repítense en cada unidade de corte transversal.
	</para>
	<para context="tex">
	  Aplícase tan só se o conxunto vixente de datos ten estrutura de panel,
	  e devolve unha serie na que cada valor é a suma de <argname>y</argname>
	  nas distintas unidades de corte transversal de cada período temporal,
	  é dicir, \[ \tilde{y}_t = \sum_{i=1}^{N} y_{i,t}\] onde $N$ é o número
	  de unidades de corte transversal.
	</para>
	<para>
	  Cando indicas o segundo argumento (opcional), vanse ignorar aquelas
	  observacións nas que o valor de <argname>máscara</argname> sexa igual a
	  cero.
	</para>
	<para>
	  Cae na conta de que esta función opera na outra dimensión do panel,
	  diferente á da función <fncref targ="psum"/>.
	</para>
      </description>
    </function>

    <function name="qform" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">x</fnarg>
	<fnarg type="symmat">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devolve unha matriz co resultado de calcular a forma cuadrática
	  <equation status="inline" ascii="Y = xAx'" tex="$Y = x A x'$"/>.
	  Se a matriz simétrica <argname>A</argname> do argumento é de tipo
	  xenérico, cando utilizas esta función en vez da típica multiplicación
	  de matrices, garantes unha maior rapidez e mellor precisión. Porén, no
	  caso especial de que <argname>A</argname> sexa unha matriz
	  identidade, a simple expresión <lit>x'x</lit> resulta moito mellor ca
	  <lit>qform(x',I(rows(x))</lit>.
	</para>
	<para context="tex">
	  Devolve unha matriz co resultado de calcular a forma cuadrática
	  <equation status="inline" ascii="Y = xAx'" tex="$Y = x A x'$"/>.
	  Se a matriz simétrica <argname>A</argname> do argumento é de tipo
	  xenérico, cando utilizas esta función en vez da típica multiplicación
	  de matrices, garantes unha maior rapidez e mellor precisión. Porén, no
	  caso especial <equation status="inline" ascii="A = I" tex="$A = I$"/>,
	  a simple expresión <lit>x'x</lit> resulta moito mellor ca
	  <lit>qform(x',I(rows(x))</lit>.
	</para>
	<para>
	Se <argname>x</argname> e <argname>A</argname> non son matrices
	conformables, ou se <argname>A</argname> non é simétrica, a función
	devolve un fallo.
	</para>
      </description>
    </function>

    <function name="qlrpval" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="scalar">X2</fnarg>
	<fnarg type="int">df</fnarg>
	<fnarg type="scalar">p1</fnarg>
	<fnarg type="scalar">p2</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar coa probabilidade asociada (<math>P</math>) ao valor
	  do estatístico para facer a proba LR de Quandt (ou sup-Wald) de cambio
	  estrutural nun punto descoñecido (consulta <cmdref targ="qlrtest"/>),
	  segundo <cite key="hansen97">Bruce Hansen (1997)</cite>.
	</para>
	<para>
	  O primeiro argumento, <argname>X2</argname>, indica o valor do
	  estatístico de proba de Wald máximo (en formato khi-cadrado), e o
	  segundo, <argname>df</argname>, indica os seus graos de liberdade.
	  O terceiro e o cuarto argumentos, representan os puntos de comezo e
	  de remate do rango central de observacións sobre o que se van calcular
	  os sucesivos estatísticos de Wald das probas, e debes expresalos como
	  fraccións decimais en relación ao rango total de estimación. Por
	  exemplo, se queres adoptar o enfoque estándar de recorte do 15 por
	  cento, debes de establecer <argname>p1</argname> igual a 0.15 e
	  <argname>p2</argname> igual a 0.85.
	</para>
	<para>
	  <seelist>
            <fncref targ="pvalue"/>
	    <fncref targ="urcpval"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="qnorm" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) cos cuantís dunha
	  Normal estándar que se corresponden con cada valor do argumento. Se
	  <argname>x</argname> non está entre 0 e 1, devólvese <lit>NA</lit>.
	  <seelist>
            <fncref targ="cnorm"/>
            <fncref targ="dnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="qrdecomp" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;R</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz co cálculo da descomposición QR dunha matriz
	  <argname>X</argname> de orde <by r="m" c="n"/>; é dicir,
	  <math>X = QR</math> onde <math>Q</math> é unha matriz <by r="m" c="n"/>
	  ortogonal, e <math>R</math> é unha matriz <by r="n" c="n"/> triangular
	  superior. A matriz <math>Q</math> devólvese directamente, mentres que
	  podes obter <math>R</math> mediante o segundo argumento (opcional).
	</para>
	<para>
	  <seelist>
            <fncref targ="eigengen"/>
            <fncref targ="eigensym"/>
            <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="quadtable" section="stats" output="matrix">
      <fnargs>
	<fnarg type="int">n</fnarg>
	<fnarg type="int" optional="true">tipo</fnarg>
	<fnarg type="scalar" optional="true">a</fnarg>
	<fnarg type="scalar" optional="true">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz <by r="n" c="2"/> para utilizar coa cuadratura
	  Gaussiana (en integración numérica). A primeira columna contén os
	  nodos ou abscisas, e a segunda as ponderacións.
	</para>
	<para>
	  O primeiro argumento especifica o número de puntos (filas) que se
	  van calcular. O segundo argumento codifica o tipo de cuadratura:
	  utiliza 1 para a Gauss&ndash;Hermite (a establecida por defecto);
	  2 para a Gauss&ndash;Legendre; ou 3 para a Gauss&ndash;Laguerre.
	  O sentido dos parámetros <argname>a</argname> e <argname>b</argname>
	  (opcionais) depende do <argname>type</argname> seleccionado,
	  como se explica deseguido.
	</para>
	<para context="notex">
	  A cuadratura Gaussiana é un método para aproximar numericamente a
	  integral definida de algunha función que te interese. Supoñamos que a
	  función se representa mediante o produto <math>f(x)W(x)</math>.
	  Os distintos tipos de cuadratura difiren na especificación da
	  compoñente <math>W(x)</math>: no caso da Hermite isto é igual a
	  exp(&minus;<math>x</math><sup>2</sup>); no caso da Laguerre é
	  igual a exp(&minus;<math>x</math>); e no caso da Legendre simplemente
	  é <math>W(x)</math> = 1.
	</para>
	<para context="tex">
	  A cuadratura Gaussiana é un método para aproximar numericamente a
	  integral definida de algunha función que te interese. Supoñamos que a
	  función se representa mediante o produto $f(x)W(x)$. Os distintos
	  tipos de cuadratura difiren na especificación da compoñente $W(x)$:
	  no caso da Hermite temos $W(x) = \exp(-x^2)$; no caso da Laguerre,
	  $W(x) = \exp(-x)$; e no caso da Legendre temos simplemente
	  $W(x) = 1$.
	</para>
	<para context="notex">
	  Para cada especificación de <math>W</math>, pode calcularse un
	  conxunto de nodos (<math>x</math><sub>i</sub>) e un conxunto de
	  ponderacións (<math>w</math><sub>i</sub>), de tal xeito que a suma
	  desde <math>i</math>=1 ata <math>n</math> de
	  <math>w</math><sub>i</sub>
	  <math>f</math>(<math>x</math><sub>i</sub>) vaise aproximar á
	  integral desexada. Para isto vaise utilizar o método de
	  <cite key="golub69">Golub e Welsch (1969)</cite>.
	</para>
	<para context="tex">
	  Para cada especificación de $W(x)$, pode calcularse un conxunto de
	  nodos ($x_i$) e un conxunto de ponderacións ($w_i$), de tal xeito que
	  $\sum_{i=1}^n f(x_i) w_i$ vaise aproximar á integral desexada. Vaise
	  usar o método de <cite key="golub69">Golub e Welsch (1969)</cite>.
	</para>
	<para context="notex">
	  Cando se selecciona o tipo de Gauss&ndash;Legendre, podes utilizar
	  os argumentos opcionais <argname>a</argname> e <argname>b</argname>
	  para controlar os límites inferior e superior da integración, sendo
	  neste caso os valores por defecto &minus;1 e 1. (Na cuadratura
	  de Hermite, os límites están fixados en menos e máis infinito;
	  mentres que no caso da cuadratura de Laguerre, están fixados en 0
	  e infinito.)
	</para>
	<para context="tex">
	  Cando se selecciona o tipo de Gauss&ndash;Legendre, podes utilizar
	  os argumentos opcionais <argname>a</argname> e <argname>b</argname>
	  para controlar os límites inferior e superior da integración, sendo
	  neste caso os valores por defecto $-1$ e 1. (Na cuadratura
	  de Hermite, os límites están fixados en $-\infty$ e $+\infty$;
	  mentres que no caso de Laguerre, están fixados en 0 e $\infty$.)
	</para>
	<para context="notex">
	  No caso de Hermite, <argname>a</argname> e <argname>b</argname>
	  xogan papeis diferentes: poden utilizarse para substituír a forma
	  por defecto de <math>W</math>(<math>x</math>) pola distribución
	  Normal de probabilidade con media <argname>a</argname> e desviación
	  padrón <argname>b</argname> (coa que está estreitamente emparentada).
	  Por exemplo, se indicas os valores 0 e 1 para estes parámetros,
	  respectivamente, vas provocar que <math>W</math>(<math>x</math>)
	  sexa a función de densidade de probabilidade Normal estándar; o
	  que é equivalente a multiplicar os nodos por defecto pola raíz
	  cadrada de dous, e dividir as ponderacións pola raíz cadrada de
	  &pi;.
	</para>
	<para context="tex">
	  No caso de Hermite, <argname>a</argname> e <argname>b</argname>
	  xogan papeis diferentes: poden utilizarse para substituír a forma
	  por defecto de $W(x)$ pola distribución Normal de probabilidade con
	  media <argname>a</argname> e desviación padrón <argname>b</argname>
	  (coa que está estreitamente emparentada). Por exemplo, se indicas
	  os valores 0 e 1 para estes parámetros, respectivamente, vas
	  provocar que $W(x)$ sexa a función de densidade de probabilidade
	  Normal estándar; o que é equivalente a multiplicar os valores
	  $x_i$ por defecto por $\sqrt{2}$, e dividir as ponderacións por defecto
	  $w_i$ por $\sqrt{\pi}$.
	</para>
      </description>
    </function>

    <function name="quantile" section="stats" output="scalar" altout="matrix">
      <fnargs>
	<fnarg type="series-or-mat">y</fnarg>
	<fnarg type="pscalar">p</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>y</argname> é unha serie, devolve un escalar que
	  representa o cuantil <argname>p</argname> da mesma. Por exemplo,
	  cando <math>p</math> = 0.5, devólvese a mediana.
	</para>
	<para>
	  Se <argname>y</argname> é unha matriz, devolve un vector fila que
	  contén os <argname>p</argname> cuantís das diferentes columnas
	  de <argname>y</argname>; é dicir, cada unha das súas columnas
	  trátase como una serie.
	</para>
	<para>
	  Amais, para unha matriz <argname>y</argname> admítese unha forma
	  alternativa do segundo argumento: podes indicar <argname>p</argname>
	  coma un vector. Nese caso, o valor que se te devolve é unha matriz
	  de orde <by r="m" c="n"/>, na que <repl>m</repl> indica o número de
	  elementos de <argname>p</argname> e <repl>n</repl> indica o número
	  de columnas de <argname>y</argname>.
	</para>
	<para context="tex">
	  Para unha serie de longura $n$, $q$ é o cuantil $p$ se cumpre a
	  igualdade:
	  \[q = y_{[k]} + [(n+1) \cdot p - k] (y_{[k+1]} - y_{[k]})\]
	  onde $k$ é a parte enteira de $(n+1) \cdot p$, e $y_{[i]}$
	  é o elemento $i$-ésimo da serie cando se ordena de menor a
	  maior.
	</para>
      </description>
    </function>

    <function name="randgen" section="probdist" output="series">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="scalar-or-series">p1</fnarg>
	<fnarg type="scalar-or-series" conditional="true">p2</fnarg>
	<fnarg type="scalar" conditional="true">p3</fnarg>
      </fnargs>
      <examples>
	<example>series x = randgen(u, 0, 100)</example>
	<example>series t14 = randgen(t, 14)</example>
	<example>series y = randgen(B, 0.6, 30)</example>
	<example>series g = randgen(G, 1, 1)</example>
	<example>series P = randgen(P, mu)</example>
      </examples>
      <description>
	<para>
	  Devolve unha serie calculada cun xerador universal de números
	  aleatorios. O argumento <argname>d</argname> é unha cadea de texto
	  (que xeralmente está formada por un só carácter) que permite
	  especificar o tipo de distribución de probabilidade da que se extraen
	  os números pseudoaleatorios. Os argumentos de <argname>p1</argname>
	  a <argname>p3</argname> especifican os parámetros da distribución
	  escollida, e o número destes parámetros depende desa distribución.
	  Para outras distribucións diferentes á Beta-Binomial, os parámetros
	  <argname>p1</argname> e (caso de ser aplicable) <argname>p2</argname>
	  podes indicalos en formato de escalar ou de serie. Cando os utilizas
	  en formato escalar, a serie que resulta procede de distribucións
	  identicamente distribuídas. Cando utilizas series para os argumentos
	  <argname>p1</argname> ou <argname>p2</argname>, a serie resultante
	  procede de distribucións condicionadas ao valor dos parámetros en
	  cada observación. No caso da Beta-Binomial, todos os parámetros
	  deben de ser escalares.
	</para>
	<para>
	  A continuación indícanse detalles máis específicos: o código de
	  texto para cada tipo de distribución móstrase entre parénteses,
	  seguido da interpretación do argumento <argname>p1</argname> e,
	  cando é aplicable, da interpretación de <argname>p2</argname> e
	  <argname>p3</argname>.
	</para>

	<ilist context="notex">
	  <li>
            <para>
              Uniforme (continua) (u ou U): mínimo, máximo
            </para>
	  </li>
	  <li>
            <para>
              Uniforme (discreta) (i): mínimo, máximo
            </para>
	  </li>
	  <li>
            <para>
              Normal (z, n ou N): media, desviación padrón
            </para>
	  </li>
	  <li>
            <para>
              t de Student (t): graos de liberdade
            </para>
	  </li>
	  <li>
            <para>
              Khi-cadrado (c, x ou X): graos de liberdade
            </para>
	  </li>
	  <li>
            <para>
              F de Snedecor (f ou F): graos de liberdade (num.), graos de liberdade (den.)
            </para>
	  </li>
	  <li>
            <para>
              Gamma (g ou G): forma, escala
            </para>
	  </li>
	  <li>
            <para>
              Binomial (b ou B): probabilidade, cantidade de ensaios
            </para>
	  </li>
	  <li>
            <para>
              Poisson (p ou P): media
            </para>
	  </li>
	  <li>
            <para>
              Exponencial (exp): escala
            </para>
	  </li>
	  <li>
            <para>
              Loxística (lgt ou s): posición, escala
            </para>
	  </li>
	  <li>
            <para>
              Weibull (w ou W): forma, escala
            </para>
	  </li>
	  <li>
            <para>
              Laplace (l ou L): media, escala
            </para>
	  </li>
	  <li>
            <para>
              Erro Xeneralizado (E): forma
            </para>
	  </li>
	  <li>
            <para>
              Beta (beta): forma1, forma2
            </para>
	  </li>
	  <li>
            <para>
              Beta-Binomial (bb): ensaios, forma1, forma2
            </para>
	  </li>
	</ilist>
	<tabular colspec="lllll">
	  \textbf{Distribución} &amp; \textsl{d} &amp; \textsl{p1} &amp; \textsl{p2} &amp; \textsl{p3}\\[4pt]
	  Uniforme (continua) &amp; \texttt{u} ou \texttt{U} &amp; mínimo &amp; máximo &amp; --\\
	  Uniforme (discreta) &amp; \texttt{i} &amp; mínimo &amp; máximo &amp; --\\
	  Normal &amp; \texttt{z}, \texttt{n} ou \texttt{N} &amp; media &amp; desviación padrón &amp; --\\
	  $t$ de Student &amp; \texttt{t} &amp; graos de liberdade &amp; -- &amp; --\\
	  Khi-cadrado &amp; \texttt{c}, \texttt{x} ou \texttt{X} &amp; graos de liberdade &amp; -- &amp; --\\
	  $F$ de Snedecor &amp; \texttt{f} ou \texttt{F} &amp; gl (num.) &amp; gl (den.) &amp; --\\
	  Gamma &amp; \texttt{g} ou \texttt{G} &amp; forma &amp; escala  &amp; --\\
	  Binomial &amp; \texttt{b} ou \texttt{B} &amp; $p$ &amp; $n$  &amp; --\\
	  Poisson &amp; \texttt{p} ou \texttt{P} &amp; media &amp; --  &amp; --\\
	  Exponencial &amp; \texttt{exp} &amp; escala &amp; -- &amp; --\\
	  Loxística &amp; \texttt{s} &amp; posición &amp; escala &amp; --\\
	  Weibull &amp; \texttt{w} ou \texttt{W} &amp; forma &amp; escala &amp; --\\
	  Laplace &amp; \texttt{l} ou \texttt{L} &amp; media &amp; escala &amp; --\\
	  Erro Xeneralizado &amp; \texttt{E} &amp; forma &amp; -- &amp; --\\
	  Beta &amp; \texttt{beta} &amp; forma1 &amp; forma2 &amp; --\\
	  Beta-Binomial &amp; \texttt{bb} &amp; $n$ &amp; forma1 &amp; forma2
	</tabular>
	<para>
	  <seelist>
            <fncref targ="normal"/>
            <fncref targ="uniform"/>
            <fncref targ="mrandgen"/>
            <fncref targ="randgen1"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="randgen1" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="char">d</fnarg>
	<fnarg type="scalar">p1</fnarg>
	<fnarg type="scalar" conditional="true">p2</fnarg>
      </fnargs>
      <examples>
	<example>scalar x = randgen1(z, 0, 1)</example>
	<example>scalar g = randgen1(g, 3, 2.5)</example>
      </examples>
      <description>
	<para>
	  Funciona do mesmo xeito que <fncref targ="randgen"/> agás polo
	  feito de que devolve un escalar en troques dunha serie.
	</para>
	<para>
	  O primeiro exemplo de enriba devolve un valor extraído da distribución
	  Normal estándar, mentres que o segundo devolve un valor extraído da
	  distribución Gamma cun parámetro de forma igual a 3 e de escala a 2.5.
	</para>
	<para>
	  <seelist>
            <fncref targ="mrandgen"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="randint" section="probdist" output="int">
      <fnargs>
	<fnarg type="int">min</fnarg>
	<fnarg type="int">max</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un enteiro pseudoaleatorio no intervalo pechado
	  [<argname>min</argname>, <argname>max</argname>].
	  <seelist>
	    <fncref targ="randgen"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="randperm" section="probdist" output="vector">
      <fnargs>
	<fnarg type="int">n</fnarg>
	<fnarg type="int" optional="true">k</fnarg>
      </fnargs>
      <description>
	<para>
	  Se indicas só o primeiro argumento, devolve un vector fila que
	  contén unha permutación aleatoria dos números enteiros desde 1
	  ata ese valor <argname>n</argname>, sen repetición dos elementos.
	  Cando indiques o segundo argumento, deberá ser un número enteiro
	  positivo dentro do rango de 1 a <argname>n</argname>; nese caso
	  a función devolve un vector fila que contén <argname>k</argname>
	  número enteiros escollidos de xeito aleatorio desde 1 ata
	  <argname>n</argname>, sen substitución.
	</para>
	<para>
	  Se queres extraer unha mostra de <math>k</math> filas dunha matriz
	  <lit>X</lit> que ten <math>n</math> filas (e sen substitución), iso
	  podes conseguilo tal como se amosa debaixo:
	</para>
	<code>
	  matrix S = X[randperm(n, k),]
	</code>
	<para>
	  E se desexas manter a orde orixinal das filas na
	  mostra:
	</para>
	<code>
	  matrix S = X[sort(randperm(n, k)),]
	</code>
	<para>
	  Consulta tamén a función <fncref targ="resample"/> para repetir a
	  mostraxe, con substitución.
	</para>
      </description>
    </function>

    <function name="rank" section="linalg" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un enteiro co rango da matriz <argname>X</argname>, calculado
	  numericamente mediante a descomposición en valores singulares.
	  <seelist>
            <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ranking" section="stats" output="asinput">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha serie ou vector coas posicións xerárquicas dos valores
	  de <math>y</math>. A observación <math>i</math> ten unha posición
	  na xerarquía que ven determinada polo número de elementos que son
	  menores ca <math>y</math><sub>i</sub>, máis a metade do número
	  de elementos que son iguais a <math>y</math><sub>i</sub>.
	  (Intuitivamente, podes imaxinalo como a xerarquía nun torneo de
	  xadrez, no que cada vitoria supón conceder un punto ao gañador, e
	  cada empate supón conceder medio punto). Engádese un 1 de forma
	  que o número máis pequeno para unha posición é 1, e non 0.
	</para>
	<para context="tex">
	  Formalmente,
	  \[ \mathrm{rank}(y_i) = 1 + \sum_{j \ne i} \left[
	  I(y_j &lt; y_i) + 0.5 \cdot I(y_j = y_i) \right] \]
	  onde $I$ denota a función índice.
	</para>
	<para>
	  <seelist>
            <fncref targ="sort"/>
            <fncref targ="sortby"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="rcond" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co número de condición recíproco da matriz cadrada
	  <argname>A</argname> a respecto da norma 1. En moitos casos, este
	  mide de forma máis axeitada ca o determinante, a sensibilidade de
	  <argname>A</argname> ás operacións numéricas tales como a inversión.
	</para>
	<para context="notex">
	  O valor calcúlase como o inverso (ou recíproco) do resultado de
	  multiplicar a norma 1 da matriz cadrada <argname>A</argname>, pola
	  norma 1 da matriz inversa de <argname>A</argname>.
	</para>
	<para context="tex">
	  Dada unha matriz cadrada <math>A</math> non singular, pódese definir
	  \[\kappa(A) = ||A||_1 \cdot ||A^{-1}||_1\]
	  A función devolve $\kappa(A)^{-1}$.
	</para>
	<para>
	  <seelist>
            <fncref targ="det"/>
            <fncref targ="ldet"/>
            <fncref targ="onenorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="Re" section="complex" output="matrix">
      <fnargs>
	<fnarg type="cmatrix">C</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz real coa mesma dimensión que <argname>C</argname>,
	  e que contén a parte real da matriz dese argumento. Consulta
	  tamén <fncref targ="Im"/>.
	</para>
      </description>
    </function>

    <function name="readfile" section="strings" output="string">
      <fnargs>
	<fnarg type="string">nomeficheiro</fnarg>
	<fnarg type="string" optional="true">código</fnarg>
      </fnargs>
      <description>
	<para>
	  Se existe un ficheiro co nome do argumento <argname>nomeficheiro</argname>, e
	  pode lerse, a función devolve unha cadea de texto que inclúe o contido
	  dese ficheiro; noutro caso amosa un fallo. Se <argname>nomeficheiro</argname>
	  non indica unha especificación da ruta completa ao ficheiro, vaise
	  procurar en distintas localizacións <quote>probables</quote>, comezando
	  polo cartafol vixente nese momento, <cmdref targ="workdir"/>.
	</para>
	<para>
	  Se <argname>nomeficheiro</argname> comeza cun identificador dun protocolo
	  de internet que sexa admisible (<lit>http://</lit>, <lit>ftp://</lit>
	  ou <lit>https://</lit>), actívase unha orde a 'libcurl' para que
	  descargue o recurso. Para outras operacións de descarga máis
	  complicadas, consulta tamén <fncref targ="curl"/>.
	</para>
	<para>
	  Cando o texto que se quere ler non está codificado en UTF-8, Gretl vai
	  tratar de volver a codificalo desde o tipo vixente de codificación
	  local (se este non é UTF-8), ou desde ISO-8859-15 noutro caso. Se este
	  sinxelo funcionamento por defecto non cumpre coas túas necesidades,
	  podes usar o segundo argumento (opcional) para especificar un tipo de
	  codificación. Por exemplo, se queres ler texto que está no tipo de
	  páxina de código Microsoft 1251, e este non é o teu tipo de código
	  local, deberás de indicar <lit>"cp1251"</lit> como segundo argumento.
	</para>
    <para>
        Exemplos:
    </para>
    <code>
        string web_page = readfile("http://gretl.sourceforge.net/")
        print web_page

        string current_settings = readfile("@dotdir/.gretl2rc")
        print current_settings
    </code>
	<para>
	  Consulta tamén as funcións <fncref targ="sscanf"/> e
	  <fncref targ="getline"/>.
	</para>
      </description>
    </function>

    <function name="regsub" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg type="string">atopada</fnarg>
	<fnarg type="string">substit</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha cadea de texto cunha copia de <argname>s</argname> na
	  que todos os casos nos que ocorre o padrón <argname>atopada</argname>,
	  substitúense por <argname>substit</argname>. Os dous argumentos
	  <argname>atopada</argname> e <argname>substit</argname> interprétanse
	  como expresións regulares de estilo Perl.
	</para>
	<para>
	  Consulta tamén a función <fncref targ="strsub"/> para a substitución
	  simple de cadeas de texto.
	</para>
      </description>
    </function>

    <function name="remove" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">nomeficheiro</fnarg>
      </fnargs>
      <description>
	<para>
	  Elimina o ficheiro do argumento <argname>nomeficheiro</argname> no caso
	  de que este exista, e que o usuario o poda modificar. Esta función
	  devolve un enteiro igual a 0 no caso de que a operación teña éxito,
	  e un valor non nulo se o ficheiro non existe ou non se pode eliminar.
	</para>
	<para>
	  Cando <argname>fname</argname> contén o camiño completo ata o
	  ficheiro, Gretl tratará de eliminalo, e devolverá un fallo se ese
	  ficheiro non existe ou non pode eliminarse por algún motivo (por
	  exemplo, por non ter suficientes privilexios para poder facelo).
	  Cando <argname>fname</argname> non contén o camiño completo,
	  entón asúmese que o ficheiro ao que se refire, está no cartafol
	  vixente de traballo (<cmdref targ="workdir"/>). Se o ficheiro
	  non existe ou non pode gardarse, non se vai procurar en ningún
	  outro cartafol.
	</para>
      </description>
    </function>

    <function name="replace" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
	<fnarg type="scalar-or-vec">achar</fnarg>
	<fnarg type="scalar-or-vec">substit</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo de) <argname>x</argname> trocando os
	  seus elementos que sexan iguais ao elemento <math>i</math>-ésimo de
	  <argname>achar</argname> polo concordante de <argname>substit</argname>.
	</para>
	<para>
	  Cando o segundo argumento (<argname>achar</argname>) é un escalar, o
	  terceiro argumento (<argname>substit</argname>) tamén debe de ser un
	  escalar. Cando ambos son vectores, deben de ter o mesmo número de
	  elementos. Pero cando <argname>achar</argname> é un vector e
	  <argname>substit</argname> é un escalar, entón todas as coincidencias de
	  aquel substitúense en <argname>x</argname> por <argname>substit</argname>.
	</para>
	<para>
	  Exemplo:
	</para>
	<code>
	  a = {1,2,3;3,4,5}
	  acha = {1,3,4}
	  subst = {-1,-8, 0}
	  b = replace(a, acha, subst)
	  print a b
	</code>
	<para>
	  produce...
	</para>
	<code>
          a (2 x 3)

          1   2   3
          3   4   5

          b (2 x 3)

          -1    2   -8
          -8    0    5
	</code>
      </description>
    </function>

    <function name="resample" section="stats" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
	<fnarg optional="true" type="int">tamañobloque</fnarg>
	<fnarg optional="true" type="int">extraccions</fnarg>
      </fnargs>
      <description>
	<para>
	  A descrición inicial desta función refírese aos casos con datos
	  de corte transversal ou con series temporais; mira máis abaixo
	  para os casos con datos de panel.
	</para>
	<para>
	  Devolve o resultado (do tipo do argumento) que se obtén facendo unha
	  mostraxe por repetición de <argname>x</argname> con substitución. Se
	  o argumento é unha serie, cada valor <math>y</math><sub>t</sub> da
	  serie que se devolve, obtense de entre todos os valores de
	  <math>x</math><sub>t</sub> que teñen a mesma probabilidade. Cando
	  o argumento é unha matriz, cada fila da matriz que se devolve vaise
	  obter das filas de <argname>x</argname> que teñen a mesma
	  probabilidade. Consulta tamén <fncref targ="randperm"/> para
	  extraer unha mostra de filas dunha matriz sen substitución.
	</para>
	<para>
	  O argumento <argname>tamañobloque</argname> (opcional) representa o
	  tamaño do bloque para facer a mostraxe por repetición movendo
	  bloques. Cando se indique este argumento, deberá de ser un enteiro
	  positivo maior ou igual a 2. Como consecuencia, o resultado vaise
	  compoñer por selección aleatoria con substitución, de entre todas as
	  posibles secuencias contiguas de lonxitude <argname>tamañobloque</argname>
	  do argumento. (No caso de que o argumento sexa unha matriz, isto
	  significa filas contiguas.) Se a lonxitude dos datos non é un número
	  enteiro que sexa múltiplo do tamaño do bloque, o derradeiro bloque
	  seleccionado trónzase para que se axuste.
	</para>
	<subhead>Número de extraccións</subhead>
	<para>
	  Por defecto, o número de observacións que se volven extraer
	  para acadar o resultado é igual ó do argumento indicado
	  &mdash;se <argname>x</argname> fose unha serie, sería a longura do
	  rango mostral vixente; se <argname>x</argname> fose unha matriz, sería
	  o número das súas filas. No caso matricial, <emphasis>só</emphasis>
	  podes axustar isto por medio do terceiro argumento (opcional), que
	  deberá ser un número enteiro positivo. Cae na conta de que se o
	  argumento <argname>tamañobloque</argname> é maior ca 1, o
	  argumento <argname>extraccions</argname> refírese ao número de
	  observacións individuais, non ao número de bloques.
	</para>
	<subhead>Datos de panel</subhead>
	<para>
	  Cando o argumento <argname>x</argname> é unha serie, e o conxunto
	  de datos ten formato de panel, non se admite facer a mostraxe por
	  repetición movendo bloques. A forma básica de facer este tipo de
	  mostraxe está admitida, pero ten a súa propia interpretación: faise
	  a mostraxe por repetición dos datos <quote>por individuo</quote>.
	  Supón que tes un panel no que se observan 100 individuos ao longo
	  de 5 períodos. Entón, a serie que se devolve tamén vai estar composta
	  por 100 bloques de 5 observacións: cada bloque vai obterse con igual
	  probabilidade das 100 series temporais individuais, conservándose
	  a orde das series temporais.
	</para>
      </description>
    </function>

    <function name="round" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado, do tipo do argumento, que o arredonda ao
	  enteiro máis próximo. Ten en conta que se <math>x</math> está xusto
	  entre dous enteiros, o arredondamento faise "afastándose de cero" de
	  xeito que, por exemplo, 2.5 arredóndase a 3, pero <lit>round(-3.5)</lit>
	  devolve &minus;4. Esta convención é común en software de follas de
	  cálculo, mais outro tipo de software pode xerar resultados diferentes.
	  <seelist>
            <fncref targ="ceil"/>
            <fncref targ="floor"/>
            <fncref targ="int"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="rnameget" section="strings" output="string-or-strings">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="int" optional="true">r</fnarg>
      </fnargs>
      <description>
	<para>
	  Se indicas o argumento <argname>r</argname>, devolve unha
	  cadea co nome da fila <argname>r</argname> da matriz
	  <argname>M</argname>. Se as filas de <argname>M</argname>
	  non teñen nome, entón devólvese unha cadea baleira; e se
	  <argname>r</argname> está fóra dos límites do número de filas
	  desta matriz, amósase un fallo.
	</para>
	<para>
	  Se non indicas o segundo argumento, devolve un arranxo de cadeas
	  de texto que contén os nomes das filas de <argname>M</argname>,
	  ou un arranxo baleiro se a matriz non ten asignados nomes para as súas
	  filas.
	</para>
	<para>
	  Exemplo:
	</para>
	<code>
	  matrix A = { 11, 23, 13 ; 54, 15, 46 }
	  rnameset(A, "Primeira Segunda")
	  string name = rnameget(A, 2)
	  print name
	</code>
	<para>
	  <seelist>
            <fncref targ="rnameset"/>
	  </seelist>
	</para>
      </description>
    </function>

	  <function name="rnameset" section="matbuild" output="int">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="strings-or-list">S</fnarg>
      </fnargs>
      <description>
	<para>
	  Permite engadir nomes ás filas dunha matriz <argname>M</argname>
	  de orde <by r="m" c="n"/>. Cando o argumento <argname>S</argname>
	  se refire a unha lista, os nomes tómanse das series da lista (que
	  deberá de ter <math>m</math> elementos). Cando <argname>S</argname>
	  é un arranxo de cadeas de texto, deberá de ter <math>m</math>
	  elementos. Para manter a compatibilidade con versións anteriores
	  de Gretl, tamén podes utilizar unha única cadea de texto como
	  segundo argumento; neste caso esta deberá de ter <math>m</math>
	  subcadeas de texto separadas por espazos.
	</para>
	<para>
	  Devolve o valor enteiro 0 se as filas se nomean con éxito, e un valor
	  non nulo en caso de fallo. Consulta tamén <fncref targ="cnameset"/>.
	</para>
	<para>
	  Exemplo:
	</para>
	<code>
	  matrix M = {1, 2; 2, 1; 4, 1}
	  strings S = array(3)
	  S[1] = "Fila1"
	  S[2] = "Fila2"
	  S[3] = "Fila3"
	  rnameset(M, S)
	  print M
	</code>
      </description>
    </function>

    <function name="rows" section="matshape" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un enteiro co número de filas da matriz <argname>X</argname>.
	  <seelist>
            <fncref targ="cols"/>
            <fncref targ="mshape"/>
            <fncref targ="unvech"/>
            <fncref targ="vec"/>
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="schur" section="complex" output="cmatrix">
      <fnargs>
	<fnarg type="cmatrix">A</fnarg>
	<fnarg type="matrixref" optional="true">&amp;Z</fnarg>
	<fnarg type="matrixref" optional="true">&amp;w</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza a descomposición de Schur da matriz complexa
	  <argname>A</argname> do argumento, devolvendo unha matriz
	  triangular superior complexa <math>T</math>. Cando indicas un
	  segundo argumento que non sexa <lit>null</lit> (nulo), recolle
	  unha matriz complexa <math>Z</math> que contén os vectores de
	  Schur asociados a <math>A</math> e <math>T</math>, tales que
	  <math>A</math> = <math>ZTZ</math><sup>H</sup>. Cando indicas o
	  terceiro argumento, recolle os autovalores da matriz <math>A</math>
	  nun vector columna complexo.
	</para>
      </description>
    </function>

    <function name="sd" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>x</argname> é unha serie, a función devolve un escalar
	  coa súa desviación padrón na mostra, descartando as observacións ausentes.
	</para>
	<para>
	  Se <argname>x</argname> é unha lista, a función devolve unha serie
	  <math>y</math> tal que <math>y</math><sub>t</sub> representa a
	  desviación padrón na mostra dos valores das variables da lista, na
	  observación <math>t</math>; ou <lit>NA</lit> se existe algún valor
	  ausente para a observación <math>t</math>.
	</para>
	<para>
	  <seelist>
            <fncref targ="var"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sdc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="scalar" optional="true">df</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector fila coas desviacións padrón das columnas da
	  matriz <argname>X</argname>. Se <argname>df</argname> é positivo,
	  utilízase como divisor para as varianzas das columnas; noutro caso,
	  o divisor é igual ao número de filas que ten <argname>X</argname>
	  (é dicir, nese caso non se aplica a corrección polos graos de
	  liberdade).
	  <seelist>
            <fncref targ="meanc"/>
            <fncref targ="sumc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sdiff" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-or-list">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado co cálculo das diferenzas estacionais:
	  <equation status="inline" ascii="y(t) - y(t-k)"  tex="$y_t - y_{t-k}$"/>,
	  onde <math>k</math> indica a periodicidade do conxunto vixente de
	  datos (consulta <fncref targ="$pd"/>). Os valores iniciais defínense
	  como <lit>NA</lit>.
	</para>
	<para>
	  Cando se devolve unha lista, cada variable individual desta noméase de
	  forma automática seguindo o padrón <lit>sd_</lit><repl>nomevar</repl>,
	  no que <repl>nomevar</repl> indica o nome da serie orixinal. A parte
	  orixinal do nome vai tronzarse cando así resulte necesario, e mesmo
	  poderá axustarse para garantir que sexa único dentro do conxunto de
	  nomes que así se vaian construír.
	</para>
	<para>
	  <seelist>
            <fncref targ="diff"/>
            <fncref targ="ldiff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="seasonals" section="data-utils" output="list">
      <fnargs>
	<fnarg optional="true" type="int">base</fnarg>
	<fnarg optional="true" type="bool">centro</fnarg>
      </fnargs>
      <description>
	<para>
	  Aplícase tan só se o conxunto vixente de datos ten unha estrutura
	  de series temporais con periodicidade maior ca 1. Devolve unha lista con
	  variables ficticias que representan cada período ou estación, e que se
	  nomean como <lit>S1</lit>, <lit>S2</lit>, etc.
	</para>
	<para>
	  Utiliza o argumento <argname>base</argname> (opcional) para
	  excluír da lista á variable ficticia que representa un dos períodos.
	  Por exemplo, se lle asignas un valor igual a 1 tendo un conxunto de
	  datos trimestrais, obtés unha lista que só ten as variables ficticias
	  dos trimestres 2, 3 e 4. Se omites este argumento ou é igual a 0,
	  xéranse variables ficticias para todos os períodos; e se non é cero,
	  deberá ser un enteiro comprendido entre 1 e a periodicidade dos datos.
	</para>
	<para>
	  O argumento <argname>centro</argname>, se non é nulo, indica que
	  as variables ficticias van centrarse; é dicir, os seus valores van
	  calcularse restándolle as medias na poboación. Por exemplo, con
	  datos trimestrais, as variables ficticias estacionais centradas van
	  ter valores iguais a &minus;0.25 e 0.75 en vez de 0 e 1.
	</para>
	<para>
	  Con datos de frecuencia semanal, o resultado concreto depende
	  de se os datos teñen data ou non. Se teñen data, créanse ata
	  53 series estacionais, baseadas no número de semana ISO 8601
	  (consulta <fncref targ="isoweek"/>); se non a teñen, o número
	  máximo de series é 52 (e ao longo dun período prolongado as series
	  <quote>estacionais</quote> vanse desfasar co ano do calendario).
	  No caso de ter datos semanais, se desexas xerar series estacionais
	  mensuais podes facelo do seguinte xeito:
	</para>
	<code>
	  series month = $obsminor
	  list months = dummify(month)
	</code>
	<para>
	  Para obter máis detalles, consulta <fncref targ="dummify"/>.
	</para>
      </description>
    </function>

    <function name="selifc" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="rvec">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz tras seleccionar só aquelas columnas de
	  <argname>A</argname> nas que o elemento correspondente de
	  <argname>b</argname> non é nulo. O <argname>b</argname> debe de ser un
	  vector fila co mesmo número de columnas que <argname>A</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="selifr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="selifr" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="cvec">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz tras seleccionar só aquelas filas de
	  <argname>A</argname> nas que o elemento correspondente de
	  <argname>b</argname> non é nulo. O <argname>b</argname> debe de ser un
	  vector columna co mesmo número de filas que <argname>A</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="selifc"/>
            <fncref targ="trimr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="seq" section="matbuild" output="rvec">
      <fnargs>
	<fnarg type="scalar">a</fnarg>
	<fnarg type="scalar">b</fnarg>
	<fnarg optional="true" type="scalar">k</fnarg>
      </fnargs>
      <description>
	<para>
	  Con só dous argumentos, devolve un vector fila coa secuencia crecente
	  (sumando 1) desde <argname>a</argname> ata <argname>b</argname>, se o
	  primeiro argumento é menor ca o segundo; ou coa secuencia decrecente
	  (restando 1) se o primeiro argumento é maior ca o segundo.
	</para>
	<para>
	  Se indicas o terceiro argumento <argname>k</argname> (opcional),
	  a función vai devolver un vector fila coa secuencia iniciada en
	  <argname>a</argname>, e ampliada (ou diminuída no caso inverso de
	  que <argname>a</argname> sexa maior ca <argname>b</argname>) en
	  <argname>k</argname> unidades a cada paso. A secuencia remata no
	  maior valor posible que sexa menor ou igual a <argname>b</argname>
	  (ou no menor valor posible que sexa maior ou igual a <argname>b</argname>,
	  no caso inverso). O argumento <argname>k </argname> debe de ser
	  positivo.
	</para>
	<para>
	  <seelist>
            <fncref targ="ones"/>
            <fncref targ="zeros"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="setnote" section="data-utils" output="int">
      <fnargs>
	<fnarg type="bundle">b</fnarg>
	<fnarg type="string">clave</fnarg>
	<fnarg type="string">nota</fnarg>
      </fnargs>
      <description>
	<para>
	  Insire unha nota descritiva para un obxecto que se identifica pola
	  <argname>clave</argname>, dentro dun feixe <argname>b</argname>.
	  Vaise amosar esa nota cando se utilice a instrución <lit>print</lit>
	  co feixe. Esta función devolve un enteiro igual a 0 no caso de
	  executarse con éxito, e un valor non nulo no caso de fallo (por
	  exemplo, se non existe ningún obxecto <argname>clave</argname> no
	  feixe <argname>b</argname>).
	</para>
      </description>
    </function>

    <function name="sgn" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve a función signo de <argname>x</argname>; é dicir,
	  0 se <argname>x</argname> é cero, 1 se <argname>x</argname> é
	  positivo, &minus;1 se <argname>x</argname> é negativo, ou
	  <lit>NA</lit> se <argname>x</argname> é Non Numérico.
	</para>
      </description>
    </function>

    <function name="simann" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="int" optional="true">maxit</fnarg>
      </fnargs>
      <description>
	<para>
	  Pon en práctica o recocemento simulado, que pode ser útil para
	  mellorar a determinación do punto de partida dun problema de
	  optimización numérica.
	</para>
	<para>
	  Indicando o primeiro argumento, establécese o valor inicial dun
	  vector de parámetros; e indicando o segundo argumento, se especifica
	  unha chamada a unha función que devolve o valor escalar da
	  función obxectivo a maximizar. O terceiro argumento (opcional)
	  especifica o número máximo de iteracións (que por defecto é de 1024).
	  Cando se completa con éxito, a función <lit>simann</lit> devolve un
	  escalar co valor final da función obxectivo a maximizar, e
	  <argname>b</argname> contén o vector de parámetros asociado.
	</para>
	<para>
	  Para obter máis detalles e un exemplo, consulta o
	  <guideref targ="chap:numerical"/>.
	  <seelist>
            <fncref targ="BFGSmax"/>
            <fncref targ="NRmax"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sin" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co seno de <argname>x</argname>.
	  <seelist>
            <fncref targ="cos"/>
            <fncref targ="tan"/>
            <fncref targ="atan"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sinh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co seno hiperbólico de <argname>x</argname>.
	</para>
	<para context="tex">
	  \[ \sinh x = \frac{e^x - e^{-x}}{2}  \]
	</para>
	<para>
	  <seelist>
            <fncref targ="asinh"/>
            <fncref targ="cosh"/>
            <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="skewness" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co valor do coeficiente de asimetría da serie
	  <argname>x</argname>, descartando calquera observación ausente.
	</para>
      </description>
    </function>

    <function name="sleep" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="int">ns</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta función non ten ningún uso directo en Econometría, mais pode
	  ser de utilidade para comprobar métodos de computación en paralelo.
	  Simplemente provoca que se <quote>durma</quote> a liña de cómputo
	  vixente (é dicir, que se pare) durante <argname>ns</argname> segundos.
	  Ao <quote>espertar</quote>, a función devolve o escalar 0.
	</para>
      </description>
    </function>

    <function name="smplspan" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="string">obsinicio</fnarg>
	<fnarg type="string">obsfin</fnarg>
	<fnarg type="int">pd</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve o número de observacións que hai contando desde
	  <argname>obsinicio</argname> ata <argname>obsfin</argname>
	  (ambas incluídas), para datos de series temporais que teñen
	  unha frecuencia <argname>pd</argname>.
	</para>
	<para>
	  Deberías de indicar os dous primeiros argumentos no formato
	  que prefire Gretl para datos de tipo anual, trimestral ou
	  mensual (por exemplo, <lit>1970</lit>, <lit>1970:1</lit>
	  ou <lit>1970:01</lit> para cada unha desas frecuencias,
	  respectivamente) ou como datas no formato ISO 8601,
	  <lit>YYYY-MM-DD</lit>.
	</para>
	<para>
	  O argumento <argname>pd</argname> debe de ser ben 1, 4
	  ou 12 (datos anuais, trimestrais ou mensuais), ben unha
	  das frecuencias diarias (5, 6, 7), ou ben 52 (semanal).
	  Se <argname>pd</argname> é igual a 1, 4 ou 12, entón as
	  datas ISO 8601 acéptanse para os dous primeiros argumentos,
	  se indican o comezo do período en cuestión. Por exemplo,
	  <lit>2015-04-01</lit> admítese en troques de <lit>2015:2</lit>
	  para representar o segundo trimestre de 2015.
	</para>
	<para>
	  Se xa tes un conxunto de datos con frecuencia <argname>pd</argname>
	  preparado, e cun rango suficiente de observacións, entón podes
	  imitar doadamente o comportamento desta función utilizando
	  a función <fncref targ="obsnum"/>. A vantaxe de <lit>smplspan</lit>
	  consiste en que podes calcular o número de observacións sen
	  necesidade de ter preparado un conxunto apropiado de datos
	  (nin ningún conxunto de datos). Deseguido, un exemplo:
	</para>
	<code>
	  scalar T = smplspan("2010-01-01", "2015-12-31", 5)
	  nulldata T
	  setobs 5 2010-01-01
	</code>
	<para>
	  Isto xera
	</para>
	<code>
	  ? scalar T = smplspan("2010-01-01", "2015-12-31", 5)
	  Xerouse o escalar T = 1565
	  ? nulldata T
	  Periodicidade: 1, máx. obs: 1565
	  Rango de observacións: 1 ata 1565
	  ? setobs 5 2010-01-01
	  Rango completo de datos: 2010-01-01 - 2015-12-31 (n = 1565)
	</code>
	<para>
	  Despois do anterior, podes ter confianza en que a derradeira
	  observación do conxunto de datos que se vai xerar por medio
	  de <cmdref targ="nulldata"/> vai ser <lit>2015-12-31</lit>.
	  Cae na conta de que o número 1565 sería máis ben complicado
	  calculalo doutro xeito.
	</para>
      </description>
    </function>

    <function name="sort" section="matshape" output="asinput">
      <fnargs>
	<fnarg type="series-vec-or-strings">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado do mesmo tipo ca <argname>x</argname> cos seus
	  valores ordenados de forma ascendente, descartando as observacións
	  con valores ausentes cando <math>x</math> é unha serie.
	  <seelist>
            <fncref targ="dsort"/>
            <fncref targ="values"/>
	  </seelist>
	  Para matrices, en especial, consulta <fncref targ="msortby"/>.
	</para>
      </description>
    </function>

    <function name="sortby" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y1</fnarg>
	<fnarg type="series">y2</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha serie que contén os elementos de <argname>y2</argname>
	  ordenados de acordo cos valores crecentes do primeiro argumento
	  <argname>y1</argname>.
	  <seelist>
            <fncref targ="sort"/>
            <fncref targ="ranking"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sprintf" section="strings" output="string">
      <fnargs>
	<fnarg type="string">formato</fnarg>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Devolve unha cadea de texto (<quote>string</quote>) que se constrúe
	  representando os valores dos argumentos (indicados polos puntos de
	  arriba) que acompañan á instrución, baixo o control do argumento
	  <argname>formato</argname>. Ten a intención de darte gran flexibilidade
	  para crear cadeas de texto. Utiliza <argname>formato</argname> para
	  indicar o xeito preciso no que queres que se presenten os argumentos.
	</para>
	<para>
	  En xeral, o argumento <argname>formato</argname> debe de ser unha
	  expresión que se corresponda cunha cadea de texto, pero nos máis
	  dos casos só vai ser unha cadea de texto literal (unha secuencia
	  alfanumérica contornada entre comiñas). Algunhas secuencias de
	  caracteres de formato teñen un significado especial: aquelas que
	  comezan co símbolo (%) interprétanse como <quote>comodíns</quote>
	  para os elementos que contén a lista de argumentos. Amais, caracteres
	  especiais (por exemplo, o de nova liña) represéntanse por medio dunha
	  combinación de símbolos que comeza cunha barra diagonal inversa.
	</para>
	<para>
	  Por exemplo, o código de abaixo...
	</para>
	<code>
	  scalar x = sqrt(5)
	  string claim = sprintf("sqrt(%d) é (aproximadamente) %6.4f.\n", 5, x)
	  print claim
	</code>
	<para>
	  vai producir...
	</para>
	<code>
	  sqrt(5) é (aproximadamente) 2.2361.
	</code>
	<para>
	  A expresión <lit>%d</lit> na cadea de formato, indica que se quere un
	  número enteiro nese preciso lugar da saída que se vai presentar, e dado
	  que esa é a expresión co símbolo <quote>por cento</quote> que está
	  máis á esquerda, emparéllase co primeiro argumento, é dicir 5.
	  A segunda secuencia especial é <lit>%6.4f</lit>, e representa un
	  valor con 6 díxitos de largo como mínimo, e con 4 díxitos despois do
	  separador decimal. O número desas secuencias debe de coincidir coa
	  cantidade de argumentos que acompañan á cadea de texto para o formato.
	</para>
	<para>
	  Consulta a páxina de axuda da instrución <cmdref targ="printf"/>
	  para obter máis detalles en relación coa sintaxe que podes utilizar
	  nas cadeas de texto para o formato.
	</para>
      </description>
    </function>

    <function name="sqrt" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado, do mesmo tipo ca <argname>x</argname>, coa raíz
	  cadrada positiva deste. Xera <lit>NA</lit> para valores negativos deste.
	</para>
	<para>
	  Advirte que, se o argumento é unha matriz, realízase a operación
	  para cada elemento. Para a <quote>raíz cadrada matricial</quote>
	  consulta <fncref targ="cholesky"/>.
	</para>
      </description>
    </function>

    <function name="square" section="transforms" output="list">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg optional="true" type="bool">produtos-cruz</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha lista que contén os cadrados das variables da lista
	  <argname>L</argname>, cos seus elementos nomeados de acordo co
	  seguinte padrón :<lit>sq_</lit><repl>nomevariable</repl>. Cando indicas
	  o segundo argumento (opcional) e ten un valor non nulo, a lista
	  tamén vai incluír os produtos cruzados dos elementos da lista
	  <argname>L</argname>, que se nomearán de acordo co formato do
	  padrón <repl>var1</repl><lit>_</lit><repl>var2</repl>. De ser
	  necesario, o nome das series dos argumentos vai tronzarse e mesmo
	  axustarse o nome do resultado final, para evitar a duplicación de
	  nomes na lista que se devolve.
	</para>
      </description>
    </function>

    <function name="sscanf" section="strings" output="int">
      <fnargs>
	<fnarg type="string-or-strings">orixe</fnarg>
	<fnarg type="string">formato</fnarg>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Le valores indicados polo argumento <argname>orixe</argname> baixo
	  o control do argumento <argname>formato</argname>, e asigna estes
	  valores a un ou máis dos argumentos seguintes, indicados polos
	  puntos de arriba. Devolve un enteiro co número de valores que se
	  asignan. Esta función é unha versión simplificada da función
	  <lit>sscanf</lit> da linguaxe C de programación, cunha extensión
	  para escanear unha matriz enteira, e que se describe máis abaixo
	  baixo o título <quote>Escaneando unha matriz</quote>. Ten en conta que
	  indicar un arranxo de cadeas de texto como <argname>orixe</argname>
	  só se acepta no caso de que escanees unha matriz.
	</para>
	<para>
	  Como argumento <repl>orixe</repl> podes usar unha cadea de texto literal
	  contornada entre comiñas, ou ben o nome dunha cadea de texto que
	  definiras previamente. O argumento <repl>formato</repl> indícase de
	  xeito similar á cadea do argumento <quote>formato</quote> en
	  <cmdref targ="printf"/> (mira máis abaixo); nesta última función,
	  <repl>elementos</repl> debe de ser unha lista de variables definidas antes,
	  separadas por comas e que son os obxectivos da conversión de
	  <repl>orixe</repl>. (Para os afeitos a C: podedes fixar previamente os
	  nomes das variables numéricas con <lit>&amp;</lit>, pero non se esixe.)
	</para>
	<para>
	  O texto literal no argumento <repl>formato</repl> compárase con
	  <repl>orixe</repl>. Os elementos que especifican a conversión comezan
	  co carácter <lit>%</lit>, e as conversións que están admitidas
	  inclúen: <lit>%f</lit>, <lit>%g</lit> ou <lit>%lf</lit> para números
	  de punto flotante; <lit>%d</lit> para números enteiros; e <lit>%s</lit>
	  para cadeas de texto. Podes inserir un enteiro positivo despois do
	  símbolo de porcentaxe, que establece o número máximo de caracteres
	  que se van ler para a conversión indicada. Como forma alternativa,
	  podes inserir un carácter literal de asterisco, <lit>*</lit>, logo do
	  símbolo de porcentaxe para eliminar a conversión (saltándose así
	  calquera carácter que, doutro xeito, podería terse convertido ao tipo
	  indicado). Por exemplo, a expresión <lit>%3d</lit> converte os
	  seguintes 3 caracteres de <repl>orixe</repl> nun enteiro, en caso
	  de que sexa posible; e a expresión <lit>%*g</lit> permite saltarse
	  tantos caracteres de <repl>orixe</repl> como os que poderían
	  converterse nun número de punto flotante simple.
	</para>
	<para>
	  Ademais da conversión <lit>%s</lit> para cadeas de texto, tamén
	  está dispoñible unha versión simplificada do formato C
	  <lit>%</lit><repl>N</repl><lit>[</lit><repl>chars</repl><lit>]</lit>.
	  Neste formato, <repl>N</repl> representa o número máximo de
	  caracteres que se van ler, e <repl>chars</repl> expresa un conxunto de
	  caracteres que sexan admisibles, contornados entre corchetes:
	  o proceso de lectura remata cando se acada <repl>N</repl>, ou cando
	  se atopa un carácter que non está en <repl>chars</repl>. Podes
	  trocar o funcionamento de <repl>chars</repl>indicando o circunflexo
	  <lit>^</lit> como primeiro carácter; nese caso, o proceso de lectura
	  remata cando se atopa un carácter que está indicado no conxunto.
	  (A diferenza do que acontece en C, o guión non xoga ningún papel
	  especial no conxunto <repl>chars</repl>.)
	</para>
	<para>
	  Se a cadea de texto da orixe non coincide (exactamente) co formato,
	  o número de conversións pode quedarse curta a respecto do número
	  de argumentos indicados. Isto non é por si mesmo un fallo no que
	  atinxe a Gretl. Así e todo, poderías querer comprobar o número de
	  conversións que se completaron; isto indícase no valor que se
	  devolve De seguido indícanse varios exemplos:
	</para>
	<code>
	  # Escaneando valores escalares
	  scalar x
	  scalar y
	  sscanf("123456", "%3d%3d", x, y)
	  # Escaneando valores de cadea de texto
	  string s = "un dous"
	  string s1
	  string s2
	  sscanf(s, "%s %s", s1, s2)
	  print s1 s2
	</code>
	<subhead>Escaneando unha matriz</subhead>
	<para>
	  O escaneado de matrices debe sinalarse mediante a especificación
	  especial de conversión, <quote><lit>%m</lit></quote>. Podes indicar
	  o número máximo de filas a ler, inserindo un número enteiro entre o
	  signo <quote><lit>%</lit></quote> e a <quote><lit>m</lit></quote>
	  indicativa de matriz. Se permiten dúas variantes: que
	  <argname>orixe</argname> indique unha cadea de texto única que
	  represente unha matriz, e que <argname>orixe</argname> indique un
	  arranxo de cadeas de texto. Estas opcións descríbense de vez.
	</para>
	<para>
	  Se <argname>orixe</argname> é un argumento de cadea de texto única,
	  o escáner le unha liña da entrada e conta o número de campos numéricos
	  (separados por espazo ou por tabulador). Isto define o número de
	  columnas da matriz. Por defecto, o proceso de lectura continúa con
	  todas as liñas (filas) que conteñan o mesmo número de columnas
	  numéricas, mais o número máximo de filas pode limitarse mediante
	  o valor enteiro opcional mencionado antes.
	</para>
	<para>
	  Se <argname>orixe</argname> é un arranxo de cadeas de texto, o
	  resultado vai ser forzosamente un vector columna, do que cada
	  elemento vai ser a conversión numérica da cadea correspondente, ou
	  <lit>NA</lit> se a cadea de texto non representa un número.
	  A continuación, tes varios exemplos:
	</para>
	<code>
	  # Escaneando unha única cadea de texto
	  string s = sprintf("1 2 3 4\n5 6 7 8")
	  print s
	  matrix m
	  sscanf(s, "%m", m)
	  print m
	  # Escaneando un arranxo de cadeas de texto
	  strings S = defarray("1.1", "2.2", "3.3", "4.4", "5.5")
	  sscanf(S, "%4m", m)
	  print m
	</code>
      </description>
    </function>

    <function name="sst" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar coa suma dos cadrados das desviacións respecto á
	  media (SCT), das observacións non ausentes da serie <argname>y</argname>.
	  <seelist>
            <fncref targ="var"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="stack" section="data-utils" output="series">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg type="int">n</fnarg>
	<fnarg type="int" optional="true">desprazamento</fnarg>
      </fnargs>
      <description>
	<para>
	  Deseñado para o manexo de datos no formato de series de tempo
	  encasteladas, que necesita Gretl para datos de panel. O valor
	  que se devolve é unha serie que se obtén encastelando de forma
	  <quote>vertical</quote>, grupos de <argname>n</argname>
	  observacións de cada serie da lista <argname>L</argname>. Por
	  defecto, se usan as primeiras <argname>n</argname> observacións
	  (iso se corresponde con <argname>desprazamento</argname> = 0),
	  pero podes trasladar o punto de inicio indicando un valor positivo
	  para <argname>desprazamento</argname>. Se a serie resultante fose
	  máis longa que o conxunto de datos vixente, engádense tantas
	  observacións como sexan necesarias.
	</para>
	<para>
	  Con esta función podes manexar o caso dun ficheiro de datos que conteña
	  series de tempo colocadas unhas a carón das outras, para un grupo de
	  unidades de sección cruzada. E tamén cando se considera o tempo en
	  sentido horizontal, e cada fila representa unha unidade atemporal.
	</para>
	<para>
	  Consulta a sección titulada <quote>Panel data specifics</quote>
	  no <guideref targ="chap:datafiles"/> para obter detalles e exemplos
	  do seu uso.
	</para>
      </description>
    </function>

    <function name="stdize" section="stats" output="asinput">
      <fnargs>
	<fnarg type="series-list-or-mat">X</fnarg>
	<fnarg type="int" optional="true">v</fnarg>
      </fnargs>
      <description>
	<para>
	  Por defecto, devolve un resultado do mesmo tipo que o argumento, coa
	  versión tipificada desa serie, lista ou matriz: o argumento céntrase
	  e divídese pola súa desviación padrón mostral (con corrección de 1,
	  nos graos de liberdade). No caso de que o argumento sexa unha matriz,
	  os resultados calcúlanse por columnas.
	</para>
	<para>
	  Podes usar o segundo argumento (opcional) para modular o resultado.
	  Un valor non negativo dese <argname>v</argname> permite configurar
	  a corrección nos graos de liberdade que se utilizan para a desviación
	  padrón; así <argname>v</argname> = 0 solicita utilizar o estimador
	  máximo-verosímil. Como caso especial, se estableces que
	  <argname>v</argname> sexa igual a &minus;1, unicamente
	  se vai centrar o primeiro argumento.
	</para>
      </description>
    </function>

    <function name="strftime" section="calendar" output="string">
      <fnargs>
	<fnarg type="scalar">tm</fnarg>
	<fnarg optional="true" type="string">formato</fnarg>
      </fnargs>
      <description>
	<para>
	  O argumento <argname>tm</argname> utilízase para proporcionar
	  o número de segundos dende o inicio do ano 1970, de acordo
	  co UTC (Tempo Universal Coordinado, antes coñecido como
	  tempo medio de Greenwich). O valor que se devolve é unha
	  cadea de texto que proporciona a data e/ou hora correspondente,
	  ben nun formato especificado mediante o segundo argumento
	  (opcional) ou ben, por defecto, mediante a
	  <quote>representación preferida de data e hora no entorno local vixente</quote>
	  tal como determinaría a biblioteca do sistema C.
	</para>
	<para>
	  Podes obter valores axeitados de <argname>tm</argname> para
	  utilizar con esta función mediante o accesorio <fncref targ="$now"/>
	  ou a función <fncref targ="strptime"/>.
	</para>
	<para>
	  Podes atopar as opcións de formato consultando as páxinas
	  sobre <lit>strftime</lit> do manual, en sistemas que as teñan;
	  ou por medio dun dos moitos sitios web que presentan
	  información relevante, como por exemplo
	  <url>https://devhints.io/strftime</url>.
	</para>
      </description>
    </function>

    <function name="stringify" section="strings" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="strings">S</fnarg>
      </fnargs>
      <description>
	<para>
	  Proporciona un xeito de definir valores de cadea de texto para a
	  serie <argname>y</argname>. Para que isto funcione, deben de
	  cumprirse dúas condicións: a serie obxectivo non debe de ter outra
	  cousa que non sexan valores enteiros positivos (ningún deles menor
	  ca 1); e o arranxo <argname>S</argname> debe de ter polo menos
	   <math>n</math> elementos, sendo <math>n</math> o maior valor de
	   <argname>y</argname>. Amais, cada elemento de <argname>S</argname>
	   debe de ter un formato UTF-8 válido.
	  <seelist>
            <fncref targ="strvals"/>
	  </seelist>
	</para>
	<para>
	  O valor que devolve esta función é cero no caso de completarse con
	  éxito, ou un código de fallo positivo no caso de fallar.
	</para>
      </description>
    </function>

    <function name="strlen" section="strings" output="int">
      <fnargs>
	<fnarg type="string-or-strings">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>s</argname> é unha cadea de texto simple, devolve
	  a cantidade de caracteres UTF-8 que contén. Ten en conta que
	  iso non é igual ao número de bytes, se algúns caracteres están
	  fóra do intervalo de impresión ASCII. Cando desexes obter o número
	  de bytes, podes usar a función <fncref targ="nelem"/>. Por exemplo:
	</para>
	<code>
	  string s = "Olé!"
	  printf "strlen(s) = %d, nelem(s) = %d\n", strlen(s), nelem(s)
	</code>
	<para>
	  debera devolver
	</para>
	<code>
	  strlen(s) = 5, nelem(s) = 7
	</code>
	<para>
	  Se o argumento é un arranxo de cadeas de texto, o valor que se devolve
	  é un vector columna que contén o número de caracteres de cada cadea.
	  Tamén se acepta que uses como argumento unha serie con cadeas de
	  valores; nese caso, o valor que se devolve é unha serie que contén a
	  longura das cadeas de valores ao longo do rango mostral vixente.
	</para>
      </description>
    </function>

    <function name="strncmp" section="strings" output="int">
      <fnargs>
	<fnarg type="string">s1</fnarg>
	<fnarg type="string">s2</fnarg>
	<fnarg optional="true" type="int">n</fnarg>
      </fnargs>
      <description>
	<para>
	  Compara as dúas cadeas de texto dos argumentos, e devolve un enteiro
	  que é menor, igual ou maior ca 0 cando <argname>s1</argname> é
	  (respectivamente) menor, igual ou maior que <argname>s2</argname>,
	  ata os <argname>n</argname> primeiros caracteres. Cando se omite
	  <argname>n</argname>, a comparación continúa ata onde resulte
	  posible.
	</para>
	<para>
	  Cae na conta de que, se só queres comprobar se dúas cadeas de texto
	  son iguais, podes facelo sen necesidade de utilizar esta función, como
	  coa indicación <lit>if (s1 == s2)...</lit>.
	</para>
      </description>
    </function>

    <function name="strptime" section="calendar" output="scalar">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg type="string">formato</fnarg>
      </fnargs>
      <description>
	<para>
	 Esta función é a recíproca de <fncref targ="strftime"/>. Analiza a
	 cadea de texto <argname>s</argname> que expresa tempo ou data,
	 utilizando o <argname>formato</argname> especificado; e devolve un
	 escalar que proporciona o número de segundos transcorridos dende o
	 inicio de 1970 segundo o Tempo Universal Coordinado (UTC).
	</para>
	<para>
	  Podes atopar as opcións de <argname>formato</argname> consultando
	  a páxina sobre <lit>strptime</lit> do manual, en sistemas que dispoñan
	  das mesmas; ou por medio dun dos moitos sitios web que presentan
	  información relevante, como por exemplo
	  <url>http://man7.org/linux/man-pages/man3/strptime.3.html</url>.
	</para>
	<para>
	  O exemplo de debaixo amosa como podes converter información
	  de datas dun a outro formato.
	</para>
	<code>
	  scalar tm = strptime("Sunday 17/02/19", "%A %d/%m/%y")
	  eval strftime(tm) # Resultado por defecto
	  eval strftime(tm, "%A, %d de %B de %Y")
	</code>
	<para>
	  No entorno local galego (España), o resultado é
	</para>
	<code>
	  17/02/2019 0:00:00
	  domingo, 17 de febreiro de 2019
	</code>
      </description>
    </function>

    <function name="strsplit" section="strings" output="string-or-strings">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg optional="true" type="string">sep</fnarg>
	<fnarg optional="true" type="int">i</fnarg>
      </fnargs>
      <description>
	<para>
	  No seu funcionamento básico, cun único argumento, devolve o arranxo de
	  cadeas de texto que resulta ao separar o contido de <argname>s</argname>
	  conforme aos espazos baleiros que ten (é dicir, conforme a calquera
	  combinación dos caracteres de espazo, tabulación e/ou liña nova).
	</para>
	<para>
	  Podes utilizar o segundo argumento (opcional) para especificar
	  o separador que se usa para separar <argname>s</argname>.
	  Por exemplo...
	</para>
	<code>
	  string Cesta = "Plátano,Mazá,Yaca,Laranxa"
	  strings S = strsplit(Cesta,",")
	</code>
	<para>
	  vai separar o primeiro argumento da función nun arranxo de catro
	  cadeas de texto, usando a coma como elemento separador.
	</para>
	<para>
	  As secuencias de barra diagonal esquerda para escapar, indicadas
	  mediante <quote><lit>\n</lit></quote> e <quote><lit>\t</lit></quote>,
	  considérase que representan unha liña nova e unha tabulación cando se
	  indican no argumento opcional <argname>sep</argname>. Se queres incluír
	  unha barra diagonal esquerda literal como carácter separador, debes de
	  duplicala como en <quote><lit>\\</lit></quote>. Exemplo:
	</para>
	<code>
	  string s = "c:\fiddle\sticks"
	  strings S = strsplit(s, "\\")
	</code>
	<para>
	  Con independencia do separador, aos elementos do arranxo que se
	  devolve, se lles recorta calquera espazo en branco ao comezo ou
	  ao final. En consecuencia, se <argname>sep</argname> contén
	  caracteres que non son espazos en branco, entón se lle quita
	  calquera espazo ao comezo ou ao final.
	</para>
	<para>
	  Cando indicas un valor enteiro maior ca cero como terceiro argumento,
	  o valor que se devolve é unha única cadea de texto; en concreto, o
	  elemento <argname>i</argname> (en base 1) do arranxo que se xeraría
	  doutro xeito sen ese terceiro argumento. Cando <argname>i</argname>
	  sexa menor ca 1, se produce un fallo; mais cando <argname>i</argname>
	  excede o número de elementos implicados, devólvese unha cadea de
	  texto baleira.
	</para>
      </description>
    </function>

    <function name="strstr" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s1</fnarg>
	<fnarg type="string">s2</fnarg>
      </fnargs>
      <description>
	<para>
	  Procura en <argname>s1</argname> a cadea <argname>s2</argname>.
	  No caso de atopar a cadea de texto, devolve outra cadea cunha copia da
	  parte de <argname>s1</argname> que comeza con <argname>s2</argname>;
	  noutro caso, devolve unha cadea de texto baleira.
	</para>
  <para>
          Exemplo:
  </para>
  <code>
          string s1 = "Gretl é un programa de Econometría"
          string s2 = strstr(s1, "un")
          print s2
  </code>
	<para>
	  Se unicamente queres descubrir se <argname>s1</argname>
	  contén a <argname>s2</argname> (proba booleana), consulta
	  <fncref targ="instring"/>.
	</para>
      </description>
    </function>

    <function name="strstrip" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha cadea de texto cunha copia de <argname>s</argname>
	  na que se eliminaron os espazos en branco do inicio e do final.
	</para>
  <para>
          Exemplo:
  </para>
  <code>
          string s1 = "    Moito espazo en branco.  "
          string s2 = strstrip(s1)
          print s1 s2
  </code>
      </description>
    </function>

    <function name="strsub" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg type="string">atopada</fnarg>
	<fnarg type="string">substit</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha cadea de texto cunha copia de <argname>s</argname> na que
	  se substituíu toda a cadea <argname>atopada</argname> por
	  <argname>substit</argname>. Consulta tamén <fncref targ="regsub"/> para
	  outras substitucións máis complexas mediante expresións regulares.
	</para>
  <para>
          Exemplo:
  </para>
  <code>
          string s1 = "Hola, Gretl!"
          string s2 = strsub(s1, "Gretl", "Hansl")
          print s2
  </code>
      </description>
    </function>

    <function name="strvals" section="strings" output="strings">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg optional="true" type="bool">submostra</fnarg>
      </fnargs>
      <description>
	<para>
	  Cando a serie <argname>y</argname> se compón de cadeas de texto
	  que expresan valores, esta función devolve por defecto un arranxo que
	  contén todos eses valores (con independencia do rango mostral que
	  estea vixente), ordenados numericamente comezando polo 1. Se está
	  vixente unha submostra do conxunto de datos, podes proporcionar
	  un valor non nulo para o segundo argumento (opcional) e obter deste
	  xeito un arranxo que conteña só as cadeas de texto presentes na
	  submostra.
	</para>
	<para>
	  Cando <argname>y</argname> non se compón de cadeas de texto que
	  expresan valores, devólvese un arranxo de cadeas de texto baleiras.
	  <seelist>
            <fncref targ="stringify"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="substr" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg type="int">inicio</fnarg>
	<fnarg type="int">fin</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve a subcadea do argumento <argname>s</argname>, comezando no
	  carácter indicado polo enteiro positivo de <argname>inicio</argname>,
	  e rematando no indicado polo de <argname>fin</argname>, ambos
	  incluídos; ou desde <argname>inicio</argname> ata o remate de
	  <argname>s</argname> se <argname>fin</argname> é igual a &minus;1.
	</para>
  <para>
          Por exemplo, o código de abaixo
  </para>
  <code>
          string s1 = "Hola, Gretl!"
          string s2 = substr(s1, 7, 11)
          print s2
  </code>
  <para>
          proporciona:
  </para>
  <code>
    ? print s2
    Gretl
  </code>
  <para>
          Debes de darte de conta de que, nalgúns casos, poderías estar
          desexando intercambiar claridade por concisión, e utilizar operadores
          de redución e incremento, como en
  </para>
  <code>
          string s1 = "Hola, Gretl!"
          string s2 = s1[7:11]
          string s3 = s1 + 6
          print s2
          print s3
  </code>
  <para>
    o que te proporcionaría
  </para>
  <code>
    ? print s2
    Gretl
    ? print s3
    Gretl!
  </code>
      </description>
    </function>

    <function name="sum" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="smlist">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Cando <argname>x</argname> é unha serie, devolve un escalar co
	  resultado de sumar as observacións non ausentes do argumento
	  <argname>x</argname>. Consulta tamén <fncref targ="sumall"/>.
	</para>
	<para>
	  Cando <argname>x</argname> é unha matriz, devolve un escalar co
	  resultado de sumar os elementos da matriz.
	</para>
	<para>
	  Cando <argname>x</argname> é unha lista de variables, a función devolve
	  unha serie <math>y</math>, na que cada valor <math>y</math><sub>t</sub>
	  indica a suma dos valores das variables da lista na observación
	  <math>t</math>, ou <lit>NA</lit> se algún deses valores está ausente
	  en <math>t</math>.
	</para>
      </description>
    </function>

    <function name="sumall" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co resultado de sumar as observacións da serie
	  <argname>x</argname> na mostra seleccionada, ou <lit>NA</lit> se
	  existe algún valor ausente. Utiliza <fncref targ="sum"/> se queres
	  obter a suma descartando os valores ausentes.
	</para>
      </description>
    </function>

    <function name="sumc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector fila coa suma das columnas de <argname>X</argname>.
	  <seelist>
            <fncref targ="meanc"/>
            <fncref targ="sumr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sumr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector columna coa suma das filas de <argname>X</argname>.
	  <seelist>
            <fncref targ="meanr"/>
            <fncref targ="sumc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="svd" section="linalg" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;V</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devolve un vector fila co resultado de descompoñer a matriz
	  <argname>X</argname> en valores singulares.
	</para>
	<para context="tex">
	  Devolve un vector fila co resultado de descompoñer a matriz $X$
	  de orde $r \times c$, en valores singulares:
	  \[ X = U \left[
	  \begin{array}{cccc}
	  \sigma_1 \\
	  &amp; \sigma_2 \\
	  &amp; &amp; \ddots \\
	  &amp; &amp; &amp; \sigma_n ,
	  \end{array}
	  \right] V \]
	  onde $n = \min(r,c)$. $U$ é $r \times n$ e $V$ é $n \times c$,
	  con $U'U = I$ e $VV' = I$.
	</para>
	<para>
	  Os valores singulares devólvense nun vector fila. Podes obter o
	  vector singular esquerdo <math>U</math> e/ou o dereito <math>V</math>
	  indicando valores non nulos nos argumentos 2 e 3, respectivamente.
	  Para calquera matriz <lit>A</lit>, o código...
	</para>
	<code>
	  s = svd(A, &amp;U, &amp;V)
	  B = (U .* s) * V
	</code>
	<para>
	  ... debera proporcionar unha matriz <lit>B</lit> idéntica a
	  <lit>A</lit> (agás pequenas diferenzas debida á precisión de cálculo).
	</para>
	<para>
	  <seelist>
            <fncref targ="eigengen"/>
            <fncref targ="eigensym"/>
            <fncref targ="qrdecomp"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="svm" section="stats" output="series">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg type="bundle">bparms</fnarg>
	<fnarg type="bundleref" optional="true">bmod</fnarg>
	<fnarg type="bundleref" optional="true">bprob</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta función te permite o adestramento (e a predición baseada nela)
	  dunha MSV (Máquina de Soporte Vectorial ou SVM), utilizando a librería
	  LIBSVM como soporte. O argumento de tipo lista <argname>L</argname>
	  deberá de incluír a variable dependente seguida das variables
	  independentes; ademáis, o feixe <argname>bparms</argname>
	  emprégase para pasarlle opcións ao mecanismo da MSV. O valor
	  que se devolve é unha serie que contén as predicións da MSV.
	  Podes utilizar os dous argumentos opcionais punteiro-feixe para
	  recuperar información adicional despois do adestramento e/ou predición.
	</para>
	<para>
	  Para obter máis detalles, consulta a documentación PDF para
	  <mnu targ="gretlSVM">gretl + SVM</mnu>.
	</para>
      </description>
    </function>

    <function name="tan" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) coa tanxente de <argname>x</argname>.
	  <seelist>
            <fncref targ="atan"/>
            <fncref targ="cos"/>
            <fncref targ="sin"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="tanh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) coa tanxente hiperbólica de <argname>x</argname>.
	</para>
	<para context="tex">
	  \[ \tanh x = \frac{e^{2x} - 1}{e^{2x} + 1}  \]
	</para>
	<para>
	  <seelist>
            <fncref targ="atanh"/>
            <fncref targ="cosh"/>
            <fncref targ="sinh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="tdisagg" section="transforms" output="matrix">
      <fnargs>
	<fnarg type="series-or-mat">Y</fnarg>
	<fnarg optional="true" type="series-list-or-mat">X</fnarg>
	<fnarg type="scalar">s</fnarg>
	<fnarg optional="true" type="bundle">opcions</fnarg>
	<fnarg optional="true" type="bundle">resultados</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza a desagregación temporal (conversión a unha frecuencia maior)
	  dos datos de tipo serie temporal que haxa en <argname>Y</argname>.
	  O argumento <argname>s</argname> proporciona o factor de expansión
	  (por exemplo, 3 para pasar de trimestrais a mensuais). O argumento
	  <argname>X</argname> pode conter unha ou máis covariantes (que teñan
	  a frecuencia maior) para axudar no proceso de desagregación. Podes
	  asumir diversas opcións no argumento <argname>opcions</argname>,
	  e podes recoller os detalles da desagregación por medio de
	  <argname> resultados</argname>.
	</para>
	<para>
	  Consulta o <guideref targ="chap:tdisagg"/> para obter máis detalles.
	</para>
      </description>
    </function>

    <function name="toepsolv" section="linalg" output="cvec">
      <fnargs>
	<fnarg type="vector">c</fnarg>
	<fnarg type="vector">r</fnarg>
	<fnarg type="vector">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector columna coa solución dun sistema Toeplitz
	  de ecuacións lineais, é dicir <math>Tx = b</math>
	  onde <math>T </math> é unha matriz cadrada cuxo elemento
	  <math>T</math><sub>i,j</sub> é
	  igual a <math>c</math><sub>i-j</sub>
	  cando <equation status="inline" ascii="i&gt;=j" tex="$i\ge j$"/>, e
	  igual a <math>r</math><sub>j-i</sub>
	  cando <equation status="inline" ascii="i&lt;=j" tex="$i\le j$"/>.
	  Ten en conta que os primeiros elementos dos dous vectores
	  <math>c</math> e <math>r</math> deben de ser iguais, pois
	  noutro caso se devolve un fallo. Cando se completa con éxito,
	  a execución desta función permite obter o vector
	  <math>x</math>.
	</para>
	<para>
	  O algoritmo que se utiliza aquí aproveita a especial estrutura da
	  matriz <math>T</math>, o que o fai moito máis eficiente ca outros
	  algoritmos non especializados, particularmente para problemas moi
	  longos. Advertencia: Nalgúns casos, a función podería suxerir
	  falsamente un fallo na singularidade da matriz <math>T</math> cando
	  realmente non é singular; de calquera xeito, este problema non
	  poderá xurdir cando a matriz <math>T</math> sexa definida
	  positiva.
	</para>
      </description>
    </function>

    <function name="tolower" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha cadea de texto que é unha copia de <argname>s</argname>,
	  na que todas as letras en maiúsculas convertéronse en minúsculas.
	</para>
    <para>
        Exemplos:
    </para>
    <code>
        string s1 = "Hola, Gretl!"
        string s2 = tolower(s1)
        print s2

        string s3 = tolower("Hola, Gretl!")
        print s3
    </code>
      </description>
    </function>

    <function name="toupper" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha cadea de texto que é unha copia de <argname>s</argname>,
	  na que todas as letras en minúsculas convertéronse en maiúsculas.
	</para>
    <para>
        Exemplos:
    </para>
    <code>
        string s1 = "Hola, Gretl!"
        string s2 = toupper(s1)
        print s2

        string s3 = toupper("Hola, Gretl!")
        print s3
    </code>
      </description>
    </function>

    <function name="tr" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar coa traza da matriz cadrada <argname>A</argname>,
	  é dicir, a suma dos elementos da súa diagonal.
	  <seelist>
            <fncref targ="diag"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="transp" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz que é a trasposta de <argname>X</argname>. Aviso:
	  Esta función utilízase raramente. Para traspor unha matriz, en xeral
	  podes usar simplemente o operador para transposición: <lit>X'</lit>.
	</para>
      </description>
    </function>

    <function name="trimr" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">tsup</fnarg>
	<fnarg type="int">tinf</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz que é unha copia da matriz <argname>X</argname>
	  na que se eliminaron as <argname>tsup</argname> filas superiores
	  e as <argname>tinf</argname> filas inferiores. Os dous últimos
	  argumentos non deben de ser negativos, e a súa suma debe de ser menor
	  ca o total de filas de <argname>X</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="selifr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="typeof" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">nome</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un código de tipo numérico cando <argname>nome</argname>
	  é unha cadea de texto que identifica un obxecto que xa está definido:
	  1 para un escalar, 2 para unha serie, 3 para unha matriz, 4 para unha
	  cadea de texto, 5 para un feixe, 6 para un arranxo e 7 para unha
	  lista; noutro caso devolve 0. Para obter a cadea de texto que concorda
	  co valor que se devolve, podes usar a función <fncref targ="typestr"/>.
	</para>
	<para>
	  Tamén podes utilizar esta función para obter que tipo de elemento é
	  un dos que compoñen un feixe ou un arranxo. Por exemplo...
	</para>
	<code>
	  matrices M = array(1)
	  eval typestr(typeof(M))
	  eval typestr(typeof(M[1]))
	</code>
	<para>
	  .. no que o primeiro resultado da función <lit>eval</lit> é un
	  <quote>arranxo</quote>, e o segundo é unha <quote>matriz</quote>.
	</para>
      </description>
    </function>

    <function name="typestr" section="data-utils" output="string">
      <fnargs>
	<fnarg type="int">codigotipo</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha cadea de texto co nome do tipo de dato de Gretl que
	  se corresponde co argumento <argname>codigotipo</argname>. Podes
	  utilizalo xuntamente coas funcións <fncref targ="typeof"/> e
	  <fncref targ="inbundle"/>. A cadea de texto que se devolve pode ser
	  unha das seguintes: <quote>scalar</quote>, <quote>series</quote>,
	  <quote>matrix</quote>, <quote>string</quote>,
	  <quote>bundle</quote>, <quote>array</quote>,
	  <quote>list</quote>, ou <quote>null</quote>.
	</para>
      </description>
    </function>

    <function name="uniform" section="probdist" output="series">
      <fnargs>
	<fnarg type="scalar">a</fnarg>
	<fnarg type="scalar">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha serie que se xera cunha variable pseudoaleatoria
	  Uniforme que toma valores dentro do intervalo (<argname> a</argname>,
	  <argname>b</argname>) ou, se non indicas eses argumentos, no
	  intervalo (0,1). O algoritmo que se utiliza por defecto é o
	  <quote>SIMD-oriented Fast Mersenne Twister</quote> desenvolvido por 
	  <cite key="saito_matsumoto08">Saito e Matsumoto (2008)</cite>.
	</para>
	<para>
	  <seelist>
            <fncref targ="randgen"/>
            <fncref targ="normal"/>
            <fncref targ="mnormal"/>
            <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="uniq" section="stats" output="cvec">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector que contén os distintos elementos do argumento
	  <argname>x</argname> sen ningunha orde especial, senón na que
	  están en <argname>x</argname>. Consulta <fncref targ="values"/>
	  para a variante desta función que devolve os valores ordenados.
	</para>
      </description>
    </function>

    <function name="unvech" section="matbuild" output="smatrix">
      <fnargs>
	<fnarg type="vector">v</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve a matriz simétrica de orde <by r="n" c="n"/> que se obtén
	  reordenando os elementos do vector <math>v</math> en forma de matriz
	  triangular inferior, e copiando os das posicións simétricas. O número
	  de elementos de <math>v</math> debe de ser un enteiro triangular,
	  ou sexa, un número <math>k</math> tal que exista un enteiro
	  <math>n</math> que cumpra a seguinte propiedade:
	  <equation status="inline" ascii="k = n(n+1)/2" tex="$k = n(n+1)/2$"/>.
	  Esta función é a inversa de <fncref targ="vech"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="mshape"/>
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="upper" section="matbuild" output="smatrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devolve unha matriz triangular superior de orde <by r="n" c="n"/>. Os
	  elementos da diagonal e os de arriba desta, son iguais aos elementos que
	  se corresponden en <argname>A</argname>; os demais son iguais a cero.
	</para>
	<para context="tex">
	  Devolve unha matriz triangular superior <math>B</math> de orde
	  $n\times n$ onde $B_{ij} = A_{ij}$ se $i \le j$, e 0 noutro caso.
	</para>
	<para>
	  <seelist>
            <fncref targ="lower"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="urcpval" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="scalar">tau</fnarg>
	<fnarg type="int">n</fnarg>
	<fnarg type="int">niv</fnarg>
	<fnarg type="int">itv</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar coa probabilidade asociada (<math>P</math>) ao
	  valor do estatístico para facer a proba de raíces unitarias de
	  Dickey-Fuller ou a proba de cointegración de Engle&ndash;Granger,
	  conforme a <cite key="mackinnon96">James MacKinnon (1996)</cite>.
	</para>
	<para>
	  Os argumentos exprésanse deste xeito: <argname>tau</argname> indica
	  o valor do estatístico de proba que corresponda; <argname>n</argname>
	  sinala o número de observacións (ou 0 se o que queres é un resultado
	  asintótico);<argname>niv</argname> denota o número de variables
	  potencialmente cointegradas, se comprobas a cointegración (ou 1 se fas
	  unha proba univariante de raíces unitarias); e <argname>itv</argname>
	  é un código que especifica o tipo modelo (1 = sen constante, 2 = con
	  constante, 3 = con constante máis tendencia linear, 4 = con constante máis
	  tendencia cadrada).
	</para>
	<para>
	  Ten en conta que debes de darlle un valor de 0 a <argname>n</argname>
	  para obter un resultado asintótico, se a regresión auxiliar para a
	  proba é <quote>ampliada</quote> con retardos da variable dependente.
	</para>
	<para>
	  <seelist>
            <fncref targ="pvalue"/>
	    <fncref targ="qlrpval"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="values" section="stats" output="cvec">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector que contén os distintos elementos do argumento
	  <argname>x</argname> ordenados de forma ascendente. Se queres
	  descartar a parte decimal antes de aplicar esta función, utiliza a
	  expresión <lit>values(int(x))</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="uniq"/>
            <fncref targ="dsort"/>
            <fncref targ="sort"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="var" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Cando <argname>x</argname> é unha serie, devolve un escalar coa
	  súa varianza na mostra, descartando calquera observación ausente.
	</para>
	<para>
	  Cando <argname>x</argname> é unha lista, devolve unha serie
	  <math>y</math> na que cada valor <math>y</math><sub>t</sub> indica
	  a varianza na mostra dos valores das variables da lista na observación
	  <math>t</math>, ou <lit>NA</lit> se algún deses valores está ausente
	  en <math>t</math>.
	</para>
	<para>
	  En cada un deses casos, a suma dos cadrados das desviacións con
	  respecto á media divídese por (<math>n</math> &minus; 1) cando
	  <math>n</math> &gt; 1. Noutro caso, indícase que a varianza é igual
	  a cero se <math>n</math> = 1, ou é igual a <lit>NA</lit> se
	  <math>n</math> = 0.
	</para>
	<para>
	  <seelist>
            <fncref targ="sd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="varname" section="strings" output="string">
      <fnargs>
	<fnarg type="int-or-list">v</fnarg>
      </fnargs>
      <description>
	<para>
	  Cando se indica un número enteiro como argumento, a función devolve
	  unha cadea de texto co nome da variable que ten un número ID igual a
	  <argname>v</argname>, ou xera un fallo se esa variable non existe.
	</para>
	<para>
	  Cando se indica unha lista como argumento, devolve unha cadea de
	  texto que contén os nomes das variables da lista, separados por
	  comas. Se indicas unha lista que está baleira, devólvese unha cadea
	  de texto baleira. En troques, podes utilizar <fncref targ="varnames"/>
	  para obter un arranxo de cadeas de texto .
	</para>
    <para>
        Exemplo:
    </para>
    <code>
        open broiler.gdt
        string s = varname(7)
        print s
    </code>
      </description>
    </function>

    <function name="varnames" section="strings" output="strings">
      <fnargs>
	<fnarg type="list">L</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un arranxo de cadeas de texto que contén os nomes das
	  variables da lista <argname>L</argname>. Se a lista que indicas
	  está baleira, devólvese un arranxo baleiro.
	</para>
    <para>
        Exemplo:
    </para>
    <code>
        open keane.gdt
        list L = year wage status
        strings S = varnames(L)
        eval S[1]
        eval S[2]
        eval S[3]
    </code>
      </description>
    </function>

    <function name="varnum" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">nomevar</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un número enteiro co código ID da variable que ten o nome
	  do argumento <argname>nomevar</argname>, ou NA se esa variable
	  non existe.
	</para>
      </description>
    </function>

    <function name="varsimul" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix">U</fnarg>
	<fnarg type="matrix">y0</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz ao simular un VAR de orde <math>p</math> e
	  <math>n</math> variables, é dicir
	  <equation status="inline"
		    ascii="y(t) = A1 y(t-1) + ... + Ap y(t-p) + u(t)."
		    tex="$y_t = \sum_{i=1}^p A_i y_{t-i} + u_t$."/>
	  A matriz <argname>A</argname> de coeficientes fórmase agrupando
	  horizontalmente as matrices <math>A</math><sub>i</sub>; e é de
	  orde <by r="n" c="np"/>, con unha fila por cada ecuación. Esta
	  se corresponde coas primeiras <math>n</math> filas da matriz
	  <lit>$compan</lit> que proporcionan as instrucións <lit>var</lit> e
	  <lit>vecm</lit> de Gretl.
	</para>
	<para>
	  Os vectores <math>u_t</math> están incluídos (como filas) na matriz
	  <argname>U</argname> (<by r="T" c="n"/>). Os valores iniciais están
	  en <argname>y0</argname> (<by r="p" c="n"/>).
	</para>
	<para>
	  Cando o VAR contén algún termo determinista e/ou regresores
	  esóxenos, podes manexalos incorporándoos á matriz
	  <argname>U</argname>: neste caso cada fila de <argname>U</argname>
	  pasa a ser entón
	  <equation status="inline"
		    ascii="u(t) = B'x(t) + e(t)."
		    tex="$u_t = B' x_t + e_t$."/>
	</para>
	<para>
	  A matriz que resulta ten <math>T</math> + <math>p</math> filas e
	  <math>n</math> columnas; contén os <math>p</math> valores iniciais
	  das variables endóxenas, ademais de <math>T</math> valores
	  simulados.
	</para>
	<para>
	  <seelist>
            <fncref targ="$compan"/>
            <cmdref targ="var"/>
            <cmdref targ="vecm"/>
	  </seelist>
	</para>

      </description>
    </function>

    <function name="vec" section="matbuild" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector columna, encastelando as columnas de <argname>X</argname>.
	  <seelist>
            <fncref targ="mshape"/>
            <fncref targ="unvech"/>
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="vech" section="matbuild" output="cvec">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector columna cos elementos de <argname>A</argname> que
	  están na súa diagonal principal e por enriba dela. Normalmente esta
	  función utilízase con matrices simétricas; neste caso, esa operación
	  pode reverterse a través da función <fncref targ="unvech"/>.
	  <seelist>
            <fncref targ="vec"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="weekday" section="calendar" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-series">ano</fnarg>
	<fnarg type="scalar-or-series">mes</fnarg>
	<fnarg type="scalar-or-series">día</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve o día da semana (domingo = 0, luns = 1, etc.) da data
	  especificada polos tres argumentos, ou <lit>NA</lit> se a data
	  non é correcta. Ten en conta que os tres argumentos deben de ser
	  do mesmo tipo; ou sexa, deben de ser todos de tipo escalar (enteiro)
	  ou todos de tipo serie.
	</para>
      </description>
    </function>

    <function name="wmean" section="stats" output="series">
      <fnargs>
	<fnarg type="list">Y</fnarg>
	<fnarg type="list">W</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha serie <math>y</math> calculada de forma que cada
	  <math>y</math><sub>t</sub> indica a media ponderada dos
	  valores (na observación <math>t</math>) das variables presentes na
	  lista <argname>Y</argname>, coas respectivas ponderacións sinaladas
	  polos valores das variables que forman a lista <argname>W</argname>
	  en cada <math>t</math>. As ponderacións poden así variar no tempo.
	  As listas <argname>Y</argname> e <argname>W</argname> de variables
	  deben de ter o mesmo tamaño, e as ponderacións deben de ser non
	  negativas.
	</para>
	<para>
	  <seelist>
            <fncref targ="wsd"/>
            <fncref targ="wvar"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="wsd" section="stats" output="series">
      <fnargs>
	<fnarg type="list">Y</fnarg>
	<fnarg type="list">W</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha serie <math>y</math> calculada de forma que cada
	  <math>y</math><sub>t</sub> indica a desviación padrón ponderada
	  na mostra, dos valores (na observación <math>t</math>) das variables
	  presentes na lista <argname>Y</argname>, coas respectivas ponderacións
	  sinaladas polos valores das variables da lista <argname>W</argname>
	  en cada <math>t</math>. As ponderacións poden así variar no tempo.
	  As listas <argname>Y</argname> e <argname>W</argname> de variables
	  deben de ter o mesmo tamaño, e as ponderacións deben de ser non
	  negativas.
	</para>
	<para>
	  <seelist>
            <fncref targ="wmean"/>
            <fncref targ="wvar"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="wvar" section="stats" output="series">
      <fnargs>
	<fnarg type="list">X</fnarg>
	<fnarg type="list">W</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha serie <math>y</math> calculada de forma que cada
	  <math>y</math><sub>t</sub> indica a varianza ponderada na mostra,
	  dos valores (na observación <math>t</math>) das variables presentes na
	  lista <argname>Y</argname>, coas respectivas ponderacións sinaladas
	  polos valores das variables que forman a lista <argname>W</argname>
	  en cada <math>t</math>. As ponderacións poden así variar no tempo.
	  As listas <argname>Y</argname> e <argname>W</argname> de variables
	  deben de ter o mesmo tamaño, e as ponderacións deben de ser non
	  negativas.
	</para>
	<para context="tex">
	  A varianza ponderada na mostra calcúlase mediante
	  \[ s^2_w = \frac{n'}{n'-1} \,
	  \frac{\sum_{i=1}^n w_i(x_i - \bar{x}_w)^2}{\sum_{i=1}^n w_i} \]
	  onde $n'$ indica o número de ponderacións non nulas e $\bar{x}_w$
	  indica a media ponderada.
	</para>
	<para>
	  <seelist>
            <fncref targ="wmean"/>
            <fncref targ="wsd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="xmax" section="math" output="scalar">
      <fnargs>
	<fnarg type="scalar">x</fnarg>
	<fnarg type="scalar">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co maior valor que resulta de comparar
	  <argname>x</argname> e <argname>y</argname>. Se algún dos
	  valores está ausente, devólvese <lit>NA</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="xmin"/>
            <fncref targ="max"/>
            <fncref targ="min"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="xmin" section="math" output="scalar">
      <fnargs>
	<fnarg type="scalar">x</fnarg>
	<fnarg type="scalar">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co menor valor que resulta de comparar
	  <argname>x</argname> e <argname>y</argname>. Se algún dos
	  valores está ausente, devólvese <lit>NA</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="xmax"/>
            <fncref targ="max"/>
            <fncref targ="min"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="xmlget" section="data-utils" output="string">
      <fnargs>
	<fnarg type="string">buf</fnarg>
	<fnarg type="string-or-strings">ruta</fnarg>
      </fnargs>
      <description>
	<para>
	  O argumento <argname>buf</argname> debe de ser un búfer
	  XML, tal como pode recuperarse dun lugar web adecuado
	  mediante a función <fncref targ="curl"/> (ou lerse dun
	  ficheiro mediante a función <fncref targ="readfile"/>);
	  e o argumento <argname>ruta</argname> debe de ser, ben
	  unha especificación XPath sinxela ou ben un arranxo delas.
	</para>
	<para>
	  Esta función devolve unha cadea de texto que representa os datos
	  atopados no búfer XML na ruta especificada. Se hai múltiples nodos
	  que coincidan coa expresión da ruta, as unidades de datos se
	  presentan unha por cada liña da cadea que se devolve. Cando indicas
	  un arranxo de rutas como segundo argumento, a cadea que se devolve
	  ten a forma dun búfer separado con comas, cuxa columna <math>i</math>
	  contén as coincidencias da ruta <math>i</math>. Neste caso, se unha
	  cadea obtida do búfer XML contén algún espazo ou coma, contórnase
	  entre comiñas.
	</para>
	<para>
	  Por defecto, amósase un fallo se <argname>ruta</argname> non
	  coincide no búfer XML; pero este comportamento modifícase
	  se indicas o terceiro argumento (opcional) pois, neste
	  caso, o argumento recupera un reconto das coincidencias, devolvéndose
	  unha cadea baleira se non hai ningunha. Chamada de exemplo:
	</para>
	<code>
	  ngot = 0
	  ret = xmlget(xbuf, "//some/thing", &amp;ngot)
	</code>
	<para>
	  Agora ben, aínda vaise amosar un fallo no caso de facer unha solicitude
	  mal configurada.
	</para>	
	<para>
	  Podes atopar unha boa introdución ao uso e á sintaxe de
	  XPath en
	  <url>https://www.w3schools.com/xml/xml_xpath.asp</url>.
	  O programa de soporte (back-end) para <lit>xmlget</lit>
	  o proporciona o módulo xpath de libxml2, que admite
	  XPath 1.0 pero non XPath 2.0.
	</para>
	<para>
	  <seelist>
	    <fncref targ="jsonget"/>
	    <fncref targ="readfile"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="zeromiss" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) trocando os ceros en
	  <lit>NA</lit>s. Se <argname>x</argname> é unha serie, troca cada elemento.
	  <seelist>
            <fncref targ="missing"/>
            <fncref targ="misszero"/>
            <fncref targ="ok"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="zeros" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg optional="true" type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz nula con <math>r</math> filas e <math>c</math>
	  columnas. Se o omites, o número de columnas establécese en 1
	  (vector columna), por defecto.
      <seelist>
        <fncref targ="ones"/>
        <fncref targ="seq"/>
      </seelist>
    </para>
      </description>
    </function>

  </funclist>
</funcref>
