<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE funcref SYSTEM "gretl_functions.dtd">

<funcref language="galego">

  <funclist name="Accessors" ref="accessors">

    <function name="$ahat" section="access" output="series">
      <description>
	<para>
	  Debe de executarse logo de que o último modelo se estimase con datos de
	  panel de efectos fixos ou de efectos aleatorios. Devolve unha serie que
	  contén as estimacións dos efectos individuais.
	</para>
      </description>
    </function>

    <function name="$aic" section="access" output="scalar">
      <description>
	<para>
	  Se pode calcularse, devolve un escalar co valor do Criterio de
	  Información de Akaike (AIC) do último modelo estimado. Máis detalles
	  sobre o cálculo no <guideref targ="chap:criteria"/>.
	</para>
      </description>
    </function>

    <function name="$bic" section="access" output="scalar">
      <description>
	<para>
	  Se pode calcularse, devolve un escalar co valor do Criterio de
	  Información Bayesiano (BIC) de Schwarz do último modelo estimado.
	  Máis detalles sobre o cálculo no <guideref targ="chap:criteria"/>.
	</para>
      </description>
    </function>

    <function name="$chisq" section="access" output="scalar">
      <description>
	<para>
	  Se pode calcularse, devolve un escalar co valor do estatístico Khi-cadrado
	  global da proba de Razón de Verosimilitudes do último modelo estimado.
	</para>
      </description>
    </function>

    <function name="$coeff" section="access" output="matrix" altout="scalar">
      <fnargs>
	<fnarg optional="true" type="coeffname">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Sen argumentos <lit>$coeff</lit> devolve un vector columna que contén
	  os coeficientes do último modelo estimado. Co argumento opcional de
	  texto <lit>(nome dun regresor)</lit> a función devolve un escalar co
	  valor do parámetro estimado dese regresor.
	  <seelist>
            <fncref targ="$stderr"/>
            <fncref targ="$vcv"/>
	  </seelist>
	</para>
	<para>
	  Exemplo:
	</para>
	<code>
	  open bjg
	  arima 0 1 1 ; 0 1 1 ; lg
	  b = $coeff               # Devolve un vector
	  macoef = $coeff(theta_1) # Devolve un escalar
	</code>
	<para>
	  Se o <quote>modelo</quote> en cuestión é un sistema de ecuacións,
	  o resultado depende das características deste; para VARs e VECMs
	  o resultado devolto é una matriz con unha columna por cada ecuación;
	  noutro caso é un vector columna que contén os coeficientes da primeira
	  ecuación seguidos polos coeficientes da segunda ecuación e así de
	  maneira sucesiva.
	</para>
      </description>
    </function>

    <function name="$command" section="access" output="string">
      <description>
	<para>
	  Debe executarse tras estimar un modelo e devolve a cadea cos caracteres
	  da instrución utilizada (exemplo: <lit>ols</lit> ou <lit>probit</lit>).
	</para>
      </description>
    </function>

    <function name="$compan" section="access" output="matrix">
      <description>
	<para>
	  Debe executarse logo da estimación dun VAR ou dun VECM e devolve a
	  matriz compañeira.
	</para>
      </description>
    </function>

    <function name="$datatype" section="access" output="scalar">
      <description>
	<para>
	  Devolve un escalar enteiro que representa o tipo de datos que se están
	  utilizando actualmente: 0 = sen datos; 1 = datos de corte transversal;
	  2 = datos de series temporais; 3 = datos de panel.
	</para>
      </description>
    </function>

    <function name="$depvar" section="access" output="string">
      <description>
	<para>
	  Debe executarse logo da estimación dun modelo con unha única ecuación
	  e devolve unha cadea de texto co nome da variable dependente.
	</para>
      </description>
    </function>

    <function name="$df" section="access" output="scalar">
      <description>
	<para>
	  Devolve un escalar cos graos de liberdade do último modelo estimado.
	  Se este é un sistema de ecuacións, o valor devolto é o número de graos
	  de liberdade por cada ecuación. Se os graos de liberdade das diferentes
	  ecuacións non son os mesmos en todas elas, entón o valor devolto se
	  calcula restando o número de observacións menos a media do número de
	  coeficientes das ecuacións (esta media arredóndase ao valor enteiro
	  inmediatamente superior).
	</para>
      </description>
    </function>

    <function name="$diagpval" section="access" output="scalar">
      <description>
	<para>
	  Debe executarse logo da estimación dun sistema de ecuacións e devolve
	  un escalar coa probabilidade asociada ao valor do estatístico
	  <fncref targ="$diagtest"/>.
	</para>
      </description>
    </function>

    <function name="$diagtest" section="access" output="scalar">
      <description>
	<para>
	  Debe executarse logo da estimación dun sistema de ecuacións. Devolve
	  un escalar co valor do estatístico utilizado para probar a hipótese
	  nula de que a matriz de varianzas-covarianzas dos erros das ecuacións
	  do sistema, é diagonal. Esta é a proba de Breusch-Pagan, agás cando
	  o estimador é o dun SUR reiterado (sen restricións), pois nese caso é
	  unha proba de Razón de Verosimilitudes. Para obter máis detalles, véxase
	  o <guideref targ="chap:system"/>  (tamén <fncref targ="$diagpval"/>).
	</para>
      </description>
    </function>

    <function name="$dw" section="access" output="scalar">
      <description>
	<para>
	  Devolve un escalar (se é posible) co valor do estatístico de Durbin&ndash;Watson
	  para probar autocorrelación de primeira orde no derradeiro model estimado.
	</para>
      </description>
    </function>

    <function name="$dwpval" section="access" output="scalar">
      <description>
	<para>
	  Se pode calcularse, devolve un escalar coa probabilidade asociada ao
	  valor do estatístico de Durbin-Watson do último modelo estimado.
	  Calcúlase utilizando o método Imhof.
	</para>
	<para>
	  Debido á limitada precisión da aritmética das computadoras, o resultado
	  do cálculo da integral do método Imhof pode volverse negativo cando
	  o estatístico de Durbin-Watson está próximo ao seu límite inferior;
	  por iso este accesorio devolve <lit>NA</lit> nesa situación. Dado que
	  calquera outra modalidade de fallo ten como resultado un erro que se
	  sinaliza, posiblemente é seguro asumir que un resultado NA indica que
	  a verdadeira probabilidade asociada é <quote>moi pequena</quote>,
	  aínda que non sexa posible cuantificala.
	</para>
      </description>
    </function>

    <function name="$ec" section="access" output="matrix">
      <description>
	<para>
	  Debe executarse logo da estimación dun VECM e devolve unha matriz que
	  contén os termos de Corrección de Erros. O número de filas é igual ao
	  número de observacións utilizadas e o número de columnas é igual á orde
	  de cointegración do sistema.
	</para>
      </description>
    </function>

    <function name="$error" section="access" output="scalar">
      <description>
	<para>
	  Devolve un escalar cun dos códigos internos de fallo do programa. Ese
	  código é un valor non nulo cando ocorre un fallo pero é capturado usando
	  a función <cmdref targ="catch"/>. Cae na conta de ao utilizar este
	  accesorio, o código interno de fallo vólvese novamente cero. Se desexas
	  obter a mensaxe de fallo asociada a un <lit>$error</lit> en concreto,
	  é preciso gardar o seu valor nunha variable provisional, por exemplo
	  utilizando o código:
	</para>
	<code>
	  err = $error
	  if (err)
	      printf "Obtívose o fallo %d (%s)\n", err, errmsg(err);
	  endif
	</code>
	<para>
	  <seelist>
            <cmdref targ="catch"/>
            <fncref targ="errmsg"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$ess" section="access" output="scalar">
      <description>
	<para>
	  Se pode calcularse, devolve un escalar coa suma dos erros cadrados do
	  último modelo estimado.
	</para>
      </description>
    </function>

    <function name="$evals" section="access" output="matrix">
      <description>
	<para>
	  Debe executarse logo da estimación dun VECM e devolve un vector que
	  contén os autovalores que se utilizan no cálculo da proba da traza para
	  verificar se existe cointegración.
	</para>
      </description>
    </function>

    <function name="$fcast" section="access" output="matrix">
      <description>
	<para>
	  Debe executarse logo da instrución de predición <cmdref targ="fcast"/>
	  e devolve unha matriz cos valores previstos. Se o modelo que se utiliza
	  para facer as predicións é un sistema de ecuacións, a matriz está
	  formada por unha columna para cada ecuación; noutro caso é un vector
	  columna.
	</para>
      </description>
    </function>

    <function name="$fcse" section="access" output="matrix">
      <description>
	<para>
	  Se pode calcularse, debe executarse logo de procesar a instrución
	  <cmdref targ="fcast"/> e devolve unha matriz cas desviacións padrón
	  das predicións. Se o modelo que se utiliza para facer as predicións é
	  un sistema de ecuacións, a matriz está formada por unha columna para
	  cada ecuación; noutro caso é un vector columna.
	</para>
      </description>
    </function>

    <function name="$fevd" section="access" output="matrix">
      <description>
	<para>
	  Debe executarse logo da estimación dun VAR e devolve unha matriz que
	  contén a descomposición da varianza dos erros de predición (FEVD, na
	  sigla en inglés). Esa matriz ten <math>h</math> filas que indican o
	  número de períodos do horizonte de predición, o cal pode escollerse
	  de forma manual por medio de <lit>set horizon</lit> ou de forma
	  automática en base á frecuencia dos datos.
	</para>
	<para>
	  Para un VAR con <math>p</math> variables, a matriz ten <math>p</math>
	  <sup>2</sup> columnas: as primeiras <math>p</math> columnas conteñen
	  a FEVD para a primeira variable do VAR; as <math>p</math> columnas
	  seguintes conteñen a FEVD para a segunda variable do VAR e así de
	  maneira sucesiva. A fracción (decimal) do erro de predición da variable
	  <math>i</math> causada por unha innovación na variable <math>j</math>
	  vai atoparse entón inspeccionando a columna (<math>i</math> &minus; 1)
	  <math>p</math> + <math>j</math>.
	</para>
	<para>
	  Para unha variante máis flexible desta funcionalidade, consulta a
	  función <fncref targ="fevd"/>.
	</para>
      </description>
    </function>

    <function name="$Fstat" section="access" output="scalar">
      <description>
	<para>
	  Se pode calcularse, devolve un escalar co estatístico F da proba de
	  validez global do último modelo estimado.
	</para>
      </description>
    </function>

    <function name="$gmmcrit" section="access" output="scalar">
      <description>
	<para>
	  Debe executarse logo dun bloque <lit>gmm</lit> (do Método Xeneralizado
	  dos Momentos) e devolve un escalar co mínimo da función obxectivo.
	</para>
      </description>
    </function>

    <function name="$h" section="access" output="series">
      <description>
	<para>
	  Debe executarse logo da instrución <lit>garch</lit> e devolve unha
	  serie coas varianzas condicionais estimadas.
	</para>
      </description>
    </function>

    <function name="$hausman" section="access" output="rvec">
      <description>
	<para>
	  Debe executarse logo de estimar un modelo por medio de <lit>tsls</lit>
	  ou <lit>panel</lit> coa opción de efectos aleatorios e devolve un
	  vector fila <by r="1" c="3"/> que contén nesta orde: o valor do
	  estatístico da proba de Hausman, os graos de liberdade que se
	  corresponden e a probabilidade asociada ao valor do estatístico.
	</para>
     </description>
    </function>

    <function name="$hqc" section="access" output="scalar">
      <description>
	<para>
	  Se pode calcularse, devolve un escalar co valor do Criterio de
	  Información de Hannan-Quinn para o último modelo estimado. Para
	  detalles sobre o cálculo, consulta o <guideref targ="chap:criteria"/>.
	</para>
      </description>
    </function>

    <function name="$huge" section="access" output="scalar">
      <description>
	<para>
	  Devolve un escalar cun número positivo moi grande. Por defecto é igual
	  a 1.0E100, pero pode cambiarse coa instrución <cmdref targ="set"/>.
	</para>
      </description>
    </function>

    <function name="$jalpha" section="access" output="matrix">
      <description>
	<para>
	  Debe executarse logo de estimar un VECM e devolve a matriz de carga.
	  O número de filas desa matriz é igual ao número de variables do VECM,
	  e o número de columnas é igual ao rango de cointegración.
	</para>
      </description>
    </function>

    <function name="$jbeta" section="access" output="matrix">
      <description>
	<para>
	  Debe executarse logo de estimar un VECM e devolve a matriz de
	  cointegración. O seu número de filas é igual ao número de variables do
	  VECM (máis o número de variables esóxenas que se restrinxen ao espazo
	  de cointegración, se hai algunha); e o seu número de columnas é igual
	  ao rango de cointegración.
	</para>
      </description>
    </function>

    <function name="$jvbeta" section="access" output="smatrix">
      <description>
	<para>
	  Debe executarse logo de estimar un VECM e devolve a matriz estimada de
	  varianzas-covarianzas dos elementos dos vectores de cointegración.
	</para>
	<para>
	  No caso de tratarse dunha estimación sen restricións, o número de filas
	  desa matriz é igual ao número de elementos non restrinxidos do espazo
	  de cointegración logo da normalización de Phillips. Polo contrario, de
	  tratarse da estimación dun sistema restrinxido por medio da instrución
	  <lit>restrict</lit> coa opción <lit>--full</lit>, obtense unha matriz
	  singular con <math>(n+m)r</math> filas (onde <math>n</math> é o número
	  de variables endóxenas, <math>m</math> o número de variables esóxenas
	  restrinxidas ao espazo de cointegración e <math>r</math> o rango de
	  cointegración).
	</para>
	<para>
	  Exemplo: o código...
	</para>
	<code>
	  open denmark.gdt
	  vecm 2 1 LRM LRY IBO IDE --rc --seasonals -q
	  s0 = $jvbeta

	  restrict --full
	    b[1,1] = 1
	    b[1,2] = -1
	    b[1,3] + b[1,4] = 0
	  end restrict
	  s1 = $jvbeta

	  print s0
	  print s1
	</code>
	<para>
	  ... orixina o seguinte resultado:
	</para>
	<code>
	  s0 (4 x 4)

          0.019751     0.029816  -0.00044837     -0.12227
          0.029816      0.31005     -0.45823     -0.18526
	   -0.00044837     -0.45823       1.2169    -0.035437
          -0.12227     -0.18526    -0.035437      0.76062

	  s1 (5 x 5)

	  0.0000       0.0000       0.0000       0.0000       0.0000
	  0.0000       0.0000       0.0000       0.0000       0.0000
	  0.0000       0.0000      0.27398     -0.27398    -0.019059
	  0.0000       0.0000     -0.27398      0.27398     0.019059
	  0.0000       0.0000    -0.019059     0.019059    0.0014180
	</code>
      </description>
    </function>

    <function name="$lang" section="access" output="string">
      <description>
	<para>
	  Devolve unha cadea de texto que representa o idioma que se está usando
	  (se este pode determinarse). A cadea de texto está composta por dúas
	  letras do código de linguaxe ISO 639-1 (por exemplo, <lit>en</lit>
	  para o idioma inglés, <lit>jp</lit> para o xaponés, <lit>el</lit> para
	  o grego) seguidas dun subliñado máis outras dúas letras do código de
	  país ISO 3166-1. Así, por exemplo, o idioma portugués de Portugal
	  represéntase por <lit>pt_PT</lit> ao tempo que o idioma portugués do
	  Brasil represéntase por <lit>pt_BR</lit>.
	</para>
	<para>
	  Se non é posible determinar o idioma actual, se devolve o texto
	  <quote><lit>unknown</lit></quote>.
	</para>
      </description>
    </function>

    <function name="$llt" section="access" output="series">
      <description>
	<para>
	  Para unha selección de modelos que se estiman polo método de Máxima
	  Verosimilitude, a función devolve unha serie cos valores do logaritmo
	  da verosimilitude para cada observación. Polo momento esa función só
	  está dispoñible para logit e probit binarios, tobit e heckit.
	</para>
      </description>
    </function>

    <function name="$lnl" section="access" output="scalar">
      <description>
	<para>
	  Devolve un escalar co logaritmo da verosimilitude do último modelo
	  estimado (se fose aplicable).
	</para>
      </description>
    </function>

    <function name="$macheps" section="access" output="scalar">
      <description>
	<para>
	  Devolve un escalar co valor do <quote>épsilon da máquina</quote>,
	  o cal proporciona un límite superior para o erro relativo debido ao
	  arredondamento na aritmética de punto flotante con dobre precisión.
	</para>
      </description>
    </function>

    <function name="$mnlprobs" section="access" output="matrix">
      <description>
	<para>
	  Debe executarse tras estimar un modelo logit multinomial (unicamente)
	  e devolve unha matriz coas probabilidades estimadas de cada resultado
	  posible, en cada observación da mostra utilizada na estimación do
	  modelo. Cada liña representa unha observación e cada columna un
	  resultado.
	</para>
      </description>
    </function>

    <function name="$model" section="access" output="bundle">
      <description>
	<para>
	  Debe executarse logo de estimar modelos cunha única ecuación e
	  devolve un feixe (<quote>bundle</quote>) que contén varias unidades de
	  datos pertencentes ao modelo. Inclúense todos os accesorios habituais
	  dos modelos, que son designados mediante claves iguais aos nomes
	  deses accesorios habituais menos o signo dólar inicial. Por exemplo,
	  os erros aparecen baixo a clave <lit>uhat</lit> e a suma de erros
	  cadrados baixo <lit>ess</lit>.
	</para>
	<para>
	  Dependendo do estimador, podes dispoñer de información adicional. As
	  claves para tal información é de agardar que sexan explicativas por si
	  mesmas. Para ver o que está dispoñible podes gardar unha copia do
	  feixe e mostrar o seu contido, como por exemplo co código:
	</para>
	<code>
	  ols y 0 x
	  bundle b = $model
	  print b
	</code>
      </description>
    </function>

    <function name="$ncoeff" section="access" output="int">
      <description>
	<para>
	  Devolve un número enteiro coa cantidade de coeficientes estimados
	  no último modelo.
	</para>
      </description>
    </function>

    <function name="$nobs" section="access" targ="dnobs" output="int">
      <description>
	<para>
	  Devolve un número enteiro coa cantidade total de observacións que están
	  seleccionadas na mostra actual. Relacionado: <fncref label="\$tmax" targ="dtmax"/>.
	</para>
      </description>
    </function>

    <function name="$nvars" section="access" output="int">
      <description>
	<para>
	  Devolve un número enteiro coa cantidade de variables incluídas no
	  conxunto de datos actual (contando coa constante).
	</para>
      </description>
    </function>

    <function name="$obsdate" section="access" output="series">
      <description>
	<para>
	  Pode executarse cando o conxunto de datos actual está formado por
	  series temporais con frecuencia decenal, anual, trimestral, mensual,
	  datadas semanalmente ou datadas diariamente. Tamén pode utilizarse con
	  datos de panel se a información temporal está axustada correctamente
	  (consulta a instrución <cmdref targ="setobs"/>). Devolve unha serie
	  formada por números con 8 díxitos co padrón <lit>YYYYMMDD</lit> (o
	  formato de datos <quote>básico</quote> do ISO 8601), que corresponden
	  ao día da observación, ou ao primeiro día da observación no caso dunha
	  frecuencia temporal menor que a diaria.
	</para>
	<para>
	  Estas series poden resultar de utilidade cando se emprega a instrución
	  <cmdref targ="join"/>.
	</para>
      </description>
    </function>

    <function name="$obsmajor" section="access" output="series">
      <description>
	<para>
	  Pode executarse cando as observacións do conxunto de datos actual
	  teñen unha estrutura maior:menor, como en series temporais trimestrais
	  (ano:trimestre), en series temporais mensuais (ano:mes), datos de
	  horas (día:hora) e datos de panel (individuo:período). Devolve unha
	  serie que mantén a compoñente maior (de menor frecuencia), de cada
	  observación (por exemplo, o ano).
	</para>
	<para>
	  <seelist>
            <fncref targ="$obsminor"/>
            <fncref targ="$obsmicro"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$obsmicro" section="access" output="series">
      <description>
	<para>
	  Pode executarse cando as observacións do conxunto de datos actual
	  teñen unha estrutura maior:menor:micro, como nas series temporais
	  datadas diariamente (ano:mes:día). Devolve unha serie que contén a
	  compoñente micro (de maior frecuencia) de cada observación (por
	  exemplo, o día).
	</para>
	<para>
	  <seelist>
            <fncref targ="$obsmajor"/>
            <fncref targ="$obsminor"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$obsminor" section="access" output="series">
      <description>
	<para>
	  Pode executarse cando as observacións do conxunto de datos actual
	  teñen unha estrutura maior:menor, como en series temporais trimestrais
	  (ano:trimestre), series temporais mensuais (ano:mes), datos de horas
	  (día:hora) e datos de panel (individuo:período). Devolve unha serie
	  que contén a compoñente menor (de maior frecuencia) de cada
	  observación (por exemplo, o mes).
	</para>
	<para>
	  No caso de datos datados diariamente, <lit>$obsminor</lit> devolve
	  unha serie co mes de cada observación.
	</para>
	<para>
	  <seelist>
            <fncref targ="$obsmajor"/>
            <fncref targ="$obsmicro"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$pd" section="access" output="int">
      <description>
	<para>
	  Devolve un número enteiro coa frecuencia ou periodicidade dos datos
	  (por exemplo: 4 para datos trimestrais). No caso de datos de panel o
	  valor devolto é a cantidade de períodos de tempo do conxunto de datos.
	</para>
      </description>
    </function>

    <function name="$pi" section="access" output="scalar">
      <description>
	<para>
	  Devolve un escalar co valor de &pi; con dobre precisión.
	</para>
      </description>
    </function>

    <function name="$pvalue" section="access" targ="dpvalue" output="scalar-or-matrix">
      <description>
	<para>
	  Devolve a probabilidade asociada ao valor do estatístico de proba que
	  foi xerado pola última instrución explícita de proba de hipóteses (por
	  exemplo: <lit>chow</lit>). Consulta o <guideref targ="chap:genr"/>
	  para obter máis detalles.
	</para>
	<para>
	  Xeralmente devolve un escalar, mais nalgúns casos devolve unha
	  matriz (por exemplo, isto ocorre coas probabilidades asociadas aos
	  valores dos estatísticos da traza e do máximo-lambda da proba de
	  cointegración de Johansen). Neste caso os valores están dispostos na
	  matriz do mesmo xeito que nos resultados presentados.
	</para>
	<para>
	  <seelist>
            <fncref targ="$test"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$qlrbreak" section="access" output="scalar">
      <description>
	<para>
	  Debe executarse logo da instrución <cmdref targ="qlrtest"/> (que
	  permite facer a proba QLR para a quebra estrutural nun punto
	  descoñecido). Devolve un escalar co número enteiro positivo que indexa
	  a observación na que se maximiza o valor do estatístico de proba.
	</para>
      </description>
    </function>

    <function name="$rho" section="access" output="scalar">
      <fnargs>
	<fnarg optional="true" type="scalar">n</fnarg>
      </fnargs>
      <description>
	<para>
	  Sen argumentos este accesorio devolve o coeficiente de autocorrelación
	  de primeira orde para os erros do último modelo estimado. Agora ben,
	  coa sintaxe <lit>$rho(n)</lit> logo da estimación dun modelo por medio
	  da instrución <lit>ar</lit>, devolve a valor estimado correspondente
	  ao coeficiente &rgr;(<math>n</math>).
	</para>
      </description>
    </function>

    <function name="$rsq" section="access" output="scalar">
      <description>
	<para>
	  Se pode calcularse, devolve un escalar co valor do coeficiente
	  <math>R</math><sup>2</sup> non corrixido do último modelo estimado.
	</para>
      </description>
    </function>

    <function name="$sample" section="access" output="series">
      <description>
	<para>
	  Debe executarse logo de estimar un modelo dunha soa ecuación. Devolve
	  unha serie con unha variable ficticia que ten valores iguais a: 1 nas
	  observacións utilizadas na estimación, 0 nas observacións da mostra
	  actual non utilizadas na estimación (posiblemente debido a valores
	  ausentes), e NA nas observacións fora da mostra seleccionada actual.
	</para>
	<para>
	  Se desexas calcular estatísticos baseados na mostra que se utiliza
	  para un modelo dado, pode facerse, por exemplo co código:
	</para>
	<code>
	  ols y 0 xlist
	  genr sdum = $sample
	  smpl sdum --dummy
	</code>
      </description>
    </function>

    <function name="$sargan" section="access" output="rvec">
      <description>
	<para>
	  Debe executarse logo da instrución <lit>tsls</lit>. Devolve un vector
	  fila <by r="1" c="3"/> que contén, nesta orde: o valor do estatístico
	  da proba de Sobreidentificación de Sargan, os correspondentes graos
	  de liberdade e a probabilidade asociada ao valor do estatístico. Se o
	  modelo está exactamente identificado, o estatístico non se pode
	  calcular e tratar de facelo provoca un fallo.
	</para>
      </description>
    </function>

    <function name="$sigma" section="access" output="scalar-or-matrix">
      <description>
	<para>
	  Se o último modelo estimado foi uniecuacional, devolve un escalar coa
	  Desviación Padrón da regresión (S, ou noutras palabras, a desviación
	  padrón dos erros do modelo coa oportuna corrección dos graos de
	  liberdade). Se o último modelo estimado foi un sistema de ecuacións,
	  devolve unha matriz coas varianzas-covarianzas dos erros das ecuacións
	  do sistema.
	</para>
      </description>
    </function>

    <function name="$stderr" section="access" output="matrix" altout="scalar">
      <fnargs>
	<fnarg optional="true" type="coeffname">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Cando se utiliza sen argumentos, <lit>$stderr</lit> devolve un vector
	  columna que contén as desviacións padrón dos coeficientes do último
	  modelo estimado. Co argumento opcional <lit>(nome dun regresor)</lit>
	  devolve un escalar co valor do parámetro estimado dese regresor
	  <argname>s</argname>.
	</para>
	<para>
	  Se o <quote>modelo</quote> é un sistema de ecuacións, o resultado
	  depende das características deste: para VARs e VECMs o valor devolto
	  é unha matriz que contén unha columna por cada ecuación; noutro caso
	  é un vector columna que contén os coeficientes da primeira ecuación
	  seguidos polos coeficientes da segunda ecuación e así de maneira
	  sucesiva.
	</para>
	<para>
	  <seelist>
            <fncref targ="$coeff"/>
            <fncref targ="$vcv"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$stopwatch" section="access" output="scalar">
      <description>
	<para>
	  Debe executarse logo da instrución <lit>set stopwatch</lit> que activa
	  a medición de tempo da CPU. Ao usar este accesorio por primeira vez
	  obtense un escalar coa cantidade de segundos de CPU que pasaron dende
	  a instrución <lit>set stopwatch</lit>. Con cada acceso, reiníciase o
	  reloxo, polo que as sucesivas utilizacións de <lit>$stopwatch</lit>
	  xeran cada vez un escalar cos segundos da CPU dende o acceso previo.
	</para>
      </description>
    </function>

    <function name="$sysA" section="access" output="matrix">
      <description>
	<para>
	  Debe executarse logo de estimar un sistema de ecuacións simultáneas.
	  Devolve a matriz cos coeficientes das variables endóxenas retardadas
	  (no caso de que existan), na forma estrutural do sistema. Consulta
	  tamén a instrución <cmdref targ="system"/>.
	</para>
      </description>
    </function>

    <function name="$sysB" section="access" output="matrix">
      <description>
	<para>
	  Debe executarse logo de estimar un sistema de ecuacións simultáneas.
	  Devolve unha matriz cos coeficientes das variables esóxenas, na forma
	  estrutural do sistema. Consulta a instrución
	  <cmdref targ="system"/>.
	</para>
      </description>
    </function>

    <function name="$sysGamma" section="access" output="matrix">
      <description>
	<para>
	  Debe executarse logo de estimar un sistema de ecuacións simultáneas.
	  Devolve unha matriz cos coeficientes das variables endóxenas
	  contemporáneas, na forma estrutural so sistema. Consulta a instrución
	  <cmdref targ="system"/>.
	</para>
      </description>
    </function>

    <function name="$sysinfo" section="access" output="bundle">
      <description>
	<para>
	  Devolve un feixe (<quote>bundle</quote>) que contén información das
	  capacidades do Gretl e do sistema operativo no que está executándose.
	  Os elementos do feixe indícanse deseguido:
	</para>
	<ilist>
	  <li>
            <para>
              <lit>mpi</lit>: número enteiro igual a 1 se o sistema admite
              MPI (Message Passing Interface) e 0 noutro caso.
            </para>
	  </li>
	  <li>
            <para>
              <lit>omp</lit>: número enteiro igual a 1 se Gretl compilouse
              con soporte para Open MP e 0 noutro caso.
            </para>
	  </li>
	  <li>
            <para>
              <lit>nproc</lit>: número enteiro que indica o número de
              procesadores dispoñibles.
            </para>
	  </li>
	  <li>
            <para>
              <lit>mpimax</lit>: número enteiro que indica o máximo número
              de procesos MPI que poden executarse en paralelo. É igual a
              cero se non se admite MPI; noutro caso é igual ao valor de
              <lit>nproc</lit> local, agás que se especifique un ficheiro
              de hosts MPI, caso no que é igual a suma do número de
              procesadores ou <quote>slots</quote> ao longo de todas a
              máquinas ás que se fai referencia no ficheiro.
            </para>
	  </li>
	  <li>
            <para>
              <lit>wordlen</lit>: número enteiro igual a 32 ou a 64 en
              sistemas de 32 bit e 64 bit, respectivamente.
            </para>
	  </li>
	  <li>
            <para>
              <lit>os</lit>: cadea de texto que representa o sistema
              operativo, ben <lit>linux</lit>, <lit>osx</lit>,
              <lit>windows</lit> ou <lit>other</lit>.
            </para>
	  </li>
	  <li>
            <para>
              <lit>hostname</lit>: cadea de texto co nome da máquina (ou
              <quote>host</quote>) onde o proceso actual de Gretl está
              executándose. Se non é posible determinar o nome, prodúcese
              unha volta atrás do <lit>localhost</lit>.
            </para>
	  </li>
	</ilist>
	<para>
	  Fíxate en que pode accederse a elementos individuais do feixe
	  mediante a notación <quote>dot</quote> sen necesidade de copiar o
	  feixe enteiro cun nome de usuario específico. Por exemplo co código:
	</para>
	<code>
	  if $sysinfo.os == "linux"
	      # Faga algo que sexa propio do Linux
	  endif
	</code>
      </description>
    </function>

    <function name="$system" section="access" output="bundle">
      <description>
	<para>
	  Debe de seguir á estimación dun sistema de ecuacións, feita
	  coa instrución <cmdref targ="system"/>, <cmdref targ="var"/> ou
	  con <cmdref targ="vecm"/>; e devolve un feixe que contén moitos
	  apartados de datos que pertencen ao sistema. Inclúense todos
	  os accesorios do sistema importantes e habituais, que se nomean
	  mediante símbolos chave que son idénticos aos nomes habituais
	  dos accesorios, menos o símbolo de dólar inicial. Así, por exemplo,
	  os erros aparecen baixo a chave <lit>uhat</lit> e os coeficientes
	  baixo <lit>coeff</lit>. As chaves para obter información adicional
	  agárdase que deberan explicarse suficientemente por si mesmas.
	  Para observar que tes á túa disposición, podes obter unha copia
	  do feixe e representar o seu contido, como en
	</para>
	<code>
	  var 4 y1 y2 y2
	  bundle b = $system
	  print b
	</code>
	<para>
	  Podes pasar un fexie obtido deste xeito como argumeto
	  final (opcional) das funcións <fncref targ="fevd"/> e
	  <fncref targ="irf"/>.
	</para>
      </description>
    </function>

    <function name="$T" section="access" output="int">
      <description>
	<para>
	  Devolve un número enteiro co número de observacións utilizadas na
	  estimación do último modelo.
	</para>
      </description>
    </function>

    <function name="$t1" section="access" output="int">
      <description>
	<para>
	  Devolve un enteiro positivo co número que indexa a primeira
	  observación da mostra actualmente seleccionada.
	</para>
      </description>
    </function>

    <function name="$t2" section="access" output="int">
      <description>
	<para>
	  Devolve un enteiro positivo co número que indexa a derradeira
	  observación da mostra actualmente seleccionada.
	</para>
      </description>
    </function>

    <function name="$test" section="access" output="scalar-or-matrix">
      <description>
	<para>
	  Devolve o valor do estatístico de proba que foi xerado pola última
	  instrución explícita para unha proba de hipóteses (por exemplo:
	  <lit>chow</lit>). Consulta o <guideref targ="chap:genr"/> para
	  obter máis detalles.
	</para>
	<para>
	  Xeralmente devolve un escalar, mais nalgúns casos devolve unha
	  matriz (por exemplo, iso ocorre cos estatísticos da traza e do
	  máximo-lambda da proba de cointegración de Johansen). Neste caso
	  os valores están dispostos na matriz do mesmo xeito que nos
	  resultados presentados.
	</para>
	<para>
	  <seelist>
            <fncref label="\$pvalue" targ="dpvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$tmax" section="access" output="int">
      <description>
	<para>
	  Devolve un enteiro co máximo valor válido establecido para indicar o
	  final do rango da mostra mediante a instrución <cmdref targ="smpl"/>.
	  Na maioría dos casos, isto vai ser igual ao número de observacións do
	  conxunto de datos, pero nunha función de Hansl, o valor <lit>$tmax</lit>
	  podería ser menor, posto que o acceso habitual aos datos dentro das
	  funcións, limítase ao rango mostral establecido polo solicitante.
	</para>
	<para>
	  Ten en conta que, en xeral, <lit>$tmax</lit> non é igual a
	  <fncref label="\$nobs" targ="dnobs"/>, que proporciona o
	  número de observacións do rango da mostra vixente.
	</para>
      </description>
    </function>

    <function name="$trsq" section="access" output="scalar">
      <description>
	<para>
	  Devolve o escalar <math>TR</math><sup>2</sup> (o tamaño da mostra
	  multiplicado polo R-cadrado do último modelo), se está dispoñible.
	</para>
      </description>
    </function>

    <function name="$uhat" section="access" output="series">
      <description>
	<para>
	  Devolve unha serie cos erros do último modelo estimado. Isto pode ter
	  diferentes significados dependendo dos estimadores utilizados. Por
	  exemplo, logo da estimación dun modelo ARMA, <lit>$uhat</lit> contén
	  os erros da predición de 1 paso á fronte; logo da estimación dun
	  probit, contén os erros xeneralizados.
	</para>
	<para>
	  Cando o <quote>modelo</quote> actual en cuestión é un sistema de
	  ecuacións (un VAR, un VECM ou un sistema de ecuacións simultáneas),
	  o <lit>$uhat</lit> xera unha matriz cos erros de estimación de cada
	  ecuación ordenados por columnas.
	</para>
      </description>
    </function>

    <function name="$unit" section="access" output="series">
      <description>
	<para>
	  Só e válido para datos de panel. Devolve unha serie con valor igual a
	  1 en todas as observacións na primeira unidade ou grupo, 2 en todas as
	  observacións na segunda unidade ou grupo, e así sucesivamente.
	</para>
      </description>
    </function>

    <function name="$vcv" section="access" output="matrix" altout="scalar">
      <fnargs>
	<fnarg optional="true" type="coeffname">s1</fnarg>
	<fnarg optional="true" type="coeffname">s2</fnarg>
      </fnargs>
      <description>
	<para>
	  Cando se utiliza sen argumentos, <lit>$vcv</lit> devolve unha matriz
	  cadrada que contén as varianzas-covarianzas estimadas dos coeficientes
	  do último modelo estimado. Se este último era uniecuacional pódense
	  indicar os nomes de dous regresores entre parénteses, para así obter
	  un escalar coa covarianza estimada entre <argname>s1</argname> e
	  <argname>s2</argname>.
	  <seelist>
            <fncref targ="$coeff"/>
            <fncref targ="$stderr"/>
	  </seelist>
	</para>
	<para>
	  Este accesorio non está dispoñible para VARs ou VECMs. Para modelos
	  dese tipo <fncref targ="$sigma"/> e <fncref targ="$xtxinv"/>.
	</para>
      </description>
    </function>

    <function name="$vecGamma" section="access" output="matrix">
      <description>
	<para>
	  Debe executarse logo de estimar un VECM e devolve unha matriz na que
	  as matrices Gamma (cos coeficientes das diferenzas retardadas das
	  variables cointegradas) se agrupan unhas ao lado das outras. Cada fila
	  indica unha ecuación; para un VECM con nivel de retardo <math>p</math>
	  existen <math>p</math> &minus; 1 submatrices.
	</para>
      </description>
    </function>

    <function name="$version" section="access" output="scalar">
      <description>
	<para>
	  Devolve un escalar cun valor enteiro que designa a versión de Gretl.
	  A versión actual de Gretl está formada por unha cadea de texto que
	  indica o ano con formato de 4 díxitos seguido dunha letra desde a ata
	  j, que representa as sucesivas actualizacións dentro de cada ano (por
	  exemplo, 2015d). O valor devolto por este accesorio está calculado
	  multiplicando o ano por 10 e sumándolle un número que representa á
	  letra, na orde léxica en base cero. Así, 2015d represéntase mediante
	  20153.
	</para>
	<para>
	  En versións anteriores ao Gretl 2015d, o identificador tiña o seguinte
	  formato: x.y.z (tres números enteiros separados por puntos); nese caso
	  o valor da función calculábase con <lit>10000*x + 100*y + z</lit>. Por
	  exemplo, a última versión co formato antigo (1.10.2) transcribíase
	  mediante 11002. Deste xeito a orde numérica de <lit>$version</lit> foi
	  preservada aínda despois de mudar o esquema das versións.
	</para>
      </description>
    </function>

    <function name="$vma" section="access" output="matrix">
      <description>
	<para>
	  Debe executarse logo de estimar un VAR ou un VECM e devolve unha
	  matriz que contén a representación VMA ata a orde especificada por
	  medio da instrución <lit>set horizon</lit>. Para ter máis detalles,
	  consulta o <guideref targ="chap:var"/>.
	</para>
      </description>
    </function>

    <function name="$windows" section="access" output="int">
      <description>
	<para>
	  Devolve un número enteiro co valor 1 se o Gretl esta executándose no Windows,
	  e 0 noutro caso. Poñendo como condición un destes valores, podes escribir instrucións
	  <quote>shell </quote> que podan executarse en diferentes sistemas operativos.
	</para>
	<para>
	  Consulta tamén a instrución <cmdref targ="shell"/>.
	</para>
      </description>
    </function>

    <function name="$xlist" section="access" output="list">
      <description>
	<para>
	  Se o último modelo estimado era uniecuacional, o accesorio devolve
	  unha lista cos seus regresores. Se o último modelo era un sistema de
	  ecuacións, devolve unha lista <quote>global</quote> coas variables
	  esóxenas e predeterminadas (na mesma orde na que aparecen co accesorio
	  <fncref targ="$sysB"/>). Se o último modelo era un VAR, devolve unha
	  lista cos regresores esóxenos, se hai algún.
	</para>
      </description>
    </function>

    <function name="$xtxinv" section="access" output="matrix">
      <description>
	<para>
	  Debe executarse logo da estimación dun VAR ou VECM (unicamente) e
	  devolve a matriz <math>X'X</math><sup>-1</sup>, onde <math>X</math> é
	  a matriz habitual cos regresores utilizados en cada ecuación. Este
	  accesorio non está dispoñible para un VECM estimado con restricións
	  impostas sobre a matriz de cargas(&agr;).
	</para>
      </description>
    </function>

    <function name="$yhat" section="access" output="series">
      <description>
	<para>
	  Devolve unha serie cos valores estimados da variable explicada da última regresión.
	</para>
      </description>
    </function>

    <function name="$ylist" section="access" output="list">
      <description>
	<para>
	  Se o último modelo estimado foi un VAR, un VECM ou un sistema
	  de ecuacións simultáneas, o accesorio devolve unha lista coas
	  variables endóxenas. Se o último modelo estimado foi uniecuacional,
	  o accesorio devolve unha lista cun único elemento, a variable dependente.
	  No caso especial do modelo biprobit, a lista contén dous
	  elementos.
	</para>
      </description>
    </function>

  </funclist>

  <funclist name="Functions proper" ref="functions">

    <function name="abs" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co valor absoluto de <argname>x</argname>.
	</para>
      </description>
    </function>

    <function name="acos" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) cos radiáns do arco
	  coseno de<argname>x</argname>; é dicir, dá o arco cuxo coseno é
	  <argname>x</argname> (o argumento debe estar entre &minus;1 e 1).
	</para>
      </description>
    </function>

    <function name="acosh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co coseno hiperbólico
	  inverso de <argname>x</argname> (solución positiva). Este último
	  debe ser maior ca 1, pois se non a función devolverá NA.
	  <seelist>
            <fncref targ="cosh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="aggregate" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
	<fnarg type="series-or-list">byvar</fnarg>
	<fnarg type="string" optional="true">funcname</fnarg>
      </fnargs>
      <description>
	<para>
	  Na forma máis simple de uso desta función, <argname>x</argname>
	  establécese igual a <lit>null</lit>, <argname>byvar</argname> é
	  unha serie individual e o terceiro argumento omítese. Nese caso
	  devólvese unha matriz con dúas columnas que contén: os distintos
	  valores de <argname>byvar</argname> ordenados de forma crecente
	  na primeira columna, e o número de observacións nas que
	  <argname>byvar</argname> toma cada un deses valores.
	  Por exemplo...
	</para>
	<code>
	  open data4-1
	  eval aggregate(null, bedrms)
	</code>
	<para>
	  ... amosará que a serie <lit>bedrms</lit> ten os valores
	  3 (en total 5 veces) e 4 (en total 9 veces).
	</para>
	<para>
	  Se <argname>x</argname> e <argname>byvar</argname> son ambas
	  series individuais, e indicas o terceiro argumento desta
	  función, o valor que se devolve é unha matriz con tres columnas
	  que vai conter respectivamente: os distintos valores de
	  <argname>byvar</argname> ordenados de forma crecente, o número
	  de observacións nas que <argname>byvar</argname> toma cada
	  un deses valores, e os valores do estatístico que especifica a
	  función <argname>funcname</argname>, calculado para a serie
	  <argname>x</argname>, pero usando tan só aquelas observacións
	  nas que <argname>byvar</argname> toma o mesmo valor que se
	  especifica na primeira columna da matriz.
	</para>
	<para>
	  De xeito máis xeral, se <argname>byvar</argname> é unha lista con
	  <math>n</math> elementos, entón as <math>n</math> columnas á
	  esquerda conteñen as combinacións dos distintos valores de cada
	  unha das <math>n</math> series e a columna de reconto contén
	  o número de observacións nas que se produce cada combinación.
	  Se <argname>x</argname> é unha lista con <math>m</math>
	  elementos, entón as <math>m</math> columnas máis a dereita
	  conteñen os valores do estatístico especificado, para cada unha
	  das variables de <argname>x</argname>, novamente calculadas na
	  submostra indicada na(s) primeira(s) columna(s).
	</para>
	<para>
	  As seguintes opcións de <argname>funcname</argname> mantéñense
	  de forma <quote>orixinal</quote>: <fncref targ="sum"/>,
	  <fncref targ="sumall"/>, <fncref targ="mean"/>, <fncref targ="sd"/>,
	  <fncref targ="var"/>, <fncref targ="sst"/>, <fncref targ="skewness"/>,
	  <fncref targ="kurtosis"/>, <fncref targ="min"/>, <fncref targ="max"/>,
	  <fncref targ="median"/>, <fncref targ="nobs"/> e <fncref targ="gini"/>.
	  Cada unha destas funcións utiliza á súa vez unha serie como argumento
	  e devolve un valor escalar; por iso, neste sentido, pode dicirse que
	  de algún xeito <quote>agregan</quote> a serie. Podes utilizar
	  unha función definida polo usuario como <quote>agregador</quote>;
	  nese caso, da mesma forma que as funcións orixinais, esa función
	  debe de ter como argumento unicamente unha serie e devolver un
	  valor escalar.
	</para>
	<para>
	  Cae na conta de que, a pesar de que <lit>aggregate</lit> fai o
	  reconto de casos de forma automática, a opción <lit>nobs</lit>,
	  non é redundante como función <quote>agregadora</quote>, posto que
	  proporciona o número de observacións válidas (non ausentes) de
	  <argname>x</argname> en cada combinación de <argname>byvar</argname>.
	</para>
	<para>
	  Como exemplo sinxelo, supón que con <lit>rexion</lit> se definen
	  uns códigos para representar unha distribución xeográfica por rexións,
	  utilizándose para iso enteiros desde 1 ata <math>n</math> e que
	  con <lit>renda</lit> se representa a renda dos fogares. Entón o
	  código indicado deseguido debe producir unha matriz de orde
	  <by r="n" c="3"/> que contén os códigos das rexións, o reconto de
	  observacións de cada unha e a renda media dos fogares en cada unha:
	</para>
	<code>
	  matrix m = aggregate(renda, rexion, mean)
	</code>
	<para>
	  Como exemplo de utilización con listas de variables, sexa
	  <lit>xenero</lit> unha variable binaria home/muller, sexa
	  <lit>raza</lit> unha variable categórica con tres valores e
	  considera o seguinte código:
	</para>
	<code>
	  list BY = xenero raza
	  list X = renda idade
	  matrix m = aggregate(X, BY, sd)
	</code>
	<para>
	  Invocar a función <lit>aggregate</lit> producirá unha matriz de
	  orde <by r="6" c="5"/>. As dúas primeiras columnas conteñen as
	  6 distintas combinacións dos valores de xénero e raza; a columna
	  do medio contén o reconto do número de casos para cada unha desas
	  combinacións; e as dúas columnas máis á dereita conteñen as
	  desviacións padrón mostrais de <lit>renda</lit> e <lit>idade</lit>.
	</para>
	<para>
	  Observa que se <argname>byvar</argname> é unha lista de variables,
	  algunhas combinacións dos valores de <argname>byvar</argname> poden
	  non estar presentes nos datos (producíndose un reconto igual a cero).
	  Nese caso os valores dos estatísticos para <argname>x</argname> se
	  rexistran como <lit>NaN</lit> (e dicir, non son números). Se queres
	  ignorar eses casos, podes usar a función <fncref targ="selifr"/> para
	  escoller só aquelas filas que non teñan reconto igual a cero. A columna
	  a comprobar estará unha posición á dereita da indicada polo número de
	  variables de <argname>byvar</argname>, polo que pode usarse o código:
	</para>
	<code>
	  matrix m = aggregate(X, BY, sd)
	  scalar c = nelem(BY)
	  m = selifr(m, m[,c+1])
	</code>
      </description>
    </function>

    <function name="argname" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>s</argname> é o nome dun parámetro dunha función
	  definida  previamente polo usuario, devolve unha cadea co nome dese
	  argumento, ou baleira se o argumento fora anónimo.
	</para>
      </description>
    </function>

    <function name="array" section="data-utils" output="seebelow">
      <fnargs>
	<fnarg type="int">n</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta é a función <quote>construtora</quote> básica dunha nova variable
	  de tipo arranxo (<quote>array</quote>). Ao usar esta función é
	  necesario que especifiques un tipo (na forma plural) para o arranxo:
	  <lit>strings</lit>, <lit>matrices</lit>, <lit>bundles</lit> ou
	  <lit>lists</lit>. Devolve un arranxo do tipo especificado con
	  <argname>n</argname> elementos <quote>baleiros</quote> (por exemplo
	  unha cadea de texto (<quote>string</quote>) baleira ou unha matriz
	  nula). Exemplos de utilización:
	</para>
	<code>
	  strings S = array(5)
	  matrices M = array(3)
	</code>
	<para>
	  Consulta tamén <fncref targ="defarray"/>.
	</para>
      </description>
    </function>

    <function name="asin" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) cos radiáns do arco
	  seno de<argname>x</argname>; é dicir, dá o arco cuxo seno é
	  <argname>x</argname> (o argumento debe estar entre &minus;1 e 1).
	</para>
      </description>
    </function>

    <function name="asinh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co seno hiperbólico inverso de <argname>x</argname>.
	  <seelist>
            <fncref targ="sinh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="atan" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) cos radiáns do arco tanxente de
	  <argname>x</argname>; é dicir, devolve o arco cuxa tanxente é <argname>x</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="cos"/>
            <fncref targ="sin"/>
            <fncref targ="tan"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="atanh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) coa tanxente hiperbólica inversa de <argname>x</argname>.
	  <seelist>
            <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="atof" section="strings" output="scalar">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Función moi relacionada coa da linguaxe de programación C co mesmo nome.
	  Devolve un escalar co resultado de converter a cadea de texto
	  <argname>s</argname> (ou o seu anaco relevante, logo de descartar
	  calquera espazo en branco inicial) nun número de punto flotante.
	  A diferenza do que ocorre na linguaxe C, a función <lit>atof</lit>
	  sempre asume que o carácter decimal é o <quote><lit>.</lit></quote>
	  (por cuestións de transportabilidade). Ignóranse todos os caracteres
	  que seguen logo da parte de <argname>s</argname> que se converte en
	  número de punto flotante.
	</para>
	<para>
	  Se, baixo o suposto establecido, non puidera converterse ningún dos
	  caracteres de <argname>s</argname> que queden logo de descartar
	  os espazos en branco, a función devolve <lit>NA</lit>.
	</para>
	<code>
	  # Exemplos:
	  x = atof("1.234") # Devolve x = 1.234
	  x = atof("1,234") # Devolve x = 1
	  x = atof("1.2y")  # Devolve x = 1.2
	  x = atof("y")     # Devolve x = NA
	  x = atof(",234")  # Devolve x = NA
	</code>
	<para>
	  Consulta tamén <fncref targ="sscanf"/> se queres ter maior
	  flexibilidade nas conversións de cadeas de texto en números.
	</para>
      </description>
    </function>

    <function name="bessel" section="math" output="asinput">
      <fnargs>
	<fnarg type="char">type</fnarg>
	<fnarg type="scalar">v</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Permite calcular unha das variantes da función de Bessel de clase
	  <argname>v</argname> con argumento <argname>x</argname>. O valor que
	  devolve é do mesmo tipo que este <argname>x</argname>. A clase de
	  función escóllese co primeiro argumento que debe ser <lit>J</lit>,
	  <lit>Y</lit>, <lit>I</lit> ou <lit>K</lit>. Unha boa discusión sobre
	  as funcións de Bessel pode atoparse na Wikipedia, mais aquí ofrécense
	  uns breves comentarios.
	</para>
	<para>
	  Caso <lit>J</lit>: función de Bessel de primeira clase que se asemella
	  a unha onda sinusoidal amortecida. Defínese para <argname>v</argname>
	  real e <argname>x</argname>, pero se <argname>x</argname> fose
	  negativo, entón <argname>v</argname> debe ser un número enteiro.
	</para>
	<para>
	  Caso <lit>Y</lit>: función de Bessel de segunda clase. Defínese para
	  <argname>v</argname> real e <argname>x</argname>, pero con unha
	  singularidade en <argname>x</argname> = 0.
	</para>
	<para>
	  Caso <lit>I</lit>: función de Bessel modificada de primeira clase que
	  presenta un crecemento exponencial. Os argumentos que poden usarse con
	  ela son os mesmos que no caso <lit>J</lit>.
	</para>
	<para>
	  Caso <lit>K</lit>: función de Bessel modificada de segunda clase que
	  presenta un decrecemento exponencial. Diverxe en <argname>x</argname>
	  = 0, non está definida para valores negativos de <argname>x</argname>
	  e é simétrica arredor de <argname>v</argname> = 0.
	</para>
      </description>
    </function>

    <function name="BFGSmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="fncall" optional="true">g</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co resultado dunha maximización numérica feita co
	  método de Broyden, Fletcher, Goldfarb e Shanno. O argumento vectorial
	  <argname>b</argname> debe de conter os valores iniciais dun conxunto
	  de parámetros, e o argumento <argname>f</argname> debe de especificar
	  unha chamada á función que vai calcular o criterio obxectivo (escalar)
	  que se quere maximizar, dados os valores actuais dos parámetros, así
	  como calquera outros datos que sexan relevantes. Se o que pretendes
	  é en realidade minimizar o criterio obxectivo, esta función devolve o
	  valor negativo dese criterio obxectivo. Cando se completa con éxito a
	  súa execución, <lit>BFGSmax</lit> devolve o valor maximizado do
	  criterio obxectivo, e <argname>b</argname> contén finalmente os
	  valores dos parámetros que proporcionan o máximo dese criterio.
	</para>
	<para>
	  O terceiro argumento (opcional) establece unha maneira de proporcionar
	  derivadas analíticas (noutro caso o gradiente compútase numericamente).
	  A chamada <argname>g</argname> á función gradiente debe de ter como
	  primeiro argumento a unha matriz definida previamente que teña o
	  tamaño axeitado para poder almacenar o gradiente, dado en forma de
	  punteiro. Así mesmo tamén precisa ter como argumento (en forma de
	  punteiro ou non) ao vector de parámetros. Outros argumentos son
	  opcionais.
	</para>
	<para>
	  Para máis detalles e exemplos, consulta
	  <guideref targ="chap:numerical"/>.
	  <seelist>
	          <fncref targ="BFGScmax"/>
            <fncref targ="NRmax"/>
            <fncref targ="fdjac"/>
            <fncref targ="simann"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="BFGSmin" section="numerical" output="scalar">
      <description>
	<para>
	  Un alcume de <fncref targ="BFGSmax"/>. Se invocas a función baixo
	  este nome, execútase facendo unha minimización.
	</para>
      </description>
    </function>

    <function name="BFGScmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="matrix">bounds</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="fncall" optional="true">g</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co resultado dunha maximización con restricións por
	  medio do método L-BFGS-B (BFGS con memoria limitada, consulta
	  <cite key="byrd-etal95">Byrd, Lu, Nocedal e Zhu, 1995</cite>). O argumento 
	  vectorial <argname>b</argname> debe de conter os valores iniciais dun
	  conxunto de parámetros, o argumento <argname>bounds</argname> debe de
	  conter as restricións aplicadas aos valores dos parámetros (consulta
	  máis abaixo), e o argumento <argname>f</argname> debe de especificar
	  unha chamada á función que vai calcular o criterio obxectivo (escalar)
	  que se quere maximizar, dados os valores actuais dos parámetros así
	  como calquera outros datos que sexan relevantes. Se o que pretendes
	  realmente é minimizar o criterio obxectivo, esta función debe devolver
	  o valor negativo dese criterio. Ao completar con éxito a súa execución,
	  <lit>BFGScmax</lit> devolve o valor máximo do criterio obxectivo, dadas
	  as restricións de <argname>bounds</argname>, e <argname>b</argname>
	  contén finalmente os valores dos parámetros que maximizan o criterio.
	</para>
	<para>
	  A matriz <argname>bounds</argname> debe de ter 3 columnas e un
	  número de filas igual ao número de elementos restrinxidos no vector de
	  parámetros. O primeiro elemento dunha fila dada é o enteiro positivo
	  que indexa o parámetro restrinxido; o segundo e o terceiro elementos
	  son os límites inferior e superior, respectivamente. Os valores
	  <lit>-$huge</lit> e <lit>$huge</lit> deben usarse para indicar que
	  o parámetro non posúe restricións inferiores ou superiores,
	  respectivamente. Por exemplo, a seguinte expresión é a forma de
	  especificar que o segundo elemento do vector de parámetros debe
	  de ser non negativo:
	</para>
	<code>
	  matrix bounds = {2, 0, $huge}
	</code>
	<para>
	  O cuarto argumento (opcional) estabelece unha maneira de proporcionar
	  derivadas analíticas (noutro caso o gradiente compútase numericamente).
	  A chamada <argname>g</argname> á función gradiente debe de ter como
	  primeiro argumento a unha matriz definida previamente que teña o
	  tamaño axeitado para poder almacenar o gradiente, dado en forma de
	  punteiro. Así mesmo tamén precisa ter como argumento (en forma de
	  punteiro ou non) ao vector de parámetros. Outros argumentos son
	  opcionais.
	</para>
	<para>
	  Para máis detalles e exemplos, consulta
	  <guideref targ="chap:numerical"/>.
	  <seelist>
	          <fncref targ="BFGSmax"/>
            <fncref targ="NRmax"/>
            <fncref targ="fdjac"/>
            <fncref targ="simann"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="BFGScmin" section="numerical" output="scalar">
      <description>
	<para>
	  Un alcume de <fncref targ="BFGScmax"/>. Se invocas a función baixo
	  este nome, execútase facendo unha minimización.
	</para>
      </description>
    </function>

    <function name="bkfilt" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int" optional="true">f1</fnarg>
	<fnarg type="int" optional="true">f2</fnarg>
	<fnarg type="int" optional="true">k</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha serie co resultado da aplicación do filtro paso-banda
	  de Baxter&ndash;King a unha serie <argname>y</argname>. Os
	  parámetros opcionais <argname>f1</argname> e <argname>f2</argname>
	  representan, de maneira respectiva, os límites inferior e superior
	  do rango de frecuencias que se vai extraer, namentres que
	  <argname>k</argname> representa a orde de aproximación que se vai
	  utilizar.
	</para>
	<para>
	  Se non se proporcionan eses argumentos, entón os valores por defecto
	  van depender da periodicidade do conxunto de datos. Para datos
	  anuais os valores por defecto para <argname>f1</argname>,
	  <argname>f2</argname> e <argname>k</argname> son 2, 8 e 3
	  respectivamente; para datos trimestrais son 6, 32 e 12; e para
	  datos mensuais son 18, 96 e 36. Eses valores escóllense para
	  coincidir coa elección máis común entre os usuarios, que consiste
	  na utilización deste filtro para extraer a compoñente de frecuencia
	  do <quote>ciclo de negocios</quote>. Isto, á súa vez, defínese
	  habitualmente comprendido entre 18 meses e 8 anos. O filtro abarca
	  3 anos de datos, na elección por defecto.
	</para>
	<para>
	  Se <argname>f2</argname> é maior ou igual ao número de observacións
	  dispoñibles, entón execútase a versión <quote>paso-baixo</quote>
	  do filtro, e a serie resultante debe considerarse como unha
	  estimación da compoñente de tendencia, máis ca da compoñente do
	  ciclo.
	  <seelist>
            <fncref targ="bwfilt"/>
            <fncref targ="hpfilt"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="boxcox" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="scalar">d</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve a serie resultante da transformación de Box&ndash;Cox con
	  parámetro <argname>d</argname> dunha serie positiva <argname>y</argname>.
	</para>
	<para context="tex">
	  \[ y_t^{(d)} = \left\{ \begin{array}{ll} \frac{y_t^d - 1}{d} &amp;
	  {\rm if}\quad d\neq 0 \\ \log (y_t) &amp; {\rm if}\quad d=0
	  \end{array} \right. \]
	</para>
	<para context="notex">
	  A serie transformada é (<math>y</math><sup>d</sup> - 1)/<math>d</math>
	  para <math>d</math> distinto de cero ou log(<math>y</math>) para
	  <math>d</math> = 0.
	</para>
      </description>
    </function>

    <function name="bread" section="data-utils" output="bundle">
      <fnargs>
	<fnarg type="string">fname</fnarg>
	<fnarg optional="true" type="bool">import</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve a lectura dun feixe (<quote>bundle</quote>) a partir
	  dun ficheiro de texto. A cadea de texto debe de conter o nome do
	  ficheiro do cal se le o feixe. Se ese nome ten a extensión
	  <quote><lit>.gz</lit></quote> asúmese que se aplicou a compresión
	  gzip cando se gardou ese ficheiro.
	</para>
	<para>
	  O ficheiro en cuestión debe ser un ficheiro XML apropiadamente
	  definido: debe de conter un elemento <lit>gretl-bundle</lit>, que
	  se use para almacenar cero ou máis elementos <lit>bundled-item</lit>.
	  Por exemplo:
	</para>
	<code>
	  &lt;?xml version="1.0" encoding="UTF-8"?&gt;
	  &lt;gretl-bundle name="temp"&gt;
          &lt;bundled-item key="s" type="string"&gt;moo&lt;/bundled-item&gt;
          &lt;bundled-item key="x" type="scalar"&gt;3&lt;/bundled-item&gt;
	  &lt;/gretl-bundle&gt;
	</code>
	<para>
	  Como cabería agardar, estes ficheiros os xera automaticamente a
	  función asociada <fncref targ="bwrite"/>.
	</para>
	<para>
	  Se o nome do ficheiro non contén a especificación completa do
	  camiño ao cartafol que o contén, entón vai procurarse en varias
	  localizacións <quote>probables</quote>, comezando no establecido
	  como <cmdref targ="workdir"/> actual. Agora ben, cando se
	  proporciona un valor non nulo para o argumento opcional
	  <argname>import</argname>, o ficheiro vai procurarse no cartafol
	  <quote>dot</quote> do usuario. Neste caso o argumento
	  <argname>fname</argname> deberá ser un nome simple de ficheiro,
	  sen a inclusión do camiño ao cartafol.
	</para>
	<para>
	  Se ocorre algún fallo (por exemplo que o ficheiro estea mal formatado
	  ou sexa inaccesible), devólvese o fallo por medio do accesorio
	  <fncref targ="$error"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="mread"/>
            <fncref targ="bwrite"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="bwfilt" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int">n</fnarg>
	<fnarg type="scalar">omega</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha serie co que resulta de aplicar un filtro paso-baixo
	  de Butterworth de orde <argname>n</argname> e frecuencia de
	  corte <argname>omega</argname> na serie <argname>y</argname>.
	  O corte exprésase en graos e debe de ser maior ou igual a cero,
	  e menor ca180. Os valores de corte máis pequenos van restrinxir o
	  paso-banda a menores frecuencias e así producen unha tendencia
	  máis suave. Os valores maiores de <argname>n</argname> producen
	  un corte máis agudo, mais co custo de poder ter inestabilidade
	  numérica.
	</para>
	<para>
	  A inspección preliminar do periodograma da serie de interese é moi
	  útil cando se desexa aplicar esta función. Para obter máis detalles,
	  consulta o <guideref targ="chap:tsfilter"/>.
	  <seelist>
            <fncref targ="bkfilt"/>
            <fncref targ="hpfilt"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="bwrite" section="data-utils" output="int">
      <fnargs>
	<fnarg type="bundle">B</fnarg>
	<fnarg type="string">fname</fnarg>
	<fnarg optional="true" type="bool">export</fnarg>
      </fnargs>
      <description>
	<para>
	  Escribe o feixe (<quote>bundle</quote>) <argname>B</argname> nun
	  ficheiro XML con nome <argname>fname</argname>. Se xa existe un
	  ficheiro denominado <argname>fname</argname>, vaise sobrescribir.
	  Para unha descrición concisa do seu formato, consulta
	  <fncref targ="bread"/>. Esta función devolve o valor 0 no caso de
	  conclusión con éxito; se ocorren fallos, tales como a imposibilidade
	  de sobrescribir o ficheiro, a función devolve un valor non nulo.
	</para>
	<para>
	  O ficheiro de saída gárdase no cartafol <cmdref targ="workdir"/>
	  actual agás que a cadea <argname>fname</argname> conteña o camiño
	  completo co cartafol onde vai ser gardado. Agora ben, cando se indica
	  un valor non nulo para o argumento <argname>export</argname>,
	  o ficheiro de saída vaise gardar no cartafol <quote>dot</quote>
	  do usuario. Neste caso o argumento <argname>fname</argname> deberá
	  de ser un nome simple de ficheiro, sen a inclusión do camiño ao
	  cartafol.
	</para>
	<para>
	  Por defecto, o ficheiro XML gárdase sen comprimir, mais se o
	  <argname>fname</argname> ten a extensión <lit>.gz</lit> entón
	  aplícase a compresión gzip.
	</para>
	<para>
	  <seelist>
            <fncref targ="bread"/>
            <fncref targ="mwrite"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cdemean" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz coas columnas da matriz <argname>X</argname>
    centradas con respecto ás súas medias.
	</para>
      </description>
    </function>

    <function name="cdf" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <examples>
	<example>p1 = cdf(N, -2.5)</example>
	<example>p2 = cdf(X, 3, 5.67)</example>
	<example>p3 = cdf(D, 0.25, -1, 1)</example>
      </examples>
      <description>
	<para>
	  Calcula o valor da función de distribución acumulativa e devolve
	  un resultado (do mesmo tipo ca o argumento) coa probabilidade
	  <equation status="inline" ascii="P(X &le; x)" tex="$P(X \le x)$"/>,
	  onde a distribución de <math>X</math> se especifica por medio da letra
	  <argname>d</argname>. Entre os argumentos <argname>d</argname> e
	  <argname>x</argname>, pode necesitarse algún argumento adicional
	  escalar para especificar os parámetros da distribución, tal e como
	  se indica a continuación (pero observa que a distribución Normal
	  ten a súa propia función, por conveniencia, <fncref targ="cnorm"/>):
	</para>
	<ilist context="notex">
	  <li>
            <para>
              Normal estándar (c = z, n ou N): sen argumentos extras
            </para>
	  </li>
	  <li>
            <para>
              Normal bivariante (D): coeficiente de correlación
            </para>
	  </li>
	  <li>
            <para>
              t de Student (t): graos de liberdade
            </para>
	  </li>
	  <li>
            <para>
              Khi-cadrado (c, x ou X): graos de liberdade
            </para>
	  </li>
	  <li>
            <para>
              F de Snedecor (f ou F): graos de liberdade (num.), graos de liberdade (den.)
            </para>
	  </li>
	  <li>
            <para>
              Gamma (g ou G): forma, escala
            </para>
	  </li>
	  <li>
            <para>
              Binomial (b ou B): probabilidade, cantidade de ensaios
            </para>
	  </li>
	  <li>
            <para>
              Poisson (p ou P): media
            </para>
	  </li>
	  <li>
            <para>
              Exponencial (exp): escala
            </para>
	  </li>
	  <li>
            <para>
              Weibull (w ou W): forma, escala
            </para>
	  </li>
	  <li>
            <para>
              Laplace (l ou L): media; escala
            </para>
	  </li>
	  <li>
            <para>
              Erro Xeneralizado (E): forma
            </para>
	  </li>
	  <li>
	    <para>
	      Khi-cadrado non central (ncX): graos de liberdade, parámetro de non centralidade
	    </para>
	  </li>
	  <li>
	    <para>
	      F non central (ncF): graos de liberdade (num.), graos de liberdade (den.),
	      parámetro de non centralidade
	    </para>
	  </li>
	  <li>
	    <para>
	      t non central (nct): graos de liberdade, parámetro de non centralidade
	    </para>
	  </li>
	</ilist>
	<tabular colspec="lllll">
	  \textit{Distribución} &amp; \textsl{d} &amp;
	  \textit{Arg} 2 &amp; \textit{Arg} 3 &amp; \textit{Arg} 4 \\[4pt]
	  Normal estándar &amp; \texttt{z}, \texttt{n} ou \texttt{N} &amp;
	  -- &amp; -- &amp; --\\
	  Normal bivariante &amp; \texttt{D} &amp;
	  $\rho$ &amp; -- &amp; --\\
	  $t$ de Student (central) &amp; \texttt{t} &amp;
	  gl &amp; -- &amp; --\\
	  Khi-cadrado &amp; \texttt{c}, \texttt{x} ou \texttt{X} &amp;
	  gl &amp; -- &amp; --\\
	  $F$ de Snedecor &amp; \texttt{f} ou \texttt{F} &amp;
	  gl (num.) &amp; gl (den.) &amp; --\\
	  Gamma &amp; \texttt{g} ou \texttt{G} &amp;
	  forma &amp; escala &amp; --\\
	  Binomial &amp; \texttt{b} ou \texttt{B} &amp;
	  probabilidade &amp; ensaios &amp; --\\
	  Poisson &amp; \texttt{p} ou \texttt{P} &amp;
	  media &amp; -- &amp; --\\
	  Exponencial &amp; \texttt{exp} &amp;
	  escala &amp; -- &amp; --\\
	  Weibull &amp; \texttt{w} ou \texttt{W} &amp;
	  forma &amp; escala &amp; --\\
	  Laplace &amp; \texttt{l} ou \texttt{L} &amp;
	  media &amp; escala &amp; --\\
	  Erro Xeneralizado &amp; \texttt{E} &amp;
	  forma &amp; -- &amp; --\\
	  $\chi^2$ non central &amp; \texttt{ncX} &amp;
	  gl &amp; non centralidade &amp; --\\
	  $F$ non central &amp; \texttt{ncF} &amp;
	  gl (num.) &amp; gl (den.) &amp; non centralidade\\
	  $t$ non central &amp; \texttt{nct} &amp;
	  gl &amp; non centralidade &amp; --\\
	</tabular>
	<para>
	  Cae na conta de que na maioría dos casos existen alcumes para axudar
	  a memorizar os códigos. O caso da normal bivariante é especial: a
	  sintaxe é <lit>x = cdf(D, rho, z1, z2)</lit> onde <lit>rho</lit>
	  é o coeficiente de correlación entre as variables <lit>z1</lit>
	  e <lit>z2</lit>.
	</para>
	<para context="tex">
	  A disposición de parámetros que o \app{Gretl} usa para a variable
	  aleatoria Gamma implica que a súa función de densidade pode escribirse
	  \[
	  f(x; k, \theta) = \frac{x^{k-1}}{\theta^k} \frac{e^{-x/\theta}}{\Gamma(k)}
	  \]
	  onde $k>0$ é o parámetro de forma e $\theta>0$ é o parámetro de
	  escala.
	</para>
	<para>
	  <seelist>
            <fncref targ="pdf"/>
            <fncref targ="critical"/>
            <fncref targ="invcdf"/>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cdiv" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">Y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz co resultado de dividir números complexos. Os dous
	  argumentos deben comporse do mesmo número de filas, <math>n</math>, e
	  dunha ou dúas columnas. A primeira columna contén a parte real e a
	  segunda (se existe) contén a parte imaxinaria. O resultado que se
	  devolve é unha matriz de orde <by r="n" c="2"/> ou, no caso de non
	  existir a parte imaxinaria, un vector con <math>n</math> filas.
	  <seelist>
            <fncref targ="cmult"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cdummify" section="transforms" output="list">
      <fnargs>
	<fnarg type="list">L</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta función devolve unha lista na que cada serie do argumento
	  <argname>L</argname> que teña o atributo <quote>codificado</quote>
	  substitúese por un conxunto de variables ficticias que representan
	  cada un dos seus valores codificados, pero omitindo o valor
	  máis pequeno. Se o argumento <argname>L</argname> non contén
	  ningunha serie codificada, o valor que se devolve vai ser idéntico
	  a <argname>L</argname>.
	</para>
	<para>
	  No caso de que se xeren, as variables ficticias noméanse co
	  padrón <lit>D</lit><repl>varname</repl><lit>_</lit><repl>vi</repl>,
	  no que <repl>vi</repl> indica o <repl>i</repl><sup>ésimo</sup>
	  valor representado da variable que se codifica. No caso de que
	  algúns dos valores sexan negativos, vaise inserir <quote>m</quote>
	  antes do valor (absoluto) de
	  <repl>vi</repl>.
	</para>
	<para>
	  Por exemplo, supón que <argname>L</argname> contén unha serie
	  codificada chamada <lit>C1</lit> cos valores &minus;9, &minus;7,
	  0, 1 e 2. Entón, as variables ficticias xeradas van ser
	  <lit>DC1_m7</lit> (que codifica cando C1 = &minus;7),
	  <lit>DC1_0</lit> (que codifica cando C1 = 0), etcétera.
	</para>
	<para>
	  <seelist>
            <fncref targ="dummify"/>
	    <fncref targ="getinfo"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ceil" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Función tope: devolve un resultado (do tipo do argumento) co menor
	  enteiro que sexa  maior ou igual a <argname>x</argname>.
	  <seelist>
            <fncref targ="floor"/>
            <fncref targ="int"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cholesky" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="pdmat">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza a descomposición de Cholesky da matriz <argname>A</argname>,
	  asumindo que esta é simétrica e definida positiva. O resultado é unha
	  matriz triangular inferior <math>L</math> que verifica a igualdade
	  <equation status="inline" ascii="A = LL'"  tex="$A = LL'$"/>. A
	  función vai fallar se <argname>A</argname> non é simétrica ou non
	  é definida positiva.
	  <seelist>
            <fncref targ="psdroot"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="chowlin" section="transforms" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="int">xfac</fnarg>
	<fnarg type="matrix" optional="true">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz como resultado de expandir os datos de
	  entrada, <argname>Y</argname>, a unha frecuencia maior co método
	  de <cite key="chowlin71">Chow e Lin (1971)</cite>. Asúmese que as
	  columnas de <argname>Y</argname> representan series de datos.
	  A matriz que se devolve ten o mesmo número de columnas que
	  <argname>Y</argname> e <argname>xfac</argname> veces o seu
	  número de filas.
	</para>
	<para>
	  O segundo argumento representa o factor de expansión: debe de ser
	  igual a 3 para expandir datos trimestrais a mensuais, ou igual a 4 para
	  facelo de datos anuais a trimestrais (estes son os únicos factores
	  admitidos actualmente). O terceiro argumento (opcional) pode usarse
	  para prover unha matriz de covariables con maior frecuencia obxectivo.
	</para>
	<para>
	  Os regresores que se utilizan por defecto son unha constante e unha
	  tendencia cadrada. Cando se proporciona <argname>X</argname>, as
	  súas columnas utilízanse como regresores adicionais. A función
	  devolve un fallo se o número de filas de <argname>X</argname> non
	  é igual a <argname>xfac</argname> veces o número de filas de
	  <argname>Y</argname>.
	</para>
      </description>
    </function>

    <function name="cmult" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">Y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz co resultado de multiplicar números complexos. Os dous
	  argumentos deben comporse do mesmo número de filas, <math>n</math>, e
	  dunha ou dúas columnas. A primeira columna contén a parte real e a
	  segunda (se existe) contén a parte imaxinaria. O resultado que se
	  devolve é unha matriz de orde <by r="n" c="2"/> ou, no caso de non
	  existir a parte imaxinaria, un vector con <math>n</math> filas.
	  <seelist>
            <fncref targ="cdiv"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cnorm" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve a función de distribución acumulativa para unha Normal
	  estándar.
	  <seelist>
            <fncref targ="dnorm"/>
            <fncref targ="qnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cnumber" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co número de condición dunha matriz
	  <argname>X</argname> de orde <by r="n" c="k"/>, conforme se define
	  en <cite key="belsley-etal80"> Belsley, Kuh e Welsch (1980)</cite>.
	  Se as columnas de <argname>X</argname> son mutuamente ortogonais,
	  o número de condición de <argname>X</argname> é a unidade. Pola
	  contra, un valor grande do número de condición enténdese como un
	  indicio de alto grao de multicolinearidade; habitualmente considérase
	  que o valor é <quote>grande</quote> se é maior ou igual a 50 (ou,
	  algunhas veces, a 30).
	</para>
	<para>
	  Os pasos para facer os cálculos son: (1) conformar unha matriz
	  <math>Z</math> cuxas columnas sexan o resultado de dividir cada
	  columna de <argname>X</argname> pola súa respectiva norma
	  euclidiana; (2) construír a matriz <math>Z'Z</math> e obter os seus
	  autovalores; e (3) calcular a raíz cadrada da razón entre o maior
	  e o menor autovalor.
	</para>
	<para>
	  <seelist>
            <fncref targ="rcond"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cnameget" section="strings" output="string-or-strings">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="int" optional="true">col</fnarg>
      </fnargs>
      <description>
	<para>
	  Se indicas o argumento <argname>col</argname>, devolve unha
	  cadea co nome da columna <argname>col</argname> da matriz
	  <argname>M</argname>. Se as columnas de <argname>M</argname>
	  non teñen nome, entón devólvese unha cadea baleira; e se
	  <argname>col</argname> está fóra dos límites do número de columnas
	  desta matriz, amósase un fallo.
	</para>
	<para>
	  Se non indicas o segundo argumento, devolve un arranxo de cadeas
	  de texto que contén os nomes das columnas de <argname>M</argname>,
	  ou un arranxo baleiro se <argname>M</argname> non ten asignados
	  nomes de columnas.
	</para>
	<para>
	  Exemplo:
	</para>
	<code>
	  matrix A = { 11, 23, 13 ; 54, 15, 46 }
	  cnameset(A, "Col_A Col_B Col_C")
	  string name = cnameget(A, 3)
	  print name
	</code>
	<para>
	  <seelist>
            <fncref targ="cnameset"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cnameset" section="matbuild" output="scalar">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="strings-or-list">S</fnarg>
      </fnargs>
      <description>
	<para>
	  Engade nomes ás columnas da matriz de orde <by r="T" c="k"/>,
	  <argname>M</argname>. Cando <argname>S</argname> é unha lista,
	  os nomes son os das series listadas (é preciso que esa lista teña
	  <math>k</math>elementos). Cando <argname>S</argname> é un arranxo
	  de cadeas de texto, deberá de ter <math>k</math> elementos. Para
	  manter a compatibilidade con versións anteriores de Gretl, podes
	  tamén utilizar unha única cadea de texto como segundo argumento.
	  Nese caso, esta cadea precisa ter <math>k</math> subcadeas separadas
	  por espazos.
	</para>
	<para>
	  Devolve o valor 0 se as columnas son nomeadas con éxito; noutro caso
	  devolve un valor non nulo. Consulta tamén <fncref targ="rnameset"/>.
	</para>
	<para>
	  Exemplo:
	</para>
	<code>
	  matrix M = {1, 2; 2, 1; 4, 1}
	  strings S = array(2)
	  S[1] = "Col1"
	  S[2] = "Col2"
	  cnameset(M, S)
	  print M
	</code>
      </description>
    </function>

    <function name="cols" section="matshape" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un enteiro co número de columnas da matriz <argname>X</argname>.
	  <seelist>
            <fncref targ="mshape"/>
            <fncref targ="rows"/>
            <fncref targ="unvech"/>
            <fncref targ="vec"/>
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="corr" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y1</fnarg>
	<fnarg type="series-or-vec">y2</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co valor do coeficiente de correlación entre
	  <argname>y1</argname> e <argname>y2</argname>. Os argumentos deben
	  de ser dúas series ou dous vectores do mesmo tamaño.
	  <seelist>
            <fncref targ="cov"/>
            <fncref targ="mcov"/>
            <fncref targ="mcorr"/>
            <fncref targ="npcorr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="corrgm" section="stats" output="matrix">
      <fnargs>
	<fnarg type="smlist">x</fnarg>
	<fnarg type="int">p</fnarg>
	<fnarg optional="true" type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Cando se proporcionan só os dous primeiros argumentos, a función
	  devolve unha matriz co correlograma de <argname>x</argname> para
	  os retardos de 1 ata <argname>p</argname>. Se <math>k</math> é o
	  número de elementos de <argname>x</argname> (igual a 1 se
	  <argname>x</argname> é unha serie, igual ao número de columnas se
	  <argname>x</argname> é unha matriz, ou igual ao número de elementos
	  se <argname>x</argname> é unha lista), o valor que se devolve é unha
	  unha matriz con <argname>p</argname> filas e 2<math>k</math> columnas,
	  onde as <math>k</math> primeiras columnas conteñen as respectivas
	  autocorrelacións e as restantes conteñen as respectivas autocorrelacións
	  parciais.
	</para>
	<para>
	  Cando se indica o terceiro argumento, esta función calcula o
	  correlograma cruzado desde <math>+</math><argname>p</argname>
	  ata <math>-</math><argname>p</argname> para cada un dos <math>k</math>
	  elementos de <argname>x</argname> e <argname>y</argname>. A matriz
	  que se devolve componse de 2<math>p</math> + 1 filas e <math>k</math>
	  columnas. Se <argname>x</argname> é unha serie ou unha lista, e
	  <argname>y</argname> é un vector, este último é preciso que teña
	  tantas filas coma o número total de observacións que hai na mostra
	  actualmente seleccionada.
	</para>
      </description>
    </function>

    <function name="cos" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co coseno de <argname>x</argname>.
	  <seelist>
            <fncref targ="sin"/>
            <fncref targ="tan"/>
            <fncref targ="atan"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cosh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co coseno hiperbólico de <argname>x</argname>.
	</para>
	<para context="tex">
	  \[ \cosh x = \frac{e^x + e^{-x}}{2}  \]
	</para>
	<para>
	  <seelist>
            <fncref targ="acosh"/>
            <fncref targ="sinh"/>
            <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cov" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y1</fnarg>
	<fnarg type="series-or-vec">y2</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar coa covarianza entre <argname>y1</argname> e
	  <argname>y2</argname>. Os argumentos deben de ser ben dúas series
	  ou ben dous vectores da mesma longura.
	  <seelist>
            <fncref targ="corr"/>
            <fncref targ="mcov"/>
            <fncref targ="mcorr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="critical" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="char">c</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">p</fnarg>
      </fnargs>
      <examples>
	<example>c1 = critical(t, 20, 0.025)</example>
	<example>c2 = critical(F, 4, 48, 0.05)</example>
      </examples>
      <description>
	<para>
	  Permite calcular valores críticos e devolve un resultado do mesmo tipo
	  que o introducido. O valor <math>x</math> que se devolve vai cumprir
	  <equation status="inline" ascii="P(X &gt; x) = p" tex="$P(X \gt x) = p$"/>,
	  onde a distribución <math>X</math> determínase pola letra
	  <argname>c</argname>. Entre os argumentos <argname>d</argname> e
	  <argname>x</argname>, pode necesitarse algún outro adicional (escalar)
	  para indicar os parámetros da distribución. Isto faise deste xeito:
	</para>
	<ilist context="notex">
	  <li>
            <para>
              Normal estándar (c = z, n ou N): sen argumentos extras
            </para>
	  </li>
	  <li>
            <para>
              t de Student (t): graos de liberdade
            </para>
	  </li>
	  <li>
            <para>
              Khi-cadrado (c, x ou X): graos de liberdade
            </para>
	  </li>
	  <li>
            <para>
              F de Snedecor (f ou F): graos de liberdade (num.), graos de liberdade (den.)
            </para>
	  </li>
	  <li>
            <para>
              Binomial (b ou B): probabilidade, cantidade de ensaios
            </para>
	  </li>
	  <li>
            <para>
              Poisson (p ou P): media
            </para>
	  </li>
	  <li>
            <para>
              Laplace (l ou L): media; escala
            </para>
	  </li>
	  <li>
            <para>
              Erro Xeneralizado (E): forma
            </para>
	  </li>
	</ilist>
	<tabular colspec="llll">
	  \textit{Distribución} &amp; \textsl{c} &amp;
	  \textit{Arg} 2 &amp; \textit{Arg} 3 \\[4pt]
	  Normal estándar &amp; \texttt{z}, \texttt{n} ou \texttt{N} &amp;
	  -- &amp; -- \\
	  $t$ de Student (central) &amp; \texttt{t} &amp;
	  graos de liberdade &amp; -- \\
	  Khi-cadrado &amp; \texttt{c}, \texttt{x} ou \texttt{X} &amp;
	  graos de liberdade &amp; -- \\
	  $F$ de Snedecor &amp; \texttt{f} ou \texttt{F} &amp;
	  graos de liberdade (num.) &amp; graos de liberdade (den.) \\
	  Binomial &amp; \texttt{b} ou \texttt{B} &amp;
	  $p$ &amp; $n$ \\
	  Poisson &amp; \texttt{p} ou \texttt{P} &amp;
	  $\lambda$ &amp; -- \\
	  Laplace &amp; \texttt{l} ou \texttt{L} &amp;
	  media &amp; escala \\
	  Erro Xeneralizado &amp; \texttt{E} &amp;
	  forma &amp; -- \\
	</tabular>
	<para>
	  <seelist>
            <fncref targ="cdf"/>
            <fncref targ="invcdf"/>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cum" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Acumula <argname>x</argname> (isto é, crea unha suma móbil). Cando
	  <argname>x</argname> é unha serie, produce unha serie <math>y</math>
	  na que cada un dos seus elementos é igual á suma dos valores de
	  <argname>x</argname> ata a observación correspondente. O punto de
	  partida para a acumulación é a primeira observación non ausente da
	  mostra actualmente seleccionada. Cando <argname>x</argname> é unha
	  matriz, os seus elementos acumúlanse por columnas.
	</para>
	<para context="tex">
	  Acumula <argname>x</argname>. Cando <math>x</math> é unha serie,
	  produce unha serie y_t = \sum_{s=m}^t x_s$, na que o punto de partida
	  <math>m</math> para a acumulación, é a primeira observación
	  non ausente da mostra provisionalmente seleccionada. Ao atopar valores
	  ausentes en <math>x</math>, os valores posteriores de <math>y</math>
	  defínense como valores ausentes. Cando <argname>x</argname> é unha
	  matriz, os elementos acumúlanse por columnas.
	</para>
	<para>
	  <seelist>
            <fncref targ="diff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="curl" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="bundleref">&amp;b</fnarg>
      </fnargs>
      <description>
	<para>
	  Ofrece un medio bastante flexible de obter un <quote>buffer</quote> de
	  texto que contén datos dun servidor de internet, utilizando a biblioteca
	  libcurl. Ao escribila, o argumento de tipo feixe <argname>b</argname>,
	  debe de conter unha cadea de texto chamada <lit>URL</lit> que indica
	  o enderezo completo do recurso no host de destino. Outros elementos
	  opcionais preséntanse deseguido:
	</para>
	<ilist>
	  <li>
	    <para>
	      <quote><lit>header</lit></quote>: unha cadea de texto que
	      especifica un header HTTP que vai enviarse ao host.
	    </para>
	  </li>
	  <li>
	    <para>
	      <quote><lit>postdata</lit></quote>: unha cadea de texto que
	      contén os datos que van enviarse ao host.
	    </para>
	  </li>
	</ilist>
	<para>
	  Os campos <lit>header</lit> e <lit>postdata</lit> destínanse
	  para usarse cunha solicitude HTTP do tipo <lit>POST</lit>. Se
	  está presente <lit>postdata</lit>, vai implícito o método
	  <lit>POST</lit>; noutro caso vai implícito o método <lit>GET</lit>.
	  (Mais observa que para sinxelas solicitudes <lit>GET</lit>, a
	  función <fncref targ="readfile"/> ofrece unha interface máis
	  simple.)
	</para>
	<para>
	  Recoñécese outro elemento opcional do feixe: se está presente
	  un escalar chamado <lit>include</lit> e ten un valor non nulo, isto
	  enténdese como unha solicitude para incluír o header recibido do
	  host, no corpo da saída.
	</para>
	<para>
	  Ao completarse a solicitude, o texto recibido do servidor
	  engádese ao feixe e recibe o nome de
	  <quote><lit>output</lit></quote>.
	</para>
	<para>
	  A función vai fallar se hai unha equivocación ao formular a solicitude
	  (por exemplo, se non existe a <lit>URL</lit> na entrada); noutro caso
	  vai devolver o valor 0 se a solicitude prospera, ou un valor non
	  nulo se non o fai. Neste último caso, engádese a mensaxe de
	  fallo da biblioteca curl ao feixe, co identificador 
	  <quote><lit>errmsg</lit></quote>. Cae na conta, porén, que
	  <quote>éxito</quote> neste senso non significa necesariamente
	  que obtés os datos que desexabas; en realidade significa tan só 
	  que se recibiu algunha resposta do servidor. Debes comprobar o
	  contido do <quote>buffer</quote> de saída (que de feito pode ser
	  unha mensaxe tal como <quote>Páxina non atopada</quote>).
	</para>
	<para>
	  Aquí temos un exemplo de como utilizar esta función: para baixar
	  algúns datos da web do US Bureau of Labor Statistics, que require
	  o envío dunha consulta JSON. Observa o uso de <fcnref targ="sprintf"/>
	  para inserir comiñas nos datos <lit>POST</lit>.
	</para>
	<code>
	  bundle req
	  req.URL = "http://api.bls.gov/publicAPI/v1/timeseries/data/"
	  req.include = 1
	  req.header = "Content-Type: application/json"
	  string s = sprintf("{\"seriesid\":[\"LEU0254555900\"]}")
	  req.postdata = s
	  err = curl(&amp;req)
	  if err == 0
	      s = req.output
	      string line
	      loop while getline(s, line) --quiet
	          printf "%s\n", line
	      endloop
	  endif
	</code>
	<para>
	  Consulta tamén as funcións <fncref targ="jsonget"/> e
	  <fncref targ="xmlget"/> para ver xeitos de procesamento
	  de datos recibidos no formato JSON e XML, respectivamente.
	</para>
      </description>
    </function>

    <function name="dayspan" section="calendar" output="int">
      <fnargs>
	<fnarg type="int">ed1</fnarg>
	<fnarg type="int">ed2</fnarg>
	<fnarg type="int">weeklen</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un número enteiro co número de días (relevantes) entre os
	  días de época <argname>ed1</argname> e <argname>ed2</argname>, ambos
	  incluídos, considerando a duración de semana indicada polo argumento
	  <argname>weeklen</argname>. Este debe de ser igual a 5, 6 ou 7
	  (indicando o valor 6 que non se contan os domingos, e o 5 que non se
	  contan nin os sábados nin os domingos.
	</para>
	<para>
	  Para obter os días de época no formato máis familiar das datas,
	  consulta <fncref targ="epochday"/>. Relacionado con isto, consulta
	  <fncref targ="smplspan"/>.
	</para>
      </description>
    </function>

    <function name="defarray" section="data-utils" output="seebelow">
      <fnargs>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Permite definir <emphasis>cumpridamente</emphasis> unha variable
	  de tipo arranxo (<quote>array</quote>), proporcionando un ou máis
	  elementos. Ao utilizar esta función debes especificar o tipo de
	  arranxo (en forma plural): <lit>strings</lit>, <lit>matrices</lit>,
	  <lit>bundles</lit> ou <lit>lists</lit>. Cada un dos argumentos debe
	  de ser un obxecto do mesmo tipo que o tipo especificado na definición
	  do arranxo. No caso de completarse con éxito, a función devolve como
	  resultado un arranxo con <math>n</math> elementos, onde <math>n</math>
	  é igual ao número de argumentos.
	</para>
	<code>
	  strings S = defarray("foo", "bar", "baz")
	  matrices M = defarray(I(3), X'X, A*B, P[1:])
	</code>
	<para>
	  Consulta tamén <fncref targ="array"/>.
	</para>
      </description>
    </function>

    <function name="defbundle" section="data-utils" output="bundle">
      <fnargs>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Te permite a carga inicial dunha variable feixe
	  <emphasis>extensamente</emphasis>, proporcionando cero ou
	  máis pares co formato <repl>key</repl>, <repl>member</repl>.
	  Se contamos os argumentos desde 1, cada argumento numerado
	  impar debe de avaliar unha cadea de texto (chave) e cada
	  argumento numerado par debe de avaliar un obxecto dun tipo
	  que poida incluírse nun feixe.
	</para>
	<para>
	  Un par de exemplos sinxelos:
	</para>
	<code>
	  bundle b1 = defbundle("s", "Sample string", "m", I(3))
	  bundle b2 = defbundle("yn", normal(), "x", 5)
	</code>
	<para>
	  O primeiro exemplo xera un feixe cuxos elementos son unha cadea
	  de texto e unha matriz; o segundo, un feixe cun elemento que é
	  unha serie e outro que é escalar. Ten en conta que non podes
	  especificar un tipo de cada argumento cando utilizas esta función,
	  entón debes de aceptar o tipo <quote>natural</quote> de argumento
	  en cuestión. Se queres engadir unha serie cun valor constante de 5
	  a un feixe chamado <lit>b1</lit> sería necesario facer algo como
	  o seguinte (despois de enunciar <lit>b1</lit>):
	</para>
	<code>
	  series b1.s5 = 5
	</code>
	<para>
	  Se non indicas ningún argumento para esta función, iso
	  equivale a xerar un feixe baleiro (ou a baleirar un
	  feixe existente do seu contido), como podería facer
	  mediante
	</para>
	<code>
	  bundle b = null
	</code>
      </description>
    </function>

    <function name="deflist" section="data-utils" output="list">
      <fnargs>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Xera unha lista (de series xa definidas) dados un ou máis argumentos
	  apropiados. Cada argumento debe de ser, unha serie xa definida
	  (indicada polo seu nome ou o número enteiro ID), unha lista xa definida
	  ou unha expresión que se corresponda cunha lista (incluíndo un vector que
	  pode interpretarse como un conxunto de números ID de series).
	</para>
	<para>
	  Un punto a ter en conta é que esta función simplemente encadea
	  os seus argumentos para producir a lista que devolve. Cando se
	  pretende que o valor que devolva non conteña duplicados (que non
	  se refira a ningunha serie máis dunha vez), depende do solicitante
	  asegurarse de que se satisfaga ese requirimento.
	</para>
      </description>
    </function>

    <function name="deseas" section="filters" output="series">
      <fnargs>
	<fnarg type="series">x</fnarg>
	<fnarg optional="true" type="char">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Precisa que estean instalados o TRAMO/SEATS e/ou X-12-ARIMA. Devolve
	  unha versión desestacionalizada (axustada estacionalmente) da serie
	  <argname>x</argname>, que debe de ser unha serie temporal mensual
	  ou trimestral. Para utilizar o X-12-ARIMA indica <lit>X</lit> como
	  segundo argumento; e para usar o TRAMO/SEATS indica <lit>T</lit>.
	  Se omites o segundo argumento, Gretl utiliza o X-12-ARIMA.
	</para>
	<para>
	  Observa que cando a serie de entrada non ten unha compoñente
	  estacional detectable, a execución da función vai fallar. Cae na conta
	  tamén de que tanto o TRAMO/SEATS como o X-12-ARIMA ofrecen un gran
	  número de opcións; agora ben, a función <lit>deseas</lit> as utiliza
	  con todas as súas opcións nos seus valores por defecto. En ambos
	  os dous programas, os factores estacionais calcúlanse baseados nun
	  modelo ARIMA automaticamente seleccionado. Unha das diferenzas entre
	  os dous que pode levar a resultados bastante distintos, é que o
	  TRAMO/SEATS realiza un axuste previo das observacións con valores
	  atípicos mentres que o X-12-ARIMA non o fai.
	</para>
      </description>
    </function>

    <function name="det" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co valor do determinante de <argname>A</argname>,
	  calculado por medio da descomposición LU.
	  <seelist>
            <fncref targ="ldet"/>
            <fncref targ="rcond"/>
            <fncref targ="cnumber"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="diag" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector columna cos valores da diagonal principal de
	  <argname>X</argname>. Advirte que se <argname>X</argname> é unha
	  matriz de orde <by r="m" c="n"/>, o número de elementos do vector
	  resultante é igual a min(<math>m</math>, <math>n</math>).
	  <seelist>
            <fncref targ="tr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="diagcat" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix">B</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz coa suma directa de <argname>A</argname> e
	  <argname>B</argname>, é dicir, unha matriz que abrangue a
	  <argname>A</argname> no recanto superior esquerdo e a
	  <argname>B</argname> no recanto inferior dereito. Se
	  <argname>A</argname> e <argname>B</argname> son ambas
	  cadradas, a matriz resultante é diagonal por bloques.
	</para>
      </description>
    </function>

    <function name="diff" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="smlist">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do mesmo tipo que o argumento) coas primeiras
	  diferenzas. Se <argname>y</argname> é unha serie ou unha lista de series,
	  os valores iniciais son <lit>NA</lit>; se <argname>y</argname> é unha
	  matriz, a diferenciación faise por columnas e os valores iniciais son 0.
	</para>
	<para>
	  Cando esta función devolve unha lista, cada unha das variables
	  da mesma noméase de xeito automático conforme ao padrón
	  <lit>d_</lit><repl>varname</repl>, onde <repl>varname</repl>
	  substitúese polo nome da serie orixinal. De ser necesario, o nome
	  vai tronzarse, e mesmo axustarase no caso de que o conxunto de
	  nomes que se constrúe así, dea lugar a que algún deles non sexa
	  único.
	</para>
	<para>
	  <seelist>
            <fncref targ="cum"/>
            <fncref targ="ldiff"/>
            <fncref targ="sdiff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="digamma" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devolve un resultado (do tipo do argumento) co valor da función
	  digamma (ou Psi) de <argname>x</argname>, é dicir, a derivada do
	  logaritmo da función Gamma.
	</para>
	<para context="tex">
	  Devolve un resultado co valor da función digamma (ou Psi) de $x$, é
	  dicir $\frac{d}{dx}\, \mbox{ln } \Gamma(x)$.
	</para>
      </description>
    </function>

    <function name="dnorm" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do mesmo tipo que o argumento) co valor da
	  densidade da distribución de probabilidade Normal estándar en
	  <argname>x</argname>. Para obter a densidade dunha distribución Normal
	  non estándar en <math>x</math>, transforma tipificando <math>x</math>
	  en <math>z</math>, aplícalle a isto a función <lit>dnorm</lit> e 
	  multiplica o resultado polo Jacobiano da transformación <math>z</math>,
	  é dicir , 1/&sigma;, conforme se ilustra deseguido:
	</para>
	<code>
	  mu = 100
	  sigma = 5
	  x = 109
	  fx = (1/sigma) * dnorm((x-mu)/sigma)
	</code>
	<para>
	  <seelist>
            <fncref targ="cnorm"/>
            <fncref targ="qnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="dropcoll" section="transforms" output="list">
      <fnargs>
	<fnarg type="list">X</fnarg>
	<fnarg optional="true" type="scalar">epsilon</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha lista cos mesmos elementos que <argname>X</argname>,
	  mais excluíndo as series que causan multicolinearidade perfecta. En
	  consecuencia, se todas as series que hai en <argname>X</argname>
	  son linearmente independentes, a lista que resulta é simplemente
	  unha copia de <argname>X</argname>.
	</para>
	<para>
	  O algoritmo usa a descomposición QR (transformación de Householder),
	  polo que está suxeita a erro de precisión finita. Co obxecto de
	  calibrar a sensibilidade do algoritmo, podes especificar un segundo
	  parámetro (opcional) <argname>epsilon</argname> para facer a proba
	  de multicolinearidade máis ou menos estrita, segundo desexes. Por
	  defecto, o valor para <argname>epsilon</argname> é 1.0e-8, pero
	  axustando <argname>epsilon</argname> dándolle valores maiores,
	  elévase a probabilidade de que se descarte unha das series.
	</para>
	<para>
	  O exemplo
	</para>
	<code>
	  nulldata 20
	  set seed 9876
	  series foo = normal()
	  series bar = normal()
	  series foobar = foo + bar
	  list X = foo bar foobar
	  list Y = dropcoll(X)
	  list print X
	  list print Y
	  # Indica un épsilon cun valor moi pequeno
	  list Y = dropcoll(X, 1.0e-30)
	  list print Y
	</code>
	<para>
	  produce
	</para>
	<code>
	  ? list print X
	  foo bar foobar
	  ? list print Y
	  foo bar
	  ? list Y = dropcoll(X, 1.0e-30)
	  Replaced list Y
	  ? list print Y
	  foo bar foobar
	</code>
      </description>
    </function>

    <function name="dsort" section="matshape" output="asinput">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Ordena <argname>x</argname> de forma decrecente, descartando
	  observacións con valores ausentes cando <argname>x</argname> é
	  unha serie.
	  <seelist>
            <fncref targ="sort"/>
            <fncref targ="values"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="dummify" section="transforms" output="list">
      <fnargs>
	<fnarg type="series">x</fnarg>
	<fnarg optional="true" type="scalar">omitval</fnarg>
      </fnargs>
      <description>
	<para>
	  O argumento <argname>x</argname> debe ser unha serie discreta. Esta
	  función devolve unha lista cun conxunto de variables ficticias, unha
	  para cada un dos diferentes valores da serie. Por defecto, o menor
	  valor trátase como a categoría omitida e non vai representarse
	  explicitamente.
	</para>
	<para>
	  O segundo argumento (opcional) indica o valor de <argname>x</argname>
	  que debe tratarse como a categoría omitida. Cando se indica un único
	  argumento, o efecto é equivalente ao de utilizar a instrución:
	  <lit>dummify(x, min(x))</lit>. Para producir un conxunto completo de
	  variables ficticias, é dicir, sen omitir ningunha categoría, podes
	  usar <lit>dummify(x, NA)</lit>.
	</para>
	<para>
	  As variables que se xeran noméanse automaticamente de acordo co
	  seguinte padrón:
	  <lit>D</lit><repl>varname</repl><lit>_</lit><repl>i</repl> onde
	  <repl>varname</repl> indica o nome da serie orixinal e <repl>i</repl>
	  é un índice enteiro positivo. De ser necesario, a porción orixinal do
	  nome vai tronzarse, e mesmo axustarase no caso de que o conxunto de
	  nomes que se constrúe así, dea lugar a que algún deles non sexa
	  único.
	</para>
      </description>
    </function>

    <function name="easterday" section="calendar" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Poñendo un ano como argumento <argname>x</argname>, devolve un
	  resultado do mesmo tipo ca este, coa data do domingo de Pascua dese
	  ano no calendario gregoriano, co formato <math>mes + día/100</math>.
	  Observa que con esta convención, o 10 de abril é 4.1; de aí que 4.2
	  represente o día 20 de abril e non o 2 de abril (que é 4.02). Exemplo:
	</para>
	<code>
	  scalar e = easterday(2014)
	  scalar m = floor(e)
	  scalar d = 100*(e-m)
	</code>
      </description>
    </function>

    <function name="ecdf" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Calcula a función de distribución acumulativa (CDF) empírica de
	  <argname>y</argname>. O resultado devólvese nun formato de matriz
	  con dúas columnas: a primeira contén os valores únicos ordenados de
	  <argname>y</argname> e a segunda contén a frecuencia relativa 
	  acumulada, é dicir o número de casos nos que o seu valor é menor ou
	  igual ao valor correspondente da primeira columna, dividido polo
	  número total de observacións.
	</para>
	<para context="tex">
	  Calcula a función de distribución acumulativa (CDF) empírica de
	  <argname>y</argname>. O resultado devólvese nun formato de matriz
	  con dúas columnas: a primeira contén os valores únicos ordenados de
	  <argname>y</argname> e a segunda ten a frecuencia relativa acumulada
	  \[ F(y) =
	  \frac{1}{n} \sum_{i=1}^n I(y_i \leq y)
	  \]
	  onde $n$ é o número total de observacións e $I()$ denota a función
	  indicadora.
	</para>
      </description>
    </function>

    <function name="eigengen" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula os autovalores e, opcionalmente, os autovectores da matriz
	  <argname>A</argname> de orde <by r="n" c="n"/>. Cando todos os
	  autovalores son reais, devólvese unha matriz <by r="n" c="1"/>. Noutro
	  caso o resultado é unha matriz <by r="n" c="2"/>, cunha primeira
	  columna que contén os elementos reais e unha segunda columna cos
	  elementos imaxinarios. Non se garante que os autovalores se vaian
	  clasificar en ningunha orde en particular.
	</para>
	<para>
	  Hai dúas opcións para o segundo argumento: que se trate do nome
	  dunha matriz xa existente precedida por <lit>&amp;</lit> (para
	  indicar o <quote>enderezo</quote> da matriz en cuestión), en cuxo
	  caso nesta matriz gárdase un resultado auxiliar; ou que se trate
	  da palabra chave <lit>null</lit>, en cuxo caso non se produce o
	  resultado auxiliar.
	</para>
	<para>
	  Cando o segundo argumento non é nulo, vaise sobrescribir a matriz
	  especificada co resultado auxiliar (e non é necesario que a matriz
	  existente teña a dimensión adecuada para recibir o resultado). O
	  resultado na matriz <argname>U</argname> organízase do seguinte xeito:
	</para>
	<ilist>
	  <li>
            <para>
              Se o <math>i</math>-ésimo autovalor é real, a
              <math>i</math>-ésima columna de <math>U</math> vai
              conter o autovector correspondente;
            </para>
	  </li>
	  <li>
            <para>
              Se o <math>i</math>-ésimo autovalor é complexo, a
              <math>i</math>-ésima columna de <math>U</math> vai
              conter a parte real do autovector correspondente, e a
              seguinte columna a parte imaxinaria. O autovector do autovalor
              conxugado é o conxugado do autovector.
            </para>
	  </li>
	</ilist>
	<para>
	  Noutras palabras, os autovectores gárdanse na mesma orde ca os
	  autovalores; agora ben, os autovectores reais ocupan unha columna,
	  no entanto os autovectores complexos ocupan dúas (e a parte real
	  gárdase primeiro). Aínda así, o número total de columnas é
	  <math>n</math>, pois o autovector conxugado ignórase.
	</para>
	<para>
	  <seelist>
            <fncref targ="eigensym"/>
            <fncref targ="eigsolve"/>
            <fncref targ="qrdecomp"/>
            <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="eigensym" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="symmat">A</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Funciona da mesma forma que a función <fncref targ="eigengen"/>,
	  mais o argumento <argname>A</argname> debe de ser simétrico (polo
	  que neste caso pódense acurtar os cálculos). Devolve unha matriz na
	  que, a diferenza do que acontece con <fncref targ="eigengen"/>, os
	  autovalores sitúanse en orde ascendente.
	</para>
	<para>
	  Aviso: Se o que te interesa é a descomposición espectral dunha
	  matriz da forma <math>X'X</math>, onde <math>X</math> é unha matriz
	  grande, é preferible calculala a través do operador <lit>X'X</lit> en
	  lugar de utilizar a sintaxe máis xeral <lit>X'*X</lit>. A primeira
	  expresión utiliza un algoritmo especializado que ten unha dobre
	  vantaxe pois é máis eficiente dende o punto de vista do cómputo,
	  e garante que o resultado, por construción, está libre de artefactos
	  de precisión de máquina que poden convertela en numericamente non 
	  simétrica.
	</para>
      </description>
    </function>

    <function name="eigsolve" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="symmat">A</fnarg>
	<fnarg type="symmat">B</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Resolve o problema do autovalor xeneralizado de tipo
	  |<math>A</math> &minus; &lgr;<math>B</math>| = 0, onde ambas
	  <math>A</math> e <math>B</math> son matrices simétricas e
	  <math>B</math> defínese positiva. Devólvese directamente unha matriz
	  cos autovalores ordenados de forma ascendente. Cando utilizas o
	  terceiro argumento (opcional), este debe ser o nome dunha matriz xa
	  existente, precedida por <lit>&amp;</lit>. Neste caso os autovectores
	  xeneralizados escríbense nesta matriz que se indica.
	</para>
      </description>
    </function>

    <function name="epochday" section="calendar" output="scalar-or-series">
      <fnargs>
	<fnarg type="scalar-or-series">year</fnarg>
	<fnarg type="scalar-or-series">month</fnarg>
	<fnarg type="scalar-or-series">day</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar ou unha serie, co número do día na época actual
	  especificada polo ano, mes e día, nesa orde. O número do día é igual
	  a 1 para o día 1 de xaneiro do ano 1 despois de Cristo, e a 733786
	  na data 2010-01-01. Se algún dos argumentos é unha serie, o valor
	  que se devolve tamén terá a forma dunha serie, noutro caso devólvese
	  un escalar.
	</para>
	<para>
	  Por defecto, os valores dos argumentos <argname>year</argname>,
	  <argname>month</argname> e <argname>day</argname> se
	  presupón que se están indicando de acordo ao calendario Gregoriano,
    mais se o ano ten un valor negativo, a interpretación muda á do
    calendario Xuliano.
	</para>
	<para>
	  Para a inversa desta función consulta <fncref targ="isodate"/>, e
	  tamén <fncref targ="juldate"/> (para o calendario Xuliano).
	</para>
      </description>
    </function>

    <function name="errmsg" section="strings" output="string">
      <fnargs>
	<fnarg type="int">errno</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha cadea de texto coa mensaxe de fallo do Gretl asociada
	  ao <argname>errno</argname>, que debe ser un número enteiro.
	  Consulta tamén <fncref targ="$error"/>.
	</para>
      </description>
    </function>

    <function name="exists" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">name</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar non nulo se <argname>name</argname> é o nome que
	  identifica un obxecto que xa se definiu, sexa un escalar, unha serie,
	  unha matriz, unha lista, unha cadea de texto, un feixe ou un arranxo.
	  Noutro caso devolve 0. Consulta tamén <fncref targ="typeof"/>.
	</para>
      </description>
    </function>

    <function name="exp" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do mesmo tipo que o argumento) coa transformación
	  <math>e</math><sup>x</sup> . Con matrices aplícase elemento a elemento.
	  Para a función exponencial matricial consulta <fncref targ="mexp"/>.
	</para>
      </description>
    </function>

    <function name="fcstats" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="series-list-or-mat">f</fnarg>
      </fnargs>
      <description>
	<para>
	  Xera unha matriz que contén varios estatísticos que serven
	  para avaliar a <argname>f</argname> como predición dos datos
	  observados <argname>y</argname>.
	</para>
	<para>
	  Cando <argname>f</argname> é unha serie ou un vector, o resultado
	  é un vector columna. Cando <argname>f</argname> é unha lista con
	  <math>k</math> elementos ou unha matriz de dimensión <by r="T" c="k"/>,
	  o resultado ten <math>k</math> columnas nas que cada unha contén
	  os estatísticos do termo correspondente (serie da lista ou columna
	  da matriz) como predición de <argname>y</argname>.
	</para>
	<para>
	  En tódolos casos, a dimensión <quote>vertical</quote> dos datos
	  introducidos (o longo da mostra vixente para unha serie ou unha
	  lista, e o número de filas para unha matriz) debe de coincidir entre
	  os dous argumentos.
	</para>
	<para>
	  As filas da matriz que se devolve son como se indica deseguido:
	</para>
	<code>
	  1  Erro Medio (ME)
	  2  Raíz do Erro Cadrado Medio (RMSE)
	  3  Erro Absoluto Medio (MAE)
	  4  Porcentaxe de Erro Medio (MPE)
	  5  Porcentaxe de Erro Absoluto Medio (MAPE)
	  6  U de Theil
	  7  Proporción do nesgo, UM
	  8  Proporción de regresión, UR
	  9  Proporción de perturbación, UD
	</code>
	<para>
	  Para obter máis detalles sobre o cálculo deses estatísticos e da
	  interpretación dos valores de <math>U</math>, consulta o
	  <guideref targ="chap:forecast"/>.
	</para>
      </description>
    </function>

    <function name="fdjac" section="numerical" output="matrix">
      <fnargs>
	<fnarg type="cvec">b</fnarg>
	<fnarg type="fncall">fcall</fnarg>
	<fnarg optional="true" type="scalar">h</fnarg>
      </fnargs>
      <description>
	<para>
	  Permite calcular unha aproximación numérica ao Jacobiano
	  asociado ao <math>n</math>-vector <argname>b</argname>,
	  así como a función de transformación especificada polo
	  argumento <argname>fcall</argname>. Ao apelar a esta función
	  debes de utilizar <argname>b</argname> como o seu primeiro
	  argumento (ben directamente ou en forma de punteiro), seguido
	  de calquera argumento adicional que poda necesitarse; e como
	  resultado deberase producir unha matriz <by r="m" c="1"/>.
	  Cando se executa con éxito, <lit>fdjac</lit> vai devolver
	  unha matriz <by r="m" c="n"/> que contén o Jacobiano.
	</para>
	<para>
	  Podes utilizar o terceiro argumento (opcional) para determinar o
	  tamaño da medida <math>h</math> que se usa no mecanismo de
	  aproximación (mira máis abaixo). Cando omites este argumento, o
	  tamaño da medida determínase automaticamente.
	</para>
	<para>
	  Aquí tes un exemplo do seu uso:
	</para>
	<code>
	  matrix J = fdjac(theta, myfunc(&amp;theta, X))
	</code>
	<para>
	  A función pode utilizar tres métodos distintos: diferenza simple cara
	  adiante, diferenza bilateral ou extrapolación de 4-nodos de Richardson.
	  Estas correspóndense respectivamente con:
	</para>
	<para context="tex">
	  \[ J_0 = \frac{f(x + h) - f(x)}{h} \]
	</para>
	<para context="tex">
	  \[ J_1 = \frac{f(x + h) - f(x - h)}{2h} \]
	</para>
	<para context="tex">
	  \[ J_2 = \frac{8(f(x+h) - f(x-h)) - (f(x+2h) - f(x-2h))}{12h} \]
	</para>
	<para context="notex">
	  <math>J</math><sub>0</sub> = <math>(f(x+h) - f(x))/h</math>
	</para>
	<para context="notex">
	  <math>J</math><sub>1</sub> = <math>(f(x+h) - f(x-h))/2h</math>
	</para>
	<para context="notex">
	  <math>J</math><sub>2</sub>  = <math>[8(f(x+h) - f(x-h)) -
	  (f(x+2h) - f(x-2h))] /12h</math>
	</para>
	<para>
	  Estas tres alternativas xeralmente proporcionan unha transacción
	  entre precisión e velocidade. Podes elixir entre os distintos
	  métodos utilizando a instrución <cmdref targ="set"/> e especificando
	  o valor 0, 1 ou 2 para a variable <lit>fdjac_quality</lit>.
	</para>
	<para>
	  Para máis detalles e exemplos, consulta
	  <guideref targ="chap:numerical"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="BFGSmax"/>
	          <fncref targ="numhess"/>
            <cmdref targ="set"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="fevd" section="stats" output="matrix">
      <fnargs>
	<fnarg type="int">target</fnarg>
	<fnarg type="int">shock</fnarg>
	<fnarg type="bundle" optional="true">sys</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta función proporciona unha alternativa máis flexible ao
	  accesorio <fncref targ="$fevd"/> para obter unha matriz
	  de descomposición da varianza do erro de predición (FEVD)
	  logo de estimar un VAR ou un VECM. A falta do argumento final
	  (opcional), só está dispoñible cando o último modelo estimado
	  foi un VAR ou un VECM. Como alternativa, podes gardar nun
	  feixe a información sobre estes tipos de sistemas, mediante o
	  accesorio <fncref targ="$system"/>, e posteriormente pasarlle
	  a función <lit>fevd</lit>.
	</para>
	<para>
	  Os argumentos da función, <argname>target</argname> e
	  <argname>shock</argname>, teñen a forma de índices enteiros
	  positivos das variable endóxenas do sistema, tomando o 0 para
	  representar <quote>todas</quote>. O seguinte fragmento de código,
	  ilustra o seu uso. No primeiro exemplo, a matriz <lit>fe1</lit>
	  contén as partes da FEVD para <lit>y1</lit> debidas a cada
	  parte de <lit>y1</lit>, <lit>y2</lit> e <lit>y3</lit> (polo tanto,
	  as filas suman 1 en total). No segundo, <lit>fe2</lit> contén
	  a contribución de <lit>y2</lit> á varianza do erro de predición
	  das tres variables (entón, as filas non suman 1 en total).
	  No terceiro caso, o que se devolve é un vector columna que
	  amosa a <quote>parte propia</quote> da FEVD de
	  <lit>y1</lit>.
	</para>
	<code>
	  var 4 y1 y2 y3
	  bundle vb = $system
	  matrix fe1 = fevd(1, 0, vb)
	  matrix fe2 = fevd(0, 2, vb)
	  matrix fe3 = fevd(1, 1, vb)
	</code>
	<para>
	  O número de períodos (filas) sobre os que se traza a
	  descomposición, determínase automaticamente en base á
	  frecuencia dos datos, pero podes ignorar isto mediante o
	  argumento <lit>horizon</lit> da instrución <cmdref targ="set"/>,
    como en <lit>set horizon 10</lit>.
	</para>
	<para>
	  <seelist><fncref targ="irf"/></seelist>
	</para>
      </description>
    </function>

    <function name="fft" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz coa transformación de Fourier real. Se a matriz
	  <argname>X</argname> do argumento ten <math>n</math> columnas, a que
	  se devolve ten 2<math>n</math> columnas, onde as partes reais gárdanse
	  nas columnas impares e as partes complexas nas columnas pares.
	</para>
	<para>
	  Cando necesites aplicar a transformación de Fourier sobre varios
	  vectores co mesmo número de elementos, resulta numericamente máis
	  eficiente agrupar os vectores nunha matriz ca executar <lit>fft</lit>
	  para cada un por separado.
	  <seelist>
            <fncref targ="ffti"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ffti" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz con <math>n</math> columnas co resultado da
	  transformación inversa discreta real de Fourier. Asúmese que a matriz
	  <argname>X</argname> consta de <math>n</math> vectores columna
	  complexos, coa parte real nas columnas impares e a parte imaxinaria
	  nas columnas pares, de forma que deberá ter 2<math>n</math>
	  columnas.
	</para>
	<para>
	  Cando necesites aplicar a transformación inversa de Fourier sobre
	  varios vectores co mesmo número de elementos, resulta numericamente máis
	  eficiente agrupar os vectores nunha matriz ca executar <lit>ffti</lit>
	  para cada un por separado.
	  <seelist>
            <fncref targ="fft"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="filter" section="filters" output="seebelow">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
	<fnarg optional="true" type="scalar-or-vec">a</fnarg>
	<fnarg optional="true" type="scalar-or-vec">b</fnarg>
	<fnarg optional="true" type="scalar">y0</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve o resultado de aplicar un filtro semellante a un ARMA ao
	  argumento <argname>x</argname>. A transformación pode escribirse como
	</para>
	<para context="tex">
	  \[ y_t = \sum_{i=0}^q a_i x_{t-i} + \sum_{i=1}^p b_i y_{t-i} \]
	</para>
	<para context="notex">
	  <math>y</math><sub>t</sub> =
	  <math>a</math><sub>0</sub> <math>x</math><sub>t</sub> +
	  <math>a</math><sub>1</sub> <math>x</math><sub>t-1</sub> +
	  ...
	  <math>a</math><sub>q</sub> <math>x</math><sub>t-q</sub> +
	  <math>b</math><sub>1</sub> <math>y</math><sub>t-1</sub> +
	  ...
	  <math>b</math><sub>p</sub><math>y</math><sub>t-p</sub>
	</para>
	<para>
	  Se o argumento <argname>x</argname> é unha serie, o resultado que se
	  devolve tamén é unha serie. Noutro caso se <argname>x</argname> é
	  unha matriz con <math>T</math> filas e <math>k</math> columnas, o
	  que se devolve é a matriz do mesmo tamaño que resulta de aplicar o
	  filtro columna por columna.
	</para>
	<para>
	  Os argumentos <argname>a</argname> e <argname>b</argname> son
	  opcionais. Poden ser escalares, vectores ou a palabra chave
	  <lit>null</lit>.
	</para>
	<para>
	  Cando <argname>a</argname> é un escalar, vaise utilizar como
	  <math>a</math><sub>0</sub> e implicará que <math>q=0</math>.
	  Cando é un vector con <math>q+1</math> elementos, vai conter
	  os coeficientes de <math>a</math><sub>0</sub> ata
	  <math>a</math><sub>q</sub>. Cando <argname>a</argname> é
	  <lit>null</lit> ou se omite, isto é equivalente a definir
	  <math>a</math><sub>0</sub> <math>=1</math> e
	  <math>q=0</math>.
	</para>
	<para>
	  Cando <argname>b</argname> é un escalar, vaise utilizar como
	  <math>b</math><sub>1</sub> e implicará que <math>p=1</math>.
	  Cando é un vector con <math>p</math> elementos, vai conter
	  os coeficientes de <math>b</math><sub>1</sub> ata
	  <math>b</math><sub>p</sub>. Cando <argname>b</argname> é
	  <lit>null</lit> ou se omite, isto é equivalente a definir
	  <math>B(L)=1</math>.
	</para>
	<para>
	  O argumento escalar opcional <argname>y0</argname> utilízase para
	  representar todos os valores de <math>y</math> anteriores ao comezo
	  da mostra (úsase só cando <math>p>0</math>). Cando se omite,
	  enténdese que é igual a 0. Asúmese que os valores de
	  <argname>x</argname> anteriores ao comezo da mostra son sempre 0.
	</para>
	<para>
	  <seelist>
            <fncref targ="bkfilt"/>
            <fncref targ="bwfilt"/>
            <fncref targ="fracdiff"/>
            <fncref targ="hpfilt"/>
            <fncref targ="movavg"/>
            <fncref targ="varsimul"/>
	  </seelist>
	</para>
	<para>
	  Exemplo:
	</para>
	<code>
	  nulldata 5
	  y = filter(index, 0.5, -0.9, 1)
	  print index y --byobs
	  x = seq(1,5)' ~ (1 | zeros(4,1))
	  w = filter(x, 0.5, -0.9, 1)
	  print x w
	</code>
	<para>
	  produce
	</para>
	<code>
          index            y
          
          1            1     -0.40000
          2            2      1.36000
          3            3      0.27600
          4            4      1.75160
          5            5      0.92356
          
          x (5 x 2)
          
          1   1
          2   0
          3   0
          4   0
          5   0
          
          w (5 x 2)
          
          -0.40000     -0.40000
          1.3600      0.36000
          0.27600     -0.32400
          1.7516      0.29160
          0.92356     -0.26244
	</code>
      </description>
    </function>

    <function name="firstobs" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve o número enteiro positivo que indexa a primeira observación
	  non ausente da serie <argname>y</argname>. Ten en conta que se
	  está activa algunha forma de submostraxe, o valor que se devolve
	  pode ser menor ca o valor devolto polo accesorio
	  <fncref targ="$t1"/>.
	  <seelist>
            <fncref targ="lastobs"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="fixname" section="strings" output="string">
      <fnargs>
	<fnarg type="string">rawname</fnarg>
	<fnarg type="bool" optional="true">underscore</fnarg>
      </fnargs>
      <description>
	<para>
	  En principio, esta función está ideada para utilizarse en conxunto coa instrución
	  <cmdref targ="join"/>. Devolve unha cadea co resultado da conversión
	  de <argname>rawname</argname> nun identificador válido de Gretl;
	  debe iniciarse cunha letra, debe conter só letras ASCII, díxitos
	  e/ou trazo baixo, e non debe ter máis ca 31 caracteres. As regras
	  que se utilizan na conversión son:
	</para>
	<para>
	  1. Quitar do inicio do nome, calquera carácter que non sexa unha letra.
	</para>
	<para>
	  2. Ata que se acada o límite dos 31 caracteres ou ata que se esgota o
	  indicado no argumento: transcribe os caracteres <quote>legais</quote>,
	  substitúe un ou varios espazos consecutivos por un trazo baixo
	  (agás que o carácter anterior transcrito sexa un trazo baixo,
	  pois entón elimínase o espazo) e omite os outros tipos de caracteres
	  <quote>ilegais</quote>.
	</para>
	<para>
	  Se estás convencido de que a entrada non é demasiado longa (entón
	  susceptible de ser tronzada), podes querer substituír secuencias
	  de un ou máis caracteres ilícitos mediante unha barra de subliñado,
	  en troques de só eliminalos, pois isto podería xerar un identificador
	  máis lexible. Para acadar este efecto, proporciona un valor non
	  nulo para o segundo argumento (opcional). Mais isto non é
	  recomendable no contexto da instrución <cmdref targ="join"/>,
	  posto que o nome <quote>fixado</quote> automaticamente non
	  vai utilizar barras de subliñado deste xeito.
	</para>
      </description>
    </function>

    <function name="floor" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co valor do maior enteiro
	  que é menor ou igual que <argname>x</argname>. Cae na conta de que
	  <fncref targ="int"/> e <lit>floor</lit> teñen efectos distintos
	  con argumentos negativos:<lit>int(-3.5)</lit> xera &minus;3,
	  namentres <lit>floor(-3.5)</lit> xera &minus;4.
	</para>
      </description>
    </function>

    <function name="fracdiff" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="scalar">d</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devolve unha serie coa diferenza fraccionaria de orde
	  <argname>d</argname> da a serie <argname>y</argname>.
	</para>
	<para context="tex">
          \[
          \Delta^d y_t = y_t - \sum_{i=1}^{\infty} \psi_i y_{t-i}
          \]
	  onde
          \[\psi_i = \frac{\Gamma(i-d)}{\Gamma(-d) \Gamma(i+1)}\]
	</para>
	<para>
	  Observa que, en teoría, a diferenciación fraccionaria supón un filtro
	  infinitamente longo. Pero os valores de <math>y</math><sub>t</sub>
	  anteriores á mostra, na práctica asúmese que son iguais a cero.
	</para>
	<para>
	  Podes utilizar valores negativos para <argname>d</argname>, e nese
	  caso a función realiza a integración fraccionaria.
	</para>
      </description>
    </function>

    <function name="gammafun" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co valor da función Gamma de <argname>x</argname>.
	</para>
      </description>
    </function>

    <function name="genseries" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="string">varname</fnarg>
	<fnarg type="series">rhs</fnarg>
      </fnargs>
      <description>
	<para>
	  Proporciónalle ao guionista un procedemento adecuado de xerar
	  series cuxos nomes non se coñecen a priori, e/ou de crear series e
	  engadilas a unha lista por medio dunha única operación (devolve
	  un escalar).
	</para>
	<para>
	  O primeiro argumento proporciona o nome da serie que se vai crear
	  (ou modificar); e pode ser un texto literal, unha cadea de texto ou
	  unha expresión cuxo resultado sexa unha cadea de texto. O segundo
	  argumento, <argname>rhs</argname> (<quote>lado dereito</quote> en
	  inglés), define a serie orixinal: isto pode ser o nome dunha serie
	  existente ou unha expresión cuxo resultado sexa  unha serie, no
	  xeito no que aparece habitualmente do lado dereito do símbolo de
	  igualdade cando se definen series.
	</para>
	<para>
	  O valor que devolve esta función é un escalar co número ID da serie
	  no conxunto de datos, que é axeitado para incluír a serie nunha lista
	  (ou &minus;1 no caso de fallar a execución da función).
	</para>
	<para>
	  Por exemplo, supón que queres engadir <math>n</math> series
	  aleatorias con distribución de probabilidade Normal ao conxunto de
	  datos e colocalas nunha lista. O seguinte código fai iso:
	</para>
	<code>
	  list Normals = null
	  loop i=1..n --quiet
	      Normals += genseries(sprintf("norm%d", i), normal())
	  endloop
	</code>
	<para>
	  Ao rematar a execución, a lista <lit>Normals</lit> vai conter as
	  series <lit>norm1</lit>, <lit>norm2</lit> e así sucesivamente.
	</para>
      </description>
    </function>

    <function name="getenv" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Cando xa está definida unha variable de entorno co nome do argumento
	  <argname>s</argname>, a función devolve o valor desa variable como
	  cadea de texto; noutro caso devolve unha cadea de texto baleira.
	  Consulta tamén <fncref targ="ngetenv"/>.
	</para>
      </description>
    </function>

    <function name="getinfo" section="data-utils" output="bundle">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve información sobre a serie especificada, a que podes indicar
	  mediante o seu nome ou o seu número ID. O paquete que se devolve
	  contén tódolos atributos que se poden establecer por medio da
	  instrución <cmdref targ="setinfo"/>. E tamén contén información
	  adicional relevante para series que se xeraron como transformacións
	  de datos primarios (mediante retardos, logaritmos, etc.); isto inclúe
	  a palabra da instrución de Gretl para a transformación coa 
	  clave <quote>transform</quote> e o nome da serie asociada primaria
	  coa clave <quote>parent</quote>. Para as series retardadas, podes
	  atopar o número específico de retardos baixo a clave
	  <quote>lag</quote>.
	</para>
	<para>
	  Aquí tes un exemplo do seu uso:
	</para>
	<code>
	  open data9-7
	  lags QNC
	  bundle b = getinfo(QNC_2)
	  print b
	</code>
	<para>
	  Ao executar o anterior, podemos ver:
	</para>
	<code>
	  has_string_table = 0
	  lag = 2
	  parent = QNC
	  name = QNC_2
	  graph_name = 
	  coded = 0
	  discrete = 0
	  transform = lags
	  description = = QNC(t - 2)
	</code>
	<para>
	  Para probar se a serie 5 dun conxunto de datos é un termo retardado,
	  podes facer este tipo de cousas:
	</para>
	<code>
	  if getinfo(5).lag != 0
	     printf "A serie 5 é un retardo de %s\n", getinfo(5).parent
	  endif
	</code>
	<para>
	  Ten en conta que podes utilizar a notación co punto para acceder aos
	  elementos dun paquete, mesmo cando o paquete é <quote>anónimo</quote>
	  (non gardado co seu propio nome).
	</para>
      </description>
    </function>

    <function name="getkeys" section="data-utils" output="strings">
      <fnargs>
	<fnarg type="bundle">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un arranxo de cadeas de texto que conteñen as chaves que
	  identifican o contido de <argname>b</argname>. Se o paquete está
	  baleiro, devólvese un arranxo baleiro.
	</para>
      </description>
    </function>

    <function name="getline" section="strings" output="scalar">
      <fnargs>
	<fnarg type="string">source</fnarg>
	<fnarg type="string">target</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta función le filas consecutivas de <argname>source</argname>,
	  que debe de ser unha cadea de texto xa definida. Con cada chamada á
	  función escríbese unha liña de texto en <argname>target</argname>
	  (que tamén debe de ser unha cadea de texto) sen o carácter de nova
	  liña. O valor que se devolve é un escalar igual a 1, cando existe
	  algo por ler (incluídas filas en branco), ou igual a 0 se todas as
	  filas de <argname>source</argname> xa se leron.
	</para>
	<para>
	  A continuación preséntase un exemplo onde o contido dun ficheiro de
	  texto divídese en filas:
	</para>
	<code>
	  string s = readfile("data.txt")
	  string line
	  scalar i = 1
	  loop while getline(s, line)
	      printf "line %d = '%s'\n", i++, line
	  endloop
	</code>
	<para>
	  No exemplo pódese asegurar que, cando remate o bucle, o texto de
	  <argname>source</argname> está esgotado. Se non desexas esgotalo
	  todo, podes facer unha chamada normal a <lit>getline</lit>, seguida
	  dunha nova chamada de <quote>limpeza</quote>, trocando o argumento
	  <argname>target</argname> por <lit>null</lit> (ou deixalo en branco),
	  co que se reinicia a lectura de <argname>source</argname>, como en
	</para>
	<code>
	  getline(s, line) # Obtén unha única fila
	  getline(s, null) # Reinicia a lectura
	</code>
	<para>
	  Ten en conta que, aínda que avanza a posición de lectura cada vez que
	  se executa <lit>getline</lit>, o argumento <argname>source</argname>
	  non se altera por esa función; só cambia <argname>target</argname>.
	</para>
      </description>
    </function>

    <function name="ghk" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">C</fnarg>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix">B</fnarg>
	<fnarg type="matrix">U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;dP</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula a aproximación GHK (Geweke, Hajivassiliou, Keane) á función
	  de distribución normal multivariante; podes consultar, por exemplo,
	  <cite key="geweke91">Geweke (1991)</cite>. O valor que se devolve é
	  un vector <by r="n" c="1"/> de probabilidades.
	</para>
	<para>
	  O argumento matricial <argname>C</argname> (<by r="m" c="m"/>) debe de
	  achegar o factor de Cholesky (matriz triangular inferior) da matriz de
	  covarianzas de <math>m</math> variables normais. Os argumentos
	  matriciais <argname>A</argname> e <argname>B</argname> deben de ser
	  ambos <by r="n" c="m"/>, e indicar respectivamente os límites inferior
	  e superior que se aplican ás variables en cada unha das <math>n</math>
	  observacións. Onde as variables non teñan límites, iso débese indicar
	  usando a constante <fncref targ="$huge"/> ou o seu negativo.
	</para>
	<para>
	  A matriz <argname>U</argname> debe de ser <by r="m" c="r"/>, onde
	  <math>r</math> indica o número de extraccións pseudoaleatorias dunha
	  distribución uniforme. Para crear <argname>U</argname> son adecuadas
	  as funcións <fncref targ="muniform"/> e <fncref targ="halton"/>.
	</para>
	<para>
	  Debaixo ilústrase isto cun exemplo relativamente simple, onde as
	  probabilidades multivariantes poden calcularse analiticamente.
	  As series <lit>P</lit> e <lit>Q</lit> deben de ser numericamente
	  moi semellantes unha á outra, denotando como <lit>P</lit> á
	  probabilidade <quote>verdadeira</quote> e como <lit>Q</lit> á súa
	  aproximación GHK:
	</para>
	<code>
	  nulldata 20
	  series inf1 = -2*uniform()
	  series sup1 = 2*uniform()
	  series inf2 = -2*uniform()
	  series sup2 = 2*uniform()

	  scalar rho = 0.25
	  matrix V = {1, rho; rho, 1}

	  series P = cdf(D, rho, inf1, inf2) - cdf(D, rho, sup1, inf2) \
	  - cdf(D, rho, inf1, sup2) + cdf(D, rho, sup1, sup2)

	  C = cholesky(V)
	  U = halton(2, 100)

	  series Q = ghk(C, {inf1, inf2}, {sup1, sup2}, U)
	</code>
	<para>
	  O argumento opcional <argname>dP</argname> úsase para obter a matriz
	  <by r="n" c="k"/> de derivadas das probabilidades, onde <math>k</math>
	  equivale a 2<math>m</math> + <math>m</math>(<math>m</math> + 1)/2.
	  As primeiras <math>m</math> columnas van conter as derivadas con
	  respecto a os límites inferiores, as seguintes <math>m</math> van
	  recoller as derivadas con respecto a os límites superiores, e as
	  restantes columnas van recoller as derivadas con respecto a os
	  elementos singulares da matriz <math>C</math> na orde que sigue a
	  semivectorización <quote>vech</quote> dunha matriz simétrica.
	</para>
      </description>
    </function>

    <function name="gini" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co índice de desigualdade de Gini para a serie ou
	  vector (non negativos) <argname>y</argname>. Un valor de Gini igual a
	  cero indica igualdade perfecta. O máximo valor de Gini para unha serie
	  con <math>n</math> elementos é (<math>n</math> &minus; 1)/<math>n</math>,
	  o que acontece cando unicamente un elemento ten un valor positivo;
	  polo tanto, un valor de Gini igual a 1.0 é o límite que se acada cando
	  unha serie moi longa ten máxima desigualdade.
	</para>
      </description>
    </function>

    <function name="ginv" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve a matriz <math>A</math><sup>+</sup>, a matriz pseudoinversa
	  de Moore&ndash;Penrose ou inversa xeneralizada de <argname>A</argname>,
	  calculada por medio da descomposición en valores singulares.
	</para>
	<para context="notex">
	  Esta matriz posúe as seguintes propiedades: <math>A</math>
	  <math>A</math><sup>+</sup> <math>A</math> = <math>A</math>
	  e <math>A</math><sup>+</sup> <math>A</math>
	  <math>A</math><sup>+</sup> = <math>A</math><sup>+</sup>.
	  Ademais diso, os produtos <math>A</math> <math>A</math><sup>+</sup>
	  e <math>A</math><sup>+</sup> <math>A</math> son simétricos por
	  construción.
	</para>
	<para context="tex">
	  Esta matriz posúe as seguintes propiedades:
	  \begin{eqnarray*}
	  A A^+ A &amp; = &amp; A \\
	  A^+ A A^+ &amp; = &amp; A^+
	  \end{eqnarray*}
	  Ademais diso, os produtos $A A^+$ e $A^+ A$ son
	  simétricos por construción.
	</para>
	<para>
	  <seelist>
            <fncref targ="inv"/>
            <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="GSSmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg optional="true" type="scalar">toler</fnarg>
      </fnargs>
      <description>
	<para>
	  Maximización unidimensional mediante o método Golden Section Search
	  (GSS). A matriz <argname>b</argname>do argumento debe de ser un
	  vector de 3 elementos. Ao definila, o primeiro elemento ignórase mentres
	  que o segundo e terceiro elementos establecen os límites inferior e
	  superior da procura. O argumento <argname>fncall</argname> deberá de
	  especificar unha chamada á función que devolve o valor do concepto a
	  maximizar; o termo 1 de <argname>b</argname> (que deberá conter o valor
	  vixente do parámetro que se axusta cando se invoca a función) debe de
	  indicarse como primeiro argumento; calquera outro argumento requirido
	  pode ir entón a continuación. A función en cuestión deberá de ser
	  unimodal (non debe de ter outro máximo local que non sexa o máximo
	  global) no rango estipulado, pois do contrario non se asegura que GSS
	  atope o máximo.
	</para>
	<para>
	  Ao completarse con éxito, <lit>GSSmax</lit> devolverá o valor
	  óptimo do concepto que se quere maximizar, mentres que
	  <argname>b</argname> conterá o valor óptimo do parámetro
	  xunto cos límites da súa fiestra de valores.
	</para>
	<para>
	  O terceiro argumento (opcional) pode utilizarse para establecer
	  a tolerancia para acadar a converxencia; é dicir, a amplitude
	  máxima admisible da fiestra final de valores do parámetro.
	  Se non indicas este argumento, utilízase o valor 0.0001.
	</para>
	<para>
	  Se o teu obxectivo realmente é acada un mínimo, podes
	  ben trocar a función considerando o negativo do criterio,
	  ou ben, alternativamente, podes invocar a función
	  <lit>GSSmax</lit>baixo o alcume <lit>GSSmin</lit>.
	</para>
	<para>
	  Aquí tes un exemplo sinxelo de utilización:
	</para>
	<code>
	  function scalar trigfunc (scalar theta)
	      return 4 * sin(theta) * (1 + cos(theta))
	  end function

	  matrix m = {0, 0, $pi/2}
	  eval GSSmax(&amp;m, trigfunc(m[1]))
	  printf "\n%10.7f", m
	</code>
      </description>
    </function>

    <function name="GSSmin" section="numerical" output="scalar">
      <description>
	<para>
	  Un alcume de <fncref targ="GSSmax"/>. Se invocas a función baixo
	  este nome, execútase facendo unha minimización.
	</para>
      </description>
    </function>

    <function name="halton" section="stats" output="matrix">
      <fnargs>
	<fnarg type="int">m</fnarg>
	<fnarg type="int">r</fnarg>
	<fnarg optional="true" type="int">offset</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz <by r="m" c="r"/> que contén <math>m</math>
	  secuencias de Halton de lonxitude <math>r</math>, onde o valor de
	  <math>m</math> está limitado a un máximo de 40. As secuencias
	  constrúense utilizando os primeiros <math>m</math> números primos.
	  Por defecto descártanse os primeiros 10 elementos de cada unha das
	  secuencias, aínda que iso pode axustarse por medio do argumento
	  opcional <argname>offset</argname>, que debe de ser un número
	  enteiro non negativo. Para obter máis detalles podes consultar
	  <cite key="halton64">Halton e Smith (1964)</cite>.
	</para>
      </description>
    </function>

    <function name="hdprod" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">Y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve a matriz que resulta do produto directo horizontal de dúas
	  matrices. Os dous argumentos deben de ter o mesmo número de filas,
	  <math>r</math>. O valor que se devolve é unha matriz que ten
	  <math>r</math> filas, e na que a <math>i</math>-ésima fila é o
	  produto de Kronecker das respectivas filas das matrices
	  <argname>X</argname> e <argname>Y</argname>.
	</para>
	<para context="tex">
	  Noutras palabras, se $X$ é unha matriz $r \times k$, $Y$ é
	  unha matriz $r \times m$ e $Z$ é a matriz resultante do
	  produto directo horizontal de $X$ times $Y$, entón $Z$ vai
	  ter $r$ filas e $k\cdot m$ columnas; máis aínda,
	  \[
	  Z_{in} = X_{ij} Y_{il}
	  \]
	  onde $n = (j-1) m + l$.
	</para>
	<para>
	  Esta operación chámase <quote>produto directo horizontal</quote>
	  en conformidade coa forma en que se pon en funcionamento e aplica
	  na linguaxe de programación GAUSS. A súa equivalente na álxebra
	  matricial estándar podería denominarse produto horizontal (row-wise)
	  de Khatri-Rao.
	</para>
	<para>
	  Exemplo: o código...
	</para>
	<code>
	  A = {1,2,3; 4,5,6}
	  B = {0,1; -1,1}
	  C = hdprod(A, B)
	</code>
	<para>
	  produce a seguinte matriz:
	</para>
	<code>
          0    1    0    2    0    3
         -4    4   -5    5   -6    6
	</code>
      </description>
    </function>

    <function name="hfdiff" section="midas" output="list">
      <fnargs>
	<fnarg type="list">hfvars</fnarg>
	<fnarg type="scalar">multiplier</fnarg>
      </fnargs>
      <description>
	<para>
	  Dada unha <cmdref targ="MIDAS_list"/>, a función devolve outra lista
	  da mesma lonxitude que contén as primeiras diferenzas de alta
	  frecuencia. O segundo argumento é opcional e, por defecto, igual a 1:
	  podes utilizalo para multiplicar as diferenzas por algunha constante.
	</para>
      </description>
    </function>

    <function name="hfldiff" section="midas" output="list">
      <fnargs>
	<fnarg type="list">hfvars</fnarg>
	<fnarg type="scalar">multiplier</fnarg>
      </fnargs>
      <description>
	<para>
	  Dada unha <cmdref targ="MIDAS_list"/>, a función devolve outra lista
	  da mesma lonxitude que contén as diferenzas logarítmicas de alta
	  frecuencia. O segundo argumento é opcional e, por defecto, igual a 1:
	  pode utilizarse para multiplicar as diferenzas por algunha constante;
	  por exemplo poderías darlle o valor 100 para obter aproximadamente
	  as variacións porcentuais.
	</para>
      </description>
    </function>

    <function name="hflags" section="midas" output="list">
      <fnargs>
	<fnarg type="int">minlag</fnarg>
	<fnarg type="int">maxlag</fnarg>
	<fnarg type="list">hfvars</fnarg>
      </fnargs>
      <description>
	<para>
	  Dada unha <cmdref targ="MIDAS_list"/> <repl>hfvars</repl>, a función
	  devolve outra lista cos retardos de alta frecuencia desde
	  <repl>minlag</repl> ata <repl>maxlag</repl>. Debes utilizar valores
	  positivos para indicar os retardos e negativos para indicar os
	  adiantos. Por exemplo, se <repl>minlag</repl> é &minus;3, e
	  <repl>maxlag</repl> é 5, entón a lista que se vai devolver conterá
	  9 series: 3 adiantos, o valor actual e 5 retardos.
	</para>
	<para>
	  Cae na conta de que o retardo 0 de alta frecuencia correspóndese co
	  primeiro período de alta frecuencia, dentro dun período de baixa
	  frecuencia; por exemplo, correspondería co primeiro mes dentro dun
	  trimestre ou co primeiro día dentro dun mes.
	</para>
      </description>
    </function>

    <function name="hflist" section="midas" output="list">
      <fnargs>
	<fnarg type="vector">x</fnarg>
	<fnarg type="int">m</fnarg>
	<fnarg type="string">prefix</fnarg>
      </fnargs>
      <description>
  <para>
	  Produce unha <cmdref targ="MIDAS_list"/> de <repl>m</repl> series
	  a partir do vector <repl>x</repl>, onde <repl>m</repl> indica a
	  razón entre a frecuencia (maior) das observacións da variable
	  <repl>x</repl> e a frecuencia base (menor) do conxunto de datos
	  actual. O valor de <repl>m</repl> debe de ser maior ou igual a 3, e
	  o tamaño de <repl>x</repl> debe de ser igual a <repl>m</repl> veces
	  o tamaño do rango da mostra actual.
  </para>
  <para>
	  Os nomes das series da lista que se devolve, constrúense a partir do
	  <repl>prefix</repl> indicado (que debe de ser unha cadea de texto,
	  dunha lonxitude máxima de 24 caracteres ASCII e válida como
	  identificador de Gretl), á que se engade un ou máis díxitos que
	  representan o subperíodo da observación. Se algún deses nomes duplica
	  o de algún obxecto xa existente, amósase un fallo.
  </para>
      </description>
    </function>

    <function name="hpfilt" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="scalar" optional="true">lambda</fnarg>
	<fnarg type="bool" optional="true">one-sided</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha serie que recolle a compoñente cíclica do filtro de
	  Hodrick&ndash;Prescott aplicado á serie <argname>y</argname>. Se
	  non se indica o parámetro de suavizado <argname>lambda</argname>, o
	  Gretl usa valores por defecto baseados na periodicidade dos datos;
	  concretamente, o parámetro é igual a 100 veces o cadrado da
	  periodicidade (100 para datos anuais, 1600 para datos trimestrais, etc.).
	</para>
	<para>
	  Por defecto, o filtro é o da habitual versión de dúas partes
	  (pasado e futuro), pero se indicas o terceiro argumento (opcional)
	  mediante un valor non nulo, calcúlase a variante dunha soa
	  parte (sen ollada cara adiante) do xeito no que se indica en
	  <cite key="stock-watson1999">Stock e Watson (1999)</cite>.
	</para>
	<para>
	  O uso máis habitual do filtro HP é para a eliminación da tendencia,
	  pero se estás interesado na propia tendencia, é doado de obtela
	  mediante subtracción, como no exemplo seguinte:
	</para>
	<code>
	  series hptrend = y - hfilt(y)
	</code>
	<para>
	  <seelist>
            <fncref targ="bkfilt"/>
            <fncref targ="bwfilt"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="I" section="matbuild" output="smatrix">
      <fnargs>
	<fnarg type="int">n</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz identidade con <argname>n</argname> filas e
	  columnas.
	</para>
      </description>
    </function>

    <function name="imaxc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector fila que indica, para cada columna da matriz
	  <argname>X</argname>, cal é a fila que ten o valor máis grande.
	</para>
	<para>
	  <seelist>
            <fncref targ="imaxr"/>
            <fncref targ="iminc"/>
            <fncref targ="maxc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="imaxr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector columna que indica, para cada fila da matriz
	  <argname>X</argname>, cal é a columna que ten o valor máis grande.
	</para>
	<para>
	  <seelist>
            <fncref targ="imaxc"/>
            <fncref targ="iminr"/>
            <fncref targ="maxr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="imhof" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="scalar">x</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Calcula a Prob(<math>u'Au</math> &lt; <math>x</math>) para unha forma
	  cuadrática de variables Normais estándar, <math>u</math>, usando o
	  procedemento desenvolvido por <cite key="imhof61">Imhof (1961)</cite>.
	</para>
	<para context="tex">
	  Calcula a ${\rm Prob}(u'Au &lt; x)$ para unha forma cuadrática de
	  variables Normais estándar, $u$, usando o procedemento desenvolvido
	  por <cite key="imhof61">Imhof (1961)</cite>.
	</para>
	<para>
	  Se o primeiro argumento <argname>M</argname> é unha matriz cadrada,
	  tómase para que represente a <math>A</math>. Se é un vector columna,
	  tómanse os seus elementos como se fosen os autovalores calculados
	  previamente de <math>A</math>, e noutro caso preséntase un fallo.
	</para>
	<para>
	  <seelist>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="iminc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector fila que indica, para cada columna da matriz
	  <argname>X</argname>, cal é a fila que ten o valor máis pequeno.
	</para>
	<para>
	  <seelist>
            <fncref targ="iminr"/>
            <fncref targ="imaxc"/>
            <fncref targ="minc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="iminr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector columna que indica, para cada fila da matriz
	  <argname>X</argname>, cal é a columna que ten o valor máis pequeno.
	</para>
	<para>
	  <seelist>
            <fncref targ="iminc"/>
            <fncref targ="imaxr"/>
            <fncref targ="minr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="inbundle" section="data-utils" output="int">
      <fnargs>
	<fnarg type="bundle">b</fnarg>
	<fnarg type="string">key</fnarg>
      </fnargs>
      <description>
	<para>
	  Comproba se o feixe (<quote>bundle</quote>) <argname>b</argname>
	  contén un elemento co nome <argname>key</argname>. Devolve un enteiro
	  co código do tipo de elemento: 0 no caso de non achalo e, no caso de
	  atopalo, 1 para un escalar, 2 para unha serie, 3 para unha matriz, 4 para
	  unha cadea de texto, 5 para un feixe, 6 para un arranxo e 7 para unha lista.
	  En base ao valor do seu código, a función <fncref targ="typestr"/> pódese
	  usar para obter a cadea de texto que expresa o tipo de elemento que é.
	</para>
      </description>
    </function>

    <function name="infnorm" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devolve un escalar coa norma-infinito da matriz <argname>X</argname>,
	  é dicir, o máximo valor que se obtén ao sumar os valores absolutos
	  dos elementos da matriz <argname>X</argname> que hai en cada fila.
	</para>
	<para context="tex">
	  Devolve un escalar coa norma-$\infty$ da matriz $r\times c$
	  <argname>X</argname>, concretamente,
          \[\| X \|_{\infty} = \max_i \sum_{j=1}^c |X_{ij}|\]
	</para>
	<para>
	  <seelist>
            <fncref targ="onenorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="inlist" section="data-utils" output="int">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un enteiro positivo coa posición de <argname>y</argname> na
	  lista <argname>L</argname>, ou 0 se <argname>y</argname> non está
	  presente en <argname>L</argname>.
	</para>
	<para>
	  O segundo argumento podes indicalo tanto co nome da serie como co
	  enteiro positivo que identifica a serie (ID). Cando se sabe que existe
	  unha serie cun nome concreto (por exemplo, <lit>foo</lit>), podes
	  executar esta función da seguinte forma:
	</para>
  <code>
	  pos = inlist(L, foo)
  </code>
  <para>
	  Coa expresión anterior estás pedindo: <quote>Indícame cun enteiro a
	  posición da serie <lit>foo</lit> na lista <lit>L</lit> (ou 0 se non
	  está incluída nesa lista)</quote>. De calquera xeito, se non tes
	  certeza de que exista unha serie cun nome concreto, debes indicar
	  ese nome entre comiñas desta forma:
	</para>
	<code>
	  pos = inlist(L, "foo")
  </code>
  <para>
	  Neste caso o que estás solicitando é: <quote>Se existe unha serie
	  chamada <lit>foo</lit> na lista <lit>L</lit>, indícame a súa posición
	  ou 0 no caso de que non exista.</quote>
	</para>
      </description>
    </function>

    <function name="instring" section="strings" output="int">
      <fnargs>
	<fnarg type="string">s1</fnarg>
	<fnarg type="string">s2</fnarg>
      </fnargs>
      <description>
	<para>
	  Este é un booleano relativo de <fncref targ="strstr"/>:
	  devolve 1 se <argname>s1</argname> contén
	  <argname>s2</argname>, e 0 noutro caso. Deste xeito, a
	  expresión condicional
	</para>
	<code>
	  if instring("gatada", "gata")
	</code>
	<para>
	  é equivalente loxicamente (pero mais eficiente) ca
	</para>
	<code>
	  if strlen(strstr("gatada", "gata")) > 0
	</code>
      </description>
    </function>

    <function name="int" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) coa parte enteira de
	  <argname>x</argname>, tronzando a parte decimal. Ten en conta que
	  <lit>int</lit> e <fncref targ="floor"/> producen distintos efectos
	  con argumentos negativos: <lit>int(-3.5)</lit> xera &minus;3,
	  namentres <lit>floor(-3.5)</lit> xera &minus;4.
	  <seelist>
            <fncref targ="ceil"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="inv" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve a matriz inversa de <argname>A</argname>. Cando esta última
	  é unha matriz singular ou non cadrada, prodúcese unha mensaxe de fallo
	  e non se devolve nada. Cae na conta de que o Gretl comproba
	  automaticamente a estrutura de <argname>A</argname> e utiliza o 
	  procedemento numérico máis eficiente para realizar a inversión.
	</para>
	<para>
	  Os tipos de matriz que o Gretl comproba automaticamente son:
	  identidade, diagonal, simétrica definida positiva, simétrica definida
	  non positiva, e triangular.
	</para>
	<para>
	  Nota: En boa lóxica, só debes utilizar esta función cando tratas de
	  aplicar a inversa de <argname>A</argname> máis dunha vez. Cando
	  unicamente necesitas calcular, por exemplo, unha expresión da forma
	  <math>A</math><sup>-1</sup><math>B</math>, é preferible que
	  utilices os operadores de <quote>división</quote>: <lit>\</lit> e
	  <lit>/</lit>. Para obter máis detalles, podes consultar o
	  <guideref targ="chap:matrices"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="ginv"/>
            <fncref targ="invpd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="invcdf" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">p</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula a inversa da función de distribución acumulativa e devolve un
	  resultado (do tipo do argumento) co valor de <math>x</math> que cumpre
	  <equation status="inline" ascii="P(X &le; x) = p" tex="$P(X \le x) = p$"/>,
	  onde o tipo de distribución de <math>X</math> se especifica por
	  medio da letra <argname>d</argname>. Entre os argumentos
	  <argname>d</argname> e <argname>p</argname>, podes necesitar
	  algún argumento adicional escalar para especificar os parámetros
	  da distribución de que se trate. Isto faise da forma que se indica
	  a continuación:
	</para>
	<ilist context="notex">
	  <li>
            <para>
              Normal estándar (c = z, n ou N): sen argumentos extras
            </para>
	  </li>
	  <li>
            <para>
              Gamma (g ou G): forma, escala
            </para>
	  </li>
	  <li>
            <para>
              t de Student (t): graos de liberdade
            </para>
	  </li>
	  <li>
            <para>
              Khi-cadrado (c, x ou X): graos de liberdade
            </para>
	  </li>
	  <li>
            <para>
              F de Snedecor (f ou F): graos de liberdade (num.), graos de liberdade (den.)
            </para>
	  </li>
	  <li>
            <para>
              Binomial (b ou B): probabilidade, cantidade de ensaios
            </para>
	  </li>
	  <li>
            <para>
              Poisson (p ou P): media
            </para>
	  </li>
	  <li>
            <para>
              Laplace (l ou L): media, escala
            </para>
	  </li>
	  <li>
            <para>
              Erro Xeneralizado (E): forma
            </para>
	  </li>
	  <li>
	    <para>
	      Khi-cadrado non central (ncX): graos de liberdade, parámetro de non centralidade
	    </para>
	  </li>
	  <li>
	    <para>
	      F non central (ncF): graos de liberdade (num.), graos de liberdade (den.),
	      parámetro de non centralidade
	    </para>
	  </li>
	  <li>
	    <para>
	      t non central (nct): graos de liberdade, parámetro de non centralidade
	    </para>
	  </li>
	</ilist>
	<tabular colspec="lllll">
	  \textit{Distribución} &amp; \textsl{d} &amp;
	  \textit{Arg} 2 &amp; \textit{Arg} 3 &amp; \textit{Arg} 4 \\[4pt]
	  Normal estándar &amp; \texttt{z}, \texttt{n} ou \texttt{N} &amp;
	  -- &amp; -- &amp; --\\
	  Gamma &amp; \texttt{g} ou \texttt{G} &amp;
	  forma &amp; escala &amp; --\\
	  $t$ de Student (central) &amp; \texttt{t} &amp;
	  gl &amp; -- &amp; --\\
	  Khi-cadrado &amp; \texttt{c}, \texttt{x} ou \texttt{X} &amp;
	  gl &amp; -- &amp; --\\
	  $F$ de Snedecor &amp; \texttt{f} ou \texttt{F} &amp;
	  gl (num.) &amp; gl (den.) &amp; --\\
	  Binomial &amp; \texttt{b} ou \texttt{B} &amp;
	  $p$ &amp; $n$  &amp; --\\
	  Poisson &amp; \texttt{p} ou \texttt{P} &amp;
    $\lambda$ &amp; --  &amp; --\\
	  Laplace &amp; \texttt{l} ou \texttt{L} &amp;
    media &amp; escala  &amp; -- \\
	  Erro Xeneralizado &amp; \texttt{E} &amp;
	  forma &amp; -- &amp; --\\
	  $\chi^2$ non central &amp; \texttt{ncX} &amp;
	  gl &amp; non centralidade &amp; --\\
	  $F$ non central &amp; \texttt{ncF} &amp;
	  gl (num.) &amp; gl (den.) &amp; non centralidade\\
	  $t$ non central &amp; \texttt{nct} &amp;
	  gl &amp; non centralidade &amp; --\\
	</tabular>
	<para>
	  <seelist>
            <fncref targ="cdf"/>
            <fncref targ="critical"/>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="invmills" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) coa razón inversa de
	  Mills en <argname>x</argname>, é dicir, a razón entre a densidade
	  Normal estándar e o complementario da función de distribución
	  Normal estándar, ambas avaliadas en <argname>x</argname>.
	</para>
	<para>
	  Esta función utiliza un algoritmo axeitado que proporciona unha
	  precisión moito mellor que a que se acada facendo os cálculos con
	  <fncref targ="dnorm"/> e <fncref targ="cnorm"/>, agora ben, a
	  diferenza entre os dous métodos é considerable só para valores
	  moi negativos de <argname>x</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="cdf"/>
            <fncref targ="cnorm"/>
            <fncref targ="dnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="invpd" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="pdmat">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve a matriz cadrada resultante de inverter a matriz simétrica
	  definida positiva <argname>A</argname>. Esta función é lixeiramente
	  máis rápida ca <fncref targ="inv"/> para matrices moi grandes, posto
	  que con ela non se comproba se a matriz é simétrica. Por esta razón,
	  esa función debe de utilizarse con prudencia.
	</para>
	<para>
	  Nota: Se pretendes inverter unha matriz da forma <math>X'X</math>
	  onde <math>X</math> é unha matriz moi grande, é preferible que a
	  calcules por medio do operador principal <lit>X'X</lit> en lugar
	  de usar a sintaxe máis xeral <lit>X'*X</lit>. A primeira expresión
	  utiliza un algoritmo especializado que ten unha dobre vantaxe:
	  resulta máis eficiente desde o punto de vista do cómputo, e vai
	  garantir que a matriz resultante estea libre, por construción, dos
	  artefactos de precisión de máquina que puideran convertela en
	  numericamente non simétrica.
	</para>
      </description>
    </function>

    <function name="irf" section="stats" output="matrix">
      <fnargs>
	<fnarg type="int">target</fnarg>
	<fnarg type="int">shock</fnarg>
	<fnarg type="pscalar" optional="true">alpha</fnarg>
	<fnarg type="bundle" optional="true">sys</fnarg>
      </fnargs>
      <description>
	<para>
	  A falta do argumento final (opcional), esta función só está
	  dispoñible cando o último modelo estimado foi un VAR ou un
	  VECM. Como alternativa, podes gardar nun feixe a información
	  sobre un VAR ou un VECM co accesorio <fncref targ="$system"/>
	  e posteriormente pasarlle a función <lit>irf</lit>.
	</para>
	<para>
	  Como resultado, devolve unha matriz que contén
	  a resposta estimada da variable <argname>target</argname> ante un
	  impulso na variable <argname>shock</argname> de magnitude igual a
	  unha vez a súa desviación padrón. Estas dúas variables identifícanse
	  tendo en conta as súas posicións na especificación do modelo: por
	  exemplo, cando indicas os argumentos <argname>target</argname>
	  e <argname>shock</argname> cos valores 1 e 3, respectivamente, a
	  matriz que se devolve proporciona a resposta da primeira variable
	  do sistema ante un impulso da terceira variable.
	</para>
	<para>
	  Se indicas o terceiro argumento <argname>alpha</argname> (opcional),
	  a matriz que te devolve a función ten tres columnas: a primeira coa
	  estimación por punto das respostas, e as outras cos límites inferior e
	  superior do intervalo con confianza (1 &minus; &agr;) para as mesmas,
	  obtidas mediante autosuficiencia (<quote>bootstrapping</quote>).
	  Se <argname>alpha</argname> = 0.1, a confianza será do 90 por cento.
	  Cando <argname>alpha</argname> se omite ou se iguala a cero, tan só
	  se proporciona a estimación por punto.
	</para>
	<para>
	  O número de períodos (filas) sobre os que se traza a resposta se
	  determina automaticamente dependendo da frecuencia dos datos; mais
	  iso pode axustarse por medio da instrución <cmdref targ="set"/>,
	  como por exemplo con <lit>set horizon 10</lit>.
	</para>
	<para>
	  <seelist><fncref targ="fevd"/></seelist>
	</para>
      </description>
    </function>

    <function name="irr" section="math" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar coa Taxa Interna de Rendemento (TIR) para
	  <argname>x</argname>, considerada como unha secuencia de pagos
	  (negativos) e ingresos (positivo).
	  <seelist>
            <fncref targ="npv"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="isconst" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="int" optional="true">panel-code</fnarg>
      </fnargs>
      <description>
	<para>
	  Sen o segundo argumento (opcional), devolve o número enteiro igual
	  a 1 cando <argname>y</argname> teña un valor constante ao longo da
	  mostra actual seleccionada (ou ao longo de toda a súa extensión se
	  <argname>y</argname> é un vector); noutro caso, devolve o enteiro 0.
	</para>
	<para>
	  O segundo argumento só se acepta cando <argname>y</argname> é unha
	  serie, e o conxunto de datos actual é un panel. Neste caso, un valor
	  de <argname>panel-code</argname> igual a 0 solicita que a función
	  verifique se a serie non varía co paso do tempo; e un valor igual a
	  1 fai que a función verifique se a serie non varía transversalmente
	  (é dicir, se o valor de <argname>y</argname> en cada período de
	  tempo, é o mesmo para todos os grupos).
	</para>
	<para>
	  Se <argname>y</argname> é unha serie, as observacións con valores
	  ausentes ignóranse durante a verificación da invariabilidade da serie.
	</para>
      </description>
    </function>

    <function name="isdiscrete" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">name</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>name</argname> é unha cadea que identifica unha serie xa
	  definida, e se está marcada como de tipo discreto, a función devolve
	  un enteiro igual a1; noutro caso devolve 0. Se <argname>name</argname>
	  non identifica unha serie, a función devolve <lit>NA</lit>.
	</para>
      </description>
    </function>

    <function name="isdummy" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Se todos os valores contidos en <argname>x</argname> son iguais a 0 ou
	  1 (ou ausentes), devolve un enteiro co número de uns; senón devolve 0.
	</para>
      </description>
    </function>

    <function name="isnan" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-matrix">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Dado un argumento escalar, devolve 1 se <argname>x</argname> non é un
	  número, <quote>Not a Number</quote> (NaN); noutro caso devolve 0. Dada
	  unha matriz como argumento, devolve outra matriz da mesma dimensión
	  que contén valores iguais a 1 nas posicións onde os elementos que lles
	  corresponden da matriz de entrada son NaN, e 0 nas demais posicións.
	</para>
      </description>
    </function>

    <function name="isoconv" section="calendar" output="scalar">
      <fnargs>
	<fnarg type="series">date</fnarg>
	<fnarg type="seriesref">&amp;year</fnarg>
	<fnarg type="seriesref">&amp;month</fnarg>
	<fnarg type="seriesref" optional="true">&amp;day</fnarg>
      </fnargs>
      <description>
	<para>
	  Dada a serie <argname>date</argname> que contén datas no formato
	  ISO 8601 <quote>básico</quote> (<lit>YYYYMMDD</lit>), esta función
	  converte as compoñentes de ano, mes e (opcionalmente) día en novas
	  series designadas polo segundo e seguintes argumentos. Un exemplo
	  da súa aplicación, asumindo que a serie <lit>dates</lit> contén valores
	  axeitados de 8 díxitos, sería:
	</para>
	<code>
	  series y, m, d
	  isoconv(dates, &amp;y, &amp;m, &amp;d)
	</code>
	<para>
	  Esta función devolve o escalar 0 no caso de completarse con éxito,
	  e un escalar non nulo en caso de fallo.
	</para>
      </description>
    </function>

    <function name="isodate" section="calendar" output="seebelow">
      <fnargs>
	<fnarg type="scalar-or-series">ed</fnarg>
	<fnarg type="bool" optional="true">as-string</fnarg>
      </fnargs>
      <description>
	<para>
	  O argumento <argname>ed</argname> interprétase como un día de
	  época (que tomará o valor 1 para o primeiro día de xaneiro do ano 1
	  despois de Cristo no proléptico calendario Gregoriano). O valor que
	  se devolve por defecto é un número de 8 díxitos do mesmo tipo ca
	  <argname>ed</argname>, ou unha serie composta por números desa
	  clase. Séguese o padrón <lit>YYYYMMDD</lit> (formato ISO 8601
	  <quote>básico</quote>) para proporcionar a data no calendario
	  Gregoriano que se corresponde ao dia na época actual.
	</para>
	<para>
	  Cando <argname>ed</argname> é unicamente un escalar e o segundo
	  argumento <argname>as-string</argname> (opcional) é non nulo, a
	  función non devolve un valor numérico senón unha cadea de texto
	  que segue o padrón <lit>YYYY-MM-DD</lit> (formato ISO 8601
	  <quote>estendido</quote>).
	</para>
	<para>
	  Con relación á función inversa consulta <fncref targ="epochday"/>.
	  Consulta tamén <fncref targ="juldate"/>.
	</para>
      </description>
    </function>

    <function name="iwishart" section="stats" output="matrix">
      <fnargs>
	<fnarg type="symmat">S</fnarg>
	<fnarg type="int">v</fnarg>
      </fnargs>
      <description>
	<para>
	  Dada <argname>S</argname> (unha matriz de orde <by r="p" c="p"/>
	  definida positiva), esta función devolve unha matriz xerada a partir
	  dunha realización da distribución Inversa de Wishart con
	  <argname>v</argname> graos de liberdade. O resultado que se devolve
	  tamén é unha matriz <by r="p" c="p"/>. Utilízase o algoritmo de
	  <cite key="odell-feiveson66">Odell e Feiveson (1966)</cite>.
	</para>
      </description>
    </function>

    <function name="jsonget" section="data-utils" output="string">
      <fnargs>
	<fnarg type="string">buf</fnarg>
	<fnarg type="string">path</fnarg>
	<fnarg optional="true" type="scalarref">nread</fnarg>
      </fnargs>
      <description>
	<para>
	  Como argumento <argname>buf</argname> deberás utilizar
	  un búfer JSON, tal como pode recuperarse dun sitio web
	  adecuado por medio da función <fncref targ="curl"/>; e como
	  argumento <argname>path</argname> deberás usar unha
	  especificación de tipo JsonPath.
	</para>
	<para>
	  Esta función devolve unha cadea de texto que representa os datos que
	  se atopan no búfer na ruta especificada. Se admiten os tipos de datos
	  <quote>double</quote> (punto flotante), <quote>int</quote> (enteiro)
	  e cadea de texto. No caso de enteiros ou de puntos flotantes, se
	  devolve a súa representación como cadeas de texto (usando para os
	  segundos, <quote>C</quote> local). Se o obxecto ao que se refire
	  a ruta (<argname>path</argname>) é un arranxo, os seus elementos
	  imprímense un por cada fila na cadea de texto devolta.
	</para>
	<para>
	  Por defecto, amósase un erro se <argname>path</argname>
	  non coincide no búfer JSON, pero este comportamento
	  modifícase se indicas o terceiro argumento (opcional) pois, neste
	  caso, o argumento recupera un reconto das coincidencias, devolvéndose
	  unha cadea baleira se non hai ningunha. Chamada de exemplo:
	</para>
	<code>
	  ngot = 0
	  ret = jsonget(jbuf, "$.some.thing", &amp;ngot)
	</code>
	<para>
	  Agora ben, aínda vaise amosar un erro no caso de facer unha solicitude
	  mal configurada.
	</para>
	<para>
	  Podes atopar unha exposición fidedigna da sintaxe JsonPath en
	  <url>http://goessner.net/articles/JsonPath/</url>. De calquera
	  xeito, observa que o sostemento de <lit>jsonget</lit> o fornece
	  <lit>json-glib</lit>, que non necesariamente soporta tódolos
	  elementos de JsonPath. E ademais, a funcionalidade concreta
	  que desenvolve <lit>json-glib</lit> pode ser moi diferente,
	  dependendo da versión que teñas no teu sistema. Podes consultar
	  <url>http://developer.gnome.org/json-glib/</url> se necesitas
	  ter máis detalles.
	</para>
	<para>
	  Dito isto, os seguintes operadores deberan de estar dispoñibles
	  para <lit>jsonget</lit>:
	</para>
	  <ilist>
	    <li>
              <para>
		nodo raíz, por medio do carácter <lit>$</lit>
              </para>
	    </li>
	    <li>
              <para>
		operador descendente recursivo: <lit>..</lit>
              </para>
	    </li>
	    <li>
              <para>
		operador comodín: <lit>*</lit>
              </para>
	    </li>
	    <li>
              <para>
		operador subíndice: <lit>[]</lit>
              </para>
	    </li>
	    <li>
              <para>
		operador de notación de conxunto, por exemplo <lit>[i,j]</lit>
              </para>
	    </li>
	    <li>
              <para>
		operador de tronzado: <lit>[inicio:fin:paso]</lit>
              </para>
	    </li>
	  </ilist>
      </description>
    </function>

    <function name="jsongetb" section="data-utils" output="bundle">
      <fnargs>
	<fnarg type="string">buf</fnarg>
	<fnarg type="string" optional="true">path</fnarg>
      </fnargs>
      <description>
	<para>
	  Como argumento <argname>buf</argname> deberás utilizar un búfer
	  JSON, tal como pode recuperarse dun sitio web adecuado por medio
	  da función <fncref targ="curl"/>. A especificación e o efecto do
	  argumento opcional <argname>path</argname> descríbese
	  máis abaixo.
	</para>
	<para>
	  O que se devolve é un feixe (bundle) cuxa estrutura basicamente
	  reflicte a da entrada: os obxectos JSON tórnanse feixes de Gretl,
	  e os arranxos JSON tórnanse arranxos de Gretl, cada un deles
	  contendo cadeas de texto ou feixes. Os nodos de <quote>valor</quote>
	  JSON tórnanse compoñentes de feixes ou elementos de arranxos;
	  no último caso, os valores numéricos convértense en cadeas de texto
	  utilizando <lit>sprintf</lit>. Cae na conta de que, dado que non
	  podes aniñar os arranxos (arrays) de Gretl, o argumento que acepta
	  esta función é un pouco máis restritivo que a especificación JSON,
	  pois esta admite aniñar os arranxos.
	</para>
	<para>
	  Podes usar o argumento <argname>path</argname> para limitar
	  os elementos JSON incluídos no feixe que se devolve. Ten en
	  conta que isto non é un <quote>JsonPath</quote> tal como se
	  describe na axuda para <fncref targ="jsonget"/>; isto é unha
	  sinxela composición suxeita á seguinte especificación:
	</para>
	<ilist>
	  <li>
	    <para>
	      <argname>path</argname> é unha formación de elementos separados
	      por unha barra, onde esta barra (<quote>/</quote>) indica o
	      desprazamento a un nivel <quote>máis baixo</quote> na árbore
	      JSON representada por <argname>buf</argname>. Permítese unha
	      barra inicial pero non é necesaria, pois implicitamente a ruta
	      sempre comeza na raíz. Non debes de incluír caracteres estraños
	      para espazos en branco.
	    </para>
	  </li>
	  <li>
	    <para>
	      Cada elemento que se separa con unha barra debe de ter
	      unha das seguintes formas: (a) un nome unicamente, en
	      cuxo caso só se vai incluír un elemento JSON cuxo nome
	      coincida no nivel estrutural indicado; ou (b) <quote>*</quote>
	      (asterisco), en cuxo caso vanse incluír todos aqueles
	      elementos do nivel indicado; ou (c) un arranxo de nomes
	      separados con comas e contornados entre chaves
	      (<quote>{</quote> e <quote>}</quote>), en cuxo caso só
	      se van incluír os elementos JSON cuxos nomes coincidan
	      con un dos nomes indicados.
	    </para>
	  </li>
	</ilist>
	<para>
	  Consulta tamén a función orientada a cadeas <fncref targ="jsonget"/>;
	  pois, dependendo da túa intención, unha destas funcións pódeche ser
	  de máis axuda que a outra.
	</para>
      </description>
    </function>

    <function name="juldate" section="calendar" output="seebelow">
      <fnargs>
	<fnarg type="scalar-or-series">ed</fnarg>
	<fnarg type="bool" optional="true">as-string</fnarg>
      </fnargs>
      <description>
	<para>
	  O argumento <argname>ed</argname> interprétase como un día de
	  época (que tomará o valor 1 para o primeiro día de xaneiro do ano 1
	  despois de Cristo no proléptico calendario Gregoriano). O valor que
	  se devolve por defecto é un número de 8 díxitos do mesmo tipo ca
	  <argname>ed</argname>, ou unha serie composta por números desa
	  clase. Séguese o padrón <lit>YYYYMMDD</lit> (formato ISO 8601
	  <quote>básico</quote>) para proporcionar a data no calendario Xuliano
	  que se corresponde ao dia na época actual.
	</para>
	<para>
	  Cando <argname>ed</argname> é unicamente un escalar e o segundo
	  argumento <argname>as-string</argname> (opcional) é non nulo, a
	  función non devolve un valor numérico senón unha cadea de texto
	  que segue o padrón <lit>YYYY-MM-DD</lit> (formato ISO 8601
	  <quote>estendido</quote>).
	</para>
	<para>
	  Consulta tamén <fncref targ="isodate"/>.
	</para>
      </description>
    </function>

    <function name="kdensity" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg type="scalar" optional="true">scale</fnarg>
	<fnarg type="bool" optional="true">control</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula unha estimación da densidade kernel da serie ou vector
	  <argname>x</argname>. A matriz que se devolve ten dúas columnas,
	  a primeira inclúe un conxunto de abscisas equidistantes e a segunda
	  a densidade estimada correspondente a cada unha delas.
	</para>
	<para>
	  O parámetro <argname>scale</argname> (opcional) podes usalo para
	  axustar o grao de suavizado en relación ao valor por defecto que é
	  1.0 (valores maiores producen un resultado máis suave). O parámetro
	  <argname>control</argname> (opcional) actúa como un booleano: 0
	  (valor por defecto) significa que se utiliza o kernel gaussiano;
	  un valor non nulo troca ao kernel de Epanechnikov.
	</para>
	<para>
	  Podes obter un gráfico dos resultados utilizando a instrución
	  <cmdref targ="gnuplot"/>, como en
	</para>
	<code>
	  matrix d = kdensity(x)
	  gnuplot 2 1 --matrix=d --with-lines --fit=none
	</code>
      </description>
    </function>

    <function name="kdsmooth" section="sspace" output="scalar">
      <fnargs>
	<fnarg type="bundleref">&amp;Mod</fnarg>
	<fnarg type="bool" optional="true">MSE</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza o suavizado das perturbacións dun feixe de Kalman,
	  configurado previamente mediante a instrución <fncref targ="ksetup"/>,
	  e devolve o escalar 0 cando se completa con éxito, ou o escalar 1
	  cando se atopan problemas numéricos.
	</para>
	<para>
	  Cando se completa con éxito a operación, as perturbacións suavizadas
	  van estar dispoñibles como <lit>Mod.smdist</lit>.
	</para>
	<para>
	  O argumento <argname>MSE</argname> (opcional) determina o contido
	  da chave <lit>Mod.smdisterr</lit>. Cando é 0 ou se omite, esta
	  matriz vai estar composta das desviacións padrón incondicionais
	  das perturbacións suavizadas, que habitualmente se utilizan para
	  calcular os denominados <emphasis>erros auxiliares</emphasis>. Mais no caso
	  contrario, <lit>Mod.smdisterr</lit> vai conter as raíces das
	  desviacións cadradas medias entre os erros auxiliares e os seus
	  valores verdadeiros.
	</para>
	<para>
	  Para obter máis detalles, consulta o <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="ksetup"/>
            <fncref targ="kfilter"/>
            <fncref targ="ksmooth"/>
            <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="kfilter" section="sspace" output="scalar">
      <fnargs>
	<fnarg type="bundleref">&amp;Mod</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza o filtrado cara adiante dun feixe de Kalman configurado
	  previamente mediante a instrución <fncref targ="ksetup"/>, e
	  devolve o escalar 0 cando se completa con éxito, ou o escalar 1
	  cando se atopan problemas numéricos.
	</para>
	<para>
	  Cando se completa con éxito, os erros de predición dun paso adiante
	  van estar dispoñibles como <lit>Mod.prederr</lit> e a secuencia das
	  súas matrices de covarianzas como <lit>Mod.pevar</lit>. Por outra
	  banda, <lit>Mod.llt</lit> permitirá que teñas acceso a un
	  <math>T</math>-vector que vai conter o logaritmo da verosimilitude
	  de cada observación.
	</para>
	<para>
	  Para obter máis detalles, consulta o <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="kdsmooth"/>
            <fncref targ="ksetup"/>
            <fncref targ="ksmooth"/>
            <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="kmeier" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">d</fnarg>
	<fnarg type="series-or-vec" optional="true">cens</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz co cálculo do estimador non paramétrico
	  de Kaplan&ndash;Meier da función de supervivencia
	  (<cite key="kaplan-meier">Kaplan e Meier, 1958</cite>), dada unha
	  mostra <argname>d</argname> de datos de duración, posiblemente
	  acompañada dun rexistro de estado de censura, <argname>cens</argname>.
	  A matriz que se devolve ten tres columnas que conteñen,
	  respectivamente: os valores únicos ordenados en <argname>d</argname>,
	  a estimación da función de supervivencia que se corresponde cos
	  valores de duración da columna 1, e a desviación padrón (para mostras
	  grandes) do estimador, calculados por medio do método de
	  <cite key="greenwood26">Greenwood (1926)</cite>.
	</para>
	<para>
	  Cando indicas a serie <argname>cens</argname>, utilízase o valor 0
	  para sinalar que unha observación non está censurada, namentres
	  que o valor 1 indica que unha observación está censurada do lado
	  dereito (é dicir, o período de observación do individuo en cuestión
	  concluíu antes da duración ou o período rexistrouse como rematado).
	  Cando non indicas <argname>cens</argname>, asúmese que todas as
	  observacións son non censuradas. (Aviso: a semántica de
	  <argname>cens</argname> pode estenderse nalgún punto para cubrir
	  outros tipos de censura.)
	</para>
	<para>
	  <seelist>
            <fncref targ="naalen"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="kpsscrit" section="stats" output="matrix">
      <fnargs>
	<fnarg type="scalar">T</fnarg>
	<fnarg type="bool">trend</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector fila que contén os valores críticos aos niveis de
	  10, 5 e 1 por cento da proba KPSS para a estacionariedade dunha
	  serie temporal. O argumento <argname>T</argname> debe indicar o
	  número de observacións e o argumento <argname>trend</argname> debe de
	  ser igual a 1 se a proba inclúe unha constante, ou 0 noutro caso.
	</para>
	<para>
	  Os valores críticos que se ofrecen están baseados en superficies
	  de resposta estimadas do xeito que está establecido por
	  <cite key="sephton95">Sephton (Economics Letters,1995)</cite>.
	  Consulta tamén a instrución <cmdref targ="kps"/>.
 	</para>
      </description>
    </function>

    <function name="ksetup" section="sspace" output="bundle">
      <fnargs>
	<fnarg type="smlist">Y</fnarg>
	<fnarg type="scalar-or-matrix">H</fnarg>
	<fnarg type="scalar-or-matrix">F</fnarg>
	<fnarg type="scalar-or-matrix">Q</fnarg>
	<fnarg optional="true" type="matrix">C</fnarg>
      </fnargs>
      <description>
	<para>
	  Configura un feixe de Kalman, é dicir un obxecto que contén toda
	  a información necesaria para definir un modelo de espazo dos estados
	  linear, da forma
	  <equation status="display"
		    tex="\[y_t=H'\alpha_t\]"
		    ascii="y(t) = H'a(t)"
		    graphic="kalman1"/>
	  e coa ecuación de transición de estado
	  <equation status="display"
		    tex="\[\alpha_{t+1}=F \alpha_t + u_t\]"
		    ascii="a(t+1) = F a(t) + u(t)"
		    graphic="kalman2"/>
	  onde Var<math>(u) = Q</math>.
	</para>
	<para>
	  Os obxectos que creas mediante esta función podes utilizalos máis
	  adiante, coa intervención das seguintes funcións específicas:
	  <fncref targ="kfilter"/> para facer filtrado, <fncref targ="ksmooth"/>
	  e <fncref targ="kdsmooth"/> para suavizado e <fncref targ="ksimul"/>
	  para facer simulacións.
	</para>
	<para>
	  En realidade, o tipo de modelos que Gretl pode manexar é moito máis
	  amplo ca o implicado na anterior representación: é posible dispoñer
	  de modelos variantes no tempo, de modelos con precedentes difusos
	  e con variable esóxena na ecuación de medida, e de modelos con
	  innovacións con correlacións cruzadas. Para obter máis detalles,
	  consulta o <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="kdsmooth"/>
            <fncref targ="kfilter"/>
            <fncref targ="ksmooth"/>
            <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ksimul" section="sspace" output="scalar">
      <fnargs>
	<fnarg type="bundleref">&amp;Mod</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar. Utiliza un feixe de tipo Kalman previamente
	  definido coa a función <fncref targ="ksetup"/> para simular datos.
	</para>
	<para>
	  Para obter máis detalles, consulta o <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="ksetup"/>
            <fncref targ="kfilter"/>
            <fncref targ="ksmooth"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ksmooth" section="sspace" output="matrix">
      <fnargs>
	<fnarg type="bundleref">&amp;Mod</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza un suavizado de punto fixo (cara atrás) dun feixe de
	  Kalman previamente configurado mediante <fncref targ="ksetup"/>
	  e devolve un 0 cando se executa con éxito, ou un 1 cando se atopan
	  problemas de tipo numérico.
	</para>
	<para>
	  Cando se completa con éxito, vas ter á túa disposición o estado xa
	  suavizado como <lit>Mod.state</lit> e a secuencia das súas matrices
	  de varianzas-covarianzas como <lit>Mod.stvar</lit>. Para obter máis
	  detalles, consulta o <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="ksetup"/>
            <fncref targ="kdsmooth"/>
            <fncref targ="kfilter"/>
            <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="kurtosis" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve o exceso de curtose da serie <argname>x</argname>,
	  descartando calquera observación ausente.
	</para>
      </description>
    </function>

    <function name="lags" section="transforms" output="list-or-mat">
      <fnargs>
	<fnarg type="scalar-or-vec">p</fnarg>
	<fnarg type="series-list-or-mat">y</fnarg>
	<fnarg type="bool" optional="true">bylag</fnarg>
      </fnargs>
      <description>
	<para>
	  Cando o primeiro argumento é un escalar, xera os retardos do 1 ao
	  <argname>p</argname> da serie <argname>y</argname> ou. Cando
	  <argname>y</argname> é unha lista, xera eses retardos para todas as
	  series que contén esa lista. Cando <argname>y</argname> é unha matriz,
	  xera eses retardos para todas as columnas da matriz. No caso de que
	  <argname>p</argname> = 0, e <argname>y</argname> sexa unha serie
	  ou unha lista, o retardo máximo toma por defecto a periodicidade dos
	  datos; aparte diso <argname>p</argname> deberá de ser positivo.
	</para>
	<para>
	  Cando o primeiro argumento é un vector, os retardos xerados son os
	  que están especificados nese vector. Un uso habitual neste caso
	  podería ser o de poñer, por exemplo, <argname>p</argname> como
	  <lit>seq(3,7)</lit>; daquela omitindo o primeiro e segundo retardos.
	  Así e todo, tamén é correcto indicar un vector con saltos como en
	  <lit>{3,5,7}</lit>, aínda que os retardos deberán indicarse sempre
	  en orde ascendente.
	</para>
	<para>
	  No caso de que o resultado sexa unha lista, noménase automaticamente as
	  variables xeradas co padrón <repl>varname</repl><lit>_</lit><repl>i</repl>
	  onde <repl>varname</repl> estará indicando o nome da serie orixinal e
	  <repl>i</repl> expresará o retardo concreto de cada caso. A parte
	  orixinal do nome vaise tronzar cando así resulte necesario, e mesmo
	  poderá axustarse oportunamente para garantir que resulte único dentro
	  do conxunto de nomes que así se vaian construír.
	</para>
	<para>
	  Cando o segundo argumento <argname>y</argname> é unha lista ou unha
	  matriz con máis dunha columna, e o nivel de retardo é maior ca 1, a
	  disposición por defecto dos elementos na lista que se devolve é por orde
	  de variable: primeiro se devolven todos os retardos da primeira serie
	  ou columna contida nese argumento, seguidos de todos os da segunda, e
	  así de forma sucesiva. O terceiro argumento (opcional) podes usalo para
	  cambiar isto: se é non nulo <argname>bylag</argname>, entón os elementos
	  ordénanse por retardo: o primeiro retardo de todas as series ou columnas,
	  logo o segundo retardo de todas as series ou columnas, etc.
	</para>
	<para>
	  Consulta tamén <fncref targ="mlag"/> para a utilización con matrices.
	</para>
      </description>
    </function>

    <function name="lastobs" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve o número enteiro positivo que indexa a última observación non
	  ausente da serie <argname>y</argname>. Ten en conta que se está
	  activa algunha forma de submostraxe, o valor que se devolve pode ser
	  maior ca o valor devolto polo accesorio <fncref targ="$t2"/>.
	  <seelist>
            <fncref targ="firstobs"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ldet" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co logaritmo natural do determinante de
	  <math>A</math>, calculado por medio da descomposición LU.
	  <seelist>
            <fncref targ="det"/>
            <fncref targ="rcond"/>
            <fncref targ="cnumber"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ldiff" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-or-list">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) coas primeiras diferenzas
	  do logaritmo deste; os valores iniciais considéranse <lit>NA</lit>.
	</para>
	<para>
	  Cando se devolve unha lista, as variables individuais noméanse de
	  forma automática seguindo o padrón <lit>ld_</lit><repl>varname</repl>,
	  onde <repl>varname</repl> indica o nome da serie orixinal. A parte
	  orixinal do nome vai tronzarse cando así resulte necesario, e mesmo
	  poderá axustarse para garantir que sexa único dentro do conxunto de
	  nomes que así se vaian construír.
	</para>
	<para>
	  <seelist>
            <fncref targ="diff"/>
            <fncref targ="sdiff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="lincomb" section="transforms" output="series">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg type="vector">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha nova serie calculada como unha combinación linear das
	  series da lista <argname>L</argname>. Os coeficientes veñen dados
	  polo vector <argname>b</argname>, cuxo tamaño debe ser igual ao
	  número de series que hai en <argname>L</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="wmean"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="linearize" section="filters" output="series">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Para executalo é preciso ter instalado o TRAMO. Devolve unha serie
	  que é unha versión <quote>linearizada</quote> do argumento; é dicir,
	  unha serie onde calquera valor ausente substitúese por valores
	  interpolados, e onde as observacións anómalas axústanse. Para iso
	  utilízase un mecanismo completamente automático do TRAMO. Para obter
	  máis detalles, consulta a documentación do TRAMO.
	</para>
	<para>
	  Cae na conta de que, se a serie do argumento non posúe valores
	  ausentes nin observacións que o TRAMO considere anómalas, esta
	  función devolve unha copia da serie orixinal.
	</para>
      </description>
    </function>

    <function name="ljungbox" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int">p</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co cálculo do estatístico Q de Ljung&ndash;Box
	  para a serie <argname>y</argname>, utilizando o nivel de retardo
	  <argname>p</argname>, ao longo da mostra actualmente seleccionada.
	  O nivel de retardo debe de ser maior ou igual a 1, e menor ca o número
	  de observacións dispoñibles.
	</para>
	<para>
	  Ese valor do estatístico podes cotexalo coa distribución Khi-cadrado
	  con <argname>p</argname> graos de liberdade para verificar a
	  hipótese nula de que a serie <argname>y</argname> non ten correlación
	  serial.
	  <seelist>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="lngamma" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co log da función Gamma de <argname>x</argname>.
	</para>
      </description>
    </function>

    <function name="loess" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series">x</fnarg>
	<fnarg optional="true" type="int">d</fnarg>
	<fnarg optional="true" type="scalar">q</fnarg>
	<fnarg optional="true" type="bool">robust</fnarg>
      </fnargs>
      <description>
	<para>
	  Realiza unha regresión polinómica ponderada localmente, e devolve
	  unha serie que contén os valores previstos de <argname>y</argname>
	  para cada valor non ausente de <argname>x</argname>. O método que
	  se utiliza é do tipo que está descrito por
	  <cite key="cleveland79">William Cleveland (1979)</cite>.
	</para>
	<para>
	  Os argumentos <argname>d</argname> e <argname>q</argname> (opcionais)
	  permiten especificar: a orde do polinomio de <argname>x</argname>
	  e que proporción dos puntos de datos se van utilizar na estimación
	  local, respectivamente. Os valores que se lles supoñen por defecto
	  son <argname>d</argname> = 1 e <argname>q</argname> = 0.5; e outros
	  valores admisibles para <argname>d</argname> son 0 e 2. Cando
	  establezas <argname>d</argname> = 0 vas reducir a regresión local
	  a unha forma de media móbil. O valor de <argname>q</argname> debe
	  de ser maior ca 0 e non pode ser maior ca 1; os valores máis grandes
	  producen un resultado final máis suavizado.
	</para>
	<para>
	  Cando se especifica un valor non nulo para o argumento
	  <argname>robust</argname>, as regresións locais reitéranse dúas veces,
	  con modificacións nas ponderacións en base aos erros da iteración
	  previa, e de xeito que teñan menos influenza as observacións anómalas.
	</para>
	<para>
	  Revisa tamén a función <fncref targ="nadarwat"/> e, por engadido,
	  consulta o <guideref targ="chap:nonparam"/> para obter máis detalles
	  sobre métodos non paramétricos.
	</para>
      </description>
    </function>

    <function name="log" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co logaritmo natural de
	  <argname>x</argname>, xerando <lit>NA</lit> se este non é positivo.
	  Aviso: <lit>ln</lit> é un pseudónimo admisible para <lit>log</lit>.
	</para>
	<para>
	  Cando se devolve unha lista, as variables individuais noméanse de
	  forma automática seguindo o padrón <lit>l_</lit><repl>varname</repl>,
	  onde <repl>varname</repl> indica o nome da serie orixinal. A parte
	  orixinal do nome vai tronzarse cando así resulte necesario, e mesmo
	  poderá axustarse para garantir que sexa único dentro do conxunto de
	  nomes que así se vaian construír.
	</para>
      </description>
    </function>

    <function name="log10" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co logaritmo en base 10 de
	  <argname>x</argname>, xerando <lit>NA</lit> se este non é positivo.
	</para>
      </description>
    </function>

    <function name="log2" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co logaritmo en base 2 de
	  <argname>x</argname>, xerando <lit>NA</lit> se este non é positivo.
	</para>
      </description>
    </function>

    <function name="logistic" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para context="tex">
	  Devolve un resultado (do mesmo tipo do argumento <argname>x</argname>)
	  coa función loxística deste; isto é, $\Lambda(x) = e^x/(1+e^x)$. Se
	  <argname>x</argname> é unha matriz, a función aplícase a cada elemento.
	</para>
	<para context="notex">
	  Devolve un resultado (do mesmo tipo do argumento <argname>x</argname>)
	  coa función loxística deste; isto é, <math>e</math><sup>x</sup>/(1
	  + <math>e</math><sup>x</sup>). Se <argname>x</argname> é unha matriz,
	  a función aplícase a cada elemento.
	</para>
      </description>
    </function>

    <function name="lower" section="matbuild" output="smatrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devolve unha matriz triangular inferior de orde <by r="n" c="n"/>: os
	  elementos da diagonal principal e abaixo desta son iguais aos elementos
	  correspondentes de <argname>A</argname> e os demais son iguais a cero.
	</para>
	<para context="tex">
	  Devolve <math>B</math>, unha matriz triangular inferior $n\times n$,
	  na que para cada $B_{ij} = A_{ij}$ se $i \ge j$, e 0 noutro caso.
	</para>
	<para>
	  <seelist>
            <fncref targ="upper"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="lrcovar" section="filters" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="bool" optional="true">demean</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz coas varianzas e covarianzas de longo prazo
	  das columnas da matriz <argname>A</argname>. Primeiro, aos datos
	  se lles resta a media, agás que se asigne un cero ao segundo
	  argumento (opcional). Podes escoller o tipo de kernel e o parámetro
	  de tronzado do retardo (o tamaño da fiestra), antes de chamar a
	  esta función mediante as opcións relacionadas co HAC que ofrece
	  a instrución <cmdref targ="set"/>, tales como <lit>hac_kernel</lit>,
	  <lit>hac_lag</lit>, ou <lit>hac_prewhiten</lit>. Consulta tamén
	  a sección sobre datos de Series de tempo e matrices de covarianzas
	  HAC en <guideref targ="chap:robust_vcv"/>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="lrvar"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="lrvar" section="filters" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="int" optional="true">k</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar coa varianza de longo prazo do argumento
	  <argname>y</argname>, calculada usando un núcleo (<quote>kernel</quote>) de
	  Bartlett con tamaño de xanela igual a <argname>k</argname>. Se omites o
	  segundo argumento (ou lle asignas un valor menor ca 0), o tamaño da xanela
	  establécese por defecto igual á parte enteira da raíz cúbica do tamaño da mostra.
	</para>
	<para context="tex">
	  Fórmula:
	  \[ \hat{\omega}^2(k) = \frac{1}{T} \sum_{t=k}^{T-k}
	  \left[ \sum_{i=-k}^k w_i (y_t - \bar{X}) (y_{t-i} - \bar{Y})
	  \right] \]
	  con
	  \[ w_i = 1 - \frac{|i|}{k + 1} \]
	</para>
	<para>
	  Para unha contrapartida multivariante, consulta <fncref targ="lrcovar"/>.
	</para>
      </description>
    </function>

    <function name="max" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Se o argumento <argname>y</argname> é unha serie, a función devolve
	  un escalar co valor máximo desa serie (nas observacións non ausentes).
	  Se o argumento é unha lista, devolve unha serie onde cada un dos seus
	  valores indica o máximo de entre as series listadas, para cada
	  observación.
	</para>
	<para>
	  <seelist>
            <fncref targ="min"/>
            <fncref targ="xmax"/>
            <fncref targ="xmin"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="maxc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector fila que contén os valores máximos de cada columna
	  da matriz <argname>X</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="imaxc"/>
            <fncref targ="maxr"/>
            <fncref targ="minc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="maxr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector fila que contén os valores máximos de cada fila
	  da matriz <argname>X</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="imaxc"/>
            <fncref targ="maxc"/>
            <fncref targ="minr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mcorr" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula unha matriz de correlacións tratando cada columna da matriz
	  argumento <argname>X</argname> como se fose unha variable.
	  <seelist>
            <fncref targ="corr"/>
            <fncref targ="cov"/>
            <fncref targ="mcov"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mcov" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcula unha matriz de varianzas-covarianzas tratando cada columna da
	  matriz argumento <argname>X</argname> como se fose unha variable.
	  <seelist>
            <fncref targ="corr"/>
            <fncref targ="cov"/>
            <fncref targ="mcorr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mcovg" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="vector">u</fnarg>
	<fnarg optional="true" type="vector">w</fnarg>
	<fnarg type="int">p</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve a matriz covariograma para outra matriz <argname>X</argname>
	  de orde <by r="T" c="k"/> (que xeralmente contén regresores), un
	  vector <argname>u</argname> de orde <math>T</math> (opcional,
	  que adoita conter erros), un vector <argname>w</argname> de orde
	  <math>p</math>+1 (opcional, que contén unhas ponderacións), e un
	  número enteiro <argname>p</argname> que indica o nivel de retardo
	  e debe de ser maior ou igual a 0.
	</para>
	<para context="tex">
	  A matriz que se devolve ven dada por
	  \[\sum_{j=-p}^{p} \sum_j w_{|j|} (X_t u_t
	  u_{t-j} X_{t-j}')\]
	</para>
	<para context="notex">
	  A matriz que se devolve é a suma para <math>j</math> dende
	  <math>-p</math> ata <math>p</math> de <math>w(|j|) *
	  X(t)X(t-j)' * u(t)u(t-j)</math>, onde <math>X(t)'</math> é
	  a <math>t</math>-ésima fila de <argname>X</argname>.
	</para>
	<para>
	  Se <argname>u</argname> ven indicado como <lit>nulo</lit>,
	  os termos <math>u</math> omítense, e se
	  <argname>w</argname> ven indicado como <lit>nulo</lit>,
	  todas as ponderacións asúmese que son 1.0.
	</para>
	<para>
	  Por exemplo, o seguinte anaco de código
	</para>
	<code>
	  set seed 123
	  X    = mnormal(6,2)
	  Retardo  = mlag(X,1)
	  Adianto = mlag(X,-1)
	  print X Retardo Adianto
	  eval X'X
	  eval mcovg(X, , , 0)
	  eval X'(X + Retardo + Adianto)
	  eval mcovg(X, , , 1)
	</code>
	<para>
	  produce este resultado:
	</para>
	<code>
	  ? print X Retardo Adianto
	  X (6 x 2)

	    -0.76587      -1.0600
	    -0.43188      0.30687
	    -0.82656      0.40681
	     0.39246      0.75479
	     0.36875       2.5498
	     0.28855     -0.55251

	  Retardo (6 x 2)

	      0.0000       0.0000
	    -0.76587      -1.0600
	    -0.43188      0.30687
	    -0.82656      0.40681
	     0.39246      0.75479
	     0.36875       2.5498

	  Adianto (6 x 2)

	    -0.43188      0.30687
	    -0.82656      0.40681
	     0.39246      0.75479
	     0.36875       2.5498
	     0.28855     -0.55251
	      0.0000       0.0000

	  ? eval X'X
	      1.8295       1.4201
	      1.4201       8.7596

	  ? eval mcovg(X,,, 0)
	      1.8295       1.4201
	      1.4201       8.7596

	  ? eval X'(X + Retardo + Adianto)
	      3.0585       2.5603
	      2.5603       10.004

	  ? eval mcovg(X,,, 1)
	      3.0585       2.5603
	      2.5603       10.004
	</code>
      </description>
    </function>

    <function name="mean" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>x</argname> é unha serie, a función devolve un escalar
	  coa súa media na mostra, ignorando calquera observación ausente.
	</para>
	<para>
	  Se <argname>x</argname> é unha lista, a función devolve unha serie
	  <math>y</math> tal que <math>y</math><sub>t</sub> indica a media
	  dos valores das variables desa lista na observación <math>t</math>,
	  ou <lit>NA</lit> no caso de que exista algún valor ausente en
	  <math>t</math>.
	</para>
      </description>
    </function>

    <function name="meanc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector fila coa media de cada columna de <argname>X</argname>.
	  <seelist>
            <fncref targ="meanr"/>
            <fncref targ="sumc"/>
            <fncref targ="sdc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="meanr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector columna coa media de cada fila de <argname>X</argname>.
	  <seelist>
            <fncref targ="meanc"/>
            <fncref targ="sumr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="median" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>x</argname> é unha serie, a función devolve un escalar
	  coa súa mediana na mostra, ignorando calquera observación ausente.
	</para>
	<para>
	  Se <argname>x</argname> é unha lista, a función devolve unha serie
	  <math>y</math> tal que <math>y</math><sub>t</sub> indica a mediana
	  dos valores das variables desa lista na observación <math>t</math>,
	  ou <lit>NA</lit> no caso de que exista algún valor ausente en
	  <math>t</math>.
	</para>
      </description>
    </function>

    <function name="mexp" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Calcula e devolve a matriz exponencial dunha matriz cadrada
	  <argname>A</argname> utilizando para elo o algoritmo 11.3.1 de
	  <cite key="golub96">Golub e Van Loan (1996)</cite>.
	</para>
	<para context="tex">
	  Calcula e devolve a matriz exponencial dunha matriz cadrada,
	  \[ e^A = \sum_{k=0}^{\infty} \frac{A^k}{k!}
	  = \frac{I}{0!} + \frac{A}{1!} + \frac{A^2}{2!} + \frac{A^3}{3!}
	  + \cdots\]
	  (A serie que está implícita nesta expresión vai converxer con
	  seguridade.) O algoritmo que se vai utilizar é o 11.3.1 de
	  <cite key="golub96">Golub e Van Loan (1996)</cite>.
	</para>
      </description>
    </function>

    <function name="mgradient" section="midas" output="matrix">
      <fnargs>
	<fnarg type="int">p</fnarg>
	<fnarg type="vector">theta</fnarg>
	<fnarg type="int-or-string">type</fnarg>
      </fnargs>
      <description>
	<para>
	  Derivadas analíticas para as ponderacións de MIDAS. Denotando como
	  <math>k</math> ao número de elementos que compoñen o vector
	  <repl>theta</repl> de hiperparámetros, esta función devolve unha
	  matriz de orde <by r="p" c="k"/> que contén o gradiente do vector de
	  ponderacións (tal como o calcula a función <fncref targ="mweights"/>)
	  con respecto a os elementos de <repl>theta</repl>. O primeiro
	  argumento representa o nivel de retardo desexado e o derradeiro
	  argumento especifica o tipo de disposición de parámetros. Consulta
	  a función <lit>mweights</lit> para ter unha relación dos valores
	  admisibles para <repl>type</repl>.
	</para>
	<para>
	  <seelist>
            <fncref targ="mweights"/>
	    <fncref targ="mlincomb"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="min" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Cando o argumento <argname>y</argname> é unha serie, devolve un
	  escalar co valor mínimo das observacións non ausentes da serie.
	  Cando o argumento é unha lista, devolve unha serie onde cada
	  elemento é o valor mínimo de entre as series listadas, en cada
	  observación.
	</para>
	<para>
	  <seelist>
            <fncref targ="max"/>
            <fncref targ="xmax"/>
            <fncref targ="xmin"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="minc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector fila co valor mínimo de cada columna de <argname>X</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="iminc"/>
            <fncref targ="maxc"/>
            <fncref targ="minr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="minr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector columna co valor mínimo de cada fila de <argname>X</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="iminr"/>
            <fncref targ="maxr"/>
            <fncref targ="minc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="missing" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="sslist">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha variable binaria (do mesmo tipo que o argumento) que
	  toma o valor 1, cando <argname>x</argname> é <lit>NA</lit>. Cando
	  <argname>x</argname> é unha serie, faise a comprobación para cada
	  elemento. Cando <argname>x</argname> é unha lista de series, devolve
	  unha serie que toma o valor 1 nas observacións nas que ao menos unha
	  das series presenta un valor ausente, e o valor 0 noutro caso.
	</para>
	<para>
	  <seelist>
            <fncref targ="misszero"/>
            <fncref targ="ok"/>
            <fncref targ="zeromiss"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="misszero" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado do tipo do argumento, mudando os <lit>NA</lit>s
	  en ceros. Se <argname>x</argname> é unha serie, múdase cada elemento.
	  <seelist>
            <fncref targ="missing"/>
            <fncref targ="ok"/>
            <fncref targ="zeromiss"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mlag" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="scalar-or-vec">p</fnarg>
	<fnarg type="scalar" optional="true">m</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Move cara arriba ou abaixo as filas da matriz <argname>X</argname>.
	  Cando <argname>p</argname> é un escalar positivo, a función devolve
	  unha matriz semellante a <argname>X</argname>, pero cos valores de
	  cada columna desprazados <argname>p</argname> filas cara abaixo
	  e coas primeiras <argname>p</argname> filas cubertas co valor
	  <argname>m</argname>. Cando <argname>p</argname> é un número
	  negativo, a matriz que se devolve seméllase a <argname>X</argname>,
	  pero cos valores de cada columna desprazados cara arriba e as últimas
	  filas cubertas co valor <argname>m</argname>. Se omites
	  <argname>m</argname>, enténdese que é igual a cero.
	</para>
	<para context="tex">
	  Move cara arriba ou abaixo as filas da matriz <argname>X</argname>.
	  cando $p$ é un escalar positivo, a función devolve unha matriz
	  $Y$ cuxo elemento característico $Y_{i,j} = X_{i-p,j}$ para $i \ge p$,
	  e cero noutro caso. Noutras palabras, devolve unha matriz semellante
	  a <argname>X</argname> pero cos valores de cada columna desprazados
	  <argname>p</argname> filas cara abaixo e coas primeiras
	  <argname>p</argname> filas cubertas co valor <argname>m</argname>.
	  Cando <argname>p</argname> é un número negativo, a matriz que se
	  devolve seméllase a <argname>X</argname>, pero cos valores de cada
	  columna desprazados cara arriba e as últimas filas cubertas co valor
	  <argname>m</argname>. Se omites <argname>m</argname>, enténdese que
	  é igual a cero.
	</para>
	<para context="notex">
	  Se <argname>p</argname> é un vector, a operación indicada no parágrafo
	  anterior realízase con cada un dos elementos de <argname>p</argname>,
	  xuntando horizontalmente as matrices resultantes.
	</para>
	<para context="tex">
	  Se $p$ é un vector, a operación indicada no parágrafo anterior,
	  realízase con cada un dos elementos de $p$ xuntando horizontalmente
	  as matrices resultantes.
	</para>
	<para>
	  Consulta tamén <fncref targ="lags"/>.
	</para>
      </description>
    </function>

    <function name="mlincomb" section="midas" output="series">
      <fnargs>
	<fnarg type="list">hfvars</fnarg>
	<fnarg type="vector">theta</fnarg>
	<fnarg type="int-or-string">type</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta é unha función MIDAS moi oportuna que combina as funcións
	  <fncref targ="lincomb"/> e <fncref targ="mweights"/>. Dada a lista
	  <repl>hfvars</repl>, elabora unha serie que é unha suma ponderada
	  dos elementos desa lista. As ponderacións baséanse no vector
	  <repl>theta</repl> de hiperparámetros e no tipo de disposición de
	  parámetros: consulta a función <lit>mweights</lit> para obter máis
	  detalles. Cae na conta de que <fncref targ="hflags"/> xeralmente
	  é o mellor xeito de crear unha lista apropiada para que sexa o
	  primeiro argumento desta función.
	</para>
	<para>
	  Para ser máis explícitos, a orde
	</para>
	<code>
	  series s = mlincomb(hfvars, theta, 2)
	</code>
	<para>
	  é equivalente a
	</para>
	<code>
	  matrix w = mweights(nelem(hfvars), theta, 2)
	  series s = lincomb(hfvars, w)
	</code>
	<para>
	  pero utilizar a función <lit>mlincomb</lit>, permite economizar algo
	  ao teclear e tamén algúns ciclos de uso de CPU.
	</para>
      </description>
    </function>

    <function name="mnormal" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz feita con valores xerados de forma pseudoaleatoria
	  mediante variables con distribución Normal estándar, e que vai ter
	  <argname>r</argname> filas e <argname>c</argname> columnas.
	  <seelist>
            <fncref targ="normal"/>
            <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mols" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;V</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz <by r="k" c="n"/> de estimacións de parámetros
	  obtidos mediante a regresión de Mínimos Cadrados Ordinarios da matriz
	  <argname>Y</argname> de orde <by r="T" c="n"/> sobre a matriz
	  <argname>X</argname> de orde <by r="T" c="k"/>.
	</para>
	<para>
	  Cando se indica o terceiro argumento, e non é <lit>null</lit>, a
	  función vai xerar unha nova matriz <argname>U</argname> de orde
	  <by r="T" c="n"/>, que contén os erros. Cando se indica o último
	  argumento, e non é <lit>null</lit>, a matriz <argname>V</argname>
	  que se xera vai ser de orde <by r="k" c="k"/> e contén (a) a matriz
	  de covarianzas dos estimadores dos parámetros, se <argname>Y</argname>
	  ten só unha columna, ou (b) a matriz <math>X'X</math><sup>-1</sup>
	  se <argname>Y</argname> ten varias columnas.
	</para>
	<para>
	  Por defecto, as estimacións obtéñense por medio da descomposición de
	  Cholesky, cun último recurso á descomposición QR se as columnas de
	  <argname>X</argname> teñen alta multicolinearidade. Podes forzar o
	  uso da descomposición SVD mediante a instrución <lit>set svd on</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="mpols"/>
            <fncref targ="mrls"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="monthlen" section="calendar" output="int">
      <fnargs>
	<fnarg type="int">month</fnarg>
	<fnarg type="int">year</fnarg>
	<fnarg type="int">weeklen</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un número enteiro que expresa cantos días (relevantes) ten
	  un mes dun ano (no proléptico calendario Gregoriano) especificados
	  nos dous primeiros argumentos, considerando a duración de semana
	  indicada por <argname>weeklen</argname>. Este debe de ser igual
	  a 5, 6 ou 7 (indicando o valor 6 que non se contan os domingos,
	  e 5 que non se contan nin os sábados nin os domingos).
	</para>
      </description>
    </function>

    <function name="movavg" section="filters" output="series">
      <fnargs>
	<fnarg type="series">x</fnarg>
	<fnarg type="scalar">p</fnarg>
	<fnarg type="int" optional="true">control</fnarg>
	<fnarg type="scalar" optional="true">y0</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha serie que é unha media móbil de <argname>x</argname>,
	  e dependendo do valor do parámetro <argname>p</argname> resultará
	  unha media móbil simple ou ponderada exponencialmente.
	</para>
	<para context="notex">
	  Cando <argname>p</argname> &gt; 1, a función calcula unha media
	  móbil simple de <argname>p</argname> elementos; é dicir, calcula
	  a media aritmética de <math>x</math> desde o período <math>t</math>
	  ata o período <math>t-p+1</math>. Cando indicas un valor non nulo
	  para o argumento <argname>control</argname> (opcional), a media
	  móbil <quote>céntrase</quote>; noutro caso <quote>retárdase</quote>.
	  O outro argumento <argname>y0</argname> non se vai ter en
	  conta.
	</para>
	<para context="tex">
	  Cando $p&gt;1$, a función calcula unha media móbil simple de
	  <argname>p</argname> elementos; é dicir, calcula
	  $\frac{1}{p} \sum_{i=0}^{p-1} x_{t-i}$. Cando indicas un valor non
	  nulo para o argumento <argname>control</argname> (opcional), a media
	  móbil <quote>céntrase</quote>; noutro caso <quote>retárdase</quote>.
	  O outro argumento <argname>y0</argname> non se vai ter en conta.
	</para>
	<para context="notex">
	  Cando <argname>p</argname> é un fracción decimal entre 0 e 1, a
	  función calcula unha media móbil exponencial:
	</para>
	<para context="notex">
	  <math>y(t) = p*x(t) + (1-p)*y(t-1)</math>
	</para>
	<para context="notex">
	  Por defecto, a serie <math>y</math> que se devolve, iníciase
	  utilizando o primeiro valor válido de <argname>x</argname>. Pero
	  podes utilizar o parámetro <argname>control</argname> para
	  especificar o número de observacións iniciais que deben de tomarse
	  para que a súa media sexa <math>y(0)</math>; un valor de cero para
	  <argname>control</argname> expresa que deben de tomarse todas as
	  observacións para iso. Outra posibilidade consiste en que podes
	  especificar o valor inicial utilizando o argumento opcional
	  <argname>y0</argname>; nese caso o argumento
	  <argname>control</argname> non vai terse en conta.
	</para>
	<para context="tex">
	  Cando $0 &lt; p &lt; 1$, a función calcula unha media móbil
	  exponencial: \[y_t = p x_t + (1-p)y_{t-1}\]. Esta é a fórmula de
	  <cite key="roberts59">Roberts (1959)</cite>. Por defecto, a serie
	  $y$ que se devolve, iníciase utilizando o primeiro valor válido de
	  $x$. Pero podes utilizar o parámetro <argname>control</argname>
	  para especificar o número de observacións iniciais que deben de
	  tomarse para que a súa media sexa $y_0$; un valor de cero para
	  <argname>control</argname> expresa que deben de tomarse todas as
	  observacións para iso. Outra posibilidade consiste en que podes
	  especificar o valor inicial utilizando o argumento opcional
	  <argname>y0</argname>; nese caso o argumento
	  <argname>control</argname> non vai terse en conta.
	</para>
      </description>
    </function>

    <function name="mpols" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Funciona igual que <fncref targ="mols"/>, devolvendo unha matriz, agás
	  que os cálculos fanse con alta precisión utilizando a biblioteca GMP.
	</para>
	<para>
	  Por defecto, GMP utiliza 256 bits para cada número de punto flotante,
	  pero podes axustar isto utilizando a variable de contexto
	  <lit>GRETL_MP_BITS</lit>; por exemplo, <lit>GRETL_MP_BITS=1024</lit>.
	</para>
      </description>
    </function>

    <function name="mrandgen" section="probdist" output="matrix">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="scalar">p1</fnarg>
	<fnarg type="scalar" conditional="true">p2</fnarg>
	<fnarg type="scalar" conditional="true">p3</fnarg>
	<fnarg type="int">rows</fnarg>
	<fnarg type="int">cols</fnarg>
      </fnargs>
      <examples>
	<example>matrix mx = mrandgen(u, 0, 100, 50, 1)</example>
	<example>matrix mt14 = mrandgen(t, 14, 20, 20)</example>
      </examples>
      <description>
	<para>
	  Funciona da mesma forma que a función <fncref targ="randgen"/> agás
	  polo feito de que devolve unha matriz en troques dunha serie. Os
	  argumentos iniciais (cuxo número depende da distribución escollida)
	  para esta función, xa se describen para <lit>randgen</lit>, pero
	  deben de seguirse con dous números enteiros para especificar o
	  número de filas e de columnas que vai ter a matriz aleatoria
	  desexada.
	</para>
	<para>
	  O primeiro dos exemplos precedentes crea un vector columna con 50
	  elementos, a partir dunha distribución uniforme. O segundo exemplo
	  crea unha matriz aleatoria de orde <by r="20" c="20"/>, con valores
	  xerados da distribución <math>t</math> con 14 graos de liberdade.
	</para>
	<para>
	  <seelist>
            <fncref targ="mnormal"/>
            <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mread" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="string">fname</fnarg>
	<fnarg optional="true" type="bool">import</fnarg>
      </fnargs>
      <description>
	<para>
	  Le unha matriz gardada no ficheiro chamado <argname>fname</argname>.
	  Se o ficheiro posúe a extensión <quote><lit>.gz</lit></quote> asúmese
	  que se aplicou a compresión gzip ao gardar os datos. Se ten a
	  extensión <quote><lit>.bin</lit></quote> asúmese que o ficheiro
	  está en formato binario (consulta a función <fncref targ="mwrite"/>
	  para ter máis detalles). Noutro caso, asúmese que o ficheiro ten
	  un formato de texto simple, de acordo coas seguintes
	  especificacións:
	</para>
	<ilist>
	  <li>
            <para>
	          O ficheiro pode comezar con unha cantidade calquera de
	          comentarios, definidos por liñas que comezan co carácter
	          cancelo, <lit>#</lit>; estas liñas van ignorarse.
            </para>
	  </li>
	  <li>
            <para>
              A primeira liña que non sexa un comentario debe de conter
              dous enteiros, separados por un espazo ou unha tabulación,
              para indicar o número de filas e columnas, respectivamente.
            </para>
	  </li>
	  <li>
            <para>
              As columnas deben de estar separadas por espazos ou por
              tabulacións.
            </para>
	  </li>
	  <li>
            <para>
              O separador decimal debe de ser o carácter punto,
              <quote><lit>.</lit></quote>.
            </para>
	  </li>
	</ilist>
	<para>
	  Se no primeiro argumento non está especificado o camiño completo
	  ata o ficheiro, vaise procurar en algunhas localizacións que se
	  consideren <quote>probables</quote>, empezando polo cartafol de
	  traballo actualmente establecido en <cmdref targ="workdir"/>. Non
	  obstante, cando se indica un valor non nulo para o segundo argumento
	  <argname>import</argname> (opcional) da función, o ficheiro
	  procúrase no cartafol <quote>dot</quote> do usuario. Isto ten a
	  intención de que se use esta función xunto coas que exportan matrices
	  e que se ofrecen o contexto da instrución <cmdref targ="foreign"/>.
	  Nese caso o argumento <argname>fname</argname> debe de ser un nome
	  de ficheiro simple, sen indicar o camiño ata o ficheiro.
	</para>
	<para>
	  <seelist>
            <fncref targ="bread"/>
            <fncref targ="mwrite"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mreverse" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="bool" optional="true">bycol</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz que contén as filas de <argname>X</argname>
	  en orde inversa; ou as columnas en orde inversa se o segundo
	  argumento ten un valor non nulo.
	</para>
      </description>
    </function>

    <function name="mrls" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">R</fnarg>
	<fnarg type="cvec">q</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;V</fnarg>
      </fnargs>
      <description>
	<para>
	  Mínimos cadrados restrinxidos: xera a matriz de orde <by r="k" c="n"/>
	  cos parámetros estimados mediante a regresión de mínimos cadrados da
	  matriz <argname>Y</argname> de orde <by r="T" c="n"/>, sobre a matriz
	  <argname>X</argname> de orde <by r="T" c="k"/>, suxeita ao conxunto
	  de restricións lineais dos parámetros <math>RB </math> = <math>q</math>,
	  onde <math>B</math> representa o vector que formarían os parámetros
	  encastelados uns sobre os outros. <argname>R</argname> debe de ter
	  <math>kn</math> columnas e cada liña dela indica os coeficientes dunha
	  das restricións lineais. O número de filas de <argname>q</argname>
	  debe de coincidir co número de filas de <argname>R</argname>.
	</para>
	<para>
	  Se o quinto argumento da función non é <lit>null</lit>, entón a
	  matriz <argname>U</argname> de orde <by r="T" c="n"/> vai conter
	  os erros. Cando proporcionas un argumento final que non é
	  <lit>null</lit>, entón a matriz <argname>V</argname> de orde
	  <by r="k" c="k"/> vai gardar a contrapartida restrinxida da matriz
	  <math>X'X</math><sup>-1</sup>. Podes construír a matriz de
	  varianzas-covarianzas dos estimadores da ecuación <math>i</math>
	  multiplicando a submatriz apropiada de <argname>V</argname> por
	  unha estimación da varianza da perturbación esa
	  ecuación.
	</para>
      </description>
    </function>

    <function name="mshape" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">r</fnarg>
	<fnarg type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Reordena os elementos da matriz <argname>X</argname> nunha nova matriz
	  que ten <argname>r</argname> filas e <argname>c</argname> columnas. Os
	  elementos lense e gárdanse comezando polo da primeira columna e fila
	  de <argname>X</argname>, e seguindo cos das seguintes filas ata acabar
	  cos desa columna, e logo coas demais columnas. Se <argname>X</argname>
	  ten menos elementos ca <math>k</math>= <math>rc</math>, estes vanse
	  repetir de forma cíclica. Noutro caso, se <argname>X</argname> ten
	  máis elementos, só se utilizan os primeiros <math>k</math> elementos.
	</para>
	<para>
	  <seelist>
            <fncref targ="cols"/>
            <fncref targ="rows"/>
            <fncref targ="unvech"/>
            <fncref targ="vec"/>
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="msortby" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">j</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz coas mesmas filas da matriz do argumento
	  <argname>X</argname> reordenadas de forma crecente de acordo cos
	  elementos da columna <argname>j</argname>. Esta orde é estable: as
	  filas que comparten o mesmo valor na columna <argname>j</argname>
	  non se intercambian.
	</para>
      </description>
    </function>

    <function name="muniform" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz feita con números xerados de forma pseudoaleatoria
	  mediante variables con distribución Uniforme (0,1), e que vai ter
	  <argname>r</argname> filas e <argname>c</argname> columnas.
	  Aviso: O método predilecto para xerar números pseudoaleatorios con
	  distribución uniforme é o que usa a función <fncref targ="randgen1"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="mnormal"/>
            <fncref targ="uniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mweights" section="midas" output="matrix">
      <fnargs>
	<fnarg type="int">p</fnarg>
	<fnarg type="vector">theta</fnarg>
	<fnarg type="int-or-string">type</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector de orde <math>p</math> coas ponderacións MIDAS
	  que se aplican aos <math>p</math> retardos dunha serie de alta
	  frecuencia, baseado no vector <repl>theta</repl> de hiperparámetros.
	</para>
	<para>
	  O argumento <repl>type</repl> identifica o tipo de disposición de
	  parámetros que vai regular o número <math>k</math> de elementos
	  que se solicitan para <repl>theta</repl>: 1 = para Almon exponencial
	  normalizada (<math>k</math> debe de ser cando menos igual a1,
	  habitualmente 2); 2 = para Beta normalizada co retardo final nulo
	  (<math>k</math> = 2); 3 = para Beta normalizada co retardo final
	  non nulo (<math>k</math> = 3); e 4 = para Almon polinómico
	  (<math>k</math> debe de ser cando menos igual a 1). Ten en conta
	  que no caso de Beta normalizada, os dous primeiros elementos de
	  <repl>theta</repl> deben de ser positivos.
	</para>
	<para>
	  Podes indicar o <repl>type</repl> como un código enteiro tal e
	  como se amosa máis abaixo, ou mediante unha das seguintes cadeas
	  de texto (respectivamente): <lit>nealmon</lit>, <lit>beta0</lit>,
	  <lit>betan</lit> ou <lit>almonp</lit>. Se utilizas unha cadea de
	  texto, esta deberá de estar situada entre comiñas. Por exemplo,
	  as dúas seguintes expresións son equivalentes:
	</para>
	<code>
	  W = mweights(8, theta, 2)
	  W = mweights(8, theta, "beta0")
	</code>
	<para>
	  <seelist>
            <fncref targ="mgradient"/>
	    <fncref targ="mlincomb"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mwrite" section="data-utils" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="string">fname</fnarg>
	<fnarg optional="true" type="bool">export</fnarg>
      </fnargs>
      <description>
	<para>
	  Escribe a matriz do argumento <argname>X</argname> nun ficheiro co
	  nome <argname>fname</argname>. Por defecto, este ficheiro vai ser de
	  texto plano e, na primeira liña, vai conter dous números enteiros que
	  representan o número de filas e columnas, respectivamente, separados
	  por un carácter de tabulación. Nas seguintes filas, os elementos da
	  matriz amósanse en notación científica, separados por tabulacións
	  (unha liña por fila). Para formatos alternativos, mira máis abaixo.
	</para>
	<para>
	  Cando xa existe un ficheiro chamado <argname>fname</argname>, vaise
	  sobrescribir. A execución da función devolve un enteiro igual a 0 se
	  non se completa con éxito; e devolve un enteiro que non é cero cando
	  acontece un fallo (por exemplo se non se pode sobrescribir o ficheiro).
	</para>
	<para>
	  O ficheiro cos resultados vai escribirse no cartafol establecido
	  como actual, <cmdref targ="workdir"/>, agás que a cadea de texto
	  do argumento <repl>fname</repl> especifique o cartafol co
	  camiño completo. Non obstante, se indicas un valor non nulo para o
	  argumento <argname>export</argname>, o ficheiro cos resultados vai
	  escribirse no cartafol <quote>dot</quote> do usuario, onde estará
	  accesible por defecto por medio das funcións para cargar matrices
	  que se ofrecen no contexto da instrución <cmdref targ="foreign"/>.
	  Neste caso, debes de indicar un simple nome de ficheiro para o
	  segundo argumento, sen a parte que expresa o camiño ao cartafol.
	</para>
	<para>
	  As matrices gardadas mediante a forma que ten por defecto a función
	  <lit>mwrite</lit>, poden lerse doadamente con outros programas.
	  Consulta o <guideref targ="chap:matrices"/> para obter máis detalles.
	</para>
	<para>
	  Dúas matizacións, que se exclúen mutuamente, desta función están
	  dispoñibles como se indica deseguido:
	</para>
	<ilist>
	  <li>
	    <para>
	      Se o argumento <argname>fname</argname> ten a extensión
	      <quote><lit>.gz</lit></quote>, entón o ficheiro gárdase coa
	      compresión gzip.
	    </para>
	  </li>
	  <li>
	    <para>
	      Se o argumento <argname>fname</argname> ten a extensión
	      <quote><lit>.bin</lit></quote>, entón o ficheiro gárdase con
	      formato binario. Neste caso os primeiros 19 bytes conteñen
	      os caracteres <lit>gretl_binary_matrix</lit>, os seguintes
	      8 bytes conteñen dous enteiros de 32 bits que proporcionan
	      o número de filas e de columnas, e o que resta do ficheiro
	      contén os elementos da matriz ordenados por columnas, en
	      formato <quote>little-endian doubles</quote>. Cando executas
	      Gretl nun sistema <quote>big-endian</quote>, os valores
	      binarios convértense a <quote>little-endian</quote> ao
	      escribilos, e a <quote>big-endian</quote> aos ler.
	    </para>
	  </li>
	</ilist>
	<para>
	  Cae na conta de que se vas ler o ficheiro coa matriz, utilizando
	  outro software alleo, non resulta aconsellable que utilices as
	  opcións gzip nin binario. Pero se o queres para que o lea Gretl,
	  estes dous formatos alternativos permiten aforrar espazo; e co
	  formato binario logras unha lectura máis rápida de matrices
	  grandes. O formato gzip non é recomendable para matrices moi
	  grandes porque a descompresión pode ser bastante lenta.
	</para>
	<para>
	  <seelist>
            <fncref targ="mread"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mxtab" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz que inclúe a tabulación cruzada dos valores
	  contidos en <argname>x</argname> (por filas) e <argname>y</argname>
	  (por columnas). Os dous argumentos desta función deben de ser
	  do mesmo tipo (ambas series ou ambos vectores columna) e, a causa
	  da utilización típica desta función, asúmese que contén unicamente
	  valores enteiros.
	</para>
	<para>
	  <seelist>
            <fncref targ="values"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="naalen" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">d</fnarg>
	<fnarg type="series-or-vec" optional="true">cens</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve o cálculo do estimador non paramétrico de Nelson&ndash;Aalen
	  da función de risco (<cite key="nelson72">Nelson, 1972</cite>;
	  <cite key="aalen78">Aalen, 1978</cite>), dada unha mostra
	  <argname>d</argname> de datos de duración, que posiblemente estea
	  acompañada dun rexistro de estado de censura, <argname>cens</argname>.
	  A matriz que devolve a función ten tres columnas que conteñen,
	  respectivamente: os valores únicos ordenados en
	  <argname>d</argname>, a estimación da función de risco acumulado
	  que se corresponde cos valores de duración da columna 1, e a desviación
	  padrón do estimador.
	</para>
	<para>
	  Cando indicas a serie <argname>cens</argname>, utilízase o valor 0
	  para sinalar que unha observación non está censurada, namentres
	  que o valor 1 indica que unha observación está censurada do lado
	  dereito (é dicir, o período de observación do individuo en cuestión
	  concluíu antes da duración ou o período rexistrouse como rematado).
	  Cando non indicas <argname>cens</argname>, asúmese que todas as
	  observacións son non censuradas. (Aviso: a semántica de
	  <argname>cens</argname> pode estenderse nalgún punto para cubrir
	  outros tipos de censura.)
	</para>
	<para>
	  <seelist>
            <fncref targ="kmeier"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="nadarwat" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series">x</fnarg>
	<fnarg type="scalar">h</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha serie coa estimación non paramétrica da media
	  condicional de <argname>y</argname> dado <argname>x</argname>,
	  de Nadaraya-Watson. A serie que devolve a función, contén os
	  valores das estimacións non paramétricas de
	  <math>E(y</math><sub>i</sub><math>|x</math><sub>i</sub><math>)</math>
	  para cada un dos elementos non ausentes da serie
	  <argname>x</argname>.
	</para>
	<para context="tex">
	  \[
	  m(x_i) = \frac{ \sum_{j=1}^{n} y_j \cdot K_h(x_i -
	  x_j)} {\sum_{j=1}^{n} K_h(x_i - x_j)}
	  \]
	  onde a función kernel <math>K_h(\cdot)</math> ven dada
	  por
	  \[
	  K_h(x) = \exp\left(-\frac{x^2}{2h}\right)
	  \]
	  para $|x| &lt; \tau$ e cero noutro caso.
	</para>
	<para context="notex">
	  A función núcleo (<quote>kernel</quote>) <math>K</math> ven dada por
	  <math>K = exp(-x</math><sup>2</sup><math> / 2h)</math> cando
	  <math>|x| &lt; T</math>, e igual a cero noutro caso.
	</para>
	<para context="tex">
	  O argumento <argname>h</argname>, que se coñece como o ancho de
	  banda ou \emph{bandwidth}, é un parámetro que determina o usuario
	  cun número real positivo. Habitualmente este é un número pequeno
	  pois valores máis grandes de $h$ fan que $m(x)$ sexa máis suave;
	  unha escolla popular é $h \propto n^{-0.2}$. Podes obter máis detalles no
	  <guideref targ="chap:nonparam"/>.
	</para>
	<para context="notex">
	  O argumento <argname>h</argname>, que se coñece como o ancho
	  de banda (<quote>bandwidth</quote>), é un parámetro que determina
	  o usuario cun número real positivo. Habitualmente este é un número
	  pequeno pois valores máis grandes de <argname>h</argname> fan que
	  <math>m(x)</math> sexa máis suave; unha escolla popular é facer que
	  <argname>h</argname> sexa proporcional a <math>n</math><sup>-0.2</sup>.
	  Podes obter máis detalles no <guideref targ="chap:nonparam"/>.
	</para>
	<para context="tex">
	  O escalar $\tau$ utilízase para previr problemas numéricos cando se
	  avalía a función núcleo lonxe de máis do cero, e chámase parámetro
	  trim.
	</para>
	<para context="notex">
	  O escalar <math>T</math> utilízase para previr problemas numéricos
	  cando se avalía a función núcleo lonxe de máis do cero, e chámase
	  parámetro <quote>trim</quote>.
	</para>
	<para>
	  Este parámetro <quote>trim</quote> pode axustarse establecendo
	  <lit>nadarwat_trim</lit> como múltiplo de <argname>h</argname>.
	  O valor por defecto é 4.
	</para>
	<para>
	  O usuario pode indicar un valor negativo para o ancho de banda.
	  Iso interprétase como un convencionalismo sintáctico para obter o
	  estimador que omite unha observación; é dicir, unha variante do
	  estimador que non utiliza a observación <math>i</math>-ésima para
	  avaliar <math>m(x</math><sub>i</sub><math>)</math>. Isto fai que
	  o estimador de Nadaraya&ndash;Watson sexa numericamente máis
	  robusto, e por iso recoméndase habitualmente utilizalo cando se
	  calcula coa intención de facer inferencias. Loxicamente, o ancho de
	  banda que se utiliza en realidade é o valor absoluto de
	  <argname>h</argname>.
	</para>
	<para context="tex">
          Nas fórmulas, o estimador que non utiliza unha observación é
          \[
          m(x_i) = \frac{ \sum_{j \ne i} y_j \cdot K_h(x_i -
          x_j)} {\sum_{j \ne i} K_h(x_i - x_j)}
          \]
	</para>

      </description>
    </function>

    <function name="nelem" section="data-utils" output="int">
      <fnargs>
	<fnarg type="listetc">L</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un enteiro co número de elementos que hai no argumento;
	  este pode ser unha lista, unha matriz, un feixe ou un arranxo
	  (pero non unha serie).
	</para>
      </description>
    </function>

    <function name="ngetenv" section="strings" output="scalar">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co valor numérico dunha variable de contexto que
	  ten o nome do argumento <argname>s</argname>, se esa variable está
	  definida e se ten un valor numérico; noutro caso devolve NA.
	  Consulta tamén <fncref targ="getenv"/>.
	</para>
      </description>
    </function>

    <function name="nlines" section="strings" output="scalar">
      <fnargs>
	<fnarg type="string">buf</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar coa cantidade de filas completas (é dicir, filas
	  que rematan co carácter de nova liña) en <argname>buf</argname>.
	</para>
    <para>
        Exemplo:
    </para>
    <code>
        string web_page = readfile("http://gretl.sourceforge.net/")
        scalar number = nlines(web_page)
        print number
    </code>
      </description>
    </function>

    <function name="NMmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg optional="true" type="int">maxfeval</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co resultado dunha maximización numérica feita co
	  método do simplex sen derivadas de Nelder&ndash;Mead. O argumento
	  <argname>b</argname> debe de conter os valores iniciais dun conxunto
	  de parámetros, e o argumento <argname>f</argname> debe de especificar
	  unha chamada á función que vai calcular o criterio obxectivo (escalar)
	  que se quere maximizar, dados os valores actuais dos parámetros, así
	  como calquera outros datos que sexan relevantes. Cando se completa
	  con éxito a súa execución, <lit>NMmax</lit> devolve o valor maximizado
	  do criterio obxectivo, e <argname>b</argname> contén finalmente os
	  valores dos parámetros que producen o máximo.
	</para>
	<para>
	  Podes utilizar o terceiro argumento (opcional) para indicar o número
	  máximo de avaliacións da función; so o omites ou o estableces igual
	  a cero, o máximo tómase por defecto igual a 2000. Como indicación
	  especial para esta función, podes poñer un valor negativo para o
	  argumento <argname>maxfeval</argname>. Nese caso, tómase o seu
	  valor absoluto e <lit>NMmax</lit> amosa un fallo se o mellor valor
	  atopado para a función obxectivo despois de realizar o máximo número
	  de avaliacións da función, non é un óptimo local. Por outra parte,
	  neste senso a non converxencia non se trata coma un fallo.
	</para>
	<para>
	  Se o teu obxectivo realmente é acadar un mínimo, podes
	  ben trocar a función considerando o negativo do criterio,
	  ou ben, alternativamente, podes invocar a función
	  <lit>NMmax</lit>baixo o alcume <lit>NMmin</lit>..
	</para>
	<para>
	  Para máis detalles e exemplos, consulta
	  <guideref targ="chap:numerical"/>.
	  <seelist>
            <fncref targ="simann"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="NMmin" section="numerical" output="scalar">
      <description>
	<para>
	  Un alcume de <fncref targ="NMmax"/>. Se invocas a función baixo
	  este nome, execútase facendo unha minimización.
	</para>
      </description>
    </function>

    <function name="nobs" section="stats" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve o número de observacións non ausentes da variable
	  <argname>y</argname> na mostra actual seleccionada.
	</para>
      </description>
    </function>

    <function name="normal" section="probdist" output="series">
      <fnargs>
	<fnarg type="scalar">&mu;</fnarg>
	<fnarg type="scalar">&sigma;</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha serie xerada cunha variable pseudoaleatoria gaussiana
	  de media &mu; e desviación padrón &sigma;. Se non indicas ningún
	  argumento, os valores que se devolven son os dunha variable con
	  distribución de probabilidade Normal estándar, <math>N</math>(0,1).
	  Os valores prodúcense utilizando o método Ziggurat
	  (<cite key="marsaglia00" p="true">Marsaglia e Tsang, 2000</cite>).
	</para>
	<para>
	  <seelist>
            <fncref targ="randgen"/>
            <fncref targ="mnormal"/>
            <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="normtest" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="string" optional="true">method</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector fila cos resultados de realizar unha proba de
	  Normalidade sobre <argname>y</argname>. A función fai por defecto
	  a proba de Doornik&ndash;Hansen, pero podes utilizar o argumento
	  <argname>method</argname> (opcional) para escoller unha alternativa.
	  Indica: <lit>swilk</lit> para executar a proba de Shapiro&ndash;Wilk,
	  <lit>jbera</lit> para realizar a proba de Jarque&ndash;Bera, ou
	  <lit>lillie</lit> para efectuar a proba de Lilliefors.
	</para>
	<para>
	  Podes indicar o segundo argumento con formato entre comiñas ou sen
	  elas. Neste último caso, tamén podes indicar unha cadea de texto cuxo
	  valor sexa o nome dun dos métodos, polo que se vai substituír cando se
	  executa. A continuación amósanse tres xeitos aceptables de executar
	  a proba de Shapiro&ndash;Wilk:
	</para>
	<code>
	  matrix nt = normtest(y, swilk)
	  matrix nt = normtest(y, "swilk")
	  string testtype = "swilk"
	  matrix nt = normtest(y, testtype)
	</code>
	<para>
	  O vector fila que se devolve é de orde <by r="1" c="2"/>; contén
	  o valor do estatístico de proba solicitado e a probabilidade asociada
	  a ese valor. Consulta tamén a instrución <cmdref targ="normtest"/>.
	</para>
      </description>
    </function>

    <function name="npcorr" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="string" optional="true">method</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector fila cos cálculos dunha medida de correlación entre
	  <argname>x</argname> e <argname>y</argname>, utilizando un método
	  non paramétrico. Se indicas o terceiro argumento, este debe de ser
	  <lit>kendall</lit> (para o método por defecto, o tau de Kendall,
	  versión b) ou ben <lit>spearman</lit> (para o rho de Spearman).
	</para>
	<para>
	  O resultado que se devolve é un vector fila con 3 valores que indican:
	  a medición da correlación, o valor do estatístico de proba da hipótese
	  nula de incorrelación, e a probabilidade asociada a ese valor. Advirte
	  que, se o tamaño da mostra é moi pequeno, o estatístico de proba e/ou
	  a probabilidade pode ser <lit>NaN</lit> (non é número, ou ausente).
	</para>
	<para>
	  Consulta tamén <fncref targ="corr"/> para a correlación de Pearson.
	</para>
      </description>
    </function>

    <function name="npv" section="math" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg type="scalar">r</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co Valor Actual Neto de <argname>x</argname>,
	  considerado este como unha secuencia de pagos (negativos) e ingresos
	  (positivos), avaliados a unha taxa de desconto anual que debes de
	  indicar no argumento <argname>r</argname> como fracción decimal entre
	  0 e 1, non como porcentaxe (por exemplo 0.05, e non 5<lit>%</lit>).
	  O primeiro valor da serie/vector do primeiro argumento, considérase
	  que está datado <quote>agora</quote> e non se desconta. Para imitar
	  unha función VAN na que se desconte o primeiro valor, engade un cero
	  ao principio da serie/vector do primeiro argumento.
	</para>
	<para>
	  O tipo de frecuencia dos datos que admite esta función pode ser anual,
	  trimestral, mensual e sen data (este tipo trátase como se fora anual).
	</para>
	<para>
	  <seelist>
            <fncref targ="irr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="NRmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="fncall" optional="true">g</fnarg>
	<fnarg type="fncall" optional="true">h</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co resultado dunha maximización numérica feita co
	  método de Newton&ndash;Raphson. O argumento <argname>b</argname>
	  debe de conter os valores iniciais do conxunto de parámetros, e o
	  argumento <argname>f</argname> debe de indicar unha chamada á función
	  que vai calcular o criterio obxectivo (escalar) que queres maximizar,
	  dados os valores actuais dos parámetros, así como calquera outro dato
	  relevante. Se o que queres realmente é minimizar o criterio obxectivo,
	  esta función debera de devolver o valor negativo do mesmo. Cando se
	  completa con éxito a súa execución, <lit>NRmax</lit> devolve o valor
	  maximizado do criterio obxectivo, e <argname>b</argname> vai conter
	  os valores dos parámetros que proporcionan o máximo dese criterio.
	</para>
	<para>
	  O terceiro e cuarto argumentos (opcionais) proporcionan xeitos de
	  indicar, respectivamente, as derivadas analíticas e unha matriz
	  hessiana analítica (negativa). As funcións ás que se refiren estes
	  argumentos <argname>g</argname> e <argname>h</argname>
	  deben de ter, como primeiro elemento, unha matriz definida con
	  anterioridade que sexa do rango correcto para poder conter o vector
	  gradiente ou a matriz hessiana, indicados en forma de punteiro.
	  Ademais, outro dos seus elementos, debe de ser o vector de parámetros
	  (en forma de punteiro ou non). Outro tipo de elementos son opcionais.
	  Se omites calquera dos argumentos opcionais (ou os dous), utilízase
	  unha aproximación numérica.
	</para>
	<para>
	  Para máis detalles e exemplos, consulta
	  <guideref targ="chap:numerical"/>.
	  <seelist>
            <fncref targ="BFGSmax"/>
            <fncref targ="fdjac"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="NRmin" section="numerical" output="scalar">
      <description>
	<para>
	  Un alcume de <fncref targ="NRmax"/>. Se invocas a función baixo
	  este nome, execútase facendo unha minimización.
	</para>
      </description>
    </function>

    <function name="nullspace" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devolve unha matriz co cálculo do espazo nulo á dereita correspondente
	  á matriz <argname>A</argname>, feito mediante a descomposición en
	  valores singulares: o resultado é unha matriz <math>B</math> que fai
	  que o produto <math>AB</math> sexa unha matriz nula. Como excepción,
	  se a matriz <argname>A</argname> ten rango completo por columnas, o
	  resultado que se devolve é unha matriz baleira. Por outra banda, se
	  <argname>A</argname> é de orde <by r="m" c="n"/>, entón <math>B</math>
	  vai ser <math>n</math> por (<math>n</math> &minus; <math>r</math>),
	  onde <math>r</math> é o rango de <argname>A</argname>.
	</para>
	<para context="notex">
	  Se <argname>A</argname> non ten rango completo por columnas,
	  entón ao concatenar verticalmente a matriz <argname>A</argname> e
	  a matriz trasposta de <argname>B</argname>, xérase unha matriz con
	  rango completo.
	</para>
	<para context="tex">
	  Devolve unha matriz co cálculo do espazo nulo á dereita correspondente
	  á matriz <argname>A</argname>, feito mediante a descomposición en
	  valores singulares: o resultado é unha matriz $B$ que fai que
	  \begin{itemize}
	  \item $AB = [0]$. Como excepción, se a matriz $A$ ten rango completo
	  por columnas, o resultado que se devolve é unha matriz baleira. Por
	  outra banda, se $A$ é de orde $m \times n$, entón $B$ vai ser unha
	  matriz de orde $n \times (n-r)$, onde $r$ é o rango $A$.
	  \item Se $A$ non ten rango completo por columnas, entón ao concatenar
	  verticalmente $A$ e $B'$, xérase unha matriz con rango completo.
	  \end{itemize}
	</para>
    <para>
        Exemplo:
    </para>
    <code>
      A = mshape(seq(1,6),2,3)
      B = nullspace(A)
      C = A | B'

      print A B C

      eval A*B
      eval rank(C)
    </code>
    <para>
        produce...
    </para>
    <code>
      ? print A B C
      A (2 x 3)

      1   3   5
      2   4   6

      B (3 x 1)

      -0.5
         1
      -0.5

      C (3 x 3)

         1      3      5
         2      4      6
      -0.5      1   -0.5

      ? eval A*B
      -4.4409e-16
      -4.4409e-16

      ? eval rank(C)
      3
    </code>
    <para>
      <seelist>
        <fncref targ="rank"/>
        <fncref targ="svd"/>
      </seelist>
	</para>
      </description>
    </function>

    <function name="numhess" section="numerical" output="matrix">
      <fnargs>
	<fnarg type="cvec">b</fnarg>
	<fnarg type="fncall">fcall</fnarg>
	<fnarg optional="true" type="scalar">d</fnarg>
      </fnargs> 
      <description>
	<para>
	  Calcula unha aproximación numérica á matriz hessiana asociada
	  ao vector <math>n</math>-dimensional <argname>b</argname>,
	  e á función obxectivo que se especifique mediante o argumento
	  <argname>fcall</argname>. A chamada á función debe de ter o
	  <argname>b</argname> como primeiro argumento (ben directamente
	  ou ben en forma de punteiro), seguido de calquera argumento
	  adicional que poida ser necesario, e debe de devolver como
	  resultado un escalar. Ao completarse con éxito <lit>numhess</lit>
	  devolve unha matriz <by r="n" c="n"/> que contén a hessiana,
	  e que é exactamente simétrica por construción.
	</para>
	<para>
	  O método utiliza a extrapolación de Richardson, con catro pasos.
	  Podes usar o terceiro argumento (opcional) para establecer a
	  fracción <math>d</math> do valor do parámetro que se utiliza
	  para establecer o tamaño da medida inicial. Cando omites este
	  argumento, por defecto vai ser <math>d</math> = 0.01.
	</para>
	<para>
	  Aquí tes un exemplo do seu uso:
	</para>
	<code>
	  matrix H = numhess(theta, myfunc(&amp;theta, X))
	</code>
	<para>
	  <seelist>
            <fncref targ="BFGSmax"/>
	          <fncref targ="fdjac"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="obs" section="data-utils" output="series">
      <description>
	<para>
	  Devolve unha serie de números enteiros consecutivos, establecendo o 1
	  ao comezo do conxunto de datos. Ten en conta que o resultado non vai
	  depender de que teñas escollida unha submostra. Esta función é útil
	  especialmente con conxuntos de datos de series temporais. Advertencia:
	  Podes escribir <lit>t</lit> en vez de <lit>obs</lit>, co mesmo efecto.
	</para>
	<para>
	  <seelist>
            <fncref targ="obsnum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="obslabel" section="data-utils" output="string">
      <fnargs>
	<fnarg type="int">t</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve o marcador da observación <argname>t</argname>, onde
	  <argname>t</argname> é un número enteiro positivo que representa
	  a esta observación. A operación inversa pódese facer mediante a
	  función <fncref targ="obsnum"/>.
	</para>
      </description>
    </function>

    <function name="obsnum" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve o número enteiro que indica a observación que se corresponde
	  coa cadea do argumento <math>s</math>. Observa que o resultado non vai
	  depender de que teñas escollida unha submostra. Esta función é útil
	  con conxuntos de datos temporais. Por exemplo, o seguinte código ...
	</para>
	<code>
	  open denmark
	  k = obsnum(1980:1)
	</code>
	<para>
	  ... xera <lit>k = 25</lit>, indicando que o primeiro trimestre de 1980
	  é a vixésimo quinta observación da base de datos <lit>denmark</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="obs"/>
            <fncref targ="obslabel"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ok" section="data-utils" output="seebelow">
      <fnargs>
	<fnarg type="anyfloat-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Cando o argumento <argname>x</argname> é un escalar, esta función
	  devolve 1 se <argname>x</argname> non é <lit>NA</lit>, e 0 noutro
	  caso. Cando <argname>x</argname> é unha serie, devolve outra serie que
	  toma o valor 1 nas observacións nas que o argumento non ten valores
	  ausentes, e toma o valor cero nos demais. Se <argname>x</argname> é
	  unha lista, o resultado é unha serie con 0 nas observacións nas que
	  ao menos unha serie da lista ten un valor ausente, e 1 noutro caso.
	</para>
	<para>
	  Cando o argumento <argname>x</argname> é unha matriz, o comportamento
	  é un pouco diferente, posto que as matrices non poden conter
	  <lit>NA</lit>s: a función devolve outra matriz da mesma dimensión que
	  <argname>x</argname>, co valor 1 nas posicións que se corresponden
	  con elementos finitos de <argname>x</argname>, e co valor 0 nas
	  posicións onde os elementos non son finitos (ou ben infinitos, ou ben
	  <quote>non números</quote>, coma no estándar IEEE 754).
	</para>
	<para>
	  <seelist>
            <fncref targ="missing"/>
            <fncref targ="misszero"/>
            <fncref targ="zeromiss"/>
	  </seelist>
	  Pero ten en conta que estas funcións non son aplicables a matrices.
	</para>
      </description>
    </function>

    <function name="onenorm" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devolve un escalar coa norma 1 da matriz <argname>X</argname>,
	  é dicir, o máximo dos resultados de sumar os valores absolutos dos
	  elementos de <argname>X</argname> por columnas.
	</para>
	<para context="tex">
	  Devolve un escalar coa norma 1 da matriz
	  <argname>X</argname> de orde $r \times c$:
	  \[\| X \|_1 = \max_j \sum_{i=1}^r |X_{ij}| \]
	</para>
	<para>
	  <seelist>
            <fncref targ="infnorm"/>
            <fncref targ="rcond"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ones" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz con <math>r</math> filas e <math>c</math>
	  columnas, cuberta con valores iguais a 1.
	</para>
	<para>
	  <seelist>
            <fncref targ="seq"/>
            <fncref targ="zeros"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="orthdev" section="transforms" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Aplícase tan só se o conxunto de datos actual ten unha estrutura
	  de panel, e devolve unha serie co cálculo das desviacións ortogonais
	  adiantadas para a variable <argname>y</argname>.
	</para>
	<para context="tex">
	  Aplícase tan só se o conxunto de datos actual ten unha estrutura
	  de panel, e devolve unha serie co cálculo das desviacións ortogonais
	  adiantadas para a variable <argname>y</argname>, é dicir
	  \[ \tilde{y}_{i,t} =
	  \sqrt{ \frac{T_i - t}{T_i - t + 1}} \left( y_{i,t} -
	  \frac{1}{T_i - t} \sum_{s=t+1}^{T_i} y_{i,s} \right) \]
	</para>
	<para>
	  Algunhas veces se utiliza esta transformación en troques da
	  diferenciación para eliminar os efectos individuais dos datos de
	  panel. Por compatibilidade coas primeiras diferenzas, as desviacións
	  gárdanse un paso adiante da súa localización temporal verdadeira
	  (é dicir, o valor na observación <math>t</math> é a desviación que,
	  expresándoo de maneira estrita, pertence a <math>t</math> &minus; 1).
	  Deste xeito, pérdese a primeira observación en cada serie temporal,
	  non a derradeira.
	</para>
	<para>
	  <seelist>
            <fncref targ="diff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pdf" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <examples>
	<example>f1 = pdf(N, -2.5)</example>
	<example>f2 = pdf(X, 3, y)</example>
	<example>f3 = pdf(W, forma, escala, y)</example>
      </examples>
      <description>
	<para>
	  Calcula o valor da función de densidade de probabilidade e devolve
	  un resultado (do mesmo tipo ca o argumento) coa densidade en
	  <argname>x</argname> da distribución identificada polo código
	  <argname>d</argname>. Consulta <fncref targ="cdf"/> para obter máis
	  detalles acerca dos argumentos (escalares) esixidos. Esta función
	  <lit>pdf</lit> acepta as distribucións: Normal, <math>t</math> de
	  Student, Khi-cadrado, <math>F</math>, Gamma, Exponencial, Weibull,
	  Laplace, Erro Xeneralizado, Binomial e Poisson. Cae na conta de que
	  para a Binomial e a Poisson, o que se calcula de feito é a masa de
	  probabilidade no punto especificado. Para <math>t</math> de Student,
	  Khi-cadrado e <math>F</math> tamén están dispoñibles as súas
	  variantes non centrais.
	</para>
	<para>
	  Para a distribución Normal, consulta tamén <fncref targ="dnorm"/>.
	</para>
      </description>
    </function>

    <function name="pergm" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg optional="true" type="scalar">bandwidth</fnarg>
      </fnargs>
      <description>
	<para>
	  Se só se indica a serie ou vector do primeiro argumento, calcula o seu
	  periodograma na mostra. Se indicas o escalar do segundo argumento,
	  calcula a estimación do espectro de <argname>x</argname> cunha xanela
	  de retardos de Bartlett cun ancho de banda igual a ese escalar, ata un
	  máximo igual á metade do número de observacións (<math>T</math>/2).
	</para>
	<para>
	  Devolve unha matriz con <math>T</math>/2 filas e dúas columnas: a
	  primeira destas ten a frecuencia (&omega;) desde 2&pi;/<math>T</math>
	  ata &pi;, e a segunda das columnas contén a densidade espectral
	  correspondente.
	</para>
      </description>
    </function>

    <function name="pexpand" section="data-utils" output="series">
      <fnargs>
	<fnarg type="vector">v</fnarg>
      </fnargs>
      <description>
	<para>
	  Aplícase tan só se o conxunto de datos actual ten unha estrutura
	  de panel, e realiza a operación inversa de <fncref targ="pshrink"/>.
	  É dicir, dado un vector que ten unha lonxitude igual ao número de
	  elementos da mostra (de panel) actualmente seleccionada, esta
	  función devolve unha serie na cal cada valor do argumento repítese
	  <math>T</math> veces, onde <math>T</math> expresa a lonxitude
	  temporal do panel. Deste xeito, a serie resultante é invariante en
	  relación ao tempo.
	</para>
      </description>
    </function>

    <function name="pmax" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para>
	  Aplícase tan só se o conxunto de datos actual ten unha estrutura de
	  panel, e devolve unha serie que contén cada un dos valores máximos
	  da variable <argname>y</argname> en cada unidade de corte transversal
	  (repetíndoo nos períodos de tempo de cada unha destas).
	</para>
	<para>
	  Cando indicas o segundo argumento (opcional), vanse ignorar aquelas
	  observacións onde o valor de <argname>mask</argname> sexa igual a
	  cero.
	</para>
	<para>
	  <seelist>
            <fncref targ="pmin"/>
            <fncref targ="pmean"/>
            <fncref targ="pnobs"/>
            <fncref targ="psd"/>
            <fncref targ="pxsum"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pmean" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Aplícase tan só se o conxunto de datos actual ten unha estrutura de
	  panel, e devolve unha serie que contén cada unha das medias temporais
	  da variable <argname>y</argname> en cada unidade de corte transversal
	  (repetindo cada valor nos períodos temporais de cada unha destas).
	  As observacións ausentes ignóranse no cálculo das medias.
	</para>
	<para context="tex">
	  Aplícase tan só se o conxunto de datos actual ten unha estrutura de
	  panel, e devolve unha serie que contén cada unha das medias temporais
	  da variable <argname>y</argname> en cada unidade de corte transversal,
	  é dicir, \[ \bar{y}_i = \frac{1}{T_i} \sum_{t=1}^{T_i} y_{i,t}\]
	  onde $T_i$ representa o número de observacións válidas da unidade
	  $i$.
	</para>
	<para>
	  Cando indicas o segundo argumento (opcional), vanse ignorar aquelas
	  observacións onde o valor de <argname>mask</argname> sexa igual a
	  cero.
	</para>
	<para>
	  <seelist>
            <fncref targ="pmax"/>
            <fncref targ="pmin"/>
            <fncref targ="pnobs"/>
            <fncref targ="psd"/>
            <fncref targ="pxsum"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pmin" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para>
	  Aplícase tan só se o conxunto de datos actual ten unha estrutura de
	  panel, e devolve unha serie que contén cada un dos valores mínimos
	  da variable <argname>y</argname> en cada unidade de corte transversal
	  (repetindo cada valor nos períodos temporais de cada unha destas).
	</para>
	<para>
	  Cando indicas o segundo argumento (opcional), vanse ignorar aquelas
	  observacións onde o valor de <argname>mask</argname> sexa igual a
	  cero.
	</para>
	<para>
	  <seelist>
            <fncref targ="pmax"/>
            <fncref targ="pmean"/>
            <fncref targ="pnobs"/>
            <fncref targ="psd"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pnobs" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para>
	  Aplícase tan só se o conxunto de datos actual ten unha estrutura de
	  panel, e devolve unha serie que contén o número de observacións
	  válidas da variable <argname>y</argname> en cada unidade de corte
	  transversal (repetíndoo nos períodos temporais de cada unha destas).
	</para>
	<para>
	  Cando indicas o segundo argumento (opcional), vanse ignorar aquelas
	  observacións onde o valor de <argname>mask</argname> sexa igual a
	  cero.
	</para>
	<para>
	  <seelist>
            <fncref targ="pmax"/>
            <fncref targ="pmin"/>
            <fncref targ="pmean"/>
            <fncref targ="psd"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="polroots" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="vector">a</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz coas raíces dun polinomio. Se o polinomio é
	  de grao <math>p</math>, o vector <argname>a</argname> debe de
	  conter <math>p</math> + 1 coeficientes en orde ascendente; é
	  dicir, comezando coa constante e finalizando co coeficiente de
	  <math>x</math><sup>p</sup>.
	</para>
	<para>
	  Se todas as raíces son reais, vanse devolver nun vector columna de
	  dimensión <math>p</math>; noutro caso devólvese unha matriz de orde
	  <by r="p" c="2"/>, coas partes reais na primeira columna e as partes
	  imaxinarias na segunda.
	</para>
      </description>
    </function>

    <function name="polyfit" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int">q</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha serie, axustando unha tendencia polinómica de orde
	  <argname>q</argname> á serie do argumento <argname>y</argname>,
	  utilizando o método de polinomios ortogonais. A serie que se xera
	  contén os valores axustados.
	</para>
      </description>
    </function>

    <function name="princomp" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">p</fnarg>
	<fnarg optional="true" type="bool">covmat</fnarg>
      </fnargs>
      <description>
	<para>
	  Sexa <argname>X</argname> unha matriz de orde <by r="T" c="k"/>,
	  que contén <math>T</math> observacións sobre <math>k</math>
	  variables. O argumento <argname>p</argname> debe de ser un número
	  enteiro positivo menor que ou igual a <math>k</math>. Esta función
	  devolve unha matriz <math>P</math>, de orde <by r="T" c="p"/>,
	  que contén as <math>p</math> primeiras compoñentes principais de
	  <argname>X</argname>.
	</para>
	<para>
	  O terceiro argumento (opcional) opera coma un conmutador booleano:
	  se non é cero, as compoñentes principais calcúlanse en base á matriz
	  de varianzas-covarianzas das columnas de <argname>X</argname>
	  (por defecto utilízase a matriz de correlacións).
	</para>
	<para context="notex">
	  Os elementos da matriz <math>P</math> que se devolve, calcúlanse
	  como a suma desde <math>i</math> ata <math>k</math> de
	  <math>Z</math><sub>ti</sub> veces <math>v</math><sub>ji</sub>,
	  onde <math>Z</math><sub>ti</sub> representa o valor
	  estandarizado (ou simplemente o valor centrado, se utilizas a matriz
	  de covarianzas) da variable <math>i</math> na observación
	  <math>t</math>, e <math>v</math><sub>ji</sub> representa o
	  <math>j</math>-ésimo autovector da matriz de correlacións (ou a
	  matriz de covarianzas) entre as <math>X</math><sub>i</sub>s, cos
	  autovectores ordenados de acordo aos valores decrecentes dos
	  autovalores correspondentes.
	</para>
	<para context="tex">
	  Os elementos da matriz $P$ que se devolve, calcúlanse como
	  \[ P_{tj} = \sum_{i=1}^{k} Z_{ti} \, v^{(j)}_i \]
	  onde $Z_{ti}$ representa o valor estandarizado (ou simplemente
	  o valor centrado, se utilizas a matriz de covarianzas) da variable $i$
	  na observación $t$, $Z_{ti} = (X_{ti} - \bar{X}_i) / \hat{\sigma}_i$,
	  e $v^{(j)_i}$ representa o $j$-ésimo autovector da matriz de
	  correlacións (ou de covarianzas) dos $X_i$s, cos autovectores
	  ordenados de acordo aos valores decrecentes dos autovalores
	  correspondentes.
	</para>
	<para>
	  <seelist>
            <fncref targ="eigensym"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="prodc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector fila co produto dos elementos das columnas de
	  <argname>X</argname>.
	  <seelist>
            <fncref targ="prodr"/>
            <fncref targ="meanc"/>
            <fncref targ="sdc"/>
            <fncref targ="sumc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="prodr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector columna co produto dos elementos das filas de
	  <argname>X</argname>.
	  <seelist>
            <fncref targ="prodc"/>
            <fncref targ="meanr"/>
            <fncref targ="sumr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="psd" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Aplícase tan só se o conxunto de datos actual ten unha estrutura de
	  panel, e devolve unha serie que contén a desviación padrón da variable
	  <math>y</math> na mostra en cada unidade de corte transversal
	  (repetindo cada valor nos períodos temporais de cada unha destas).
	  O denominador que se utiliza é o tamaño da mostra en cada unidade
	  menos 1, agás que só haxa 1 única observación válida para unha
	  unidade dada (pois neste caso devólvese 0) ou que non haxa ningunha
	  (neste caso devólvese <lit>NA</lit>).
	</para>
	<para context="tex">
	  Aplícase tan só se o conxunto de datos actual ten unha estrutura de
	  panel, e devolve unha serie que contén a desviación padrón da variable
	  <math>y</math> na mostra, en cada unidade de corte transversal, é dicir,
	  \[ \sigma_i = \sqrt{\frac{1}{T_i - 1} \sum_{t=1}^{T_i} (y_{i,t} -
	  \bar{y}_i)^2 } \]. Esta fórmula aplícase cando $T_i \ge 2$, onde
	  $T_i$ representa o número de observacións válidas para a unidade
	  $i$; se $T_i = 0$ devólvese <lit>NA</lit> e se $T_i = 1$
	  devólvese 0.
	</para>
	<para>
	  Cando indicas o segundo argumento (opcional), vanse ignorar aquelas
	  observacións onde o valor de <argname>mask</argname> sexa igual a
	  cero.
  </para>
	<para>
	  Nota: Esta función permite comprobar se unha variable calquera
	  (por exemplo, <lit>X</lit>) é invariante ao longo do tempo,
	  por medio da condición <lit>max(psd(X)) == 0</lit>.
	</para>
	<para>
		<seelist>
            <fncref targ="pmax"/>
            <fncref targ="pmin"/>
            <fncref targ="pmean"/>
            <fncref targ="pnobs"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="psdroot" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="symmat">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve a matriz cadrada que resulta de aplicarlle á matriz simétrica
	  <argname>A</argname> do argumento, unha variante xeneralizada da
	  descomposición de Cholesky. A matriz do argumento debe de ser
	  semidefinida positiva (aínda que pode ser singular) pero, se non é
	  cadrada, amósase unha mensaxe de fallo. A simetría asúmese e non se
	  comproba; só se le o triángulo inferior de <argname>A</argname>.
	  O resultado é unha matriz triangular inferior, <math>L</math>, que
	  cumpre <equation status="inline" ascii="A = LL'" tex="$A = LL'$"/>.
	  Os elementos indeterminados da solución establécense iguais a cero.
	</para>
	<para>
	  Para o caso no que a matriz <argname>A</argname> é definida positiva,
	  consulta <fncref targ="cholesky"/>.
	</para>
      </description>
    </function>

    <function name="pshrink" section="data-utils" output="matrix">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Aplícase tan só se o conxunto de datos actual ten unha estrutura de
	  panel, e devolve un vector que contén cada unha das primeiras
	  observacións válidas da serie <argname>y</argname> en cada unidade
	  de corte transversal no panel, ao longo do rango da mostra actual.
	  Se a serie ten algunha unidade sen observacións válidas, esa
	  unidade ignórase.
	</para>
	<para>
	  Esta función te proporciona un xeito de compactar as series que
	  te van devolver algunhas funcións tales como <fncref targ="pmax"/>
	  e <fncref targ="pmean"/>, nas que se repite un mesmo valor nos
	  diferentes períodos de tempo dunha mesma unidade de corte
	  transversal.
	</para>
	<para>
	  Consulta <fncref targ="pexpand"/> para a operación inversa.
	</para>
      </description>
    </function>

    <function name="psum" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Aplícase tan só se o conxunto de datos actual ten unha estrutura de
	  panel, e devolve unha serie na que cada valor é a suma da variable
	  <argname>y</argname> nos distintos períodos temporais de cada unidade
	  de corte transversal. En cada unha destas, a suma así calculada se
	  repite para cada período temporal. As observacións ausentes ignóranse
	  no cálculo das sumas.
	</para>
	<para context="tex">
	  Aplícase tan só se o conxunto de datos actual ten unha estrutura de
	  panel, e devolve unha serie na que cada valor é a suma da variable
	  <argname>y</argname> nos distintos períodos temporais de cada unidade
	  de corte transversal, é dicir, \[ S_i = \sum_{t=1}^{T_i} y_{i,t}\]
	  onde $T_i$ indica o número de observacións válidas da unidade $i$.
	</para>
	<para>
	  Cando indicas o segundo argumento (opcional), vanse ignorar aquelas
	  observacións onde o valor de <argname>mask</argname> sexa igual a
	  cero.
	</para>
	<para>
	  <seelist>
            <fncref targ="pmax"/>
            <fncref targ="pmean"/>
            <fncref targ="pmin"/>
            <fncref targ="pnobs"/>
            <fncref targ="psd"/>
            <fncref targ="pxsum"/>
            <fncref targ="pshrink"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pvalue" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="char">c</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <examples>
	<example>p1 = pvalue(z, 2.2)</example>
	<example>p2 = pvalue(X, 3, 5.67)</example>
	<example>p2 = pvalue(F, 3, 30, 5.67)</example>
      </examples>
      <description>
	<para>
	  Calcula valores <math>P</math> de probabilidade e devolve un
	  resultado (do mesmo tipo ca o argumento) coa probabilidade
	  <equation status="inline" ascii="P(X > x)" tex="$P(X > x)$"/>, onde
	  a distribución de probabilidade de <math>X</math> indícase coa letra
	  <argname>c</argname>. Entre os argumentos <argname>d</argname> e
	  <argname>p</argname>, podes necesitar algún argumento adicional
	  escalar para especificar os parámetros da distribución de que se
	  trate. Para máis detalles, consulta <fncref targ="cdf"/>. As
	  distribucións soportadas pola función <lit>pvalue</lit> son:
	  Normal estándar, <math>t</math>, Khi-cadrado, <math>F</math>, Gamma,
	  Binomial, Poisson, Exponencial, Weibull, Laplace e Erro Xeneralizado.
	</para>
	<para>
	  <seelist>
            <fncref targ="critical"/>
            <fncref targ="invcdf"/>
            <fncref targ="urcpval"/>
            <fncref targ="imhof"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pxnobs" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para>
	  Aplícase tan só se o conxunto de datos actual ten unha estrutura de
	  panel, e devolve unha serie que contén o número de observacións
	  válidas de <argname>y</argname> en cada período de tempo (o valor
	  calculado, repítese en cada unha das unidades de corte transversal).
	</para>
	<para>
	  Cando indicas o segundo argumento (opcional), vanse ignorar aquelas
	  observacións onde o valor de <argname>mask</argname> sexa igual a
	  cero.
	</para>
	<para>
	  Cae na conta de que esta función opera na outra dimensión do panel,
	  diferente á da función <fncref targ="pnobs"/>.
	</para>
      </description>
    </function>

    <function name="pxsum" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Aplícase tan só se o conxunto de datos actual ten estrutura de panel,
	  e devolve unha serie na que cada valor é a suma de <argname>y</argname>
	  nas distintas unidades de corte transversal de cada período temporal.
	  As sumas así calculadas repítense en cada unidade de corte transversal.
	</para>
	<para context="tex">
	  Aplícase tan só se o conxunto de datos actual ten estrutura de panel,
	  e devolve unha serie na que cada valor é a suma de <argname>y</argname>
	  nas distintas unidades de corte transversal de cada período temporal,
	  é dicir, \[ \tilde{y}_t = \sum_{i=1}^{N} y_{i,t}\] onde $N$ é o número
	  de unidades de corte transversal.
	</para>
	<para>
	  Cando indicas o segundo argumento (opcional), vanse ignorar aquelas
	  observacións onde o valor de <argname>mask</argname> sexa igual a
	  cero.
	</para>
	<para>
	  Cae na conta de que esta función opera na outra dimensión do panel,
	  diferente á da función <fncref targ="psum"/>.
	</para>
      </description>
    </function>

    <function name="qform" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">x</fnarg>
	<fnarg type="symmat">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devolve unha matriz co resultado de calcular a forma cuadrática
	  <equation status="inline" ascii="Y = xAx'" tex="$Y = x A x'$"/>.
	  Se a matriz simétrica <argname>A</argname> do argumento, é de tipo
	  xenérico, cando utilizas esta función en vez da típica multiplicación
	  de matrices, garantes unha maior rapidez e mellor precisión. Porén, no
	  caso especial de que <argname>A</argname> sexa unha matriz
	  identidade, a simple expresión <lit>x'x</lit> resulta moito mellor ca
	  <lit>qform(x',I(rows(x))</lit>.
	</para>
	<para context="tex">
	  Devolve unha matriz co resultado de calcular a forma cuadrática
	  <equation status="inline" ascii="Y = xAx'" tex="$Y = x A x'$"/>.
	  Se a matriz simétrica <argname>A</argname> do argumento, é de tipo
	  xenérico, cando utilizas esta función en vez da típica multiplicación
	  de matrices, garantes unha maior rapidez e mellor precisión. Porén, no
	  caso especial <equation status="inline" ascii="A = I" tex="$A = I$"/>,
	  a simple expresión <lit>x'x</lit> resulta moito mellor ca
	  <lit>qform(x',I(rows(x))</lit>.
	</para>
	<para>
	Se <argname>x</argname> e <argname>A</argname> non son matrices
	conformables, ou se <argname>A</argname> non é simétrica, a función
	devolve un fallo.
	</para>
      </description>
    </function>

    <function name="qlrpval" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="scalar">X2</fnarg>
	<fnarg type="int">df</fnarg>
	<fnarg type="scalar">p1</fnarg>
	<fnarg type="scalar">p2</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar coa probabilidade asociada (<math>P</math>) ao valor
	  do estatístico para facer a proba LR de Quandt (ou sup-Wald) de cambio
	  estrutural nun punto descoñecido (consulta <cmdref targ="qlrtest"/>),
	  segundo <cite key="hansen97">Bruce Hansen (1997)</cite>.
	</para>
	<para>
	  O primeiro argumento, <argname>X2</argname>, indica o valor do
	  estatístico de proba de Wald máximo (en formato khi-cadrado), e o
	  segundo <argname>df</argname> indica os seus graos de liberdade.
	  O terceiro e o cuarto argumentos, representan os puntos de comezo e
	  de remate do rango central de observacións sobre o que se van calcular
	  os sucesivos estatísticos de Wald das probas, e debes expresalos como
	  fraccións decimais en relación ao rango total de estimación. Por
	  exemplo, se queres adoptar o enfoque estándar do recorte do 15 por
	  cento, debes de establecer <argname>p1</argname> igual a 0.15 e
	  <argname>p2</argname> igual a 0.85.
	</para>
	<para>
	  <seelist>
            <fncref targ="pvalue"/>
	    <fncref targ="urcpval"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="qnorm" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) cos cuantís dunha
	  Normal estándar que se corresponden con cada valor do argumento. Se
	  <argname>x</argname> non está entre 0 e 1, devólvese <lit>NA</lit>.
	  <seelist>
            <fncref targ="cnorm"/>
            <fncref targ="dnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="qrdecomp" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;R</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz co cálculo da descomposición QR dunha matriz
	  <argname>X</argname> de orde <by r="m" c="n"/>, é dicir,
	  <math>X = QR</math> onde <math>Q</math> é unha matriz <by r="m" c="n"/>
	  ortogonal e <math>R</math> é unha matriz <by r="n" c="n"/> triangular
	  superior. A matriz <math>Q</math> devólvese directamente, mentres que
	  podes obter <math>R</math> mediante o segundo argumento (opcional).
	</para>
	<para>
	  <seelist>
            <fncref targ="eigengen"/>
            <fncref targ="eigensym"/>
            <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="quadtable" section="stats" output="matrix">
      <fnargs>
	<fnarg type="int">n</fnarg>
	<fnarg type="int" optional="true">type</fnarg>
	<fnarg type="scalar" optional="true">a</fnarg>
	<fnarg type="scalar" optional="true">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz <by r="n" c="2"/> para utilizar coa cuadratura
	  Gaussiana (en integración numérica). A primeira columna contén os
	  nodos ou abscisas, e a segunda as ponderacións.
	</para>
	<para>
	  O primeiro argumento especifica o número de puntos (filas) que se
	  van calcular. O segundo argumento codifica o tipo de cuadratura:
	  utiliza 1 para a Gauss&ndash;Hermite (a establecida por defecto);
	  2 para a Gauss&ndash;Legendre; ou 3 para a Gauss&ndash;Laguerre.
	  O sentido dos parámetros <argname>a</argname> e <argname>b</argname>
	  (opcionais) depende do tipo (<argname>type</argname>) seleccionado,
	  como se explica deseguido.
	</para>
	<para context="notex">
	  A cuadratura Gaussiana é un método para aproximar numericamente a
	  integral definida de algunha función que te interese. Supón que a
	  función se representa mediante o produto <math>f(x)W(x)</math>.
	  Os distintos tipos de cuadratura difiren na especificación da
	  compoñente <math>W(x)</math>: no caso da Hermite isto é igual a
	  exp(&minus;<math>x</math><sup>2</sup>); no caso da Laguerre é
	  igual a exp(&minus;<math>x</math>); e no caso da Legendre simplemente
	  é <math>W(x)</math> = 1.
	</para>
	<para context="tex">
	  A cuadratura Gaussiana é un método para aproximar numericamente a
	  integral definida de algunha función que te interese. Supón que a
	  función se representa mediante o produto $f(x)W(x)$. Os distintos
	  tipos de cuadratura difiren na especificación da compoñente $W(x)$:
	  no caso da Hermite temos $W(x) = \exp(-x^2)$; no caso da Laguerre,
	  $W(x) = \exp(-x)$; e no caso da Legendre temos simplemente
	  $W(x) = 1$.
	</para>
	<para context="notex">
	  Para cada especificación de <math>W</math>, pode calcularse un
	  conxunto de nodos, <math>x</math><sub>i</sub>, e un conxunto de
	  ponderacións, <math>w</math><sub>i</sub>, de tal xeito que a suma
	  desde <math>i</math>=1 ata <math>n</math> de
	  <math>w</math><sub>i</sub>
	  <math>f</math>(<math>x</math><sub>i</sub>) vaise aproximar á
	  integral desexada. Para isto vaise utilizar o método de
	  <cite key="golub69">Golub e Welsch (1969)</cite>.
	</para>
	<para context="tex">
	  Para cada especificación de $W(x)$, pode calcularse un conxunto de
	  nodos, $x_i$, e un conxunto de ponderacións, $w_i$, de tal xeito que
	  $\sum_{i=1}^n f(x_i) w_i$ vaise aproximar á integral desexada. Vaise
	  usar o método de <cite key="golub69">Golub e Welsch (1969)</cite>.
	</para>
	<para context="notex">
	  Cando se selecciona o tipo de Gauss&ndash;Legendre, podes utilizar
	  os argumentos opcionais <argname>a</argname> e <argname>b</argname>
	  para controlar os límites inferior e superior da integración, sendo
	  neste caso os valores por defecto o &minus;1 e o 1. (Na cuadratura
	  de Hermite, os límites están fixados no menos e máis infinito;
	  mentres que no caso da cuadratura de Laguerre, están fixados no 0
	  e no infinito.)
	</para>
	<para context="tex">
	  Cando se selecciona o tipo de Gauss&ndash;Legendre, podes utilizar
	  os argumentos opcionais <argname>a</argname> e <argname>b</argname>
	  para controlar os límites inferior e superior da integración, sendo
	  neste caso os valores por defecto o $-1$ e 1. (Na cuadratura
	  de Hermite, os límites están fixados no $-\infty$ e $+\infty$;
	  mentres que no caso de Laguerre, están fixados no 0 e $\infty$.)
	</para>
	<para context="notex">
	  No caso de Hermite, <argname>a</argname> e <argname>b</argname>
	  xogan papeis diferentes: poden utilizarse para substituír a forma
	  por defecto de <math>W</math>(<math>x</math>) pola distribución
	  Normal de probabilidade con media <argname>a</argname> e desviación
	  padrón <argname>b</argname> (coa que está estreitamente emparentada).
	  Por exemplo, se indicas os valores de 0 e 1 para estes parámetros,
	  respectivamente, vas provocar que <math>W</math>(<math>x</math>)
	  sexa a función de densidade de probabilidade Normal estándar, o
	  que é equivalente a multiplicar os nodos por defecto pola raíz
	  cadrada de dous e dividir as ponderacións pola raíz cadrada de
	  &pi;.
	</para>
	<para context="tex">
	  No caso de Hermite, <argname>a</argname> e <argname>b</argname>
	  xogan papeis diferentes: poden utilizarse para substituír a forma
	  por defecto de $W(x)$ pola distribución Normal de probabilidade con
	  media <argname>a</argname> e desviación padrón <argname>b</argname>
	  (coa que está estreitamente emparentada). Por exemplo, se indicas
	  os valores de 0 e 1 para estes parámetros, respectivamente, vas
	  provocar que $W(x)$ sexa a función de densidade de probabilidade
	  Normal estándar, o que é equivalente a multiplicar os valores
	  $x_i$ por defecto por $\sqrt{2}$ e dividir as ponderacións por defecto
	  $w_i$ por $\sqrt{\pi}$.
	</para>
      </description>
    </function>

    <function name="quantile" section="stats" output="scalar" altout="matrix">
      <fnargs>
	<fnarg type="series-or-mat">y</fnarg>
	<fnarg type="pscalar">p</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>y</argname> é unha serie, devolve un escalar que
	  representa o cuantil <argname>p</argname> da mesma. Por exemplo,
	  cando <math>p</math> = 0.5, devólvese a mediana.
	</para>
	<para>
	  Se <argname>y</argname> é unha matriz, devolve un vector fila que
	  contén os <argname>p</argname> cuantís das diferentes columnas
	  de <argname>y</argname>; é dicir, cada unha das súas columnas
	  trátase como una serie.
	</para>
	<para>
	  Amais, para unha matriz <argname>y</argname> admítese unha forma
	  alternativa do segundo argumento: podes indicar <argname>p</argname>
	  coma un vector. Nese caso, o valor que se te devolve é unha matriz
	  de orde <by r="m" c="n"/>, na que <repl>m</repl> indica o número de
	  elementos de <argname>p</argname> e <repl>n</repl> indica o número
	  de columnas de <argname>y</argname>.
	</para>
	<para context="tex">
	  Para unha serie de longura $n$, $q$ é o cuantil $p$, se cumpre a
	  igualdade:
	  \[q = y_{[k]} + [(n+1) \cdot p - k] (y_{[k+1]} - y_{[k]})\]
	  onde $k$ é a parte enteira de $(n+1) \cdot p$ e $y_{[i]}$
	  é o elemento $i$-ésimo da serie cando se ordena de menor a
	  maior.
	</para>
      </description>
    </function>

    <function name="randgen" section="probdist" output="series">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="scalar-or-series">p1</fnarg>
	<fnarg type="scalar-or-series" conditional="true">p2</fnarg>
	<fnarg type="scalar" conditional="true">p3</fnarg>
      </fnargs>
      <examples>
	<example>series x = randgen(u, 0, 100)</example>
	<example>series t14 = randgen(t, 14)</example>
	<example>series y = randgen(B, 0.6, 30)</example>
	<example>series g = randgen(G, 1, 1)</example>
	<example>series P = randgen(P, mu)</example>
      </examples>
      <description>
	<para>
	  Devolve unha serie calculada cun xerador universal de números
	  aleatorios. O argumento <argname>d</argname> é unha cadea de texto
	  (que xeralmente está formada por un só carácter) que permite
	  especificar o tipo de distribución de probabilidade da que se
	  extraen os pseudonúmeros. Os argumentos de <argname>p1</argname>
	  ata <argname>p3</argname> especifican os parámetros da distribución
	  escollida, e o número destes parámetros depende desa distribución.
	  Para outras distribucións diferentes á Beta-Binomial, os parámetros
	  <argname>p1</argname> e (caso de ser aplicable) <argname>p2</argname>
	  podes indicalos en formato de escalar ou de serie. Cando os utilizas
	  en formato escalar, a serie que resulta procede de distribucións
	  identicamente distribuídas.Cando utilizas series para os argumentos
	  <argname>p1</argname> ou <argname>p2</argname>, a serie resultante
	  procede de distribucións condicionadas ao valor dos parámetros en
	  cada observación. No caso da Beta-Binomial todos os parámetros
	  deben de ser escalares.
	</para>
	<para>
	  A continuación indícanse detalles máis específicos: o código de
	  texto para cada tipo de distribución móstrase entre parénteses,
	  seguido da interpretación do argumento <argname>p1</argname> e,
	  cando é aplicable, da interpretación de <argname>p2</argname> e
	  <argname>p3</argname>.
	</para>

	<ilist context="notex">
	  <li>
            <para>
              Uniforme (continua) (u ou U): mínimo, máximo
            </para>
	  </li>
	  <li>
            <para>
              Uniforme (discreta) (i): mínimo, máximo
            </para>
	  </li>
	  <li>
            <para>
              Normal (z, n ou N): media, desviación padrón
            </para>
	  </li>
	  <li>
            <para>
              t de Student (t): graos de liberdade
            </para>
	  </li>
	  <li>
            <para>
              Khi-cadrado (c, x ou X): graos de liberdade
            </para>
	  </li>
	  <li>
            <para>
              F de Snedecor (f ou F): graos de liberdade (num.), graos de liberdade (den.)
            </para>
	  </li>
	  <li>
            <para>
              Gamma (g ou G): forma, escala
            </para>
	  </li>
	  <li>
            <para>
              Binomial (b ou B): probabilidade, cantidade de ensaios
            </para>
	  </li>
	  <li>
            <para>
              Poisson (p ou P): media
            </para>
	  </li>
	  <li>
            <para>
              Exponencial (exp): escala
            </para>
	  </li>
	  <li>
            <para>
              Weibull (w ou W): forma, escala
            </para>
	  </li>
	  <li>
            <para>
              Laplace (l ou L): media, escala
            </para>
	  </li>
	  <li>
            <para>
              Erro Xeneralizado (E): forma
            </para>
	  </li>
	  <li>
            <para>
              Beta (beta): forma1, forma2
            </para>
	  </li>
	  <li>
            <para>
              Beta-Binomial (bb): ensaios, forma1, forma2
            </para>
	  </li>
	</ilist>
	<tabular colspec="lllll">
	  \textbf{Distribución} &amp; \textsl{d} &amp; \textsl{p1} &amp; \textsl{p2} &amp; \textsl{p3}\\[4pt]
	  Uniforme (continua) &amp; \texttt{u} ou \texttt{U} &amp; mínimo &amp; máximo &amp; --\\
	  Uniforme (discreta) &amp; \texttt{i} &amp; mínimo &amp; máximo &amp; --\\
	  Normal &amp; \texttt{z}, \texttt{n} ou \texttt{N} &amp; media &amp; desviación padrón &amp; --\\
	  $t$ de Student &amp; \texttt{t} &amp; graos de liberdade &amp; -- &amp; --\\
	  Khi-cadrado &amp; \texttt{c}, \texttt{x} ou \texttt{X} &amp; graos de liberdade &amp; -- &amp; --\\
	  $F$ de Snedecor &amp; \texttt{f} ou \texttt{F} &amp; gl (num.) &amp; gl (den.) &amp; --\\
	  Gamma &amp; \texttt{g} ou \texttt{G} &amp; forma &amp; escala  &amp; --\\
	  Binomial &amp; \texttt{b} ou \texttt{B} &amp; $p$ &amp; $n$  &amp; --\\
	  Poisson &amp; \texttt{p} ou \texttt{P} &amp; media &amp; --  &amp; --\\
	  Exponencial &amp; \texttt{exp} &amp; escala &amp; -- &amp; --\\
	  Weibull &amp; \texttt{w} ou \texttt{W} &amp; forma &amp; escala &amp; --\\
	  Laplace &amp; \texttt{l} ou \texttt{L} &amp; media &amp; escala &amp; --\\
	  Erro Xeneralizado &amp; \texttt{E} &amp; forma &amp; -- &amp; --\\
	  Beta &amp; \texttt{beta} &amp; forma1 &amp; forma2 &amp; --\\
	  Beta-Binomial &amp; \texttt{bb} &amp; $n$ &amp; forma1 &amp; forma2
	</tabular>
	<para>
	  <seelist>
            <fncref targ="normal"/>
            <fncref targ="uniform"/>
            <fncref targ="mrandgen"/>
            <fncref targ="randgen1"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="randgen1" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="char">d</fnarg>
	<fnarg type="scalar">p1</fnarg>
	<fnarg type="scalar" conditional="true">p2</fnarg>
      </fnargs>
      <examples>
	<example>scalar x = randgen1(z, 0, 1)</example>
	<example>scalar g = randgen1(g, 3, 2.5)</example>
      </examples>
      <description>
	<para>
	  Funciona do mesmo xeito que <fncref targ="randgen"/> agás polo
	  feito de que devolve un escalar en troques dunha serie.
	</para>
	<para>
	  O primeiro exemplo de enriba devolve un valor extraído da distribución
	  Normal estándar, mentres que segundo devolve un valor extraído da
	  distribución Gamma cun parámetro de forma igual a 3 e de escala a 2.5.
	</para>
	<para>
	  <seelist>
            <fncref targ="mrandgen"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="randint" section="probdist" output="int">
      <fnargs>
	<fnarg type="int">min</fnarg>
	<fnarg type="int">max</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un enteiro pseudoaleatorio no intervalo pechado
	  [<argname>min</argname>, <argname>max</argname>].
	  <seelist>
	    <fncref targ="randgen"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="rank" section="linalg" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un enteiro co rango da matriz <argname>X</argname>, calculado
	  numericamente mediante a descomposición en valores singulares.
	  <seelist>
            <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ranking" section="stats" output="asinput">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha serie ou vector coas posicións xerárquicas dos valores
	  de <math>y</math>. A observación <math>i</math> ten unha posición
	  na xerarquía que ven determinada polo número de elementos que son
	  menores ca <math>y</math><sub>i</sub>, máis a metade do número
	  de elementos que son iguais a <math>y</math><sub>i</sub>.
	  (Intuitivamente, podes imaxinalo como a xerarquía nun torneo de
	  xadrez, onde cada vitoria supón conceder un punto ao gañador e
	  cada empate supón conceder medio punto). Engádese un 1 de forma
	  que o número máis pequeno para unha posición é 1, e non 0.
	</para>
	<para context="tex">
	  Formalmente,
	  \[ \mathrm{rank}(y_i) = 1 + \sum_{j \ne i} \left[
	  I(y_j &lt; y_i) + 0.5 \cdot I(y_j = y_i) \right] \]
	  onde $I$ denota a función índice.
	</para>
	<para>
	  <seelist>
            <fncref targ="sort"/>
            <fncref targ="sortby"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="rcond" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co número de condición recíproco da matriz cadrada
	  <argname>A</argname> a respecto da norma 1. En moitos casos, este
	  mide de forma máis axeitada ca o determinante, a sensibilidade de
	  <argname>A</argname> ás operacións numéricas tales como a inversión.
	</para>
	<para context="notex">
	  O valor calcúlase como o inverso (ou recíproco) do resultado de
	  multiplicar a norma 1 da matriz cadrada <argname>A</argname> pola
	  norma 1 da matriz inversa de <argname>A</argname>.
	</para>
	<para context="tex">
	  Dada unha matriz cadrada <math>A</math> non singular, pódese definir
	  \[\kappa(A) = ||A||_1 \cdot ||A^{-1}||_1\]
	  A función devolve $\kappa(A)^{-1}$.
	</para>
	<para>
	  <seelist>
            <fncref targ="det"/>
            <fncref targ="ldet"/>
            <fncref targ="onenorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="readfile" section="strings" output="string">
      <fnargs>
	<fnarg type="string">fname</fnarg>
	<fnarg type="string" optional="true">codeset</fnarg>
      </fnargs>
      <description>
	<para>
	  Se existe un ficheiro co nome do argumento <argname>fname</argname>, e
	  pode lerse, a función devolve unha cadea de texto que inclúe o contido
	  dese ficheiro; noutro caso amosa un fallo. Se <argname>fname</argname>
	  non indica unha especificación da ruta completa ao ficheiro, vaise
	  procurar en distintas localizacións <quote>probables</quote>,
	  comezando pola establecida actualmente, <cmdref targ="workdir"/>.
	</para>
	<para>
	  Se <argname>fname</argname> comeza cun identificador dun protocolo
	  de internet que sexa admisible (<lit>http://</lit>, <lit>ftp://</lit>
	  ou <lit>https://</lit>), actívase unha orde a libcurl para que
	  descargue o recurso. Para outras operacións de descarga máis
	  complicadas, consulta tamén <fncref targ="curl"/>.
	</para>
	<para>
	  Cando o texto que se quere ler non está codificado en UTF-8, Gretl vai
	  tratar de volver a codificalo desde o tipo actual de codificación
	  local (se este non é UTF-8) ou desde ISO-8859-15 noutro caso. Se este
	  sinxelo funcionamento por defecto non cumpre as túas necesidades,
	  podes usar o segundo argumento (opcional) para especificar un tipo de
	  codificación. Por exemplo, se queres ler texto que está no tipo de
	  páxina de código Microsoft 1251, e este non é o teu tipo de código
	  local, deberás de indicar <lit>"cp1251"</lit> como segundo argumento.
	</para>
    <para>
        Exemplos:
    </para>
    <code>
        string web_page = readfile("http://gretl.sourceforge.net/")
        print web_page

        string current_settings = readfile("@dotdir/.gretl2rc")
        print current_settings
    </code>
	<para>
	  Consulta tamén as funcións <fncref targ="sscanf"/> e
	  <fncref targ="getline"/>.
	</para>
      </description>
    </function>

    <function name="regsub" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg type="string">match</fnarg>
	<fnarg type="string">repl</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha cadea de texto cunha copia de <argname>s</argname> onde
	  todos os casos nos que ocorre do padrón <argname>match</argname>,
	  substitúense por <argname>repl</argname>. Os dous argumentos
	  <argname>match</argname> e <argname>repl</argname> interprétanse
	  como expresións regulares de estilo Perl.
	</para>
	<para>
	  Consulta tamén a función <fncref targ="strsub"/> para a substitución
	  simple de cadeas de texto.
	</para>
      </description>
    </function>

    <function name="remove" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">fname</fnarg>
      </fnargs>
      <description>
	<para>
	  Elimina o ficheiro do argumento <argname>fname</argname> no caso
	  de que este exista e que o usuario o poda gardar. Esta función
	  devolve un enteiro igual a 0 no caso de que a operación teña éxito,
	  e un valor non nulo se o ficheiro non existe ou non se pode eliminar.
	</para>
	<para>
	  Cando <argname>fname</argname> contén o camiño completo ata o
	  ficheiro, Gretl tratará de eliminalo, e devolverá un fallo se ese
	  ficheiro non existe ou non pode eliminarse por algún motivo (por
	  exemplo, por non ter suficientes privilexios para poder facelo).
	  Cando <argname>fname</argname> non contén o camiño completo,
	  entón asúmese que o ficheiro ao que se refire, está no cartafol
	  de traballo establecido (<cmdref targ="workdir"/>). Se o ficheiro
	  non existe ou non pode gardarse, non se vai procurar en ningún
	  outro cartafol.
	</para>
      </description>
    </function>

    <function name="replace" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
	<fnarg type="scalar-or-vec">find</fnarg>
	<fnarg type="scalar-or-vec">subst</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo de) <argname>x</argname> trocando os
	  seus elementos que sexan iguais ao elemento <math>i</math>-ésimo de
	  <argname>find</argname> polo concordante de <argname>subst</argname>.
	</para>
	<para>
	  Cando o segundo argumento (<argname>find</argname>) é un escalar, o
	  terceiro argumento (<argname>subst</argname>) tamén debe de ser un
	  escalar. Cando ambos son vectores, deben de ter o mesmo número de
	  elementos. Pero cando <argname>find</argname> é un vector e
	  <argname>subst</argname> é un escalar, entón todas as coincidencias de
	  aquel substitúense en <argname>x</argname> con <argname>subst</argname>.
	</para>
	<para>
	  Exemplo:
	</para>
	<code>
	  a = {1,2,3;3,4,5}
	  find = {1,3,4}
	  subst = {-1,-8, 0}
	  b = replace(a, find, subst)
	  print a b
	</code>
	<para>
	  produce...
	</para>
	<code>
          a (2 x 3)

          1   2   3
          3   4   5

          b (2 x 3)

          -1    2   -8
          -8    0    5
	</code>
      </description>
    </function>

    <function name="resample" section="stats" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
	<fnarg optional="true" type="int">blocksize</fnarg>
      </fnargs>
      <description>
	<para>
	  A descrición inicial desta función refírese ao casos con datos de
	  corte transversal ou con series de tempo; mira máis abaixo para os
	  casos con datos de panel.
	</para>
	<para>
	  Devolve o resultado (do tipo do argumento) que se obtén facendo unha
	  mostraxe por repetición de <argname>x</argname> con substitución. Se
	  o argumento é unha serie, cada valor <math>y</math><sub>t</sub> da
	  serie que se devolve, obtense de entre todos os valores de
	  <math>x</math><sub>t</sub> que teñen a mesma probabilidade. Cando o
	  argumento é unha matriz, cada fila da matriz que se devolve, obtense
	  das filas de <argname>x</argname> que teñen a mesma probabilidade.
	</para>
	<para>
	  O argumento <argname>blocksize</argname> (opcional) representa o
	  tamaño do bloque para facer a mostraxe por repetición movendo
	  bloques. Cando se indica este argumento, deberá de ser un enteiro
	  positivo maior ou igual a 2. Como consecuencia, o resultado vaise
	  compoñer por selección aleatoria con substitución, de entre todas as
	  posibles secuencias contiguas de lonxitude <argname>blocksize</argname>
	  do argumento. (No caso de que o argumento sexa unha matriz, isto
	  significa filas contiguas.) Se a lonxitude dos datos non é un número
	  enteiro que sexa múltiplo do tamaño do bloque, o derradeiro bloque
	  seleccionado trúncase para que se axuste.
	</para>
	<para>
	  Cando o argumento <argname>x</argname> é unha serie e o conxunto
	  de datos ten un formato de panel, non se admite facer a mostraxe por
	  repetición movendo bloques. A forma básica de facer este tipo de
	  mostraxe está admitida, pero ten a súa propia interpretación: faise
	  a mostraxe por repetición dos datos <quote>por individuo</quote>.
	  Supón que tes un panel no que se observan 100 individuos ao longo
	  de 5 períodos. Entón, a serie que se devolve tamén vai estar composta
	  por 100 bloques de 5 observacións: cada bloque vai obterse con igual
	  probabilidade das 100 series temporais individuais, conservándose
	  a orde das series temporais.
	</para>
      </description>
    </function>

    <function name="round" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado, do tipo do argumento, que o arredonda ao
	  enteiro máis próximo. Ten en conta que se <math>x</math> está xusto
	  entre dous enteiros, o arredondamento faise "afastándose de cero" de
	  modo que, por exemplo, 2.5 arredóndase a 3, pero <lit>round(-3.5)</lit>
	  devolve &minus;4. Esta convención é común en software de follas de
	  cálculo, mais outro tipo de software pode xerar resultados diferentes.
	  <seelist>
            <fncref targ="ceil"/>
            <fncref targ="floor"/>
            <fncref targ="int"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="rnameget" section="strings" output="string-or-strings">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="int" optional="true">row</fnarg>
      </fnargs>
      <description>
	<para>
	  Se indicas o argumento <argname>row</argname>, devolve unha
	  cadea co nome da fila <argname>row</argname> da matriz
	  <argname>M</argname>. Se as filas de <argname>M</argname>
	  non teñen nome, entón devólvese unha cadea baleira; e se
	  <argname>row</argname> está fóra dos límites do número de filas
	  desta matriz, amósase un fallo.
	</para>
	<para>
	  Se non indicas o segundo argumento, devolve un arranxo de cadeas
	  de texto que contén os nomes das filas de <argname>M</argname>,
	  ou un arranxo baleiro se <argname>M</argname> non ten asignados
	  nomes de filas.
	</para>
	<para>
	  Exemplo:
	</para>
	<code>
	  matrix A = { 11, 23, 13 ; 54, 15, 46 }
	  rnameset(A, "Primeira Segunda")
	  string name = rnameget(A, 2)
	  print name
	</code>
	<para>
	  <seelist>
            <fncref targ="rnameset"/>
	  </seelist>
	</para>
      </description>
    </function>

	  <function name="rnameset" section="matbuild" output="int">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="strings-or-list">S</fnarg>
      </fnargs>
      <description>
	<para>
	  Permite engadir nomes ás filas dunha matriz <argname>M</argname>
	  de orde <by r="m" c="n"/>. Cando o argumento <argname>S</argname>
	  se refire a unha lista, os nomes tómanse das series da lista (que
	  deberá de ter <math> m</math> elementos). Cando <argname>S</argname>
	  é un arranxo de cadeas de texto, deberá de ter <math>m</math>
	  compoñentes. Para manter a compatibilidade con versións anteriores
	  de Gretl, tamén podes utilizar unha única cadea de texto como
	  segundo argumento; neste caso esta deberá de ter <math>m</math>
	  subcadeas de texto separadas por espazos.
	</para>
	<para>
	  Devolve o valor enteiro 0 se as filas se nomean con éxito, e un valor
	  non nulo en caso de fallo. Consulta tamén <fncref targ="cnameset"/>.
	</para>
	<para>
	  Exemplo:
	</para>
	<code>
	  matrix M = {1, 2; 2, 1; 4, 1}
	  strings S = array(3)
	  S[1] = "Fila1"
	  S[2] = "Fila2"
	  S[3] = "Fila3"
	  rnameset(M, S)
	  print M
	</code>
      </description>
    </function>

    <function name="rows" section="matshape" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un enteiro co número de filas da matriz <argname>X</argname>.
	  <seelist>
            <fncref targ="cols"/>
            <fncref targ="mshape"/>
            <fncref targ="unvech"/>
            <fncref targ="vec"/>
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sd" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>x</argname> é unha serie, a función devolve un escalar
	  coa desviación padrón na mostra, descartando as observacións ausentes.
	</para>
	<para>
	  Se <argname>x</argname> é unha lista, a función devolve unha serie
	  <math>y</math> tal que <math>y</math><sub>t</sub> representa a
	  desviación padrón na mostra dos valores das variables da lista, na
	  observación <math>t</math>; ou <lit>NA</lit> se existe algún valor
	  ausente para a observación <math>t</math>.
	</para>
	<para>
	  <seelist>
            <fncref targ="var"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sdc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="scalar" optional="true">df</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector fila coas desviacións padrón das columnas da
	  matriz <argname>X</argname>. Se <argname>df</argname> é positivo,
	  utilízase como divisor para as varianzas das columnas, noutro caso
	  o divisor é igual ao número de filas que ten <argname>X</argname>
	  (é dicir, nese caso non se aplica a corrección polos graos de
	  liberdade).
	  <seelist>
            <fncref targ="meanc"/>
            <fncref targ="sumc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sdiff" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-or-list">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado co cálculo das diferenzas estacionais:
	  <equation status="inline" ascii="y(t) - y(t-k)"  tex="$y_t - y_{t-k}$"/>,
	  onde <math>k</math> indica a periodicidade do conxunto actual de
	  datos (consulta <fncref targ="$pd"/>). Os valores iniciais defínense
	  como <lit>NA</lit>.
	</para>
	<para>
	  Cando se devolve unha lista, cada variable individual desta noméase de
	  forma automática seguindo o padrón <lit>sd_</lit><repl>varname</repl>,
	  onde <repl>varname</repl> indica o nome da serie orixinal. A parte
	  orixinal do nome vai tronzarse cando así resulte necesario, e mesmo
	  poderá axustarse para garantir que sexa único dentro do conxunto de
	  nomes que así se vaian construír.
	</para>
	<para>
	  <seelist>
            <fncref targ="diff"/>
            <fncref targ="ldiff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="seasonals" section="data-utils" output="list">
      <fnargs>
	<fnarg optional="true" type="int">baseline</fnarg>
	<fnarg optional="true" type="bool">center</fnarg>
      </fnargs>
      <description>
	<para>
	  Aplícase tan só se o conxunto de datos actual ten unha estrutura
	  de series temporais con periodicidade maior ca 1. Devolve unha lista con
	  variables ficticias que representan cada período ou estación, e que se
	  nomean como <lit>S1</lit>, <lit>S2</lit>, etc.
	</para>
	<para>
	  Utiliza o argumento <argname>baseline</argname> (opcional) para
	  excluír da lista á variable ficticia que representa un dos períodos.
	  Por exemplo, se lle asignas un valor igual a 1 tendo un conxunto de
	  datos trimestrais, obtés unha lista que só ten as variables ficticias
	  dos trimestres 2, 3 e 4. Se omites este argumento ou é igual a 0,
	  xéranse variables ficticias para todos os períodos; e se non é cero,
	  deberá ser un enteiro comprendido entre 1 e a periodicidade dos datos.
	</para>
	<para>
	  O argumento <argname>center</argname>, se non é nulo, indica que
	  as variables ficticias van centrarse; é dicir, os seus valores van
	  calcularse restándolle as medias na poboación. Por exemplo, con
	  datos trimestrais, as variables ficticias estacionais centradas van
	  ter valores iguais a &minus;0.25 e 0.75 en vez de 0 e 1.
	</para>
      </description>
    </function>

    <function name="selifc" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="rvec">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz tras seleccionar só aquelas columnas de
	  <argname>A</argname> nas que o elemento correspondente de
	  <argname>b</argname> non é nulo. O <argname>b</argname> debe ser un
	  vector fila co mesmo número de columnas que <argname>A</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="selifr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="selifr" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="cvec">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz tras seleccionar só aquelas filas de
	  <argname>A</argname> nas que o elemento correspondente de
	  <argname>b</argname> non é nulo. O <argname>b</argname> debe ser un
	  vector columna co mesmo número de filas que <argname>A</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="selifc"/>
            <fncref targ="trimr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="seq" section="matbuild" output="rvec">
      <fnargs>
	<fnarg type="scalar">a</fnarg>
	<fnarg type="scalar">b</fnarg>
	<fnarg optional="true" type="scalar">k</fnarg>
      </fnargs>
      <description>
	<para>
	  Con só dous argumentos, devolve un vector fila coa secuencia crecente
	  (de 1 en 1) desde <argname>a</argname> ata <argname>b</argname>, se o
	  primeiro argumento é menor ca o segundo; ou coa secuencia decrecente
	  (de 1 en 1) se o primeiro argumento é maior ca o segundo.
	</para>
	<para>
	  Se indicas o terceiro argumento <argname>k</argname> (opcional),
	  a función vai devolver un vector fila coa secuencia iniciada en
	  <argname>a</argname> e ampliada (ou diminuída no caso inverso de
	  que <argname>a</argname> sexa maior ca <argname>b</argname>), en
	  <argname>k</argname> unidades a cada paso. A secuencia remata no
	  maior valor posible que sexa menor ou igual a <argname>b</argname>
	  (ou no menor valor posible que sexa maior ou igual a <argname>b</argname>,
	  no caso inverso). O argumento <argname>k </argname> debe de ser
	  positivo.
	</para>
	<para>
	  <seelist>
            <fncref targ="ones"/>
            <fncref targ="zeros"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="setnote" section="data-utils" output="int">
      <fnargs>
	<fnarg type="bundle">b</fnarg>
	<fnarg type="string">key</fnarg>
	<fnarg type="string">note</fnarg>
      </fnargs>
      <description>
	<para>
	  Insire unha nota descritiva para un obxecto que se identifica por
	  <argname>key</argname>, dentro dun feixe <argname>b</argname>.
	  Vaise amosar esa nota cando se utilice a instrución <lit>print</lit>
	  co feixe. Esta función devolve un enteiro igual a 0 no caso de
	  executarse con éxito, e un valor non nulo no caso de fallo (por
	  exemplo, se non existe ningún obxecto <argname>key</argname> no
	  feixe <argname>b</argname>).
	</para>
      </description>
    </function>

    <function name="simann" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="int" optional="true">maxit</fnarg>
      </fnargs>
      <description>
	<para>
	  Pon en práctica o recocemento simulado, que pode ser útil para
	  mellorar a determinación do punto de partida dun problema de
	  optimización numérica.
	</para>
	<para>
	  Indicando o primeiro argumento, establécese o valor inicial dun
	  vector de parámetros; e indicando o segundo argumento, se especifica
	  unha chamada a unha función que devolve o valor escalar da
	  función obxectivo a maximizar. O terceiro argumento (opcional)
	  especifica o número máximo de iteracións (que por defecto é de 1024).
	  Cando se completa con éxito, a función <lit>simann</lit> devolve un
	  escalar co valor final da función obxectivo a maximizar, e
	  <argname>b</argname> contén o vector de parámetros asociado.
	</para>
	<para>
	  Para ter máis detalles e un exemplo, consulta
	  <guideref targ="chap:numerical"/>.
	  <seelist>
            <fncref targ="BFGSmax"/>
            <fncref targ="NRmax"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sin" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co seno de <argname>x</argname>.
	  <seelist>
            <fncref targ="cos"/>
            <fncref targ="tan"/>
            <fncref targ="atan"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sinh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) co seno hiperbólico de <argname>x</argname>.
	</para>
	<para context="tex">
	  \[ \sinh x = \frac{e^x - e^{-x}}{2}  \]
	</para>
	<para>
	  <seelist>
            <fncref targ="asinh"/>
            <fncref targ="cosh"/>
            <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="skewness" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co valor do coeficiente de asimetría da serie
	  <argname>x</argname>, descartando calquera observación ausente.
	</para>
      </description>
    </function>

    <function name="sleep" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="int">ns</fnarg>
      </fnargs>
      <description>
	<para>
	  Esta función non ten ningún uso directo en Econometría, mais pode
	  ser de utilidade para comprobar métodos de computación en paralelo.
	  Simplemente provoca que se <quote>durma</quote> a liña de cómputo
	  actual (é dicir, que se pare) durante <argname>ns</argname> segundos.
	  Ao <quote>espertar</quote>, a función devolve o escalar 0.
	</para>
      </description>
    </function>

    <function name="smplspan" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="string">startobs</fnarg>
	<fnarg type="string">endobs</fnarg>
	<fnarg type="int">pd</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve o número de observacións que hai contando desde
	  <argname>startobs</argname> ata <argname>endobs</argname>
	  (ambas incluídas), para datos de series temporais que teñen
	  unha frecuencia <argname>pd</argname>.
	</para>
	<para>
	  Deberías de indicar os dous primeiros argumentos no formato
	  que prefire Gretl para datos de tipo anual, trimestral ou
	  mensual (por exemplo, <lit>1970</lit>, <lit>1970:1</lit>
	  ou <lit>1970:01</lit> para cada unha desas frecuencias,
	  respectivamente) ou como datas no formato ISO 8601,
	  <lit>YYYY-MM-DD</lit>.
	</para>
	<para>
	  O argumento <argname>pd</argname> debe de ser ben 1, 4
	  ou 12 (datos anuais, trimestrais ou mensuais), ben unha
	  das frecuencias diarias (5, 6, 7), ou ben 52 (semanal).
	  Se <argname>pd</argname> é igual a 1, 4 ou 12, entón as
	  datas ISO 8601 acéptanse para os dous primeiros argumentos
	  se indican o comezo do período en cuestión. Por exemplo,
	  <lit>2015-04-01</lit> admítese en troques de <lit>2015:2</lit>
	  para representar o segundo trimestre de 2015.
	</para>
	<para>
	  Se xa tes un conxunto de datos con frecuencia <argname>pd</argname>
	  preparado, e cun rango suficiente de observacións, entón podes
	  imitar doadamente o comportamento desta función utilizando
	  a función <fncref targ="obsnum"/>. A vantaxe de <lit>smplspan</lit>
	  consiste en que podes calcular o número de observacións sen
	  necesidade de ter preparado un conxunto apropiado de datos
	  (nin ningún conxunto de datos). Deseguido, un exemplo:
	</para>
	<code>
	  scalar T = smplspan("2010-01-01", "2015-12-31", 5)
	  nulldata T
	  setobs 7 2010-01-01
	</code>
	<para>
	  Isto xera
	</para>
	<code>
	  ? scalar T = smplspan("2010-01-01", "2015-12-31", 5)
	  Xerouse o escalar T = 1565
	  ? nulldata T
	  Periodicidade: 1, máx. obs: 1565
	  Rango de observacións: 1 ata 1565
	  ? setobs 5 2010-01-01
	  Rango completo de datos: 2010-01-01 - 2015-12-31 (n = 1565)
	</code>
	<para>
	  Despois do anterior, podes ter confianza en que a derradeira
	  observación do conxunto de datos que se vai xerar por medio
	  de <cmdref targ="nulldata"/> vai ser <lit>2015-12-31</lit>.
	  Cae na conta de que o número 1565 sería máis ben complicado
	  calculalo doutro xeito.
	</para>
      </description>
    </function>

    <function name="sort" section="matshape" output="asinput">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado do mesmo tipo ca <argname>x</argname> cos seus
	  valores ordenados de forma ascendente, descartando as observacións
	  con valores ausentes cando <math>x</math> é unha serie.
	  <seelist>
            <fncref targ="dsort"/>
            <fncref targ="values"/>
	  </seelist>
	  Para matrices, en especial, consulta <fncref targ="msortby"/>.
	</para>
      </description>
    </function>

    <function name="sortby" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y1</fnarg>
	<fnarg type="series">y2</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha serie que contén os elementos de <argname>y2</argname>
	  ordenados de acordo cos valores crecentes do primeiro argumento
	  <argname>y1</argname>.
	  <seelist>
            <fncref targ="sort"/>
            <fncref targ="ranking"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sprintf" section="strings" output="string">
      <fnargs>
	<fnarg type="string">format</fnarg>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Devolve unha cadea de texto (<quote>string</quote>) que se constrúe
	  representando os valores dos argumentos (indicados polos puntos de
	  arriba) que acompañan á instrución, baixo o control do argumento
	  <argname>format</argname>. Ten a intención de darte gran flexibilidade
	  para crear cadeas de texto. Utiliza o <argname>format</argname> para
	  indicar o xeito preciso no que queres que se presenten os argumentos.
	</para>
	<para>
	  En xeral, o argumento <argname>format</argname> debe de ser unha
	  expresión que se corresponde con unha cadea de texto, pero nos máis
	  dos casos só vai ser unha cadea de texto literal (unha secuencia
	  alfanumérica contornada entre comiñas). Algunhas secuencias de
	  caracteres de formato teñen un significado especial: aquelas que
	  comezan co símbolo (%) interprétanse como <quote>comodíns</quote>
	  para os elementos que contén a lista de argumentos. Amais, caracteres
	  especiais (por exemplo, o de nova liña) represéntanse por medio dunha
	  combinación de símbolos que comeza cunha barra diagonal inversa.
	</para>
	<para>
	  Por exemplo, o código de abaixo...
	</para>
	<code>
	  scalar x = sqrt(5)
	  string claim = sprintf("sqrt(%d) é (aproximadamente) %6.4f.\n", 5, x)
	  print claim
	</code>
	<para>
	  vai producir...
	</para>
	<code>
	  sqrt(5) é (aproximadamente) 2.2361.
	</code>
	<para>
	  A expresión <lit>%d</lit> na cadea de formato, indica que se quere un
	  número enteiro nese preciso lugar da saída que se vai presentar, e dado
	  que esa é a expresión co símbolo <quote>por cento</quote> que está
	  máis á esquerda, emparéllase co primeiro argumento, é dicir 5.
	  A segunda secuencia especial é <lit>%6.4f</lit>, e representa un
	  valor con 6 díxitos de largo como mínimo, e con 4 díxitos despois do
	  separador decimal. O número desas secuencias debe de coincidir coa
	  cantidade de argumentos que acompañan á cadea de texto para o formato.
	</para>
	<para>
	  Consulta a páxina de axuda da instrución <cmdref targ="printf"/>
	  para obter máis detalles en relación coa sintaxe que podes utilizar
	  nas cadeas de texto para o formato.
	</para>
      </description>
    </function>

    <function name="sqrt" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado, do mesmo tipo ca <argname>x</argname>, coa raíz
	  cadrada positiva deste. Xera <lit>NA</lit> para valores negativos deste.
	</para>
	<para>
	  Advirte que, se o argumento é unha matriz, realízase a operación para
	  cada elemento e, posto que esta non pode conter valores <lit>NA</lit>,
	  a función xera un fallo se a matriz ten algún valor negativo. Para a
	  <quote>raíz cadrada matricial</quote> mira <fncref targ="cholesky"/>.
	</para>
      </description>
    </function>

    <function name="square" section="transforms" output="list">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg optional="true" type="bool">cross-products</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha lista que contén os cadrados das variables da lista
	  <argname>L</argname>, cos seus elementos nomeados de acordo co
	  seguinte padrón :<lit>sq_</lit><repl>varname</repl>. Cando indicas
	  o segundo argumento (opcional) e ten un valor non nulo, a lista
	  tamén vai incluír os produtos cruzados dos elementos da lista
	  <argname>L</argname>, que se nomearán de acordo co formato do
	  padrón <repl>var1</repl><lit>_</lit><repl>var2</repl>. De ser
	  necesario, o nome das series dos argumentos vai tronzarse e mesmo
	  axustarse o nome do resultado final, para evitar a duplicación de
	  nomes na lista que se devolve.
	</para>
      </description>
    </function>

    <function name="sscanf" section="strings" output="int">
      <fnargs>
	<fnarg type="string">src</fnarg>
	<fnarg type="string">format</fnarg>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Le valores indicados polo argumento <argname>src</argname> baixo
	  o control do argumento <argname>format</argname> e asigna estes
	  valores a un ou máis dos argumentos seguintes, indicados polos
	  puntos de arriba. Devolve un enteiro co número de valores que se
	  asignan. Esta función é unha versión simplificada da función
	  <lit>sscanf</lit> da linguaxe C de programación.
	</para>
	<para>
	  Como argumento <repl>src</repl> podes usar unha cadea de texto literal
	  contornada entre comiñas, ou ben o nome dunha cadea de texto que
	  definiras previamente. O argumento <repl>format</repl> indícase de
	  xeito similar á cadea do argumento <quote>format</quote> en
	  <cmdref targ="printf"/> (mira máis abaixo); nesta última función,
	  <repl>args</repl> debe ser unha lista de variables definidas antes,
	  separadas por comas que son os obxectivos da conversión de
	  <repl>src</repl>. (Para os afeitos a C: podedes fixar previamente os
	  nomes das variables numéricas con <lit>&amp;</lit> pero non se esixe.)
	</para>
	<para>
	  O texto literal no argumento <repl>format</repl> compárase con
	  <repl>src</repl>. Os elementos que especifican a conversión comezan
	  co carácter <lit>%</lit>, e as conversións que están admitidas
	  inclúen: <lit>%f</lit>, <lit>%g</lit> ou <lit>%lf</lit> para números
	  de punto flotante; <lit>%d</lit> para números enteiros; <lit>%s</lit>
	  para cadeas de texto; e <lit>%m</lit> para matrices. Podes inserir
	  un enteiro positivo despois do símbolo de porcentaxe que establece
	  o número máximo de caracteres que se van ler para a conversión
	  indicada (ou o número máximo de filas no caso da conversión dunha
	  matriz). Como forma alternativa, podes inserir un carácter literal de
	  asterisco, <lit>*</lit>, logo do símbolo de porcentaxe para eliminar
	  a conversión (saltándose así calquera carácter que de outro xeito
	  poderían terse convertido para o tipo indicado). Por exemplo,
	  a expresión <lit>%3d</lit> converte os seguintes 3 caracteres de
	  <repl>source</repl> nun enteiro, en caso de que sexa posible;
	  e a expresión <lit>%*g</lit> permite saltarse tantos caracteres de
	  <repl>source</repl> como os que poderían converterse nun número
	  de punto flotante simple.
	</para>
	<para>
	  A conversión para matrices funciona así: o escáner le unha liña do
	  argumento e conta a cantidade de campos numéricos (separados por
	  espazos ou por tabulacións). Deste xeito defínese o número de
	  columnas da matriz. Por defecto, o proceso de lectura continúa entón
	  con tantas liñas (filas) como conteñan o mesmo número de columnas,
	  pero o número máximo de filas que se van ler pode limitarse tal como
	  se describe arriba.
	</para>
	<para>
	  Ademais da conversión <lit>%s</lit> para cadeas de texto, tamén
	  está dispoñible unha versión simplificada do formato C
	  <lit>%</lit><repl>N</repl><lit>[</lit><repl>chars</repl><lit>]</lit>.
	  Neste formato <repl>N</repl> representa o número máximo de
	  caracteres que se van ler e <repl>chars</repl> expresa un conxunto de
	  caracteres que sexan admisibles, contornados entre corchetes:
	  o proceso de lectura remata cando se acada <repl>N</repl> ou cando
	  se atopa un carácter que non está en <repl>chars</repl>. Podes
	  trocar o funcionamento de <repl>chars</repl>indicando o circunflexo
	  <lit>^</lit> como primeiro carácter; nese caso, o proceso de lectura
	  remata cando se atopa un carácter que está indicado no conxunto.
	  (A diferenza do que acontece en C, o guión non xoga ningún papel
	  especial no conxunto <repl>chars</repl>.)
	</para>
	<para>
	  Se a cadea de texto da orixe non coincide (exactamente) co formato,
	  o número de conversións pode quedarse curta a respecto do número
	  de argumentos indicados. Isto non é por si mesmo un fallo no que
	  atinxe a Gretl. Así e todo, poderías querer comprobar o número de
	  conversións que se completaron; isto indícase no valor que se
	  devolve.
	</para>
	<para>
	  A continuación tes varios exemplos:
	</para>
	<code>
	  scalar x
	  scalar y
	  sscanf("123456", "%3d%3d", x, y)

	  S = sprintf("1 2 3 4\n5 6 7 8")
	  S
	  matrix m
	  sscanf(S, "%m", m)
	  print m
	</code>
      </description>
    </function>

    <function name="sst" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar coa suma dos cadrados das desviacións respecto á
	  media, das observacións non ausentes da serie <argname>y</argname>.
	  <seelist>
            <fncref targ="var"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="stringify" section="strings" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="strings">S</fnarg>
      </fnargs>
      <description>
	<para>
	  Proporciona un xeito de definir valores de cadea de texto para a
	  serie <argname>y</argname>. Para que isto funcione, deben de
	  cumprirse dúas condicións: a serie obxectivo non debe de ter outra
	  cousa que non sexan valores enteiros positivos (ningún deles menor
	  ca 1), e o arranxo <argname>S</argname> debe de ter polo menos
	   <math>n</math> elementos, sendo <math>n</math> o maior valor de
	   <argname>y</argname>. Amais, cada elemento de <argname>S</argname>
	   debe de ter un formato UTF-8 válido.
	  <seelist>
            <fncref targ="strvals"/>
	  </seelist>
	</para>
	<para>
	  O valor que devolve esta función é cero no caso de completarse con
	  éxito, ou un código de fallo positivo no caso de fallar.
	</para>
      </description>
    </function>

    <function name="strlen" section="strings" output="int">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un número enteiro coa cantidade de caracteres que ten a
	  cadea de texto <argname>s</argname>. Ten en conta que iso non é
	  necesariamente igual ao número de bytes, se algúns caracteres están
	  fóra do intervalo de impresión ASCII.
	</para>
    <para>
        Exemplo:
    </para>
    <code>
        string s = "Regresión"
        scalar number = strlen(s)
        print number
    </code>
      </description>
    </function>

    <function name="strncmp" section="strings" output="int">
      <fnargs>
	<fnarg type="string">s1</fnarg>
	<fnarg type="string">s2</fnarg>
	<fnarg optional="true" type="int">n</fnarg>
      </fnargs>
      <description>
	<para>
	  Compara as dúas cadeas de texto dos argumentos e devolve un enteiro
	  que é menor, igual ou maior ca 0 cando <argname>s1</argname> é
	  (respectivamente) menor, igual ou maior que <argname>s2</argname>,
	  ata os <argname>n</argname> primeiros caracteres. Cando se omite
	  <argname>n</argname>, a comparación continúa ata onde resulte
	  posible.
	</para>
	<para>
	  Cae na conta de que, se só queres comprobar se dúas cadeas de texto
	  son iguais, podes facelo sen necesidade de utilizar esta función, como
	  coa indicación <lit>if (s1 == s2)...</lit>.
	</para>
      </description>
    </function>

    <function name="strsplit" section="strings" output="string-or-strings">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg optional="true" type="int">i</fnarg>
	<fnarg optional="true" type="string">sep</fnarg>
      </fnargs>
      <description>
	<para>
	  No seu funcionamento básico, cun único argumento, devolve o arranxo de
	  cadeas de texto que resulta ao separar o contido de <argname>s</argname>
	  conforme aos espazos baleiros que ten (é dicir, conforme a calquera
	  combinación dos caracteres de espazo, tabulación e/ou liña nova).
	</para>
	<para>
	  Cando indicas un valor enteiro maior ca cero como segundo argumento,
	  o valor que se devolve é unha única cadea de texto, en concreto o
	  elemento <argname>i</argname> (en base 1) do arranxo que se xeraría
	  doutro xeito sen ese segundo argumento. Cando <argname>i</argname>
	  sexa menor ca 1, se produce un fallo; mais cando <argname>i</argname>
	  excede o número de elementos implicados, devólvese unha cadea de
	  texto baleira.
	</para>
	<para>
	  Podes utilizar o terceiro argumento (opcional) para axustar
	  o separador que se usa para separar <argname>s</argname>.
	  Por exemplo...
	</para>
	<code>
	  string Cesta = "Plátano,Mazá,Yaca,Laranxa"
	  strings S = strsplit(Cesta,,",")
	</code>
	<para>
	  vai separar o primeiro argumento da función nun arranxo de catro
	  cadeas de texto, usando a coma como elemento separador. A coma
	  <quote>extra</quote> indicada arriba, expresa que se quere omitir
	  o segundo argumento <argname>i</argname> da función.
	</para>
	<para>
	  As dúas secuencias de barra diagonal esquerda para escapar, indicadas
	  mediante <quote><lit>\n</lit></quote> e <quote><lit>\t</lit></quote>,
	  considérase que representan unha liña nova e unha tabulación cando se
	  indican no argumento opcional <argname>sep</argname>. Se queres incluír
	  unha barra diagonal esquerda literal como carácter separador, debes de
	  duplicala como en <quote><lit>\\</lit></quote>. Exemplo:
	</para>
	<code>
	  string s = "c:\fiddle\sticks"
	  strings S = strsplit(s, "\\")
	</code>
      </description>
    </function>

    <function name="strstr" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s1</fnarg>
	<fnarg type="string">s2</fnarg>
      </fnargs>
      <description>
	<para>
	  Procura en <argname>s1</argname> a cadea <argname>s2</argname>.
	  No caso de atopar a cadea de texto, devolve outra cadea cunha copia da
	  parte de <argname>s1</argname> que comeza con <argname>s2</argname>;
	  noutro caso, devolve unha cadea de texto baleira.
	</para>
  <para>
          Exemplo:
  </para>
  <code>
          string s1 = "Gretl é un programa de Econometría"
          string s2 = strstr(s1, "un")
          print s2
  </code>
	<para>
	  Se unicamente queres descubrir se <argname>s1</argname>
	  contén a <argname>s2</argname> (proba booleana), consulta
	  <fncref targ="instring"/>.
	</para>
      </description>
    </function>

    <function name="strstrip" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha cadea de texto cunha copia de <argname>s</argname>
	  na que se eliminaron os espazos en branco do inicio e do final.
	</para>
  <para>
          Exemplo:
  </para>
  <code>
          string s1 = "    Moito espazo en branco.  "
          string s2 = strstrip(s1)
          print s1 s2
  </code>
      </description>
    </function>

    <function name="strsub" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg type="string">find</fnarg>
	<fnarg type="string">subst</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha cadea de texto cunha copia de <argname>s</argname> na que
	  se substituíu toda a cadea <argname>find</argname> por
	  <argname>subst</argname>. Consulta tamén <fncref targ="regsub"/> para
	  outras substitucións máis complexas mediante expresións regulares.
	</para>
  <para>
          Exemplo:
  </para>
  <code>
          string s1 =  "Hola, Gretl!"
          string s2 = strsub(s1, "Gretl", "Hansl")
          print s2
  </code>
      </description>
    </function>

    <function name="strvals" section="strings" output="strings">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Cando a serie <argname>y</argname> se compón de cadeas de texto que
	  expresan valores, esta función devolve un arranxo que contén todos
	  eses valores, ordenados numericamente comezando polo 1. Cando
	  <argname>y</argname> non se compón de cadeas de texto que expresan
	  valores, devólvese un arranxo de cadeas de texto baleiras.
	  <seelist>
            <fncref targ="stringify"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="substr" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg type="int">start</fnarg>
	<fnarg type="int">end</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha subcadea do argumento <argname>s</argname>, comezando no
	  carácter indicado polo enteiro positivo de <argname>inicio</argname> e
	  rematando no indicado por <argname>fin</argname>, ambos incluídos.
	</para>
  <para>
          Por exemplo, o código de abaixo
  </para>
  <code>
          string s1 = "Hola, Gretl!"
          string s2 = substr(s1, 7, 11)
          string s3 = substr("Hola, Gretl!", 7, 11)
          print s2
          print s3
  </code>
  <para>
          proporciona:
  </para>
  <code>
    ? print s2
    Gretl
    ? print s3
    Gretl
  </code>
  <para>
          Debes de darte de conta de que, nalgúns casos, poderías estar
          desexando intercambiar claridade por concisión, e utilizar operadores
          de redución e incremento, como en
  </para>
  <code>
          string s1 = "Hola, Gretl!"
          string s2 = s1[7:11]
          string s3 = s1 + 6
          print s2
          print s3
  </code>
  <para>
    o que te proporcionaría
  </para>
  <code>
    ? print s2
    Gretl
    ? print s3
    Gretl!
  </code>
      </description>
    </function>

    <function name="sum" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="smlist">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Cando <argname>x</argname> é unha serie, devolve un escalar co
	  resultado de sumar as observacións non ausentes do argumento
	  <argname>x</argname>. Consulta tamén <fncref targ="sumall"/>.
	</para>
	<para>
	  Cando <argname>x</argname> é unha matriz, devolve un escalar co
	  resultado de sumar os elementos da matriz.
	</para>
	<para>
	  Cando <argname>x</argname> é unha lista de variables, a función devolve
	  unha serie <math>y</math> na que cada valor <math>y</math><sub>t</sub>
	  indica a suma dos valores das variables da lista na observación
	  <math>t</math>, ou <lit>NA</lit> se algún deses valores está ausente
	  en <math>t</math>.
	</para>
      </description>
    </function>

    <function name="sumall" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co resultado de sumar as observacións da serie
	  <argname>x</argname> na mostra seleccionada, ou <lit>NA</lit> se
	  existe algún valor ausente. Utiliza <fncref targ="sum"/> se queres
	  obter a suma descartando os valores ausentes.
	</para>
      </description>
    </function>

    <function name="sumc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector fila coa suma das columnas de <argname>X</argname>.
	  <seelist>
            <fncref targ="meanc"/>
            <fncref targ="sumr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sumr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector columna coa suma das filas de <argname>X</argname>.
	  <seelist>
            <fncref targ="meanr"/>
            <fncref targ="sumc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="svd" section="linalg" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;V</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devolve un vector fila co resultado de descompoñer a matriz
	  <argname>X</argname> en valores singulares.
	</para>
	<para context="tex">
	  Devolve un vector fila co resultado de descompoñer a matriz $X$
	  de orde $r \times c$, en valores singulares:
	  \[ X = U \left[
	  \begin{array}{cccc}
	  \sigma_1 \\
	  &amp; \sigma_2 \\
	  &amp; &amp; \ddots \\
	  &amp; &amp; &amp; \sigma_n ,
	  \end{array}
	  \right] V \]
	  onde $n = \min(r,c)$. $U$ é $r \times n$ e $V$ é $n \times c$,
	  con $U'U = I$ e $VV' = I$.
	</para>
	<para>
	  Os valores singulares devólvense nun vector fila. Podes obter o
	  vector singular esquerdo <math>U</math> e/ou dereito <math>V</math>
	  indicando valores non nulos nos argumentos 2 e 3, respectivamente.
	  Para calquera matriz <lit>A</lit>, o código...
	</para>
	<code>
	  s = svd(A, &amp;U, &amp;V)
	  B = (U .* s) * V
	</code>
	<para>
	  ... debera proporcionar unha matriz <lit>B</lit> idéntica a
	  <lit>A</lit> (agás pequenas diferenzas debida á precisión de cálculo).
	</para>
	<para>
	  <seelist>
            <fncref targ="eigengen"/>
            <fncref targ="eigensym"/>
            <fncref targ="qrdecomp"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="tan" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) coa tanxente de <argname>x</argname>.
	  <seelist>
            <fncref targ="atan"/>
            <fncref targ="cos"/>
            <fncref targ="sin"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="tanh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) coa tanxente hiperbólica de <argname>x</argname>.
	</para>
	<para context="tex">
	  \[ \tanh x = \frac{e^{2x} - 1}{e^{2x} + 1}  \]
	</para>
	<para>
	  <seelist>
            <fncref targ="atanh"/>
            <fncref targ="cosh"/>
            <fncref targ="sinh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="toepsolv" section="linalg" output="cvec">
      <fnargs>
	<fnarg type="vector">c</fnarg>
	<fnarg type="vector">r</fnarg>
	<fnarg type="vector">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector columna coa solución dun sistema Toeplitz
	  de ecuacións lineais, é dicir <math>Tx = b</math>
	  onde <math>T </math> é unha matriz cadrada cuxo elemento
	  <math>T</math><sub>i,j</sub> é
	  igual a <math>c</math><sub>i-j</sub>
	  cando <equation status="inline" ascii="i&gt;=j" tex="$i\ge j$"/>, e
	  igual a <math>r</math><sub>j-i</sub>
	  cando <equation status="inline" ascii="i&lt;=j" tex="$i\le j$"/>.
	  Ten en conta que os primeiros elementos dos dous vectores
	  <math>c</math> e <math>r</math> deben de ser iguais, pois
	  noutro caso se devolve un fallo. Cando se completa con éxito,
	  a execución desta función permite obter o vector
	  <math>x</math>.
	</para>
	<para>
	  O algoritmo que se utiliza aquí aproveita a especial estrutura da
	  matriz <math>T</math>, que o fai moito máis eficiente ca outros
	  algoritmos non especializados, particularmente para problemas moi
	  longos. Advertencia: Nalgúns casos a función podería suxerir
	  falsamente un fallo na singularidade da matriz <math>T</math> cando
	  realmente non é singular; de calquera xeito, este problema non
	  poderá xurdir cando a matriz <math>T</math> sexa definida
	  positiva.
	</para>
      </description>
    </function>

    <function name="tolower" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha cadea de texto que é unha copia de <argname>s</argname>,
	  na que todas as letras en maiúsculas convertéronse en minúsculas.
	</para>
    <para>
        Exemplos:
    </para>
    <code>
        string s1 = "Hola, Gretl!"
        string s2 = tolower(s1)
        print s2

        string s3 = tolower("Hola, Gretl!")
        print s3
    </code>
      </description>
    </function>

    <function name="toupper" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha cadea de texto que é unha copia de <argname>s</argname>,
	  na que todas as letras en minúsculas convertéronse en maiúsculas.
	</para>
    <para>
        Exemplos:
    </para>
    <code>
        string s1 = "Hola, Gretl!"
        string s2 = toupper(s1)
        print s2

        string s3 = toupper("Hola, Gretl!")
        print s3
    </code>
      </description>
    </function>

    <function name="tr" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar coa traza dunha matriz cadrada <argname>A</argname>,
	  é dicir, a suma dos elementos da súa diagonal.
	  <seelist>
            <fncref targ="diag"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="transp" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz que é a trasposta de <argname>X</argname>. Aviso:
	  Esta función utilízase raramente. Para traspor unha matriz, en xeral
	  podes usar simplemente o operador para trasposición: <lit>X'</lit>.
	</para>
      </description>
    </function>

    <function name="trimr" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">ttop</fnarg>
	<fnarg type="int">tbot</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz que é unha copia da matriz <argname>X</argname>
	  na que se eliminaron as <argname>ttop</argname> filas superiores
	  e as <argname>tbot</argname> filas inferiores. Os dous últimos
	  argumentos non deben de ser negativos e a súa suma debe de ser menor
	  ca o total de filas de <argname>X</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="selifr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="typeof" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">name</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un código de tipo numérico cando <argname>name</argname>
	  é unha cadea de texto que identifica un obxecto actualmente definido:
	  1 para un escalar, 2 para unha serie, 3 para unha matriz, 4 para unha
	  cadea de texto, 5 para un feixe, 6 para un arranxo e 7 para unha
	  lista; noutro caso devolve 0. Para obter a cadea de texto que concorda
	  co valor que se devolve, podes usar a función <fncref targ="typestr"/>.
	</para>
	<para>
	  Tamén podes utilizar esta función para obter que tipo de elemento é
	  un compoñente dun feixe ou dun arranxo. Por exemplo...
	</para>
	<code>
	  matrices M = array(1)
	  eval typestr(typeof(M))
	  eval typestr(typeof(M[1]))
	</code>
	<para>
	  ... no que o primeiro resultado da función <lit>eval</lit> é un
	  <quote>arranxo</quote> e o segundo é unha <quote>matriz</quote>.
	</para>
      </description>
    </function>

    <function name="typestr" section="data-utils" output="string">
      <fnargs>
	<fnarg type="int">typecode</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha cadea de texto co nome do tipo de dato de Gretl que
	  se corresponde co argumento <argname>typecode</argname>. Podes
	  utilizalo xuntamente coas funcións <fncref targ="typeof"/> e
	  <fncref targ="inbundle"/>. O cadea de texto que se devolve pode ser
	  unha das seguintes: <quote>scalar</quote>, <quote>series</quote>,
	  <quote>matrix</quote>, <quote>string</quote>,
	  <quote>bundle</quote>, <quote>array</quote>,
	  <quote>list</quote>, ou <quote>null</quote>.
	</para>
      </description>
    </function>

    <function name="uniform" section="probdist" output="series">
      <fnargs>
	<fnarg type="scalar">a</fnarg>
	<fnarg type="scalar">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha serie que se xera cunha variable pseudoaleatoria
	  uniforme que toma valores dentro do intervalo (<argname> a</argname>,
	  <argname>b</argname>) ou, se non indicas eses argumentos, no
	  intervalo (0,1). O algoritmo que se utiliza por defecto é o
	  <quote>SIMD-oriented Fast Mersenne Twister</quote> desenvolvido por 
	  <cite key="saito_matsumoto08">Saito e Matsumoto (2008)</cite>.
	</para>
	<para>
	  <seelist>
            <fncref targ="randgen"/>
            <fncref targ="normal"/>
            <fncref targ="mnormal"/>
            <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="uniq" section="stats" output="cvec">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector que contén os distintos elementos do argumento
	  <argname>x</argname> sen ningunha orde especial, senón na que
	  están en <argname>x</argname>. Consulta <fncref targ="values"/>
	  para a variante desta función que devolve os valores ordenados.
	</para>
      </description>
    </function>

    <function name="unvech" section="matbuild" output="smatrix">
      <fnargs>
	<fnarg type="vector">v</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve a matriz simétrica de orde <by r="n" c="n"/> que se obtén
	  reordenando os elementos do vector <math>v</math> en forma de matriz
	  triangular inferior, e copiando os das posicións simétricas. O número
	  de elementos de <math>v</math> debe de ser un enteiro triangular,
	  ou sexa, un número <math>k</math> tal que exista un enteiro
	  <math>n</math> que teña a seguinte propiedade:
	  <equation status="inline" ascii="k = n(n+1)/2" tex="$k = n(n+1)/2$"/>.
	  Esta función é a inversa de <fncref targ="vech"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="mshape"/>
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="upper" section="matbuild" output="smatrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Devolve unha matriz triangular superior de orde <by r="n" c="n"/>. Os
	  elementos da diagonal e de arriba desta, son iguais aos elementos que
	  se corresponden en <argname>A</argname>; os demais son iguais a cero.
	</para>
	<para context="tex">
	  Devolve unha matriz triangular superior <math>B</math> de orde
	  $n\times n$ onde $B_{ij} = A_{ij}$ se $i \le j$, e 0 noutro caso.
	</para>
	<para>
	  <seelist>
            <fncref targ="lower"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="urcpval" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="scalar">tau</fnarg>
	<fnarg type="int">n</fnarg>
	<fnarg type="int">niv</fnarg>
	<fnarg type="int">itv</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar coa probabilidade asociada (<math>P</math>) ao
	  valor do estatístico para facer a proba de raíces unitarias de
	  Dickey-Fuller ou a proba de cointegración de Engle&ndash;Granger,
	  conforme <cite key="mackinnon96">James MacKinnon (1996)</cite>.
	</para>
	<para>
	  Os argumentos exprésanse deste xeito: <argname>tau</argname> indica
	  o valor do estatístico de proba que corresponda; <argname>n</argname>
	  sinala o número de observacións (ou 0 se o que queres é un resultado
	  asintótico);<argname>niv</argname> denota o número de variables
	  potencialmente cointegradas, se comprobas a cointegración (ou 1 se fas
	  unha proba univariante de raíces unitarias); e <argname>itv</argname>
	  é un código que especifica o tipo modelo (1 = sen constante, 2 = con
	  constante, 3 = con constante máis tendencia linear, 4 = con constante máis
	  tendencia linear e cadrada).
	</para>
	<para>
	  Ten en conta que debes de darlle un valor de 0 a <argname>n</argname>
	  para obter un resultado asintótico, se a regresión auxiliar para a
	  proba é <quote>ampliada</quote> con retardos na variable dependente.
	</para>
	<para>
	  <seelist>
            <fncref targ="pvalue"/>
	    <fncref targ="qlrpval"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="values" section="stats" output="cvec">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector que contén os distintos elementos do argumento
	  <argname>x</argname> ordenados de forma ascendente. Se queres
	  descartar a parte decimal antes de aplicar esta función, utiliza a
	  expresión <lit>values(int(x))</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="uniq"/>
            <fncref targ="dsort"/>
            <fncref targ="sort"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="var" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Cando <argname>x</argname> é unha serie, devolve un escalar coa
	  súa varianza na mostra, descartando calquera observación ausente.
	</para>
	<para>
	  Cando <argname>x</argname> é unha lista, devolve unha serie
	  <math>y</math> na que cada valor <math>y</math><sub>t</sub> indica
	  a varianza na mostra dos valores das variables da lista na observación
	  <math>t</math>, ou <lit>NA</lit> se algún deses valores está ausente
	  en <math>t</math>.
	</para>
	<para>
	  En cada un deses casos, a suma dos cadrados das desviacións con
	  respecto á media divídese por (<math>n</math> &minus; 1) cando
	  <math>n</math> &gt; 1. Noutro caso, indícase que a varianza é igual
	  a cero se <math>n</math> = 1, ou é igual a <lit>NA</lit> se
	  <math>n</math> = 0.
	</para>
	<para>
	  <seelist>
            <fncref targ="sd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="varname" section="strings" output="string">
      <fnargs>
	<fnarg type="int-or-list">v</fnarg>
      </fnargs>
      <description>
	<para>
	  Cando se indica un número enteiro como argumento, a función devolve
	  unha cadea de texto co nome da variable que ten un número ID igual a
	  <argname>v</argname>, ou xera un fallo se esa variable non existe.
	</para>
	<para>
	  Cando se indica unha lista como argumento, devolve unha cadea de
	  texto que contén os nomes das variables da lista, separados por
	  comas. Se indicas unha lista que está baleira, devólvese unha cadea
	  de texto baleira. En troques, podes utilizar <fncref targ="varnames"/>
	  para obter un arranxo de cadeas de texto .
	</para>
    <para>
        Exemplo:
    </para>
    <code>
        open broiler.gdt
        string s = varname(7)
        print s
    </code>
      </description>
    </function>

    <function name="varnames" section="strings" output="strings">
      <fnargs>
	<fnarg type="list">L</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un arranxo de cadeas de texto que contén os nomes das
	  variables da lista <argname>L</argname>. Se a lista que indicas
	  está baleira, devólvese un arranxo baleiro.
	</para>
    <para>
        Exemplo:
    </para>
    <code>
        open keane.gdt
        list L = year wage status
        strings S = varnames(L)
        eval S[1]
        eval S[2]
        eval S[3]
    </code>
      </description>
    </function>

    <function name="varnum" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">varname</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un número enteiro co código ID da variable que ten o nome
	  do argumento <argname>varname</argname>, ou NA se esa variable
	  non existe.
	</para>
      </description>
    </function>

    <function name="varsimul" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix">U</fnarg>
	<fnarg type="matrix">y0</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz ao simular un VAR de orde <math>p</math> e
	  <math>n</math> variables, é dicir
	  <equation status="inline"
		    ascii="y(t) = A1 y(t-1) + ... + Ap y(t-p) + u(t)."
		    tex="$y_t = \sum_{i=1}^p A_i y_{t-i} + u_t$."/>
	  A matriz <argname>A</argname> de coeficientes fórmase agrupando
	  horizontalmente as matrices <math>A</math><sub>i</sub>; é de
	  orde <by r="n" c="np"/>, con unha fila por cada ecuación. Esta
	  se corresponde coas primeiras <math>n</math> filas da matriz
	  <lit>$compan</lit> que proporcionan as instrucións <lit>var</lit> e
	  <lit>vecm</lit> de Gretl.
	</para>
	<para>
	  Os vectores <math>u_t</math> están incluídos (como filas) na matriz
	  <argname>U</argname> (<by r="T" c="n"/>). Os valores iniciais están
	  en <argname>y0</argname> (<by r="p" c="n"/>).
	</para>
	<para>
	  Cando o VAR contén algún termo determinista e/ou regresores
	  esóxenos, podes manexalos envolvéndoos na matriz
	  <argname>U</argname>: neste caso cada fila de <argname>U</argname>
	  pasa a ser entón
	  <equation status="inline"
		    ascii="u(t) = B'x(t) + e(t)."
		    tex="$u_t = B' x_t + e_t$."/>
	</para>
	<para>
	  A matriz que resulta ten <math>T</math> + <math>p</math> filas e
	  <math>n</math> columnas; contén os <math>p</math> valores iniciais
	  das variables endóxenas, ademais de <math>T</math> valores
	  simulados.
	</para>
	<para>
	  <seelist>
            <fncref targ="$compan"/>
            <cmdref targ="var"/>
            <cmdref targ="vecm"/>
	  </seelist>
	</para>

      </description>
    </function>

    <function name="vec" section="matbuild" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un vector columna, encastelando as columnas de <argname>X</argname>.
	  <seelist>
            <fncref targ="mshape"/>
            <fncref targ="unvech"/>
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="vech" section="matbuild" output="cvec">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve nun vector columna cos elementos de <argname>A</argname> que
	  están na súa diagonal e enriba dela. Normalmente esa función utilízase
	  con matrices simétricas; neste caso esa operación pode reverterse a
	  través da función <fncref targ="unvech"/>.
	  <seelist>
            <fncref targ="vec"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="weekday" section="calendar" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-series">year</fnarg>
	<fnarg type="scalar-or-series">month</fnarg>
	<fnarg type="scalar-or-series">day</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve o día da semana (domingo = 0, luns = 1, etc.) da data
	  especificada polos tres argumentos, ou <lit>NA</lit> se a data
	  non é correcta. Ten en conta que os tres argumentos deben de ser
	  do mesmo tipo; ou sexa, deben de ser todos de tipo escalar (enteiro)
	  ou todos de tipo serie.
	</para>
      </description>
    </function>

    <function name="wmean" section="stats" output="series">
      <fnargs>
	<fnarg type="list">Y</fnarg>
	<fnarg type="list">W</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha serie <math>y</math> calculada de forma que cada
	  <math>y</math><sub>t</sub> indica a media ponderada dos
	  valores (na observación <math>t</math>) das variables presentes na
	  lista <argname>Y</argname>, coas respectivas ponderacións sinaladas
	  polos valores das variables que forman a lista <argname>W</argname>
	  en cada <math>t</math>. As ponderacións poden así variar no tempo.
	  As listas de variables <argname>Y</argname> e <argname>W</argname>
	  deben de ter o mesmo tamaño, e as ponderacións deben de ser non
	  negativas.
	</para>
	<para>
	  <seelist>
            <fncref targ="wsd"/>
            <fncref targ="wvar"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="wsd" section="stats" output="series">
      <fnargs>
	<fnarg type="list">Y</fnarg>
	<fnarg type="list">W</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha serie <math>y</math> calculada de forma que cada
	  <math>y</math><sub>t</sub> indica a desviación padrón ponderada
	  na mostra, dos valores (na observación <math>t</math>) das variables
	  presentes na lista <argname>Y</argname>, coas respectivas ponderacións
	  sinaladas polos valores das variables da lista <argname>W</argname>
	  en cada <math>t</math>. As ponderacións poden así variar no tempo.
	  As listas de variables <argname>Y</argname> e <argname>W</argname>
	  deben de ter o mesmo tamaño, e as ponderacións deben de ser non
	  negativas.
	</para>
	<para>
	  <seelist>
            <fncref targ="wmean"/>
            <fncref targ="wvar"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="wvar" section="stats" output="series">
      <fnargs>
	<fnarg type="list">X</fnarg>
	<fnarg type="list">W</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha serie <math>y</math> calculada de forma que cada
	  <math>y</math><sub>t</sub> indica a varianza ponderada na mostra,
	  dos valores (na observación <math>t</math>) das variables presentes na
	  lista <argname>Y</argname>, coas respectivas ponderacións sinaladas
	  polos valores das variables que forman a lista <argname>W</argname>
	  en cada <math>t</math>. As ponderacións poden así variar no tempo.
	  As listas de variables <argname>Y</argname> e <argname>W</argname>
	  deben de ter o mesmo tamaño, e as ponderacións deben de ser non
	  negativas.
	</para>
	<para context="tex">
	  A varianza ponderada na mostra calcúlase mediante
	  \[ s^2_w = \frac{n'}{n'-1} \,
	  \frac{\sum_{i=1}^n w_i(x_i - \bar{x}_w)^2}{\sum_{i=1}^n w_i} \]
	  onde $n'$ indica o número de ponderacións non nulas e $\bar{x}_w$
	  indica a media ponderada.
	</para>
	<para>
	  <seelist>
            <fncref targ="wmean"/>
            <fncref targ="wsd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="xmax" section="math" output="scalar">
      <fnargs>
	<fnarg type="scalar">x</fnarg>
	<fnarg type="scalar">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co maior valor que resulta de comparar
	  <argname>x</argname> e <argname>y</argname>. Se algún dos
	  valores está ausente, devólvese <lit>NA</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="xmin"/>
            <fncref targ="max"/>
            <fncref targ="min"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="xmin" section="math" output="scalar">
      <fnargs>
	<fnarg type="scalar">x</fnarg>
	<fnarg type="scalar">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un escalar co menor valor que resulta de comparar
	  <argname>x</argname> e <argname>y</argname>. Se algún dos
	  valores está ausente, devólvese <lit>NA</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="xmax"/>
            <fncref targ="max"/>
            <fncref targ="min"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="xmlget" section="data-utils" output="string">
      <fnargs>
	<fnarg type="string">buf</fnarg>
	<fnarg type="string-or-strings">path</fnarg>
      </fnargs>
      <description>
	<para>
	  O argumento <argname>buf</argname> debe de ser un búfer
	  XML, tal como pode recuperarse dun lugar web adecuado
	  mediante a función <fncref targ="curl"/> (or lerse dun
	  ficheiro mediante a función <fncref targ="readfile"/>),
	  e o argumento <argname>path</argname> debe de ser ben
	  unha especificación XPath sinxela ou un arranxo delas.
	</para>
	<para>
	  Esta función devolve unha cadea de texto que representa os datos
	  atopados no búfer XML na ruta especificada. Se hai múltiples nodos
	  que coincidan coa expresión da ruta, as unidades de datos se
	  presentan unha por cada liña da cadea que se devolve. Cando indicas
	  un arranxo de rutas como segundo argumento, a cadea que se devolve
	  ten a forma dun búfer separado con comas, cuxa columna <math>i</math>
	  contén as coincidencias da ruta <math>i</math>. Neste caso, se unha
	  cadea obtida do búfer XML contén algún espazo ou coma, contórnase
	  entre comiñas.
	</para>
	<para>
	  Por defecto, amósase un erro se <argname>path</argname> non
	  coincide no búfer XML, pero este comportamento modifícase
	  se indicas o terceiro argumento (opcional) pois, neste
	  caso, o argumento recupera un reconto das coincidencias, devolvéndose
	  unha cadea baleira se non hai ningunha. Chamada de exemplo:
	</para>
	<code>
	  ngot = 0
	  ret = xmlget(xbuf, "//some/thing", &amp;ngot)
	</code>
	<para>
	  Agora ben, aínda vaise amosar un erro no caso de facer unha solicitude
	  mal configurada.
	</para>	
	<para>
	  Podes atopar unha boa introdución ao uso e á sintaxe de
	  XPath en
	  <url>https://www.w3schools.com/xml/xml_xpath.asp</url>.
	  O programa de soporte (back-end) para <lit>xmlget</lit>
	  o proporciona o módulo xpath de libxml2, que admite
	  XPath 1.0 pero non XPath 2.0.
	</para>
	<para>
	  <seelist>
	    <fncref targ="jsonget"/>
	    <fncref targ="readfile"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="zeromiss" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve un resultado (do tipo do argumento) trocando os ceros en
	  <lit>NA</lit>s. Se <argname>x</argname> é unha serie, troca cada elemento.
	  <seelist>
            <fncref targ="missing"/>
            <fncref targ="misszero"/>
            <fncref targ="ok"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="zeros" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Devolve unha matriz nula con <math>r</math> filas e <math>c</math>
	  columnas.
      <seelist>
        <fncref targ="ones"/>
        <fncref targ="seq"/>
      </seelist>
    </para>
      </description>
    </function>

  </funclist>
</funcref>
