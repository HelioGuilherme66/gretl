<?xml version="1.0" encoding="ISO-8859-1" ?>
<!DOCTYPE funcref SYSTEM "genr_funcs.dtd">

<funcref language="italian">

  <funclist name="Accessori" ref="accessors">

    <function name="$ahat" section="access" output="series">
      <description>
	<para>
          Deve seguire la stima di un modello panel a effetti fissi. Produce le
          stime degli effetti fissi individuali (intercette delle singole
          unità).
	</para>
      </description>
    </function>

    <function name="$aic" section="access" output="scalar">
      <description>
	<para>
	  Produce il criterio di informazione di Akaike per l'ultimo modello
          stimato. Si veda <guideref targ="select-criteria"/> per dettagli.
	</para>
      </description>
    </function>

    <function name="$bic" section="access" output="scalar">
      <description>
	<para>
	  Produce il criterio di informazione bayesiana di Schwarz per l'ultimo
          modello stimato. Si veda <guideref targ="select-criteria"/> per dettagli.
	</para>
      </description>
    </function>

    <function name="$chisq" section="access" output="scalar">
      <description>
	<para>
	  Produce la statistica chi-quadro complessiva per l'ultimo
	  modello stimato, se disponibile.
	</para>
      </description>
    </function>

    <function name="$coeff" section="access" output="matrix" altout="scalar">
      <fnargs>
	<fnarg optional="true" type="coeffname">s</fnarg>
      </fnargs>
      <description>
	<para>
	  L'accessore <lit>$coeff</lit> può essere usato in due modi:
	  senza argomenti produce un vettore colonna che contiene i
	  coefficienti dell'ultimo modello stimato. Con l'argomento
	  opzionale, produce uno scalare che corrisponde alla stima
	  del coefficiente chiamato <argname>s</argname>.
	  <seelist>
	    <fncref targ="$stderr"/>
	    <fncref targ="$vcv"/>
	  </seelist>
	</para>
	<para>
	  Esempio:
	</para>
	<code>
	  open bjg
	  arima 0 1 1 ; 0 1 1 ; lg 
	  b = $coeff 
	  macoef = $coeff(theta_1)
	</code>
	<para>
	  Se il <quote>modello</quote> in questione è effettivamente
	  un sistema (un VAR o un VECM, o un sistema di equazioni
	  simultanee), <lit>$coeff</lit> senza parametri produce la
	  matrice dei coefficienti, una colonna per equazione.
	</para>
      </description>
    </function>

    <function name="$command" section="access" output="string">
      <description>
	<para>
	  Deve seguire la stima di un modello; restituisce la stringa
	  del comando relativo, come ad esempio <lit>ols</lit> oppure
	  <lit>probit</lit>.
	</para>
      </description>
    </function>

    <function name="$compan" section="access" output="matrix">
      <description>
	<para>
	  Deve seguire la stima di un VAR o un VECM; produce la matrice
          compagna.
	</para>
      </description>
    </function>

    <function name="$datatype" section="access" output="scalar">
      <description>
	<para>
	  Restituisce un intero corrispondente al tipo di dataset
	  attualmente in memoria: 0 = nessun dato; 1 = dati
	  cross-sezionali (non datati); 2 = serie storiche; 3 = panel.
	</para>
      </description>
    </function>

    <function name="$depvar" section="access" output="string">
      <description>
	<para>
	  Deve seguire la stima di un modello ad equazione singola e
	  restituisce il nome della variabile dipendente.
	</para>
      </description>
    </function>

    <function name="$df" section="access" output="scalar">
      <description>
	<para>
	  Produce i gradi di libertà dell'ultimo modello stimato. Se
	  questo consiste di un sistema di equazioni, viene restituito
	  il numero dei gradi di libertà per equazione; se questo
	  differisce da un'equazione all'altra, allora il valore
	  restituito è pari al numero di osservazioni meno la media del
	  numero di coefficienti per equazione (arrotondato all'intero
	  più vicino).
	</para>
      </description>
    </function>

    <function name="$dwpval" section="access" output="scalar">
      <description>
	<para>
	  Fornisce il p-value per la statistica Durbin&ndash;Watson
	  relativa all'ultimo modello stimato, se disponibile. Tale
	  valore è calcolato ramite la procedura di Imhof.
	</para>
      </description>
    </function>

    <function name="$ec" section="access" output="matrix">
      <description>
	<para>
	  Deve seguire la stima di un VECM e restituisce una matrice
	  contenente i termini di correzione d'errore.  La matrice
	  restituita ha tante righe quante sono le osservazioni usate
	  nella stima e un numero di colonne pari al rango di
	  cointegrazione del sistema.
	</para>
      </description>
    </function>

    <function name="$error" section="access" output="scalar">
      <description>
	<para>
	  Restituisce il codice interno di errore, che avrà un valore
	  diverso da 0 se si è verificato un errore in presenza del
	  modificatore <cmdref targ="catch"/>. Si noti che l'uso di
	  questo accessore resetta il codice di errore interno a 0. Si
	  veda anche <fncref targ="errmsg"/>. Per il messaggio
	  d'errore associato a un dato codice, bisogna salvare il
	  valore in una variabile temporanea; ad esempio:
	</para>
	<code>
	  errval = $error if (errval) printf "Errore %d (%s)\n",
	  errval, errmsg(errval); endif
	</code>
	<seelist>
	  <cmdref targ="catch"/>
	  <fncref targ="errmsg"/>
	</seelist>
      </description>
    </function>

    <function name="$ess" section="access" output="scalar">
      <description>
	<para>
	  Produce la somma dei quadrati degli errori dell'ultimo modello
          stimato.
	</para>
      </description>
    </function>

    <function name="$evals" section="access" output="matrix">
      <description>
	<para>
	  Deve seguire la stima di un VECM; restituisce un vettore
	  contenente gli autovalori usati nel calcolo del test traccia 
	  per la cointegrazione.
	</para>
      </description>
    </function>

    <function name="$fcast" section="access" output="matrix">
      <description>
	<para>
	  Deve seguire il comando <cmdref targ="fcast"/>; restituisce le
	  previsioni sotto forma di matrice. Se il modello usato per
	  le previsioni è un modello a più equazioni, ogni colonna
	  corrisponde ad un'equazione; altrimenti, restituisce un vettore
	  colonna.
	</para>
      </description>
    </function>

    <function name="$fcerr" section="access" output="matrix">
      <description>
	<para>
	  Deve seguire il comando <cmdref targ="fcast"/>; restituisce gli
	  errori standard per le previsioni sotto forma di matrice. Se
	  il modello usato per le previsioni è un modello a più
	  equazioni, ogni colonna corrisponde ad un'equazione;
	  altrimenti, restituisce un vettore colonna.
	</para>
      </description>
    </function>

    <function name="$fevd" section="access" output="matrix">
      <description>
	<para>
	  Deve seguire la stima di un VAR. Restituisce una matrice
	  contenete la scomposizione della varianza dell'errore di
	  previsione (FEVD). Questa avrà <math>h</math> righe, dove
	  <math>h</math> è l'orizzonte di previsione, che può essere
	  modificato tramite il comando <lit>set horizon</lit> o,
	  altrimenti, viene fissato automaticamente sulla base della
	  frequenza dei dati.  Per un VAR con <math>p</math>
	  variabili, la matrice ha <math>p</math><sup>2</sup>
	  colonne. La parte dell'errore di previsione sulla variabile
	  <math>i</math> attribuibile allo shock alla variabile
	  <math>j</math> si troverà nella colonna (<math>i</math> &minus;
	  1)<math>p</math> + <math>j</math>.
	</para>
      </description>
    </function>

    <function name="$Fstat" section="access" output="scalar">
      <description>
	<para>
	  Restituisce la statistica F complessiva per l'ultimo modello
	  stimato, se disponibile.
	</para>
      </description>
    </function>

    <function name="$gmmcrit" section="access" output="scalar">
      <description>
	<para>
	  Deve seguire un blocco <lit>gmm</lit>. Produce il valore della
          funzione obiettivo al suo minimo.
	</para>
      </description>
    </function>

    <function name="$h" section="access" output="series">
      <description>
	<para>
	  Deve seguire un comando <lit>garch</lit>. Produce la
	  varianza condizionale stimata.
	</para>
      </description>
    </function>

    <function name="$hausman" section="access" output="rvec">
      <description>
	<para>
	  Deve seguire un comando <lit>tsls</lit>. Produce un vettore <by r="1"
	  c="3"/> contenente nell'ordine: il valore della statistica del test di Hausman,
          i corrispondenti gradi di libertà e p-value.
	</para>
      </description>
    </function>

    <function name="$hqc" section="access" output="scalar">
      <description>
	<para>
	  Produce il criterio di informazione di Hannan-Quinn per l'ultimo
          modello stimato.
	</para>
      </description>
    </function>

    <function name="$huge" section="access" output="scalar">
      <description>
	<para>
	  Restituisce un numero positivo molto grande. Di default è pari a 1.0E100,
	  ma tale valore si può cambiare usando il comando <cmdref targ="set"/>.
	</para>
      </description>
    </function>

    <function name="$jalpha" section="access" output="matrix">
      <description>
	<para>
	  Deve seguire la stima di un VECM, e produce la matrice dei pesi, che
          contiene tante righe quante sono le variabili del VECM e tante colonne
          quanto è il rango di cointegrazione.
	</para>
      </description>
    </function>

    <function name="$jbeta" section="access" output="matrix">
      <description>
	<para>
	  Deve seguire la stima di un VECM, e produce la matrice di
          cointegrazione, che contiene tante righe quante sono le variabili del
          VECM e tante colonne quanto è il rango di cointegrazione.
	</para>
      </description>
    </function>

    <function name="$jvbeta" section="access" output="smatrix">
      <description>
	<para>
	  Deve seguire la stima di un VECM, e produce la matrice di covarianza
          stimata per gli elementi dei vettori di cointegrazione.
	</para>
	<para>
	  Nel caso di stima non vincolata, ha un numero di righe pari al numero
          di elementi non vincolati nello spazio di cointegrazione dopo la
          normalizzazione di Phillips. Se però si stima un sistema vincolato con
          il comando <lit>restrict</lit> e l'opzione <lit>--full</lit>, verrà
          prodotta una matrice singolare con <math>nr</math> righe (<math>n</math>
          è il numero delle variabili e <math>r</math> è il rango di
          cointegrazione).
	</para>
	<para>
	  Esempio: il codice
	</para>
	<code>
	  open denmark.gdt
	  vecm 2 1 LRM LRY IBO IDE --rc --seasonals -q
	  s0 = $jvbeta

	  restrict --full
	  b[1,1] = 1
	  b[1,2] = -1
	  b[1,3] + b[1,4] = 0
	  end restrict
	  s1 = $jvbeta

	  print s0
	  print s1
	</code>
	<para>
	  produce il risultato seguente.
	</para>
	<code>
	  s0 (4 x 4)

	    0.019751     0.029816  -0.00044837     -0.12227 
	    0.029816      0.31005     -0.45823     -0.18526 
	 -0.00044837     -0.45823       1.2169    -0.035437 
	    -0.12227     -0.18526    -0.035437      0.76062 

	  s1 (5 x 5)

	  0.0000       0.0000       0.0000       0.0000       0.0000 
	  0.0000       0.0000       0.0000       0.0000       0.0000 
	  0.0000       0.0000      0.27398     -0.27398    -0.019059 
	  0.0000       0.0000     -0.27398      0.27398     0.019059 
	  0.0000       0.0000    -0.019059     0.019059    0.0014180 
	</code>
      </description>
    </function>

    <function name="$llt" section="access" output="series">
      <description>
	<para>
	  Per alcuni modelli stimati con massima verosimiglianza,
	  produce la serie della log-verosimiglianza per
	  osservazione. Al momento, questo accessore funziona solo per
	  logit e probit binari, tobit e heckit.
	</para>
      </description>
    </function>

    <function name="$lnl" section="access" output="scalar">
      <description>
	<para>
	  Produce la log-verosimiglianza dell'ultimo modello stimato (dove
          possibile).
	</para>
      </description>
    </function>

    <function name="$macheps" section="access" output="scalar">
      <description>
	<para>
	  Restituisce il valore dell'<quote>epsilon macchina</quote>,
	  ossia un limite superiore all'errore relativo dovuto
	  all'aritmetica a virgola mobile in doppia precisione.
	</para>
      </description>
    </function>

    <function name="$mnlprobs" section="access" output="matrix">
      <description>
	<para>
	  Dopo la stima di un modello logit multinomiale, crea una
	  matrice con le probabilità stimate per tutti i possibili
	  esiti e tutte le osservazioni usate nella stima. Le
	  osservazioni sono per riga e gli esiti per colonna.
	</para>
      </description>
    </function>

    <function name="$ncoeff" section="access" output="int">
      <description>
	<para>
	  Produce il numero totale dei coefficienti stimati nell'ultimo modello.
	</para>
      </description>
    </function>

    <function name="$nobs" section="access" targ="dnobs" output="int">
      <description>
	<para>
	  Produce il numero delle osservazioni nel campione selezionato.
	</para>
      </description>
    </function>

    <function name="$nvars" section="access" output="int">
      <description>
	<para>
	  Produce il numero delle variabili nel dataset (inclusa la costante).
	</para>
      </description>
    </function>

    <function name="$obsdate" section="access" output="series">
      <description>
	<para>
	  Applicabile quando il dataset corrente è una serie storica
	  con frequenza decennale, annuale, trimestrale, mensile,
	  settimanale o giornaliera, oppure è un panel in cui la
	  variabile che indicizza i periodi ha la frequenza
	  appropriata (si veda il comando <cmdref targ="setobs"/>).
	  La serie risultante ha 8 cifre con la struttura
	  <lit>YYYYMMDD</lit> (forma <quote>base</quote> delle date
	  secondo l'ISO 8601), che corrisponde al giorno
	  dell'osservazione, o al primo giorno del periodo di
	  osservazione nel caso di serie storiche con frequenza minore
	  di quella giornaliera.
	</para>
	<para>
	  Questa serie può essere utile quando si usa il comando <cmdref targ="join"/>.
	</para>
      </description>
    </function>

    <function name="$obsmajor" section="access" output="series">
      <description>
	<para>
	  Applicabile quando le osservazioni nel dataset aperto hanno
	  una struttura maggiore:minore, come in serie storiche
	  trimestrali (anno:trimestre), mensili (anno:mese), orarie
	  (giorno:ora) e dati panel (individuo:periodo). Restituisce una
	  serie contenente la componente maggiore (a frequenza più
	  bassa, come l'anno).
	</para>
	<para>
	  <seelist>
	    <fncref targ="$obsminor"/>
	    <fncref targ="$obsmicro"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$obsmicro" section="access" output="series">
      <description>
	<para>
	  Applicabile quando le osservazioni nel dataset aperto hanno
	  una struttura maggiore:minore:micro, come in serie storiche
	  giornaliere (anno:mese:giorno). Restituisce una
	  serie contenente la componente micro (a frequenza più
	  alta, come il giorno).
	</para>
	<para>
	  <seelist>
	    <fncref targ="$obsmajor"/>
	    <fncref targ="$obsminor"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$obsminor" section="access" output="series">
      <description>
	<para>
	  Applicabile quando le osservazioni nel dataset aperto hanno
	  una struttura maggiore:minore, come in serie storiche
	  trimestrali (anno:trimestre), mensili (anno:mese), orarie
	  (giorno:ora) e dati panel (individuo:periodo). Restituisce una
	  serie contenente la componente minore (a frequenza più
	  alta, come il mese).
	</para>
	<para>
	  <seelist>
	    <fncref targ="$obsmajor"/>
	    <fncref targ="$obsmicro"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$pd" section="access" output="int">
      <description>
	<para>
	  Produce la frequenza o la periodicità dei dati (es. 4 per dati
          trimestrali).
	</para>
      </description>
    </function>

    <function name="$pi" section="access" output="scalar">
      <description>
	<para>
	  Restituisce il valore di &pi; in doppia precisione.
	</para>
      </description>
    </function>

    <function name="$pvalue" section="access" targ="dpvalue" output="scalar-or-matrix">
      <description>
	<para>
	  Produce il p-value della statistica test generata
	  dall'ultimo comando esplicito di test di ipotesi (es.
	  <lit>chow</lit>).  Si veda <guideref
	  targ="sec:genr-internal"/> per i dettagli.
	  <seelist>
	    <fncref targ="$test"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$rho" section="access" output="scalar">
      <fnargs>
	<fnarg optional="true" type="scalar">n</fnarg>
      </fnargs>
      <description>
	<para>
	  Senza argomenti, produce il coefficiente autoregressivo del
          prim'ordine per i residui dell'ultimo modello. Dopo aver stimato un
          modello con il comando <lit>ar</lit>, la sintassi
	  <lit>$rho(n)</lit> produce la corrispondente stima di
	  &rgr;(<math>n</math>).
	</para>
      </description>
    </function>

    <function name="$rsq" section="access" output="scalar">
      <description>
	<para>
	  Produce l'<math>R</math><sup>2</sup> non aggiustato
	  dell'ultimo modello stimato.
	</para>
      </description>
    </function>

    <function name="$sample" section="access" output="series">
      <description>
	<para>
	  Deve seguire la stima di un modello ad equazione
	  singola. Restituisce una variabile binaria con 1 per le
	  osservazioni usate nella stima, 0 per osservazioni incluse
	  nel campione corrente ma non usate nella stima (ad esempio,
	  per via di valori mancanti nella variabile dipendente) e NA
	  per osservazioni al di fuori del campione corrente.
	</para>
	<para>
	  Se fosse necessario calcolare statistiche basate sul
	  campione usato per un certo modello, ad esempio, si potrebbe
	  usare la seguente sintassi:
	</para>
	<code>
	  ols y 0 xlist
	  genr sdum = $sample
	  smpl sdum --dummy
	</code>
      </description>
    </function>

    <function name="$sargan" section="access" output="rvec">
      <description>
	<para>
	  Deve seguire un comando <lit>tsls</lit>. Produce un vettore <by r="1"
	  c="3"/> che contiene nell'ordine: il valore della statistica del test
          di Sargan per la sovraidentificazione, i corrispondenti gradi di
          libertà e il p-value.
	</para>
      </description>
    </function>

    <function name="$sigma" section="access" output="scalar-or-matrix">
      <description>
	<para>
	  Restituisce lo scarto quadratico medio dei residui dell'ultimo
	  modello stimato.
	</para>
      </description>
    </function>

    <function name="$stderr" section="access" output="matrix" altout="scalar">
      <fnargs>
	<fnarg optional="true" type="coeffname">s</fnarg>
      </fnargs>
      <description>
	<para>
	  L'accessore <lit>$stderr</lit> può usarsi in due modi: senza
	  argomenti, restituisce un vettore colonna che contiene le stime
	  dei coefficienti per l'ultimo modello stimato.  Con il
	  parametro opzionale, restituisce uno scalare contenente la
	  stima del parametro <argname>s</argname>.
	</para>
	<para>
	  Se il <quote>modello</quote> in questione è un sistema, il
	  risultato dipende dalle sue caratteristiche: per sistemi VAR
	  e VECM il valore restituito è una matrice con una colonna per
	  equazione; altrimenti, è un vettore colonna contenente i
	  coefficienti della prima equazione, seguiti da quelli della
	  seconda, e così via.
	</para>
	<para>
	  <seelist>
	    <fncref targ="$coeff"/> 
	    <fncref targ="$vcv"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$stopwatch" section="access" output="scalar">
      <description>
	<para>
	  Deve essere preceduto dal comando <lit>set stopwatch</lit>,
	  che attiva la misurazione del tempo di CPU.  Il primo uso di
	  questo accessore restituisce i secondi di CPU time trascorsi dal
	  comando <lit>set stopwatch</lit>. Ad ogni accesso il
	  cronometro viene riazzerato, cosicché l'uso successivo
	  dell'accessore restituisce i secondi di CPU intercorsi dalla
	  chiamata precedente.
	</para>
      </description>
    </function>

    <function name="$sysA" section="access" output="matrix">
      <description>
	<para>
	  Deve seguire la stima di un sistema simultaneo.  Restituisce
	  la matrice dei coefficienti delle endogene ritardate, se
	  presenti nella forma strutturale. Si veda il comando <cmdref
	  targ="system"/>.
	</para>
      </description>
    </function>

    <function name="$sysB" section="access" output="matrix">
      <description>
	<para>
	  Deve seguire la stima di un sistema simultaneo.  Restituisce
	  la matrice dei coefficienti delle esogene nella forma
	  strutturale. Si veda il comando <cmdref targ="system"/>.
	</para>
      </description>
    </function>

    <function name="$sysGamma" section="access" output="matrix">
      <description>
	<para>
	  Deve seguire la stima di un sistema simultaneo.  Restituisce
	  la matrice dei coefficienti delle endogene contemporanee
	  nella forma strutturale. Si veda il comando <cmdref
	  targ="system"/>.
	</para>
      </description>
    </function>

    <function name="$T" section="access" output="int">
      <description>
	<para>
	  Numero di osservazioni usato nella stima dell'ultimo
	  modello.
	</para>
      </description>
    </function>

    <function name="$t1" section="access" output="int">
      <description>
	<para>
	  Indice (a base 1) della prima osservazione nel campione
	  attualmente selezionato.
	</para>
      </description>
    </function>

    <function name="$t2" section="access" output="int">
      <description>
	<para>
	  Indice (a base 1) dell'ultima osservazione nel campione
	  attualmente selezionato.
	</para>
      </description>
    </function>

    <function name="$test" section="access" output="scalar-or-matrix">
      <description>
	<para>
	  Restituisce il valore della statistica test generata
	  dall'ultimo comando esplicitamente volto al test di ipotesi
	  (p. es: <lit>chow</lit>), se presente. Si veda <guideref
	  targ="sec:genr-internal"/> per maggiori dettagli.
	  <seelist>
	    <fncref label="\$pvalue" targ="dpvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$trsq" section="access" output="scalar">
      <description>
	<para>
	  Restituisce <math>TR</math><sup>2</sup> (ampiezza campionaria
	  per R quadro) dall'ultimo modello.
	</para>
      </description>
    </function>

    <function name="$uhat" section="access" output="series">
      <description>
	<para>
	  Restituisce i residui dall'ultimo modello stimato. Cosa si
	  intenda per 'residui' dipende dal modello che è stato
	  stimato. Ad esempio, dopo una stima ARMA <lit>$uhat</lit>
	  contiene gli errori di previsione a un passo; dopo un
	  probit, i residui generalizzati.
	</para>
	<para>
	  Se il modello in questione è multi-equazionale (un VAR o un
	  VECM, o un sistema simultaneo), <lit>$uhat</lit> senza
	  parametri restituisce una matrice contenente i residui nelle
	  colonne.
	</para>
      </description>
    </function>

    <function name="$unit" section="access" output="series">
      <description>
	<para>
	  Valido solo per dataset di tipo panel.  Restituisce una serie
	  con 1 per la prima unità cross-sezionale, 2 per la seconda e
	  così via.
	</para>
      </description>
    </function>

    <function name="$vcv" section="access" output="matrix" altout="scalar">
      <fnargs>
	<fnarg optional="true" type="coeffname">s1</fnarg>
	<fnarg optional="true" type="coeffname">s2</fnarg>
      </fnargs>
      <description>
	<para>
	  Senza argomenti, restituisce una matrice quadrata contenente le
	  covarianze stimate dei coefficienti dell'ultimo modello. Con
	  gli argomenti opzionali, restituisce uno scalare, con la
	  covarianza stimata fra i parametri di nome
	  <argname>s1</argname> e <argname>s2</argname>.
	  <seelist>
	    <fncref targ="$coeff"/> 
	    <fncref targ="$stderr"/>
	  </seelist>
	</para>
	<para>
	  Questo accessore non è disponibile per modelli di tipo VAR o
	  VECM; in tal caso, si veda piuttosto <fncref targ="$sigma"/> e
	  <fncref targ="$xtxinv"/>.
	</para>
      </description>
    </function>

    <function name="$vecGamma" section="access" output="matrix">
      <description>
	<para>
	  Deve seguire la stima di un VECM; restituisce una matrice in cui
	  le matrici Gamma (cioè i coefficienti delle differenze
	  ritardate) sono messe una fianco all'altra.  Ogni riga
	  rappresenta un'equazione; per un VECM di ordine
	  <math>p</math> ci sono <math>p</math> &minus; 1
	  sottomatrici.
	</para>
      </description>
    </function>    

    <function name="$version" section="access" output="scalar">
      <description>
	<para>
	  Restituisce un valore intero che codifica la versione del
	  programma, sotto la forma <lit>x.y.z</lit> (ad esempio,
	  1.7.6).  Il valore prodotto da questo accessore è pari a
	  <lit>10000*x + 100*y + z</lit>, cosicché 1.7.6 diventa
	  10706.
	</para>
      </description>
    </function>


    <function name="$vma" section="access" output="matrix">
      <description>
	<para>
	  Deve seguire la stima di un VAR o di un VECM; restituisce
	  una matrice contenente la rappresentazione VMA fino
	  all'ordine specificato tramite il comando <lit>set
	  horizon</lit>. Per maggiori dettagli, si veda <guideref
	  targ="sec:var-estim"/>.
	</para>
      </description>
    </function>

    <function name="$windows" section="access" output="int">
      <description>
	<para>
	  Restituisce 1 se gretl sta girando sotto Windows e 0
	  altrimenti. Questo accessore viene tipicamente usato per
	  scrivere script portabili da un sistema operativo ad un
	  altro.
	</para>
	<para>
	  Si veda anche il comando <cmdref targ="shell"/>.
	</para>
      </description>
    </function>

    <function name="$xlist" section="access" output="list">
      <description>
	<para>
	  Se l'ultimo modello stimato è un'equazione singola,
	  restituisce la lista dei regressori. Se l'ultimo modello
	  stimato è un sistema di equazioni, restituisce la lista
	  <quote>globale</quote> delle variabili esogene e
	  predeterminate (nello stesso ordine con cui compaiono in
	  <fncref targ="$sysB"/>). Se l'ultimo modello è un VAR,
	  restituisce la lista dei regressori esogeni, laddove
	  presenti.
	</para>
      </description>
    </function>

    <function name="$xtxinv" section="access" output="matrix">
      <description>
	<para>
	  Quando segue la stima di un VAR o di un VECM, restituisce
	  <math>X'X</math><sup>-1</sup>, dove <math>X</math> è la
	  matrice dei regressori usati in ciascuna delle
	  equazioni. Questo accessore è disponibile solo per un VECM
	  stimato con una restrizione imposta su &agr;, la matrice dei
	  <quote>loading</quote>.
	</para>
      </description>
    </function>

    <function name="$yhat" section="access" output="series">
      <description>
	<para>
	  Restituisce i valori stimati dall'ultima regressione.
	</para>
      </description>
    </function>

    <function name="$ylist" section="access" output="list">
      <description>
	<para>
	  Se l'ultimo modello stimato è un VAR, un VECM o un sistema
	  di equazioni simultanee, restituisce la lista delle
	  variabili endogene nel modello. Se l'ultimo modello stimato
	  è un'equazione singola, questo accessore fornisce una lista
	  di un solo elemento: la variabile dipendente. Nel caso
	  particolare di un modello biprobit la lista contiene due
	  elementi.
	</para>
      </description>
    </function>

  </funclist>

  <funclist name="Functions proper" ref="functions">

    <function name="abs" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Valore assoluto.
	</para>
      </description>
    </function>

    <function name="acos" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Arcocoseno di <argname>x</argname>, ossia il numero il cui
	  coseno è <argname>x</argname>.  Il risultato è in radianti;
	  l'argomento deve essere compreso fra &minus;1 e 1.
	</para>
      </description>
    </function>

    <function name="acosh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce l'arcoseno iperbolico di <argname>x</argname>
	  (soluzione positiva). <argname>x</argname> deve essere maggiore di 1;
	  in caso contrario, viene restituito NA.
	  <seelist>
	    <fncref targ="cosh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="aggregate" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
	<fnarg type="series-or-list">byvar</fnarg>
	<fnarg type="string">funcname</fnarg>	
      </fnargs>
      <description>
	<para>
	  Nella versione più semplice, in cui sia <argname>x</argname>
	  sia <argname>byvar</argname> sono serie individuali, questa
	  funzione restituisce una matrice con tre colonne: la prima
	  contiene i valori distinti di <argname>byvar</argname>,
	  ordinati in senso crescente; la seconda contiene il numero
	  delle osservazioni in cui <argname>byvar</argname> assume
	  ciascuno di questi valori; la terza, infine, contiene i
	  valori della statistica specificata da
	  <argname>funcname</argname>, calcolata sulla serie
	  <argname>x</argname> usando solo quelle osservazioni per cui
	  <argname>byvar</argname> assume il valore specificato nella
	  prima colonna.
	</para>
	<para>
	  Più in generale, se <argname>byvar</argname> è una lista di
	  <math>n</math> elementi, allora le prime <math>n</math>
	  colonne da sinistra contengono le combinazioni dei valori
	  distinti di ciascuna delle <math>n</math> serie, mentre la
	  colonna immediatamente successiva contiene il numero delle
	  osservazioni in cui ciascuna combinazione ricorre. Se
	  <argname>x</argname> è una lista con <math>m</math>
	  elementi, allora le <math>m</math> colonne più a destra
	  contengono i valori della statistica specificata da
	  <argname>funcname</argname> per ciascuna delle variabili
	  <argname>x</argname>, calcolati sul sottocampione
	  individuato dalle prime colonne.
	</para>
	<para>
	  I seguenti valori di <argname>funcname</argname> sono
	  supportati <quote>in modo nativo</quote>: <fncref
	  targ="sum"/>, <fncref targ="sumall"/>, <fncref
	  targ="mean"/>, <fncref targ="sd"/>, <fncref targ="var"/>,
	  <fncref targ="sst"/>, <fncref targ="skewness"/>, <fncref
	  targ="kurtosis"/>, <fncref targ="min"/>, <fncref
	  targ="max"/>, <fncref targ="median"/>, <fncref targ="nobs"/>
	  e <fncref targ="gini"/>. Ciascuna di queste funzioni accetta
	  come argomento una serie e restituisce uno scalare, e in tal
	  senso può dirsi che <quote>aggrega</quote> la serie in un
	  qualche modo. È anche possibile inserire il nome di
	  una funzione definita dall'utente come aggregatore; come le
	  funzioni supportate in modo nativo, tale funzione deve
	  accettare come argomento una singola serie e ritornare uno
	  scalare.
	</para>
	<para>
	  Si noti che, benché il conteggio dei casi sia fornito
	  automaticamente, la funzione <lit>nobs</lit> non è
	  ridondante come aggregatore, poiché fornisce il numero di
	  osservazioni valide (non-missing) in <argname>x</argname>
	  per ciascuna combinazione <argname>byvar</argname>.
	</para>
	<para>
	  Come semplice esempio, si supponga che <lit>region</lit> sia
	  la codifica di regioni geografiche con valori interi da 1 ad
	  <math>n</math> e <lit>income</lit> il reddito
	  familiare. Allora quanto segue produrrà una matrice <by
	  r="n" c="3"/> contenente: nella prima colonna, i codici
	  delle regioni; nella seconda, il numero delle osservazioni
	  in ciascuna regione; nella terza, il reddito familiare medio
	  per regione:
	</para>
	<code>
	  matrix m = aggregate(income, region, mean)
	</code>
	<para>
	  Per un esempio che utilizza liste, si ipotizzi che
	  <lit>gender</lit> sia una variabile dummy maschio/femmina e
	  <lit>race</lit> una variabile categoriale con tre possibili
	  valori. Allora quanto segue genererà una matrice con 6 righe
	  e 5 colonne: le prime due colonne conterranno le
	  combinazioni possibili gender/race, mentre le ultime due la
	  deviazione standard campionaria di <lit>income</lit> e
	  <lit>age</lit>:
	</para>
	<code>
	  list BY = gender race
	  list X = income age
	  matrix m = aggregate(X, BY, sd)
	</code>
	<para>
	  Si noti che, nel caso in cui <argname>byvar</argname> sia
	  una lista, alcune combinazioni dei valori di
	  <argname>byvar</argname> potrebbero non essere presenti nei
	  dati (il numero di osservazioni sarà zero). In tal caso, il
	  valore delle statistiche per <argname>x</argname> viene
	  registrato come <lit>NaN</lit> (Not a Number). Nel caso si
	  voglia non considerare tali casi, si può utilizzare la
	  funzione <fncref targ="selifr"/> per selezionare solo le
	  righe associate ad un numero di osservazioni diverso da
	  zero. Nel caso in cui <argname>byvar</argname> contenga
	  <math>n</math> elementi, la colonna da testare sarà quella
	  immediatamente a destra delle prime <math>n</math> colonne
	  partendo da sinistra. Possiamo quindi eseguire il seguente
	  codice:
	</para>
	<code>
	  matrix m = aggregate(X, BY, sd)
	  scalar c = nelem(BY)
	  m = selifr(m, m[,c+1])
	</code>
      </description>
    </function>

    <function name="argname" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Per <argname>s</argname>, il nome di un parametro in una
	  funzione definita dall'utente, restituisce il nome del
	  corrispondente argomento, o una stringa vuota se l'argomento
	  era anonimo.
	</para>
      </description>
    </function>

    <function name="asin" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce l'arcoseno di <argname>x</argname>, cioè, il
	  valore il cui seno è <argname>x</argname>.  Il risultato è
	  in radianti; l'input deve essere tra &minus;1 e 1, estremi
	  compresi.
	</para>
      </description>
    </function>

    <function name="asinh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce l'arcoseno iperbolico di <argname>x</argname>.
	  <seelist>
	    <fncref targ="sinh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="atan" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Funzione arcotangente.
	  <seelist>
	    <fncref targ="cos"/>
	    <fncref targ="sin"/>
	    <fncref targ="tan"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="atanh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the inverse hyperbolic tangent of <argname>x</argname>.
	  <seelist>
	    <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="atof" section="strings" output="scalar">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Closely related to the C library function of the same name.
	  Returns the result of converting the string
	  <argname>s</argname> (or the leading portion thereof, after
	  discarding any initial white space) to a floating-point
	  number.  Unlike C's <lit>atof</lit>, however, the decimal
	  character is always assumed (for reasons of portability) to
	  be <quote><lit>.</lit></quote>. Any characters that follow
	  the portion of <argname>s</argname> that converts to a
	  floating-point number under this assumption are ignored.
	</para>
	<para>
	  If none of <argname>s</argname> (following any discarded
	  white space) is convertible under the stated assumption,
	  <lit>NA</lit> is returned.
	</para>
	<code>
	  # examples
	  x = atof("1.234") # gives x = 1.234 
	  x = atof("1,234") # gives x = 1
	  x = atof("1.2y")  # gives x = 1.2
	  x = atof("y")     # gives x = NA
	  x = atof(",234")  # gives x = NA
	</code>	
	<para>
	  See also <fncref targ="sscanf"/> for more flexible string to
	  numeric conversion.
	</para>
      </description>
    </function>

    <function name="bessel" section="math" output="asinput">
      <fnargs>
	<fnarg type="char">type</fnarg>
	<fnarg type="scalar">v</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes one of the Bessel function variants for order
	  <argname>v</argname> and argument <argname>x</argname>.  The return
	  value is of the same type as <argname>x</argname>. The specific
	  function is selected by the first argument, which must be
	  <lit>J</lit>, <lit>Y</lit>, <lit>I</lit>, or <lit>K</lit>.  A good
	  discussion of the Bessel functions can be found on Wikipedia; here
	  we give a brief account.
	</para>
	<para>
	  case <lit>J</lit>: Bessel function of the first kind.  Resembles a
	  damped sine wave.  Defined for real <argname>v</argname> and
	  <argname>x</argname>, but if <argname>x</argname> is negative
	  then <argname>v</argname> must be an integer.
	</para>
	<para>
	  case <lit>Y</lit>: Bessel function of the second kind.  Defined
	  for real <argname>v</argname> and <argname>x</argname> but has
	  a singularity at <argname>x</argname> = 0.
	</para>
	<para>
	  case <lit>I</lit>: Modified Bessel function of the first kind.
	  An exponentially growing function.  Acceptable arguments are
	  as for case <lit>J</lit>.
	</para>
	<para>
	  case <lit>K</lit>: Modified Bessel function of the second kind.  An
	  exponentially decaying function.  Diverges at <argname>x</argname> =
	  0 and is not defined for negative <argname>x</argname>.  Symmetric
	  around <argname>v</argname> = 0.
	</para>
      </description>
    </function>

    <function name="BFGSmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="vector">b</fnarg>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Numerical maximization via the method of Broyden, Fletcher, Goldfarb
	  and Shanno.  The vector <argname>b</argname> should hold the initial
	  values of a set of parameters, and the string <argname>s</argname>
	  should specify a call to a function that calculates the (scalar)
	  criterion to be maximized, given the current parameter values and
	  any other relevant data. If the object is in fact minimization, this
	  function should return the negative of the criterion.  On successful
	  completion, <lit>BFGSmax</lit> returns the maximized value of the
	  criterion, and <argname>b</argname> holds the parameter values which
	  produce the maximum.  
	</para>
	<para>
	  For more details and examples see the chapter
	  on special functions in <lit>genr</lit> in 
	  <guideref targ="sec:genr-numerical"/>.
	  <seelist>
	    <fncref targ="fdjac"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="bkfilt" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Extracts the cyclical component of series <argname>y</argname>
	  via the Baxter&ndash;King bandpass filter, a two-sided symmetric
	  filter. See <guideref targ="chap-genr"/> for details.
	  <seelist>
	    <fncref targ="hpfilt"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="boxcox" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="scalar">d</fnarg>
      </fnargs>    
      <description>
	<para>
	  Returns the Box&ndash;Cox transformation with parameter
	  <argname>d</argname> for the positive series <argname>y</argname>.
	</para>	  
	<para context="tex">
	  \[ y_t^{(d)} = \left\{ \begin{array}{ll} \frac{y_t^d - 1}{d} &amp;
	  {\rm if}\quad d\neq 0 \\ \log (y_t) &amp; {\rm if}\quad d=0
	  \end{array} \right. \]
	</para>
	<para context="notex">
	  The transformed series is 
	  (<math>y</math><sup>d</sup> - 1)/<math>d</math> for
	  <math>d</math> not equal to zero, or log(<math>y</math>) for
	  <math>d</math> = 0.
	</para>
      </description>
    </function>

    <function name="bwfilt" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="scalar">n</fnarg>
	<fnarg type="scalar">omega</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the result from application of a low-pass
	  Butterworth filter with order <argname>n</argname> and
	  frequency cutoff <argname>omega</argname> to the series
	  <argname>y</argname>. The cutoff is expressed in degrees and
	  must be greater than 0 and less than 180. Smaller cutoff
	  values restrict the pass-band to lower frequencies and hence
	  produce a smoother trend. Higher values of
	  <argname>n</argname> produce a sharper cutoff, at the cost
	  of possible numerical instability. 
	</para>
	<para>
	  Inspecting the periodogram of the target series is a
	  useful preliminary when you wish to apply this function.
	  See <guideref targ="chap-filters"/> for details.
	  <seelist>
	    <fncref targ="bkfilt"/>
	    <fncref targ="hpfilt"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cdemean" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Centers the columns of matrix <argname>X</argname> around their
	  means.
	</para>
      </description>
    </function>

    <function name="cdf" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="char">c</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <examples>
	<example>p1 = cdf(N, -2.5)</example>
	<example>p2 = cdf(X, 3, 5.67)</example>
	<example>p3 = cdf(D, 0.25, -1, 1)</example>
      </examples>
      <description>
	<para>
	  Calcola funzioni di ripartizione. Restituisce <equation
	  status="inline" ascii="P(X &lt; x)" tex="$P(X \le x)$"/>,
	  dove la distribuzione di <math>X</math> è determinata dal
	  carattere <argname>c</argname>. Tra gli argomenti
	  <argname>c</argname> e <argname>x</argname>, possono essere
	  richiesti parametri aggiuntivi a seconda della
	  distribuzione, come specificato qui di seguito.
	</para>
	<ilist context="notex">
	  <li>
	    <para>
	      Normale standard (c = z, n, or N): no argomenti extra
	    </para>
	  </li>
	  <li>
	    <para>
	      Normale bivariata (D): coefficiente di correlazione
	    </para>
	  </li>
	  <li>
	    <para>
	      t di Student (t): gradi di libertà 
	    </para>
	  </li>
	  <li>
	    <para>
	      Chi quadro (c, x, or X): gradi di libertà
	    </para>
	  </li>
	  <li>
	    <para>
	      F di Snedecor (f or F): gradi di libertà (num.); gradi
	      di libertà (den.)
	    </para>
	  </li>
	  <li>
	    <para>
	      Gamma (g or G): forma; scala
	    </para>
	  </li>	  
	  <li>
	    <para>
	      Binomiale (b or B): probabilità; numero di prove
	    </para>
	  </li>	  
	  <li>
	    <para>
	      Poisson (p or P): Media
	    </para>
	  </li>	  
	  <li>
	    <para>
	      Weibull (w or W): forma; scala
	    </para>
	  </li>	
	  <li>
	    <para>
	      Generalized Error (E): forma
	    </para>
	  </li>	
	</ilist>
	<para context="tex">
	  \begin{center} 
	  \begin{tabular}{llll} 
	  \textit{Distribution} &amp; \textsl{c} &amp;
	  \textit{Arg} 2 &amp; \textit{Arg} 3 \\[4pt] 
	  Standard normal &amp; \texttt{z}, \texttt{n} or \texttt{N} &amp; 
	  -- &amp; -- \\ 
	  Bivariate normal &amp; \texttt{D} &amp; 
	  $\rho$ &amp; -- \\ 
	  Student's $t$ (central) &amp; \texttt{t} &amp;  
	  degrees of freedom &amp; -- \\ 
	  Chi square &amp; \texttt{c}, \texttt{x} or \texttt{X} &amp; 
	  degrees of freedom &amp; -- \\ 
	  Snedecor's $F$ &amp; \texttt{f} or \texttt{F} &amp;
	  df (num.) &amp; df (den.) \\ 
	  Gamma &amp; \texttt{g} or \texttt{G} &amp;
	  shape &amp; scale \\ 
	  Binomial &amp; \texttt{b} or \texttt{B} &amp;
	  probability &amp; trials \\ 
	  Poisson &amp; \texttt{p} or \texttt{P} &amp; 
	  mean &amp; -- 
	  \end{tabular}
	  \end{center}
	</para>
	<para>
	  La maggior parte delle distribzioni usano degli aliases per
	  rendere più agevole la memorizzazione dei codici.  Il caso
	  della normale bivariata è particolare: la sintassi è <lit>x
	  = cdf(D, rho, z1, z2)</lit> dove <lit>rho</lit> è la
	  correlazione fra <lit>z1</lit> e <lit>z2</lit>.
	</para>
	<para context="tex">
	  La parametrizzazione che \app{gretl} adotta per la
	  v.c. Gamma implica che la funzione di densità possa essere
	  scitta come \[ f(x; k, \theta) = \frac{x^{k-1}}{\theta^k}
	  \frac{e^{-x/\theta}}{\Gamma(k)} \] dove $k>0$ è il parametro
	  di forma e $\theta>0$ è il parametro di scala.
	</para>
	<para>
	  <seelist>
	    <fncref targ="critical"/>
	    <fncref targ="invcdf"/>
	    <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cdiv" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">Y</fnarg>
      </fnargs>
      <description>
	<para>
	  Divisione complessa. I due argomenti devono avere lo stesso
	  numero di righe, <math>n</math>, e una o due colonne.  La
	  prima colonna contiene la parte reale e l'eventuale seconda
	  quella immaginaria.  Restituisce una matrice <by r="n" c="2"/>
	  oppure, se la parte immaginaria del risultato è nulla, un
	  vettore a <math>n</math> elementi.
	  <seelist>
	    <fncref targ="cmult"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ceil" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Ceiling function: returns the smallest integer greater than or
	  equal to <argname>x</argname>. 
	  <seelist> 
	    <fncref targ="floor"/>
	    <fncref targ="int"/>
	  </seelist>
	</para>
      </description>
    </function>  

    <function name="cholesky" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Peforms a Cholesky decomposition of the matrix
	  <argname>A</argname>, which is assumed to be symmetric and
	  positive definite. The result is a lower-triangular matrix
	  <math>K</math> which satisfies <equation status="inline"
	  ascii="A = KK'"  tex="$A = KK'$"/>. The function will fail if
	  <argname>A</argname> is not symmetric or not positive definite.
	</para>
      </description>
    </function>

    <function name="chowlin" section="transforms" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="scalar">xfac</fnarg>
	<fnarg type="matrix" optional="true">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Expands the input data, <argname>Y</argname>, to a higher
	  frequency, using the interpolation method of <cite
	  key="chowlin71">Chow and Lin (1971)</cite>. It is
	  assumed that the columns of <argname>Y</argname>
	  represent data series; the returned matrix has as many columns
	  as <argname>Y</argname> and <argname>xfac</argname> times
	  as many rows.
	</para>
	<para>
	  The second argument represents the expansion factor: it should
	  be 3 for expansion from quarterly to monthly or 4 for expansion
	  from annual to quarterly, these being the only supported
	  factors. The optional third argument may be used to provide a
	  matrix of covariates at the higher (target) frequency.
	</para>
	<para>
	  The regressors used by default are a constant and quadratic
	  trend. If <argname>X</argname> is provided, its columns are
	  used as additional regressors; it is an error if the number of
	  rows in <argname>X</argname> does not equal
	  <argname>xfac</argname> times the number of rows in
	  <argname>Y</argname>.
	</para>
      </description>
    </function>

    <function name="cmult" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">Y</fnarg>
      </fnargs>
      <description>
	<para>
	  Moltiplicazione complessa. I due argomenti devono avere lo
	  stesso numero di righe, <math>n</math>, e una o due colonne.
	  La prima colonna contiene la parte reale e l'eventuale
	  seconda quella immaginaria.  Restituisce una matrice <by r="n"
	  c="2"/> oppure, se la parte immaginaria del risultato è
	  nulla, un vettore a <math>n</math> elementi.
	  <seelist>
	    <fncref targ="cdiv"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cnorm" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the cumulative distribution function for a standard
	  normal. 
	  <seelist>
	    <fncref targ="dnorm"/>
	    <fncref targ="qnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="colname" section="strings" output="string">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="scalar">col</fnarg>
      </fnargs>
      <description>
	<para>
	  Retrieves the name for column <argname>col</argname> of
	  matrix <argname>M</argname>. If <argname>M</argname> has
	  no column names attached the value returned is an empty
	  string; if <argname>col</argname> is out of bounds for
	  the given matrix an error is flagged. See also
	  <fncref targ="colnames"/>.
	</para>
      </description>
    </function>

    <function name="colnames" section="matbuild" output="scalar">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="list-or-string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Attaches names to the columns of the <by r="T" c="k"/> matrix
	  <argname>M</argname>. If <argname>s</argname> is a named list, the
	  column names are copied from the names of the variables; the list
	  must have <math>k</math> members. If <argname>s</argname> is a
	  string, it should contain <math>k</math> space-separated
	  sub-strings.  The return value is 0 on successful completion,
	  non-zero on error. See also <fncref targ="rownames"/>.
	</para>
	<para>
	  Example:
	</para>
	<code>
	  matrix M = {1,2;2,1;4,1}
	  colnames(M, "Col1 Col2")
	  print M
	</code>
      </description>
    </function>

    <function name="cols" section="matshape" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Il numero di colonne di <argname>X</argname>. 
	  <seelist> 
	    <fncref targ="mshape"/>
	    <fncref targ="rows"/>
	    <fncref targ="unvech"/>
	    <fncref targ="vec"/> 
	    <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="corr" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">y1</fnarg>
	<fnarg type="series">y2</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes the correlation coefficient between <argname>y1</argname>
	  and <argname>y2</argname>. 
	  <seelist> 
	    <fncref targ="cov"/>
	    <fncref targ="mcov"/>
	    <fncref targ="mcorr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="corrgm" section="stats" output="matrix">
      <fnargs>
	<fnarg type="smlist">x</fnarg>
	<fnarg type="scalar">p</fnarg>
	<fnarg optional="true" type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  If only the first two arguments are given, computes the correlogram
	  for <argname>x</argname> for lags 1 to <argname>p</argname>.  Let
	  <math>k</math> represent the number of elements in
	  <argname>x</argname> (1 if <argname>x</argname> is a series, the
	  number of columns if <argname>x</argname> is a matrix, or the number
	  of list-members is <argname>x</argname> is a list).  The return
	  value is a matrix with <argname>p</argname> rows and 2<math>k</math>
	  columns, the first <math>k</math> columns holding the respective
	  autocorrelations and the remainder the respective partial
	  autocorrelations.
	</para>
	<para>
	  If a third argument is given, this function computes the
	  cross-correlogram for each of the <math>k</math> elements in
	  <argname>x</argname> and <argname>y</argname>, from lead
	  <argname>p</argname> to lag <argname>p</argname>. The returned
	  matrix has 2<math>p</math> + 1 rows and <math>k</math> columns.
          If <argname>x</argname> is series or list and <argname>y</argname>
          is a vector, the vector must have just as many rows as there
          are observations in the current sample range.
	</para>
      </description>
    </function>

    <function name="cos" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Funzione coseno.
	  <seelist>
	    <fncref targ="sin"/>
	    <fncref targ="tan"/>
	    <fncref targ="atan"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cosh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the hyperbolic cosine of <argname>x</argname>.
	</para>
	<para context="tex">
	  \[ \cosh x = \frac{e^x + e^{-x}}{2}  \]
	</para>
	<para>
	  <seelist>
	    <fncref targ="acosh"/>
	    <fncref targ="sinh"/>
	    <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cov" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">y1</fnarg>
	<fnarg type="series">y2</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes the covariance between <argname>y1</argname> and
	  <argname>y2</argname>. 
	  <seelist> 
	    <fncref targ="corr"/> 
	    <fncref targ="mcov"/>
	    <fncref targ="mcorr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="critical" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="char">c</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">p</fnarg>
      </fnargs>
      <examples>
	<example>c1 = critical(t, 20, 0.025)</example>
	<example>c2 = critical(F, 4, 48, 0.05)</example>
      </examples>
      <description>
	<para>
	  Calcola i valori critici, ossia <math>x</math> tale che
	  <equation status="inline" ascii="P(X &gt; x) = p" tex="$P(X
	  &gt; x) = p$"/>, dove la distribuzione di <math>X</math> è
	  determinata dal carattere <argname>c</argname>. Tra gli
	  argomenti <argname>c</argname> e <argname>x</argname>,
	  possono essere richiesti parametri aggiuntivi a seconda
	  della distribuzione, come specificato qui di seguito.
	</para>
	<ilist context="notex">
	  <li>
	    <para>
	      Normale standard (c = z, n, or N): no argomenti extra
	    </para>
	  </li>
	  <li>
	    <para>
	      t di Student (t): gradi di libertà 
	    </para>
	  </li>
	  <li>
	    <para>
	      Chi quadro (c, x, or X): gradi di libertà
	    </para>
	  </li>
	  <li>
	    <para>
	      F di Snedecor (f or F): gradi di libertà (num.); gradi
	      di libertà (den.)
	    </para>
	  </li>
	  <li>
	    <para>
	      Binomiale (b or B): probabilità; numero di prove
	    </para>
	  </li>	  
	  <li>
	    <para>
	      Poisson (p or P): Media
	    </para>
	  </li>	  
	</ilist>
	<para>
	  <seelist>
	    <fncref targ="cdf"/>
	    <fncref targ="invcdf"/>
	    <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>  

    <function name="cum" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Cumulates <argname>x</argname>. When <argname>x</argname> is a
	  series, produces a series <math>y</math> each of whose elements is
	  the sum of the values of <argname>x</argname> to date; the starting
	  point of the summation is the first non-missing observation in the
	  currently selected sample. When <argname>x</argname> is a matrix,
	  its elements are cumulated by columns.
	</para>
	<para context="tex">
	  Cumulates <argname>x</argname>. When <math>x</math> is a series,
	  produces a series $y_t = \sum_{s=m}^t x_s$; the starting point of
	  the summation, <math>m</math>, is the first non-missing observation
	  of the currently selected sample.  If any missing values are
	  encountered in <math>x</math>, subsequent values of <math>y</math>
	  will be set to missing. When <argname>x</argname> is a matrix, its
	  elements are cumulated by columns.
	</para>
	<para>
	  <seelist>
	    <fncref targ="diff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="deseas" section="filters" output="series">
      <fnargs>
	<fnarg type="series">x</fnarg>
	<fnarg optional="true" type="char">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Depends on having TRAMO/SEATS or X-12-ARIMA installed. Returns a
	  deseasonalized (seasonally adjusted) version of the input series
	  <argname>x</argname>, which must be a quarterly or monthly time
	  series.  To use X-12-ARIMA give <lit>X</lit> as the second argument;
	  to use TRAMO give <lit>T</lit>.  If the second argument is omitted
	  then X-12-ARIMA is used.
	</para>
	<para>
	  Note that if the input series has no detectable seasonal
	  component this function will fail.  Also note that both
	  TRAMO/SEATS and X-12-ARIMA offer numerous options;
	  <lit>deseas</lit> calls them with all options at their default
	  settings. For both programs, the seasonal factors are calculated
	  on the basis of an automatically selected ARIMA model. One
	  difference between the programs which can sometimes make a
	  substantial difference to the results is that by default TRAMO
	  performs a prior adjustment for outliers while X-12-ARIMA does
	  not.
	</para>
      </description>
    </function>

    <function name="det" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il determinante di <argname>A</argname>,
	  calcolato trmite la scomposizione LU.
	  <seelist> 
	    <fncref targ="ldet"/>
	    <fncref targ="rcond"/>
	  </seelist>
	</para>
      </description>
    </function>  

    <function name="diag" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce la diagonale principale di <argname>X</argname> in
	  un vettore colonna. Nota: se <argname>X</argname> è una
	  matrice <by r="m" c="n"/>, il numero di elementi del vettore
	  risultato è min(<math>m</math>, <math>n</math>).
	  <seelist>
	    <fncref targ="tr"/>
	  </seelist>
	</para>
      </description>
    </function>


    <function name="diagcat" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix">B</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce la simma diretta di <argname>A</argname> e
	  <argname>B</argname>, ossia una matrice che ha
	  <argname>A</argname> nell'angolo nord-ovest e
	  <argname>B</argname> in quello sud-est. Se
	  <argname>A</argname> e <argname>B</argname> sono entrambe
	  quadrate, la matrice risultato è diagonale a blocchi.
	</para>
      </description>
    </function>

    <function name="diff" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="smlist">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes first differences.  If <argname>y</argname> is a series, or
	  a list of series, starting values are set to <lit>NA</lit>.  If
	  <argname>y</argname> is a matrix, differencing is done by columns
	  and starting values are set to 0.
	</para>
	<para>
	  <seelist>
	    <fncref targ="cum"/>
	    <fncref targ="ldiff"/>
	    <fncref targ="sdiff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="digamma" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>    
      <description>
	<para context="notex">
	  Returns the digamma (or Psi) function
	  of <argname>x</argname>, that is the derivative of the log
	  of the Gamma function.
	</para>
	<para context="tex">
	  Returns the digamma (or Psi) function of $x$, that is 
	  $\frac{\mathrm{d} \Gamma(x)}{\mathrm{d} x}$.
	</para>
      </description>
    </function>

    <function name="dnorm" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce la funzione di densità per una normale standard. 
	  <seelist>
	    <fncref targ="cnorm"/>
	    <fncref targ="qnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="dsort" section="matshape" output="asinput">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Ordina <argname>x</argname> in ordine discendente, saltando
	  le osservazioni con valori mancanti se <argname>x</argname> è
	  una serie. 
	  <seelist> 
	    <fncref targ="sort"/>
	    <fncref targ="values"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="dummify" section="transforms" output="list">
      <fnargs>
	<fnarg type="series">x</fnarg>
	<fnarg optional="true" type="scalar">omitval</fnarg>
      </fnargs>
      <description>
	<para>
	  The argument <argname>x</argname> should be a discrete series. This
	  function creates a set of dummy variables coding for the distinct
	  values in the series.  By default the smallest value is taken as the
	  omitted category and is not explicitly represented.
	</para>
	<para>
	  The optional second argument represents the value of
	  <argname>x</argname> which should be treated as the omitted
	  category. The effect when a single argument is given is equivalent
	  to <lit>dummify(x, min(x))</lit>.  To produce a full set of dummies,
	  with no omitted category, use <lit>dummify(x, NA)</lit>.
	</para>
	<para> 
	  The generated variables are automatically named according to
	  the template
	  <lit>D</lit><repl>varname</repl><lit>_</lit><repl>i</repl> where
	  <repl>varname</repl> is the name of the original series and
	  <repl>i</repl> is a 1-based index.  The original portion of the name
	  is truncated if necessary, and may be adjusted in case of
	  non-uniqueness in the set of names thus constructed. 
	</para>
      </description>
    </function>

    <function name="eigengen" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes the eigenvalues, and optionally the right eigenvectors, of
	  the <by r="n" c="n"/> matrix <argname>A</argname>.  If all the
	  eigenvalues are real, an <by r="n" c="1"/> matrix is returned;
	  otherwise, the result is an <by r="n" c="2"/> matrix, the first
	  column holding the real components and the second column the
	  imaginary components.
	</para>
	<para>
	  The second argument must be either the name of an existing
	  matrix preceded by <lit>&amp;</lit> (to indicate the
	  <quote>address</quote> of the matrix in question), in which case
	  an auxiliary result is written to that matrix, or the keyword
	  <lit>null</lit>, in which case the auxiliary result is not
	  produced.
	</para>
	<para>
	  If a non-null second argument is given, the specified matrix
	  will be over-written with the auxiliary result.  (It is not
	  required that the existing matrix be of the right dimensions to
	  receive the result.) It will be organized as follows:
	</para>
	<ilist>
	  <li>
	    <para>
	      If the <math>i</math>-th eigenvalue is real, the
	      <math>i</math>-th column of <math>U</math> will contain the
	      corresponding eigenvector;
	    </para>
	  </li>
	  <li>
	    <para>
	      If the <math>i</math>-th eigenvalue is complex, the
	      <math>i</math>-th column of <argname>U</argname> will
	      contain the real part of the corresponding eigenvector and
	      the next column the imaginary part. The eigenvector for the
	      conjugate eigenvalue is the conjugate of the eigenvector.
	    </para>
	  </li>
	</ilist>
	<para>
	  In other words, the eigenvectors are stored in the same order as
	  the eigenvalues, but the real eigenvectors occupy one column,
	  whereas complex eigenvectors take two (the real part comes
	  first); the total number of columns is still <math>n</math>,
	  because the conjugate eigenvector is skipped.
	</para>
	<para>
	  <seelist>
	    <fncref targ="eigensym"/>
	    <fncref targ="qrdecomp"/>
	    <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="eigensym" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes the eigenvalues, and optionally the right eigenvectors, of
	  the <by r="n" c="n"/> symmetrix matrix <argname>A</argname>; the
	  second argument must be either the name of an existing matrix
	  preceded by <lit>&amp;</lit> (to indicate the <quote>address</quote>
	  of the matrix in question), in which case an auxiliary result is
	  written to that matrix, or the keyword <lit>null</lit>, in which
	  case the auxiliary result is not produced.
	</para>
	<para>
	  If the second argument is not <lit>null</lit>, the specified
	  matrix will be over-written with the auxiliary result.  (It is
	  not required that the existing matrix be of the right dimensions
	  to receive the result.)
	</para>
	<para>
	  <seelist>
	    <fncref targ="eigengen"/>
	    <fncref targ="qrdecomp"/>
	    <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>


    <function name="eigsolve" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="symmat">A</fnarg>
	<fnarg type="symmat">B</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Solves the generalized eigenvalue problem |<math>A</math>
	  &minus; &lgr;<math>B</math>| = 0, where both <math>A</math>
	  and <math>B</math> are symmetric and <math>B</math> is
	  positive definite. The eigenvalues are returned directly,
	  arranged in ascending order. If the optional third argument
	  is given it should be the name of an existing matrix
	  preceded by <lit>&amp;</lit>; in that case the generalized
	  eigenvectors are written to the named matrix.
	</para>
      </description>
    </function>

    <function name="epochday" section="calendar" output="scalar-or-series">
      <fnargs>
	<fnarg type="scalar">year</fnarg>
	<fnarg type="scalar">month</fnarg>
	<fnarg type="scalar">day</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the number of the day in the current epoch specified by
	  year, month and day (which equals 1 for the first of January in
	  the year 1 AD).
	</para>
      </description>
    </function>

    <function name="errmsg" section="strings" output="string">
      <fnargs>
	<fnarg type="scalar">errno</fnarg>
      </fnargs>
      <description>
	<para>
	  Retrieves the gretl error message associated with
	  <argname>errno</argname>. See also <fncref
	  targ="$error"/>.
	</para>
      </description>
    </function>

    <function name="exp" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Exponential. Note: in case of matrices, the function acts element
	  by element. For the matrix exponential function, see <fncref
	  targ="mexp"/>.
	</para>
      </description>
    </function>


    <function name="fcstats" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="series-or-vec">f</fnarg>
      </fnargs>
      <description>
	<para>
	  Produces a column vector holding several statistics which may be
	  used for evaluating the series <argname>f</argname> as a
	  forecast of the series <argname>y</argname> over the current
	  sample range. Two vectors of the same length may be given in
	  place of two series arguments.
	</para>
	<para>
	  The layout of the returned vector is as follows:
	</para>
	<code>
	  1  Mean Error (ME)
	  2  Mean Squared Error (MSE)
	  3  Mean Absolute Error (MAE)
	  4  Mean Percentage Error (MPE)
	  5  Mean Absolute Percentage Error (MAPE)
	  6  Theil's U 
	  7  Bias proportion, UM
	  8  Regression proportion, UR
	  9  Disturbance proportion, UD
	</code>
	<para>
	  For details on the calculation of these statistics, and the
	  interpretation of the <math>U</math> values, please see 
	  <guideref targ="chap-forecast"/>.
	</para>
      </description>
    </function>

    <function name="fdjac" section="numerical" output="matrix">
      <fnargs>
	<fnarg type="cvec">b</fnarg>
	<fnarg type="string">s</fnarg>
      </fnargs> 
      <description>
	<para>
	  Calculates the (forward-difference approximation to the) Jacobian
	  associated with the vector <argname>b</argname> and the
	  transformation function defined by the function call in the string
	  <argname>s</argname>. For more details and examples see the chapter
	  on special functions in <lit>genr</lit> in 
	  <guideref targ="sec:genr-numerical"/>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="BFGSmax"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="fft" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Discrete real Fourier transform. If the input matrix
	  <argname>X</argname> has <math>n</math> columns, the output has
	  2<math>n</math> columns, where the real parts are stored in the
	  odd columns and the complex parts in the even ones.
	</para>
	<para>
	  Should it be necessary to compute the Fourier transform on several
	  vectors with the same number of elements, it is numerically more
	  efficient to group them into a matrix rather than invoking
	  <lit>fft</lit> for each vector separately.  
	  <seelist>
	    <fncref targ="ffti"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ffti" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Inverse discrete real Fourier transform. It is assumed that
	  <argname>X</argname> contains <math>n</math> complex column
	  vectors, with the real part in the odd columns and the imaginary
	  part in the even ones, so the total number of columns should be
	  2<math>n</math>. A matrix with <math>n</math> columns is
	  returned.
	</para>
	<para>
	  Should it be necessary to compute the inverse Fourier transform on
	  several vectors with the same number of elements, it is
	  numerically more efficient to group them into a matrix rather
	  than invoking <lit>ffti</lit> for each vector separately.
	  <seelist>
	    <fncref targ="fft"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="filter" section="filters" output="series">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
	<fnarg optional="true" type="scalar-or-vec">a</fnarg>
	<fnarg optional="true" type="scalar-or-vec">b</fnarg>
	<fnarg optional="true" type="scalar">y0</fnarg>
      </fnargs>
      <description>
	<para>
	Applica un filtro di tipo ARMA all'argomento
	<argname>x</argname>. In formule, la trasformazione è
	</para>
	<para context="tex">
	  \[ y_t = \sum_{i=0}^q a_i x_{t-i} + \sum_{i=i}^p b_i y_{t-i} \]
	</para>
	<para context="notex">
	  <math>y</math><sub>t</sub> = 
	  <math>a</math><sub>0</sub> <math>x</math><sub>t</sub> +
	  <math>a</math><sub>1</sub> <math>x</math><sub>t-1</sub> +
	  ...
	  <math>a</math><sub>q</sub> <math>x</math><sub>t-q</sub> +
	  <math>b</math><sub>1</sub> <math>y</math><sub>t-1</sub> +
	  ...
	  <math>b</math><sub>p</sub> <math>y</math><sub>t-p</sub>
	</para>
	<para>
	  Se l'algomento <argname>x</argname> è una serie, il risultato
	  sarà esso stesso una serie. Se invece <argname>x</argname>
	  è una matrice con <math>T</math> righe e <math>k</math>
	  colonne, il risultato sarà una matrice delle stesse dimensioni, in
	  cui il filtraggio vien fatto colonna per colonna.
	</para>
	<para>
	  I due argomenti <argname>a</argname> e <argname>b</argname>
	  sono opzionali. Possono essere scalari, vettori o la
	  parola <lit>null</lit>.
	</para>
	<para>
	  Se <argname>a</argname> è uno scalare, viene usato come
	  <math>a</math><sub>0</sub> e implica <math>q=0</math>; se è
	  un vettore di <math>q+1</math> elementi, contiene i
	  coefficienti da <math>a</math><sub>0</sub> ad
	  <math>a</math><sub>q</sub>. Se <argname>a</argname> è
	  <lit>null</lit> oppure omesso, è equivalente ad
	  <math>a</math><sub>0</sub><math>=1</math> e
	  <math>q=0</math>.
	</para>
	<para>
	  Se <argname>b</argname> è uno scalare, viene usato come
	  <math>b</math><sub>1</sub> ed implica <math>p=1</math>; se è
	  un vettore di <math>p</math> elementi, essi sono
	  interpretati come i coefficienti da
	  <math>b</math><sub>1</sub> a <math>b</math><sub>p</sub>. Se
	  <argname>b</argname> è <lit>null</lit> oppure omesso, è
	  equivalente a <math>B(L)=1</math>.
	</para>
	<para>
	  L'argomento scalare opzionale <argname>y0</argname>
	  rappresenta i valori di <math>y</math> antecedenti
	  all'inizio del campione (usato solo se <math>p>0</math>). Se
	  omesso, si intende 0.  Valori di <argname>x</argname>
	  antecedenti all'inizio del campione sono sempre considerati
	  0.
	</para>
	<para>
	  <seelist> 
	    <fncref targ="bkfilt"/>
	    <fncref targ="bwfilt"/>
	    <fncref targ="fracdiff"/>
	    <fncref targ="hpfilt"/>
	    <fncref targ="movavg"/>
	    <fncref targ="varsimul"/>
	  </seelist>
	</para>
	<para>
	  Esempio:
	</para>
	<code>
	  nulldata 5
	  y = filter(index, 0.5, -0.9, 1)
	  print index y --byobs
	  x = seq(1,5)' ~ (1 | zeros(4,1))
	  w = filter(x, 0.5, -0.9, 1)
	  print x w
	</code>
	<para>
	  produces
	</para>
	<code>
                   index            y   
           			      
          1            1     -0.40000   
          2            2      1.36000   
          3            3      0.27600   
          4            4      1.75160   
          5            5      0.92356   

          x (5 x 2)
           
            1   1 
            2   0 
            3   0 
            4   0 
            5   0 
           
          w (5 x 2)
           
              -0.40000     -0.40000 
                1.3600      0.36000 
               0.27600     -0.32400 
                1.7516      0.29160 
               0.92356     -0.26244 
	</code>
      </description>
    </function>

    <function name="firstobs" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  First non-missing observation for the variable
	  <argname>y</argname>. Note that if some form of subsampling is
	  in effect, the value returned may be smaller than the dollar
	  variable <fncref targ="$t1"/>. 
	  <seelist> 
	    <fncref targ="lastobs"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="fixname" section="strings" output="string">
      <fnargs>
	<fnarg type="string">rawname</fnarg>
      </fnargs>
      <description>
	<para>
	  Intended for use in connection with the <cmdref
	  targ="join"/> command.  Returns the result of converting
	  <argname>rawname</argname> to a valid gretl identifier,
	  which must start with a letter, contain nothing but (ASCII)
	  letters, digits and the underscore character, and must not
	  exceed 31 characters. The rules used in conversion are:
	</para>
	<para>
	  1. Skip any leading non-letters.
	</para>
	<para>
	  2. Until the 31-character limit is reached or the input is
	  exhausted: transcribe <quote>legal</quote> characters; skip
	  <quote>illegal</quote> characters apart from spaces; and
	  replace one or more consecutive spaces with an underscore,
	  unless the last character transcribed is an underscore in
	  which case space is skipped.
	</para>
      </description>
    </function>

    <function name="floor" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">y</fnarg>
      </fnargs>    
      <description>
	<para>
	  Floor function: returns the greatest integer less than or equal
	  to <argname>x</argname>. Note: <fncref targ="int"/> and
	  <lit>floor</lit> differ in their effect for negative arguments:
	  <lit>int(-3.5)</lit> gives &minus;3, while
	  <lit>floor(-3.5)</lit> gives &minus;4. 
	</para>
      </description>
    </function>

    <function name="fracdiff" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="scalar">d</fnarg>
      </fnargs>    
      <description>
	<para context="notex">
	  Returns the fractional difference of order <argname>d</argname>
	  for the series <argname>y</argname>.
	</para>	  
	<para context="tex">
	    \[
	    \Delta^d y_t = y_t - \sum_{i=1}^{\infty} \psi_i y_{t-i}
	    \]
	  where
	    \[\psi_i = \frac{\Gamma(i-d)}{\Gamma(-d) \Gamma(i+1)}\]
	</para>
	<para>
	  Note that in theory fractional differentiation is an infinitely
	  long filter. In practice, presample values of
	  <math>y</math><sub>t</sub> are assumed to be zero.
	</para>
      </description>
    </function>

    <function name="gammafun" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>    
      <description>
	<para>
	  Returns the gamma function of <argname>x</argname>. 
	</para>
      </description>
    </function>

    <function name="getenv" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>    
      <description>
	<para>
	  If an environment variable by the name of
	  <argname>s</argname> is defined, returns the string value of
	  that variable, otherwise returns an empty string.
	  See also <fncref targ="ngetenv"/>.
	</para>
      </description>
    </function>

    <function name="getline" section="strings" output="scalar">
      <fnargs>
	<fnarg type="string">source</fnarg>
	<fnarg type="string">target</fnarg>
      </fnargs>    
      <description>
	<para>
	  This function is used to read successive lines from
	  <argname>source</argname>, which should be a named string
	  variable. On each call a line from the source is written to
	  <argname>target</argname> (which must also be a named string
	  variable), with the newline character stripped off. The
	  valued returned is 1 if there was anything to be read
	  (including blank lines), 0 if the source has been exhausted.
	</para>
	<para>
	  Here is an example in which the content of a text file is
	  broken into lines:
	</para>
	<code>
	  string s = readfile("data.txt")
	  string line
	  scalar i = 1
	  loop while getline(s, line)
	    printf "line %d = '%s'\n", i++, line
          endloop
	</code>
	<para>
	  In this example we can be sure that the source is exhausted
	  when the loop terminates. If the source might not be
	  exhausted you should follow your regular call(s) to
	  <lit>getline</lit> with a <quote>clean up</quote> call, in which
	  <argname>target</argname> is replaced by <lit>null</lit> (or
	  omitted altogether) as in
	</para>
	<code>
	  getline(s, line)
	  getline(s, null)
	</code>
	<para>
	  Note that although the reading position advances at each call
	  to <lit>getline</lit>, <argname>source</argname> is not modified
	  by this function, only <argname>target</argname>.
	</para>
      </description>
    </function>

    <function name="ghk" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">C</fnarg>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix">B</fnarg>
	<fnarg type="matrix">U</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes the GHK (Geweke, Hajivassiliou, Keane) approximation to the
	  multivariate normal distribution function; see for example <cite
	  key="geweke91">Geweke (1991)</cite>. The value returned is an <by
	  r="n" c="1"/> vector of probabilities.
	</para>
	<para>
	  The argument <argname>C</argname> (<by r="m" c="m"/>) should give
	  the Cholesky decomposition (lower triangular) of the covariance
	  matrix of the <math>m</math> normal variates.  The arguments
	  <argname>A</argname> and <argname>B</argname> should both be <by
	  r="n" c="m"/>, giving respectively the lower and upper bounds
	  applying to the variates at each of <math>n</math>
	  observations. Where variates are unbounded, this should be indicated
	  using the built-in constant <fncref targ="$huge"/> or its negative.
	</para>
	<para>
	  The matrix <argname>U</argname> should be <by r="m" c="r"/>, with
	  <math>r</math> the number of pseudo-random draws from the uniform
	  distribution; suitable functions for creating <argname>U</argname>
	  are <fncref targ="muniform"/> and <fncref targ="halton"/>.
	</para>
	<para>
	  In the following example, the series <argname>P</argname>
	  and <argname>Q</argname> should be numerically very similar
	  to one another, <argname>P</argname> being the "true"
	  probability and <argname>Q</argname> its GHK approximation:
	</para>
	<code>
	  nulldata 20
	  series inf1 = -2*uniform()
	  series sup1 = 2*uniform()
	  series inf2 = -2*uniform()
	  series sup2 = 2*uniform()

	  scalar rho = 0.25
	  matrix V = {1, rho; rho, 1}

	  series P = cdf(D, rho, inf1, inf2) - cdf(D, rho, sup1, inf2) \
	  - cdf(D, rho, inf1, sup2) + cdf(D, rho, sup1, sup2)

	  C = cholesky(V)
	  U = muniform(2, 100)

	  series Q = ghk(C, {inf1, inf2}, {sup1, sup2}, U)
	</code>
      </description>
    </function>

    <function name="gini" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>    
      <description>
	<para>
	  Produce l'indice di Gini per la serie <argname>y</argname>.
	</para>
      </description>
    </function>

    <function name="ginv" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
      </fnargs>    
      <description>
	<para>
	  Returns <math>A</math><sup>+</sup>, the Moore&ndash;Penrose 
	  or generalized inverse of <argname>A</argname>, computed
	  via the singular value decomposition.
	</para>
	<para context="tex">
	  This matrix has the properties
	  \begin{eqnarray*}
	  A A^+ A &amp; = &amp; A \\
	  A^+ A A^+ &amp; = &amp; A^+ 
	  \end{eqnarray*}
	</para>
	<para>
	  <seelist>
	    <fncref targ="inv"/>
	    <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="halton" section="stats" output="matrix">
      <fnargs>
	<fnarg type="scalar">m</fnarg>
	<fnarg type="scalar">r</fnarg>
	<fnarg optional="true" type="scalar">offset</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns an <by r="m" c="r"/> matrix containing
	  <math>m</math> Halton sequences of length <math>r</math>;
	  <math>m</math> is limited to a maximum of 40. The sequences
	  are contructed using the first <math>m</math> primes. By
	  default the first 10 elements of each sequence are
	  discarded, but this figure can be adjusted via the optional
	  <argname>offset</argname> argument, which should be a
	  non-negative integer. See <cite key="halton64">Halton and
	  Smith (1964)</cite>.
	</para>
      </description>
    </function>

    <function name="hdprod" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">Y</fnarg>
      </fnargs>
      <description>
	<para>
	  Horizontal direct product. The two arguments must have the
	  same number of rows, <math>r</math>. The return value is a
	  matrix with <math>r</math> rows, in which the
	  <math>i</math>-th row is the Kronecker product of the
	  corresponding rows of <argname>X</argname> and
	  <argname>Y</argname>.
	</para>
	<para context="tex">
	  In other words, if $X$ is an $r \times k$ matrix, $Y$ is an
	  $r \times m$ matrix and $Z$ is the result matrix of the
	  horizontal direct product of $X$ times $Y$, then $Z$ will
	  have $r$ rows and $k\cdot m$ columns; moreover, 
	  \[ 
	  Z_{in} = X_{ij} Y_{il} 
	  \]
	  where $n = (j-1) m + l$.
	</para>
	<para>
	  As far as we know, there isn't an established name for this
	  operation in matrix algebra. "Horizontal direct product" is
	  the way this operation is called in the GAUSS programming
	  language.
	</para>
	<para>
	  Example: the code
	</para>
	<code>
	  A = {1,2,3; 4,5,6}
	  B = {0,1; -1,1}
	  C = hdprod(A, B)
	</code>
	<para>
	  produces the following matrix:
	</para>
	<code>
         0    1    0    2    0    3 
        -4    4   -5    5   -6    6 
	</code>
      </description>
    </function>

    <function name="hpfilt" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the cycle component from application of the
	  Hodrick&ndash;Prescott filter to series <argname>y</argname>. If the
	  smoothing parameter, <argname>lambda</argname>, is not supplied then
	  a data-based default is used, namely 100 times the square of the
	  periodicity (100 for annual data, 1600 for quarterly data, and so
	  on).  
	  <seelist> 
	    <fncref targ="bkfilt"/>
	    <fncref targ="bwfilt"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="I" section="matbuild" output="smatrix">
      <fnargs>
	<fnarg type="scalar">n</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns an identity matrix with <argname>n</argname> rows and
	  columns.
	</para>
      </description>
    </function>

    <function name="imaxc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce un vettore contenente gli indici riga dei massimi
	  delle colonne di <argname>X</argname>.
	  <seelist> 
	    <fncref targ="imaxr"/> 
	    <fncref targ="iminc"/>
	    <fncref targ="maxc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="imaxr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>    
      <description>
	<para>
	  Restituisce un vettore contenente gli indici colonna dei massimi
	  delle righe di <argname>X</argname>.
	  <seelist> 
	    <fncref targ="imaxc"/>
	    <fncref targ="iminr"/>
	    <fncref targ="maxr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="imhof" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="scalar">x</fnarg>
      </fnargs>    
      <description>
	<para context="notex">
	  Computes Prob(<math>u'Au</math> &lt; <math>x</math>) for a quadratic
	  form in standard normal variates, <math>u</math>, using the procedure
	  developed by <cite key="imhof61">Imhof (1961)</cite>.
	</para>
	<para context="tex">
	  Computes ${\rm Prob}(u'Au &lt; x)$ for a quadratic form in standard
	  normal variates, $u$, using the procedure developed by
	  <cite key="imhof61">Imhof (1961)</cite>.
	</para>
	<para>
	  If the first argument, <argname>M</argname>, is a square matrix it
	  is taken to specify <math>A</math>, otherwise if it's a column
	  vector it is taken to be the precomputed eigenvalues of
	  <math>A</math>, otherwise an error is flagged.
	</para>
	<para>
	  <seelist>
	    <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="iminc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>    
      <description>
	<para>
	  Restituisce un vettore contenente gli indici riga dei minimi
	  delle colonne di <argname>X</argname>.
	  <seelist>
	    <fncref targ="imaxc"/>
	    <fncref targ="iminr"/>
	    <fncref targ="minc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="iminr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>    
      <description>
	<para>
	  Restituisce un vettore contenente gli indici colonna dei minimi
	  delle righe di <argname>X</argname>.
	  <seelist>
	    <fncref targ="imaxr"/> 
	    <fncref targ="iminc"/>
	    <fncref targ="minr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="inbundle" section="data-utils" output="int">
      <fnargs>
	<fnarg type="bundle">b</fnarg>
	<fnarg type="string">chiave</fnarg>
      </fnargs>    
      <description>
	<para>
	  Restituisce 1 se il bundle <argname>b</argname> contiene un
	  elemento di nome <argname>chiave</argname> e 0 altrimenti.
	</para>	  
      </description>
    </function>   

    <function name="infnorm" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>    
      <description>
	<para context="notex">
	  Returns the infinity-norm of <argname>X</argname>, that is,
	  the maximum across the rows of <argname>X</argname> of
	  the sum of absolute values of the row elements.
	</para>
	<para context="tex">
	  Returns the $\infty$-norm of the $r\times c$ matrix
	  <argname>X</argname>, namely, 
	    \[\| X \|_{\infty} = \max_i \sum_{j=1}^c |X_{ij}|\]
	</para>
	<para>
	  <seelist>
	    <fncref targ="onenorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="inlist" section="data-utils" output="int">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg type="series">y</fnarg>
      </fnargs>    
      <description>
	<para>
	  Returns the (1-based) position of <argname>y</argname> in
	  list <argname>L</argname>, or 0 if <argname>y</argname>
	  is not present in <argname>L</argname>. The second
	  argument may be given as the name of a series or
	  alternatively as an integer ID number.
	</para>
      </description>
    </function>

    <function name="int" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>  
      <description>
	<para>
	  Truncates the fractional part of <argname>x</argname>. Note:
	  <lit>int</lit> and <fncref targ="floor"/> differ in their effect
	  for negative arguments: <lit>int(-3.5)</lit> gives &minus;3,
	  while <lit>floor(-3.5)</lit> gives &minus;4. 
	  <seelist> 
	    <fncref targ="ceil"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="inv" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>  
      <description>
	<para>
	  Returns the inverse of <argname>A</argname>. If
	  <argname>A</argname> is singular or not square, an error message
	  is produced and nothing is returned. Note that gretl checks
	  automatically the structure of <argname>A</argname> and uses the
	  most efficient numerical procedure to perform the inversion.
	</para>
	<para>
	  The matrix types gretl checks for are: identity; diagonal;
	  symmetric and positive definite; symmetric but not positive
	  definite; and triangular.
	</para>
	<para>
	  <seelist>
	    <fncref targ="ginv"/>
	    <fncref targ="invpd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="invcdf" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="char">c</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">p</fnarg>
      </fnargs>
      <description>
	<para>
	  Inverse cumulative distribution function calculator. Returns
	  <math>x</math> such that
	  <equation status="inline" ascii="P(X &lt; x) = p"  
	  tex="$P(X \le x) = p$"/>, where the distribution <math>X</math>
	  is determined by the character <argname>c</argname>; Between the
	  arguments <argname>c</argname> and <argname>p</argname>, zero or
	  more additional arguments are required to specify the parameters
	  of the distribution, as follows.
	</para>
	<ilist context="notex">
	  <li>
	    <para>
	      Standard normal (c = z, n, or N): no extra arguments
	    </para>
	  </li>
	  <li>
	    <para>
	      Student's t (t): degrees of freedom
	    </para>
	  </li>
	  <li>
	    <para>
	      Chi square (c, x, or X): degrees of freedom
	    </para>
	  </li>
	  <li>
	    <para>
	      Snedecor's F (f or F): df (num.); df (den.)
	    </para>
	  </li>
	  <li>
	    <para>
	      Binomial (b or B): probability; trials
	    </para>
	  </li>
	</ilist>
	<para context="tex">
	  \begin{center} 
	  \begin{tabular}{llll} 
	  \textit{Distribution} &amp; code, $c$ &amp;
	  \textit{Arg} 2 &amp; \textit{Arg} 3 \\[4pt] 
	  Standard normal &amp; \texttt{z}, \texttt{n} or \texttt{N} &amp;
	  -- &amp; -- \\ 
	  Student's $t$ (central) &amp; \texttt{t} &amp; 
	  degrees of freedom &amp; -- \\ 
	  Chi square &amp; \texttt{c}, \texttt{x} or \texttt{X} &amp; 
	  degrees of freedom &amp; -- \\
	  Snedecor's $F$ &amp; \texttt{f} or \texttt{F} &amp; 
	  df (num.) &amp; df (den.) \\ 
	  Binomial &amp; \texttt{b} or \texttt{B} &amp; 
	  $p$ &amp; $n$ \\
	  \end{tabular}
	  \end{center}
	</para>
	<para>
	  <seelist>
	    <fncref targ="cdf"/>
	    <fncref targ="critical"/>
	    <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="invmills" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>  
      <description>
	<para>
	  Returns the inverse Mills ratio at <argname>x</argname>, that is
	  the ratio between the standard normal density and the complement
	  to the standard normal distribution function, both evaluated at
	  <argname>x</argname>. 
	</para>
	<para>
	  This function uses a dedicated algorithm which yields greater
	  accuracy compared to calculation using <fncref targ="dnorm"/>
	  and <fncref targ="cnorm"/>, but the difference between the two
	  methods is appreciable only for very large negative values of
	  <argname>x</argname>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="cdf"/>
	    <fncref targ="cnorm"/>
	    <fncref targ="dnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="invpd" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="symmat">A</fnarg>
      </fnargs>  
      <description>
	<para>
	  Returns the inverse of the symmetric, positive definite matrix
	  <argname>A</argname>.   This function is slightly faster than
	  <fncref targ="inv"/> for large matrices, since no check for
	  symmetry is performed; for that reason it should be used with
	  care.
	</para>
      </description>
    </function>

    <function name="irf" section="stats" output="matrix">
      <fnargs>
	<fnarg type="scalar">target</fnarg>
	<fnarg type="scalar">shock</fnarg>
	<fnarg type="pscalar" optional="true">alpha</fnarg>
      </fnargs>  
      <description>
	<para>
	  This function is available only when the last model
	  estimated was a VAR or VECM. It returns a matrix containing
	  the estimated response of the <argname>target</argname>
	  variable to an impulse of one standard deviation in the
	  <argname>shock</argname> variable. These variables are
	  identified by their position in the VAR specification: for
	  example, if <argname>target</argname> and
	  <argname>shock</argname> are given as 1 and 3 respectively,
	  the returned matrix gives the response of the first variable
	  in the VAR for a shock to the third variable.
	</para>
	<para>
	  If the optional <argname>alpha</argname> argument is given,
	  the returned matrix has three columns: the point estimate of
	  the responses, followed by the lower and upper limits of a 1
	  &minus; &agr; confidence interval obtained via
	  bootstrapping.  (So <argname>alpha</argname> = 0.1
	  corresponds to 90 percent confidence.) If
	  <argname>alpha</argname> is omitted or set to zero, only the
	  point estimate is provided.
	</para>
	<para>
	  The number of periods (rows) over which the response is
	  traced is determined automatically based on the frequency
	  of the data, but this can be overridden via the <cmdref
	  targ="set"/> command, as in <lit>set horizon 10</lit>.
	</para>
      </description>
    </function>

    <function name="irr" section="math" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>  
      <description>
	<para>
	  Returns the Internal Rate of Return for <argname>x</argname>,
	  considered as a sequence of payments (negative) and receipts
	  (positive).
	  <seelist>
	    <fncref targ="npv"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="isconst" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="scalar" optional="true">panel-code</fnarg>
      </fnargs>
      <description>
	<para>
	  Without the optional second argument, returns 1 if
	  <argname>y</argname> has a constant value over the current
	  sample range (or over its entire length if
	  <argname>y</argname> is a vector), otherwise 0.
	</para>
	<para>
	  The second argument is accepted only if the current dataset
	  is a panel and <argname>y</argname> is a series.  In that
	  case a <argname>panel-code</argname> value of 0 calls for a
	  check for time-invariance, while a value of 1 means check
	  for cross-sectional invariance (that is, in each time period
	  the value of <argname>y</argname> is the same for all
	  groups).
	</para>
	<para>
	  If <argname>y</argname> is a series, missing values are
	  ignored in checking for constancy.
	</para>
      </description>
    </function>

    <function name="isnan" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-matrix">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Given a scalar argument, returns 1 if <argname>x</argname>
	  is <quote>Not a Number</quote> (NaN), otherwise 0. Given a
	  matrix argument, returns a matrix of the same dimensions
	  with 1s in positions where the corresponding element of the
	  input is NaN and 0s elsewhere.
	</para>
      </description>
    </function>

    <function name="isnull" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns 0 if <argname>s</argname> is the identifier for a
	  currently defined object, be it a scalar, a series, a matrix or
	  a list. Mainly used for checking arguments passed to functions.
	  <seelist>
	    <fncref targ="islist"/>
	    <fncref targ="isseries"/>
	    <fncref targ="isstring"/>
	  </seelist>
	</para>
      </description>
    </function>  

    <function name="isoconv" section="calendar" output="scalar">
      <fnargs>
	<fnarg type="series">date</fnarg>
	<fnarg type="seriesref">&amp;year</fnarg>
	<fnarg type="seriesref">&amp;month</fnarg>
	<fnarg type="seriesref" optional="true">&amp;day</fnarg>
      </fnargs>
      <description>
	<para>
	  Given a series <argname>date</argname> holding dates in
	  ISO 8601 <quote>basic</quote> format (<lit>YYYYMMDD</lit>),
	  this function writes the year, month and (optionally)
	  day components into the series named by the second and
	  subsequent arguments. An example call, assuming the
	  series <lit>dates</lit> contains suitable 8-digit values:
	</para>
	<code>
	  series y, m, d
	  isoconv(dates, &amp;y, &amp;m, &amp;d)
	</code>
	<para>
	  The return value from this function is 0 on successful
	  completion, non-zero on error.
	</para>
      </description>
    </function>

    <function name="isodate" section="calendar" output="seebelow">
      <fnargs>
	<fnarg type="scalar-or-series">ed</fnarg>
	<fnarg type="bool" optional="true">as-string</fnarg>
      </fnargs>
      <description>
	<para>
	  The argument <argname>ed</argname> is interpreted as an
	  epoch day (which equals 1 for the first of January in the
	  year 1 AD). The default return value &mdash; of the same
	  type as <argname>ed</argname> &mdash; is an 8-digit number,
	  or a series of such numbers, on the pattern
	  <lit>YYYYMMDD</lit> (ISO 8601 <quote>basic</quote> format),
	  giving the calendar date corresponding to the epoch day.
	</para>
	<para>
	  If <argname>ed</argname> is a scalar (only) and the optional
	  second argument <argname>as-string</argname> is non-zero,
	  the return value is not numeric but rather a string on the
	  pattern <lit>YYYY-MM-DD</lit> (ISO 8601
	  <quote>extended</quote> format).
	</para>
	<para>
	  For the inverse function, see <fncref targ="epochday"/>.
	</para>
      </description>
    </function>

    <function name="iwishart" section="stats" output="matrix">
      <fnargs>
	<fnarg type="symmat">S</fnarg>
	<fnarg type="int">v</fnarg>
      </fnargs>
      <description>
	<para>
	  Given <argname>S</argname> (a positive definite <by r="p"
	  c="p"/> scale matrix), returns a drawing from the Inverse
	  Wishart distribution with <argname>v</argname> degrees of
	  freedom. The returned matrix is also <by r="p" c="p"/>.  The
	  algorithm of <cite key="odell-feiveson66">Odell and Feiveson
	  (1966)</cite> is used.
	</para>
      </description>
    </function>

    <function name="kdensity" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series">x</fnarg>
	<fnarg type="scalar" optional="true">scale</fnarg>
	<fnarg type="scalar" optional="true">control</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes a kernel density estimate for the series
	  <argname>x</argname>. The returned matrix has two columns, the
	  first holding a set of evenly spaced abscissae and the second
	  the estimated density at each of these points.
	</para>
	<para>
	  The optional <argname>scale</argname> parameter can be used to
	  adjust the degree of smoothing relative to the default of 1.0
	  (higher values produce a smoother result). The
	  <argname>control</argname> parameter acts as a boolean: 0 (the
	  default) means that the Gaussian kernel is used; a non-zero
	  value switches to the Epanechnikov kernel.
	</para>
	<para>
	  A plot of the results may be obtained using the <cmdref
	  targ="gnuplot"/> command, as in
	</para>
	<code>
	  matrix d = kdensity(x)
	  gnuplot 2 1 --matrix=d --with-lines
	</code>
      </description>
    </function>

    <function name="kfilter" section="filters" output="scalar">
      <fnargs>
	<fnarg optional="true" type="matrixref">&amp;E</fnarg>
	<fnarg optional="true" type="matrixref">&amp;V</fnarg>
	<fnarg optional="true" type="matrixref">&amp;S</fnarg>
	<fnarg optional="true" type="matrixref">&amp;P</fnarg>
	<fnarg optional="true" type="matrixref">&amp;G</fnarg>
      </fnargs>
      <description>
	<para>
	  Requires that a Kalman filter be set up.  Performs a forward,
	  filtering pass and returns 0 on successful completion or 1 
	  if numerical problems are encountered.
	</para>
	<para>
	  The optional matrix arguments can be used to retrieve the following
	  information: <argname>E</argname> gets the matrix of one-step ahead
	  prediction errors and <argname>V</argname> gets the variance matrix
	  for these errors; <argname>S</argname> gets the matrix of estimated
	  values of the state vector and <argname>P</argname> the variance
	  matrix of these estimates; <argname>G</argname> gets the Kalman
	  gain.  All of these matrices have <math>T</math> rows, corresponding
	  to <math>T</math> observations.  For the column dimensions and
	  further details see <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
	    <cmdref targ="kalman"/>
	    <fncref targ="ksmooth"/>
	    <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function> 

    <function name="ksimul" section="filters" output="matrix">
      <fnargs>
	<fnarg type="matrix">v</fnarg>
	<fnarg type="matrix">w</fnarg>
	<fnarg optional="true" type="matrixref">&amp;S</fnarg>
      </fnargs>
      <description>
	<para>
	  Requires that a Kalman filter be set up.  Performs a simulation
	  and returns a matrix holding simulated values of the
	  observable variables.
	</para>
	<para>
	  The argument <argname>v</argname> supplies artificial disturbances
	  for the state transition equation and <argname>w</argname> supplies
	  disturbances for the observation equation, if applicable.  The
	  optional argument <argname>S</argname> may be used to retrieve the
	  simulated state vector.  For details see <guideref
	    targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
	    <cmdref targ="kalman"/>
	    <fncref targ="kfilter"/>
	    <fncref targ="ksmooth"/>
	  </seelist>
	</para>
      </description>
    </function> 

    <function name="ksmooth" section="filters" output="matrix">
      <fnargs>
	<fnarg optional="true" type="matrixref">&amp;P</fnarg>
      </fnargs>
      <description>
	<para>
	  Requires that a Kalman filter be set up.  Performs a backward,
	  smoothing pass and returns a matrix holding smoothed estimates of
	  the state vector.  The optional argument <argname>P</argname> may be
	  used to retrieve the MSE of the smoothed state.  For details see
	  <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
	    <cmdref targ="kalman"/>
	    <fncref targ="kfilter"/>
	    <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function> 

    <function name="kurtosis" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the excess kurtosis of the series <argname>x</argname>,
	  skipping any missing observations.
	</para>
      </description>
    </function>

    <function name="lags" section="transforms" output="list">
      <fnargs>
	<fnarg type="scalar">p</fnarg>
	<fnarg type="series-or-list">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Generates lags 1 to <argname>p</argname> of the series
	  <argname>y</argname>, or if <argname>y</argname> is a list, of all
	  variables in the list.  If <argname>p</argname> = 0, the maximum
	  lag defaults to the periodicity of the data; otherwise
	  <argname>p</argname> must be positive.
	</para>
      </description>
    </function>

    <function name="lastobs" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Last non-missing observation for the variable
	  <argname>y</argname>. Note that if some form of subsampling is
	  in effect, the value returned may be larger than the dollar
	  variable <fncref targ="$t2"/>.
	  <seelist>
	    <fncref targ="firstobs"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ldet" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the natural log of the determinant of <math>A</math>,
	  computed via the LU factorization.
	  <seelist> 
	    <fncref targ="det"/>
	    <fncref targ="rcond"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ldiff" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-or-list">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes log differences; starting values are set to
	  <lit>NA</lit>.
	</para>
      </description>
    </function>

    <function name="lincomb" section="transforms" output="series">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg type="vector">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes a new series as a linear combination of the series in the
	  list <argname>L</argname>.  The coefficients are given by the vector
	  <argname>b</argname>, which must have length equal to the number of
	  series in <argname>L</argname>.
	</para>
	<para>
	  <seelist> 
	    <fncref targ="wmean"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ljungbox" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="scalar">p</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola la statistica Q di Ljung&ndash;Box per la serie y
	  <argname>y</argname> usando <argname>p</argname> ritardi e
	  il campione definito al momento. Il parametro
	  <argname>p</argname> deve essere maggiore o uguale a 1 e
	  minore del numero di osservazioni disponibili.
	</para>
	<para>
	  Questa statistica può essere confrontata alla chi-quadro con
	  <argname>p</argname> gradi di libertà per sottoporre a test
	  l'ipotesi che la variabile <argname>y</argname> sia
	  serialmente incorrelata.
	  <seelist>
	    <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="lngamma" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Log of the gamma function of <argname>x</argname>.
	</para>
      </description>
    </function>

    <function name="log" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Logaritmo naturale; produce <lit>NA</lit> per valori non
	  positivi. Nota: <lit>ln</lit> può anche essere usato invece
	  di <lit>log</lit>.
	</para>
      </description>
    </function>

    <function name="log10" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Base-10 logarithm; produces <lit>NA</lit> for non-positive
	  values.
	</para>
      </description>
    </function>

    <function name="log2" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Base-2 logarithm; produces <lit>NA</lit> for non-positive
	  values.
	</para>
      </description>
    </function>

    <function name="loess" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series">x</fnarg>
	<fnarg optional="true" type="scalar">d</fnarg>
	<fnarg optional="true" type="scalar">q</fnarg>
	<fnarg optional="true" type="scalar">robust</fnarg>
      </fnargs>
      <description>
	<para>
	  Performs locally-weighted polynomial regression and returns
	  a series holding predicted values of <argname>y</argname>
	  for each non-missing value of <argname>x</argname>.  The
	  method is as described by <cite key="cleveland79">William
	  Cleveland (1979)</cite>.
	</para>
	<para>
	  The optional arguments <argname>d</argname> and
	  <argname>q</argname> specify the order of the polynomial in
	  <argname>x</argname> and the proportion of the data points
	  to be used in local estimation, respectively.  The default
	  values are <argname>d</argname> = 1 and <argname>q</argname>
	  = 0.5. The other acceptable values for <argname>d</argname>
	  are 0 and 2. Setting <argname>d</argname> = 0 reduces the
	  local regression to a form of moving average. The value
	  of <argname>q</argname> must be greater than 0 and cannot
	  exceed 1; larger values produce a smoother outcome.
	</para>
	<para>
	  If a non-zero value is given for the <argname>robust</argname>
	  argument the local regressions are iterated twice, with the
	  weights being modified based on the residuals from the previous
	  iteration so as to give less influence to outliers.
	</para>
	<para>
	  See also <fncref targ="nadarwat"/>, and in addition see
	  <guideref targ="chap-nonparam"/> for details on
	  nonparametric methods.
	</para>
      </description>
    </function>

    <function name="logistic" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para context="tex">
	  Returns the logistic function of the argument <argname>x</argname>,
	  that is, $\Lambda(x) = e^x/(1+e^x)$. If <argname>x</argname> is a
	  matrix, the function is applied element by element.
	</para>
	<para context="notex">
	  Returns the logistic function of the argument <argname>x</argname>,
	  that is, <math>e</math><sup>x</sup>/(1 +
	  <math>e</math><sup>x</sup>).  If <argname>x</argname> is a matrix,
	  the function is applied element by element.
	</para>
      </description>
    </function>

    <function name="lower" section="matbuild" output="smatrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Returns an <by r="n" c="n"/> lower triangular matrix: the elements
	  on and below the diagonal are equal to the corresponding elements of
	  <argname>A</argname>; the remaining elements are zero.
	</para>
	<para context="tex">
	  Returns an $n\times n$ lower triangular matrix <math>B</math>
	  for which $B_{ij} = A_{ij}$ if $i \ge j$, and 0 otherwise.
	</para>
	<para>
	  <seelist>
	    <fncref targ="upper"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="lrvar" section="filters" output="scalar">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="scalar">k</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the long-run variance of <argname>y</argname>,
	  calculated using a Bartlett kernel with window size
	  <argname>k</argname>.
	</para>
	<para context="tex">
	  In formulae: 
	  \[ \hat{\omega}^2(k) = \frac{1}{T} \sum_{t=k}^{T-k}
	  \left[ \sum_{i=-k}^k w_i (y_t - \bar{X}) (y_{t-i} - \bar{Y})
	  \right] \] 
	  with 
	  \[ w_i = 1 - \frac{|i|}{k + 1} \]
	</para>
      </description>
    </function>

    <function name="max" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  The maximum of the non-missing observations in series
	  <argname>y</argname>.
	</para>
      </description>
    </function>

    <function name="maxc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the maxima of the columns of <argname>X</argname>.
	  <seelist>
	    <fncref targ="imaxc"/>
	    <fncref targ="maxr"/>
	    <fncref targ="minc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="maxr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the maxima of the rows of <argname>X</argname>. 
	  <seelist>
	    <fncref targ="imaxr"/>
	    <fncref targ="maxc"/> 
	    <fncref targ="minr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mcorr" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes a correlation matrix treating each column of
	  <argname>X</argname> as a variable. 
	  <seelist> 
	    <fncref targ="corr"/>
	    <fncref targ="cov"/>
	    <fncref targ="mcov"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mcov" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes a covariance matrix treating each column of
	  <argname>X</argname> as a variable. 
	  <seelist> 
	    <fncref targ="corr"/>
	    <fncref targ="cov"/>
	    <fncref targ="mcorr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mcovg" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="vector">u</fnarg>
	<fnarg optional="true" type="vector">w</fnarg>
	<fnarg type="scalar">p</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the matrix covariogram for a <by r="T" c="k"/> matrix
	  <argname>X</argname> (typically containing regressors), an
	  (optional) <math>T</math>-vector <argname>u</argname> (typically
	  containing residuals), an (optional) (<math>p</math>+1)-vector
	  of weights <argname>w</argname>, and a scalar lag order
	  <argname>p</argname>, which must be greater than or equal to 0.
	</para>
	<para context="tex">
	  The returned matrix is given by
	  \[\sum_{j=-p}^{p} \sum_j w_{|j|} (X_t' u_t
	  u_{t-j} X_{t-j})\]
	</para>
	<para context="notex">
	  The returned matrix is given by
	</para>
	<para context="notex">	
	  sum_{j=-p}^p sum_j w_{|j|} (X_t' u_t u_{t-j} X_{t-j})
	</para>
	<para>
	  If <argname>u</argname> is given as <lit>null</lit> the
	  <math>u</math> terms are omitted, and if
	  <argname>w</argname> is given as <lit>null</lit> all the weights
	  are taken to be 1.0.
	</para>
      </description>
    </function>

    <function name="mean" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  The sample mean of the non-missing observations in series
	  <argname>y</argname>.
	</para>
      </description>
    </function>

    <function name="meanc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the means of the columns of <argname>X</argname>. 
	  <seelist>
	    <fncref targ="meanr"/>
	    <fncref targ="sumc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="meanr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the means of the rows of <argname>X</argname>. 
	  <seelist>
	    <fncref targ="meanc"/>
	    <fncref targ="sumr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="median" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  The median of the non-missing observations in series
	  <argname>y</argname>. 
	  <seelist>
	    <fncref targ="quantile"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mexp" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Computes the matrix exponential of <argname>A</argname>, using
	  algorithm 11.3.1 from Golub and Van Loan (1996).
	</para>
	<para context="tex">
	  Matrix exponential, 
	  \[ e^A = \sum_{k=0}^{\infty} \frac{A^k}{k!}
	  = \frac{I}{0!} + \frac{A}{1!} + \frac{A^2}{2!} + \frac{A^3}{3!}
	  + \cdots\] 
	  (This series is sure to converge.) The algorithm used
	  is 11.3.1 from Golub and Van Loan (1996).
	</para>
      </description>
    </function>

    <function name="min" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  The minimum of the non-missing observations in series
	  <argname>y</argname>.
	</para>
      </description>
    </function>

    <function name="minc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the minima of the columns of <argname>X</argname>.
	  <seelist>
	    <fncref targ="iminc"/>
	    <fncref targ="maxc"/> 
	    <fncref targ="minr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="minr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the minima of the rows of <argname>X</argname>. 
	  <seelist>
	    <fncref targ="iminr"/>
	    <fncref targ="maxr"/> 
	    <fncref targ="minc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="missing" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a binary variable holding 1 if <argname>x</argname> is
	  <lit>NA</lit>. If <argname>x</argname> is a series, the
	  comparison is done element by element. 
	  <seelist> 
	    <fncref targ="misszero"/>
	    <fncref targ="ok"/>
	    <fncref targ="zeromiss"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="misszero" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Converts <lit>NA</lit>s to zeros. If <argname>x</argname> is a
	  series, the conversion is done element by element. 
	  <seelist>
	    <fncref targ="missing"/>
	    <fncref targ="ok"/>
	    <fncref targ="zeromiss"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mlag" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="scalar-or-vec">p</fnarg>
	<fnarg type="scalar" optional="true">m</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Shifts up or down the rows of <argname>X</argname>.  If
	  <argname>p</argname> is a positive scalar, returns a matrix
	  in which the columns of <argname>X</argname> are shifted
	  down by <argname>p</argname> rows and the first
	  <argname>p</argname> rows are filled with the value
	  <argname>m</argname>. If <argname>p</argname> is a negative
	  number, <argname>X</argname> is shifted up and the last rows
	  are filled with the value <argname>m</argname>. If
	  <argname>m</argname> is omitted, it is understood to be
	  zero.
	</para>
	<para context="tex">
	  Shifts up or down the rows of <argname>X</argname>. If $p$
	  is a positive scalar, the returned matrix $Y$ has typical
	  element $Y_{i,j} = X_{i-p,j}$ for $i \ge p$ and zero
	  otherwise. In other words, the columns of
	  <argname>X</argname> are shifted down by
	  <argname>p</argname> rows and the first <argname>p</argname>
	  rows are filled with the value <argname>m</argname>. If
	  <argname>p</argname> is a negative number,
	  <argname>X</argname> is shifted up and the last rows are
	  filled with the value <argname>m</argname>. If
	  <argname>m</argname> is omitted, it is understood to be
	  zero.
	</para>
	<para context="notex">
	  If <argname>p</argname> is a vector, the above operation is
	  carried out for each element in <argname>p</argname>,
	  joining the resulting matrices horizontally.
	</para>
	<para context="tex">
	  If $p$ is a vector, the above operation is carried out for
	  each element in $p$, joining the resulting matrices
	  horizontally.
	</para>
      </description>
    </function>

    <function name="mnormal" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="scalar">r</fnarg>
	<fnarg type="scalar">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a matrix with <argname>r</argname> rows and
	  <argname>c</argname> columns, filled with standard normal
	  pseudo-random variates. 
	  <seelist> 
	    <fncref targ="normal"/>
	    <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mols" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the OLS estimates obtained by regressing the <by r="T"
	    c="n"/> matrix <argname>Y</argname> on the <by r="T" c="k"/>
	  matrix <argname>X</argname>. The Cholesky decomposition is used. If
	  the third argument is not <lit>null</lit>, the matrix
	  <argname>U</argname> will contain the residuals.
	</para>
      </description>
    </function>

    <function name="monthlen" section="calendar" output="int">
      <fnargs>
	<fnarg type="scalar">month</fnarg>
	<fnarg type="scalar">year</fnarg>
	<fnarg type="scalar">weeklen</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the number of (relevant) days in the specified month in
	  the specified year; <argname>weeklen</argname>, which must equal
	  5, 6 or 7, gives the number of days in the week that should be
	  counted (a value of 6 omits Sundays, and a value of 5 omits both
	  Saturdays and Sundays).
	</para>
      </description>
    </function>

    <function name="movavg" section="filters" output="series">
      <fnargs>
	<fnarg type="series">x</fnarg>
	<fnarg type="scalar">p</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Calcola la media mobile a <argname>p</argname> termini per
	  la serie <argname>x</argname>, vale a dire la media delle
	  osservazioni da x(t) a x(t-p+1).
	</para>
	<para context="tex">
	  Calcola la media mobile a <argname>p</argname> termini per
	  la serie <argname>x</argname>, vale a dire $y_t = \frac{1}{p}
	  \sum_{i=0}^{p-1} x_{t-i}$.
	</para>
	<para>
	  Il risultato è una media mobile non centrata. Se si desidera
	  una media mobile centrata, si può usare l'operatore anticipo
	  sulla serie risultato. Ad esempio::
	</para>
	<code>
	    tmp = movavg(x,3)
	    y = tmp(+1)
	</code>
    </description>
    </function>

    <function name="mpols" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Works exactly as <fncref targ="mols"/>, except that the calculations
	  are done in multiple precision using the GMP library.
	</para>
	<para>
	  By default GMP uses 256 bits for each floating point number, but
	  you can adjust this using the environment variable
	  <lit>GRETL_MP_BITS</lit>, &eg; <lit>GRETL_MP_BITS=1024</lit>.
	</para>
      </description>
    </function>

    <function name="mrandgen" section="probdist" output="matrix">
      <fnargs>
	<fnarg type="char">c</fnarg>
	<fnarg type="scalar">a</fnarg>
	<fnarg type="scalar">b</fnarg>
	<fnarg type="scalar">r</fnarg>
	<fnarg type="scalar">c</fnarg>
      </fnargs>
      <examples>
	<example>matrix mx = mrandgen(u, 0, 100, 50, 1)</example>
	<example>matrix mt14 = mrandgen(t, 14, 20, 20)</example>
      </examples>
      <description>
	<para>
	  Works like <fncref targ="randgen"/> except that the return
	  value is a matrix rather than a series. The initial
	  arguments to this function are as described for
	  <lit>randgen</lit>, but they must be followed by two
	  integers to specify the number of rows
	  (<argname>r</argname>) and columns (<argname>c</argname>) of
	  the desired random matrix.
	</para>
	<para>
	  The first example above calls for a uniform random column vector
	  of length 50, while the second example specifies a <by r="20"
	  c="20"/> random matrix with drawings from the the <math>t</math>
	  distribution with 14 degrees of freedom.
	</para>
	<para>
	  <seelist>
	    <fncref targ="mnormal"/>
	    <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mread" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Reads a matrix from a text file. The string <argname>s</argname>
	  must contain the name of the (plain text) file from which the
	  matrix is to be read. The file in question must conform to the
	  following rules:
	</para>
	<ilist>
	  <li>
	    <para>
	      The columns must be separated by spaces or tab characters.
	    </para>
	  </li>
	  <li>
	    <para>
	      The decimal separator must be the dot character,
	      <quote><lit>.</lit></quote>.
	    </para>
	  </li>
	  <li>
	    <para>
	      The first line in the file must contain two integers,
	      separated by a space or a tab, indicating the number of rows
	      and columns, respectively.
	    </para>
	  </li>
	</ilist>
	<para>
	  Should an error occur (such as the file being badly formatted or
	  inaccessible), an empty matrix is returned.
	</para>
	<para>
	  <seelist>
	    <fncref targ="mwrite"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mreverse" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a matrix containing the rows of <argname>X</argname> in
	  reverse order.  If you wish to obtain a matrix in which the columns
	  of <argname>X</argname> appear in reverse order you can do:
	</para>
	<code>
	  matrix Y = mreverse(X')'
	</code>
      </description>
    </function>  

    <function name="mrls" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">R</fnarg>
	<fnarg type="cvec">q</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;V</fnarg>
      </fnargs>
      <description>
	<para>
	  Restricted least squares: returns a <by r="k" c="n"/> matrix
	  of parameter estimates obtained by least-squares regression
	  of the <by r="T" c="n"/> matrix <argname>Y</argname> on the
	  <by r="T" c="k"/> matrix <argname>X</argname> subject to the
	  linear restriction <math>RB</math> = <math>q</math>, where
	  <math>B</math> denotes the stacked coefficient vector.
	  <argname>R</argname> must have <math>k</math> *
	  <math>n</math> columns; each row of this matrix represents a
	  linear restriction. The number of rows in <argname>q</argname>
	  must match the number of rows in <argname>R</argname>.
	</para>
	<para>
	  If the fifth argument is not <lit>null</lit>, the <by r="T"
	  c="n"/> matrix <argname>U</argname> will contain the
	  residuals. If the final argument is given and is not
	  <lit>null</lit> then the <by r="k" c="k"/> matrix
	  <argname>V</argname> will hold the restricted counterpart to
	  the matrix <math>X'X</math><sup>-1</sup>. The variance
	  matrix of the estimates for equation <math>i</math> can be
	  constructed by multiplying the appropriate sub-matrix of
	  <argname>V</argname> by an estimate of the error variance
	  for that equation.
	</para>
      </description>
    </function>  

    <function name="mshape" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="scalar">r</fnarg>
	<fnarg type="scalar">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Rearranges the elements of <argname>X</argname> into a matrix
	  with <argname>r</argname> rows and <argname>c</argname> columns.
	  Elements are read from <argname>X</argname> and written to the
	  target in column-major order.  If <argname>X</argname> contains
	  fewer than <math>k</math> = <math>rc</math> elements, the
	  elements are repeated cyclically; otherwise, if
	  <argname>X</argname> has more elements, only the first
	  <math>k</math> are used.
	</para>
	<para>
	  <seelist>
	    <fncref targ="cols"/>
	    <fncref targ="rows"/> 
	    <fncref targ="unvech"/>
	    <fncref targ="vec"/> 
	    <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="msortby" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="scalar">j</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a matrix in which the rows of <argname>X</argname>
	  are reordered by increasing value of the elements in
	  column <argname>j</argname>. This is a stable sort: 
	  rows that share the same value in column <argname>j</argname>
	  will not be interchanged.
	</para>
      </description>
    </function>

    <function name="muniform" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="scalar">r</fnarg>
	<fnarg type="scalar">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a matrix with <argname>r</argname> rows and
	  <argname>c</argname> columns, filled with uniform (0,1)
	  pseudo-random variates. Note: the preferred method for
	  generating a scalar uniform r.v. is recasting the output of
	  <lit>muniform</lit> to a scalar, as in 
	</para>
	<code>
	  scalar x = muniform(1,1)
	</code>
	<para>
	  <seelist>
	    <fncref targ="mnormal"/>
	    <fncref targ="uniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mwrite" section="data-utils" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Writes the matrix <argname>X</argname> to a plain text file
	  named <argname>s</argname>. The file will contain on the first
	  line two integers, separated by a tab character, with the number
	  of rows and columns; on the next lines, the matrix elements in
	  scientific notation, separated by tabs (one line per row).
	</para>
	<para>
	  If file <argname>s</argname> already exists, it will be
	  overwritten. The return value is 0 on successful completion; if
	  an error occurs, such as the file being unwritable, the return
	  value will be non-zero.
	</para>
	<para>
	  Matrices stored via the <lit>mwrite</lit> command can be easily
	  read by other programs; see <guideref targ="chap:matrices"/> for
	  details.
	</para>
	<para>
	  <seelist>
	    <fncref targ="mread"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mxtab" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a matrix holding the cross tabulation of the values
	  contained in <argname>x</argname> (by row) and
	  <argname>y</argname> (by column). The two arguments should be of
	  the same type (both series or both column vectors), and because
	  of the typical usage of this function, are assumed to contain
	  integer values only.
	</para>
	<para>
	  <seelist>
	    <fncref targ="values"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="nadarwat" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series">x</fnarg>
	<fnarg type="scalar">h</fnarg>
      </fnargs>
      <description>
	<para>
	  Stima nonparametrica della media condizionale di
	  <argname>y</argname> dato <argname>x</argname> col metodo di
	  Nadaraya&ndash;Watson. Restituisce una serie contenente la stima
	  nonparametrica di
	  <math>E(y</math><sub>i</sub><math>|x</math><sub>i</sub><math>)</math>
	  per ogni elemento non-missing della serie
	  <argname>x</argname>.
	</para>
	<para context="tex">
	  \[
	  m(x_i) = \frac{ \sum_{j=1}^{n} y_j \cdot K_h(x_i -
	  x_j)} {\sum_{j=1}^{n} K_h(x_i - x_j)}
	  \]
	  dove la funzione kernel <math>K_h(\cdot)</math> è data da
	  \[
	  K_h(x) = \exp\left(-\frac{x^2}{2h}\right)
	  \]
	  per $|x| &lt; \tau$ e 0 altrimenti.
	</para>
	<para context="notex">
	  La funzione kernel <math>K</math> è data da <math>K =
	  exp(-x</math><sup>2</sup><math> / 2h)</math> per <math>|x|
	  &lt; T</math> e 0 altrimenti.
	</para>
	<para context="tex">
	  L'argomento <argname>h</argname>, noto come \emph{ampiezza
	  di banda}, è un parametro (reale positivo) indicato
	  dall'utente. Normalmente, è un numero piccolo: valori grandi
	  di $h$ rendono $m(x)$ più liscia; una scelta molto comune è
	  $n^{-0.2}$. Per più dettagli, si veda <guideref
	  targ="sec:nadarwat"/>.
	</para>
	<para context="notex">
	  L'argomento <argname>h</argname>, noto come ampiezza di
	  banda, è un parametro (reale positivo) indicato
	  dall'utente. Normalmente, è un numero piccolo: valori grandi
	  di <argname>h</argname> rendono <math>m(x)</math> più
	  liscia; una scelta molto comune è
	  <math>n</math><sup>-0.2</sup>. Per più dettagli, si veda
	  <guideref targ="sec:nadarwat"/>.
	</para>
	<para context="tex">
	  Lo scalare $\tau$ viene usato per prevenire problemi
	  numerici che si verificano quando la funzione kernel è
	  clacolata troppo lontano dallo zero e viene detto il
	  parametro di taglio.
	</para>
	<para context="notex">
	  Lo scalare <math>T</math> viene usato per prevenire problemi
	  numerici che si verificano quando la funzione kernel è
	  clacolata troppo lontano dallo zero e viene detto il
	  parametro di taglio.
	</para>
        <para>
	  Quest'ultimo può essere tarato a piacere via il comando
	  <lit>set nadarwat_trim</lit>; è espresso come multiplo di
	  <argname>h</argname>, e il valore di default è 4.
        </para>
	<para>
	  L'utente può indicare un valore negativo per l'ampiezza di
	  banda: ciò viene interpretato come una sintassi
	  comvenzionale per la cosiddetta variante
	  <quote>leave-one-out</quote> dello stimatore, ossia una
	  variante che non usa la <math>i</math>-esima osservazione
	  per calcolare
	  <math>m(x</math><sub>i</sub><math>)</math>. Questa variante
	  rende il procedimento numericamente più robusto e il suo uso
	  è sovente consigliato quando lo stimatore è usato a fini
	  inferenziali. Ovviamente, l'ampiezza di banda effettivamente
	  usata è il valore assoluto di <argname>h</argname>.
	</para>
	  <para context="tex">
	    In formule, lo stimatore ``leave-one-out'' è
	    \[
	    m(x_i) = \frac{ \sum_{j \ne i} y_j \cdot K_h(x_i -
	    x_j)} {\sum_{j \ne i} K_h(x_i - x_j)}
	    \]
	  </para>

      </description>
    </function>

    <function name="nelem" section="data-utils" output="int">
      <fnargs>
	<fnarg type="list">L</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il numero di elementi nella lista
	  <argname>L</argname>.
	</para>
      </description>
    </function>

    <function name="ngetenv" section="strings" output="scalar">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>    
      <description>
	<para>
	  If an environment variable by the name of
	  <argname>s</argname> is defined and has a numerical value,
	  returns that value; otherwise returns NA.  See also <fncref
	  targ="getenv"/>.
	</para>
      </description>
    </function>

    <function name="nobs" section="stats" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the number of non-missing observations for the variable
	  <argname>y</argname> in the currently selected sample.
	</para>
      </description>
    </function>

    <function name="normal" section="probdist" output="series">
      <fnargs>
	<fnarg type="scalar">&mu;</fnarg>
	<fnarg type="scalar">&sigma;</fnarg>
      </fnargs>
      <description>
	<para>
	  Generates a series of Gaussian pseudo-random variates with mean
	  &mu; and standard deviation &sigma;. If no arguments are
	  supplied, standard normal variates <math>N</math>(0,1) are
	  produced.
	</para>
	<para>
	  <seelist>
	    <fncref targ="randgen"/>
	    <fncref targ="normal"/>
	    <fncref targ="genpois"/>
	    <fncref targ="mnormal"/>
	    <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="npv" section="math" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg type="scalar">r</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the Net Present Value of <argname>x</argname>,
	  considered as a sequence of payments (negative) and receipts
	  (positive), evaluated at annual discount rate
	  <argname>r</argname>.  The first value is taken as dated
	  <quote>now</quote> and is not discounted.  To emulate an NPV
	  function in which the first value is discounted, prepend zero to
	  the input sequence.
	</para>
	<para>
	  Supported data frequencies are annual, quarterly, monthly, and
	  undated (undated data are treated as if annual).
	</para>
	<para>
	  <seelist>
	    <fncref targ="irr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="NRmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="vector">b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="fncall" optional="true">g</fnarg>
	<fnarg type="fncall" optional="true">h</fnarg>
      </fnargs>
      <description>
	<para>
	  Numerical maximization via the Newton&ndash;Raphson method.
	  The vector <argname>b</argname> should hold the initial
	  values of a set of parameters, and the argument
	  <argname>f</argname> should specify a call to a function
	  that calculates the (scalar) criterion to be maximized,
	  given the current parameter values and any other relevant
	  data. If the object is in fact minimization, this function
	  should return the negative of the criterion.  On successful
	  completion, <lit>NRmax</lit> returns the maximized value of
	  the criterion, and <argname>b</argname> holds the parameter
	  values which produce the maximum.
	</para>
	<para>
	  The optional third and fourth arguments provide means of
	  supplying analytical derivatives and an analytical
	  (negative) Hessian, respectively. The functions referenced
	  by <argname>g</argname> and <argname>h</argname> must take
	  as their first argument a pre-defined matrix that is of the
	  correct size to contain the gradient or Hessian,
	  respectively, given in pointer form. They also must take the
	  parameter vector as an argument (in pointer form or
	  otherwise).  Other arguments are optional. If either or
	  both of the optional arguments are omitted, a numerical
	  approximation is used.
	</para>
	<para>
	  For more details and examples see the chapter on numerical
	  methods in <guideref targ="chap-numerical"/>.
	  <seelist>
	    <fncref targ="BFGSmax"/>
	    <fncref targ="fdjac"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="nullspace" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Computes the right nullspace of <argname>A</argname>, via the
	  singular value decomposition: the result is a matrix
	  <math>B</math> such that the product <math>AB</math> is a zero
	  matrix, except when <argname>A</argname> has full column rank,
	  in which case an empty matrix is returned. Otherwise, if
	  <argname>A</argname> is <by r="m" c="n"/>,
	  <math>B</math> will be <math>n</math> by (<math>n</math> &minus;
	  <math>r</math>), where <math>r</math> is the rank of
	  <argname>A</argname>. 
	</para>
	<para context="tex">
	  Computes the right nullspace of <argname>A</argname>, via the
	  singular value decomposition: the result is a matrix $B$ such
	  that $AB = [0]$, except when $A$ has full column rank, in which
	  case an empty matrix is returned. Otherwise, if $A$ is $m \times
	  n$, $B$ will be an $n \times (n-r)$ matrix, where $r$ is the
	  rank of $A$.  
	</para>
	<para>
	  <seelist>
	    <fncref targ="rank"/>
	    <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="obs" section="data-utils" output="series">
      <description>
	<para>
	  Restituisce una serie di interi consecutivi, partendo da 1 in
	  corrispondenza con l'inizio del dataset. Si noti che il
	  risultato è indipendente dal sottocampionamento. Questa
	  funzione è particolarmente utile con dataset di serie
	  storiche. Nota: la funzione <lit>t</lit> è un sinonimo
	  perfetto di <lit>obs</lit>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="obsnum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="obslabel" section="data-utils" output="string">
      <fnargs>
	<fnarg type="scalar">t</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce l'etichetta per la <argname>t</argname>-esima
	  osservazione, dove <argname>t</argname> è un indice che
	  parte da 1.  La funzione inversa è <fncref targ="obsnum"/>.
	</para>
      </description>
    </function>

    <function name="obsnum" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce un intero corrispondente all'osservazione
	  specificata dalla stringa <math>s</math>. Si noti che il
	  risultato è invariante al sottocampionamento. Questa
	  funzione è particolarmente utile con campioni di serie
	  storiche. Ad esempio, il codice
	</para>
	<code>
	  open denmark 
	  k = obsnum(1980:1)
	</code>
	<para>
	  produce <lit>k = 25</lit>, ciò che indica che il primo
	  trimestre 1980 è la venticinquesima osservazione nel dataset
	  <lit>denmark</lit>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="obs"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ok" section="data-utils" output="seebelow">
      <fnargs>
	<fnarg type="anyfloat-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  If <argname>x</argname> is a scalar, returns 1 if
	  <argname>x</argname> is not <lit>NA</lit>, otherwise 0.  If
	  <argname>x</argname> is a series, returns a series with
	  value 1 at observations with non-missing values and zeros
	  elsewhere. If <argname>x</argname> is a list, the output is
	  a series with 0 at observations for which at least one
	  series in the list has a missing value, and 1 otherwise.
	</para>
	<para>
	  If <argname>x</argname> is a matrix the behavior is a little
	  different, since matrices cannot contain <lit>NA</lit>s: the
	  function returns a matrix of the same dimensions as
	  <argname>x</argname>, with 1s in positions corresponding to
	  finite elements of <argname>x</argname> and 0s in positions
	  where the elements are non-finite (either infinities or
	  not-a-number, as per the IEEE 754 standard).
	</para>
	<para>
	  <seelist>
	    <fncref targ="missing"/>
	    <fncref targ="misszero"/>
	    <fncref targ="zeromiss"/>
	  </seelist>
	  But note that these functions are not applicable to matrices.
	</para>
      </description>
    </function>

    <function name="onenorm" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Returns the 1-norm of the matrix <argname>X</argname>, that is,
	  the maximum across the columns of <argname>X</argname> of the
	  sum of absolute values of the column elements.
	</para>
	<para context="tex">
	  Returns the 1-norm of the $r \times c$ matrix
	  <argname>X</argname>: 
	  \[\| X \|_1 = \max_j \sum_{i=1}^r |X_{ij}| \]
	</para>
	<para>
	  <seelist>
	    <fncref targ="infnorm"/>
	    <fncref targ="rcond"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ones" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="scalar">r</fnarg>
	<fnarg type="scalar">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Outputs a matrix with <math>r</math> rows and <math>c</math>
	  columns, filled with ones.
	</para>
	<para>
	  <seelist>
	    <fncref targ="seq"/>
	    <fncref targ="zeros"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="orthdev" section="transforms" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Only applicable if the currently open dataset has a panel
	  structure. Computes the forward orthogonal deviations for
	  variable <argname>y</argname>.
	</para>
	<para context="tex">
	  Only applicable if the currently open dataset has a panel
	  structure. Computes the forward orthogonal deviations for
	  variable <argname>y</argname>, that is 
	  \[ \tilde{y}_{i,t} =
	  \sqrt{ \frac{T_i - t + 1}{T_i - t}} \left( y_{i,t} -
	  \frac{1}{T_i - t - 1} \sum_{s=t+1}^{T_i} y_{i,s} \right) \]
	</para>
	<para>
	  This transformation is sometimes used instead of differencing to
	  remove individual effects from panel data. 
	  <seelist>
	    <fncref targ="diff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pdf" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="char">c</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <examples>
	<example>f1 = pdf(N, -2.5)</example>
	<example>f2 = pdf(X, 3, y)</example>
	<example>f3 = pdf(W, shape, scale, y)</example>
      </examples>
      <description>
	<para>
	  Calcola funzioni di densità o di probabilità. Restituisce la
	  densità (se continue) o la probabilità (se discrete)
	  <argname>x</argname> della distribzion identificata dal
	  carattere <argname>c</argname>.  Si veda <fncref targ="cdf"/>
	  per dettagli sugli argomenti.  Le distribuzioni supportate
	  dalla funzione <lit>pdf</lit> sono la normale,
	  <math>t</math> di Student, chi-quadro, <math>F</math>,
	  gamma, Weibull, Generalized Error, binomiale and Poisson. Si
	  noti che per la binomiale e la Poisson ciò che viene
	  calcolato è in effetti la probabilità nel punto specificato.
	</para>
	<para>
	  Per la normale, si veda anche la funzione <fncref
	  targ="dnorm"/>.
	</para>
      </description>
    </function>

    <function name="pergm" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg optional="true" type="scalar">bandwidth</fnarg>
      </fnargs>
      <description>
	<para>
	  If only the first argument is given, computes the sample periodogram
	  for the given series or vector. If the second argument is given,
	  computes an estimate of the spectrum of <argname>x</argname> using a
	  Bartlett lag window of the given bandwidth, up to a maximum of half
	  the number of observations (<math>T</math>/2).
	</para>
	<para>
	  Returns a matrix with two columns and <math>T</math>/2 rows: the
	  first column holds the frequency, &omega;, from 2&pi;/<math>T</math>
	  to &pi;, and the second the corresponding spectral density.
	</para>
      </description>
    </function>

    <function name="pmax" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para>
	  Only applicable if the currently open dataset has a panel
	  structure. Returns a series holding the maxima of variable
	  <argname>y</argname> for each cross-sectional unit (repeated
	  for each time period).
	</para>
	<para>
	  If the optional second argument is provided then
	  observations for which the value of <argname>mask</argname>
	  is zero are ignored.
	</para>
	<para>
	  <seelist> 
	    <fncref targ="pmin"/>
	    <fncref targ="pmean"/>
	    <fncref targ="pnobs"/>
	    <fncref targ="psd"/>
	    <fncref targ="pxsum"/>
	    <fncref targ="pshrink"/>
	    <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pmean" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Only applicable if the currently open dataset has a panel
	  structure. Computes the per-unit mean for variable
	  <argname>y</argname>; that is, the sum of the valid observations
	  for each unit divided by the number of valid observations for
	  each unit.	  
	</para>
	<para context="tex">
	  Only applicable if the currently open dataset has a panel
	  structure. Computes the per-unit mean for variable
	  <argname>y</argname>; that is, 
	  \[ \bar{y}_i = \frac{1}{T_i} \sum_{t=1}^{T_i} y_{i,t}\] 
	  where $T_i$ is the number of valid
	  observations for unit $i$.
	</para>
	<para>
	  Missing values are skipped. 
	  <seelist> 
	    <fncref targ="psd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pmin" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para>
	  Only applicable if the currently open dataset has a panel
	  structure. Returns a series holding the minima of variable
	  <argname>y</argname> for each cross-sectional unit (repeated
	  for each time period).
	</para>
	<para>
	  If the optional second argument is provided then
	  observations for which the value of <argname>mask</argname>
	  is zero are ignored.
	</para>	
	<para>
	  <seelist> 
	    <fncref targ="pmax"/>
	    <fncref targ="pmean"/>
	    <fncref targ="pnobs"/>
	    <fncref targ="psd"/>
	    <fncref targ="pshrink"/>
	    <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pnobs" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para>
	  Only applicable if the currently open dataset has a panel
	  structure. Returns a series holding the number of valid
	  observations of variable <argname>y</argname> for each
	  cross-sectional unit (repeated for each time period).
	</para>
	<para>
	  If the optional second argument is provided then
	  observations for which the value of <argname>mask</argname>
	  is zero are ignored.
	</para>
	<para>
	  <seelist> 
	    <fncref targ="pmax"/>
	    <fncref targ="pmin"/>
	    <fncref targ="pmean"/>
	    <fncref targ="psd"/>
	    <fncref targ="pshrink"/>
	    <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="polroots" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="vector">a</fnarg>
      </fnargs>
      <description>
	<para>
	  Finds the roots of a polynomial.  If the polynomial is of degree
	  <math>p</math>, the vector <argname>a</argname> should contain
	  <math>p</math> + 1 coefficients in ascending order, &ie; starting
	  with the constant and ending with the coefficient on
	  <math>x</math><sup>p</sup>.
	</para>
	<para>
	  If all the roots are real they are returned in a column vector of
	  length <math>p</math>, otherwise a <by r="p" c="2"/> matrix
	  is returned, the real parts in the first column and the imaginary
	  parts in the second.
	</para>
      </description>
    </function>

    <function name="polyfit" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="scalar">q</fnarg>
      </fnargs>
      <description>
	<para>
	  Fits a polynomial trend of order <argname>q</argname> to the
	  input series <argname>y</argname> using the method of
	  orthogonal polynomials. The series returned holds the
	  fitted values.
	</para>
      </description>
    </function>

    <function name="princomp" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="scalar">p</fnarg>
      </fnargs>
      <description>
	<para>
	  Let the matrix <argname>X</argname> be <by r="T" c="k"/>, containing
	  <math>T</math> observations on <math>k</math> variables.  The
	  argument <argname>p</argname> must be a positive integer less than
	  or equal to <math>k</math>. This function returns a <by r="T"
	    c="p"/> matrix, <math>P</math>, holding the first <math>p</math>
	  principal components of <argname>X</argname>.
	</para>
	<para context="notex">
	  The elements of <math>P</math> are computed as the sum from
	  <math>i</math> to <math>k</math> of <math>Z</math><sub>ti</sub>
	  times <math>v</math><sub>ji</sub>, where
	  <math>Z</math><sub>ti</sub> is the standardized value of
	  variable <math>i</math> at observation <math>t</math> and
	  <math>v</math><sub>ji</sub> is the <math>j</math>th eigenvector
	  of the correlation matrix of the <math>X</math><sub>i</sub>s,
	  with the eigenvectors ordered by decreasing value of the
	  corresponding eigenvalues.
	</para>
	<para context="tex">
	  The elements of $P$ are computed as 
	  \[ P_{tj} = \sum_{i=1}^{k} Z_{ti} \, v^{(j)}_i \] 
	  where $Z_{ti}$ is the standardized value
	  of variable $i$ at observation $t$, $Z_{ti} = (X_{ti} -
	  \bar{X}_i) / \hat{\sigma}_i$, and $v^{(j)}$ is the $j$th
	  eigenvector of the correlation matrix of the $X_i$s, with the
	  eigenvectors ordered by decreasing value of the corresponding
	  eigenvalues.
	</para>	
	<para>
	  <seelist>
	    <fncref targ="eigensym"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="prodc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il prodotto degli elementi di <argname>X</argname>,
	  per colonna.
	  <seelist>
	    <fncref targ="prodr"/>
	    <fncref targ="meanc"/>
	    <fncref targ="sdc"/>
	    <fncref targ="sumc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="prodr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il prodotto degli elementi di <argname>X</argname>,
	  per riga.
	  <seelist>
	    <fncref targ="prodc"/>
	    <fncref targ="meanr"/>
	    <fncref targ="sumr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="psd" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Only applicable if the currently open dataset has a panel
	  structure. Computes the per-unit sample standard deviation for
	  variable <math>y</math>.  The denominator used is the sample
	  size for each unit minus 1, unless the number of valid
	  observations for the given unit is 1 (in which case 0 is
	  returned) or 9 (in which case <lit>NA</lit> is returned).
	</para>
	<para context="tex">
	  Only applicable if the currently open dataset has a panel
	  structure. Computes the per-unit sample standard deviation for
	  variable <math>y</math>, that is 
	  \[ \sigma_i = \sqrt{\frac{1}{T_i - 1} \sum_{t=1}^{T_i} 
	  (y_{i,t} - \bar{y}_i)^2 } \]
	  The above formula holds for $T_i \ge 2$, where $T_i$ is the
	  number of valid observations for unit $i$; if $T_i = 0$,
	  <lit>NA</lit> is returned; if $T_i = 1$, 0 is returned.
	</para>
	<para>
	  Note: this function makes it possible to check whether a given
	  variable (say, <lit>X</lit>) is time-invariant via the condition
	  <lit>max(psd(X)) = 0</lit>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="pmean"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="psdroot" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="symmat">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Performs a generalized variant of the Cholesky decomposition of
	  the matrix <argname>A</argname>, which must be positive
	  semidefinite (but which may be singular). If the input matrix is
	  not square an error is flagged, but symmetry is assumed and not
	  tested; only the lower triangle of <argname>A</argname> is read.
	  The result is a lower-triangular matrix <math>L</math> which
	  satisfies <equation status="inline" ascii="A = LL'" tex="$A =
	  LL'$"/>.  Indeterminate elements in the solution are set to
	  zero.
	</para>
	<para>
	  For the case where <argname>A</argname> is positive definite,
	  see <fncref targ="cholesky"/>.
	</para>
      </description>
    </function>

    <function name="pshrink" section="data-utils" output="matrix">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Only applicable if the currently open dataset has a panel
	  structure. Returns a column vector holding the first valid
	  observation for the series <argname>y</argname> for each
	  cross-sectional unit in the panel, over the current sample
	  range. If a unit has no valid observations for the input
	  series it is skipped.
	</para>
	<para>
	  This function provides a means of compacting the series
	  returned by functions such as <fncref targ="pmax"/> and
	  <fncref targ="pmean"/>, in which a value pertaining to
	  each cross-sectional unit is repeated for each time
	  period. 
	</para>
      </description>
    </function>

    <function name="psum" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Only applicable if the currently open dataset has a panel
	  structure. Returns a series holding the sum over time of
	  variable <argname>y</argname> for each cross-sectional unit,
	  the values being repeated for each period. Missing
	  observations are skipped in calculating the sums.
	</para>
	<para context="tex">
	  Only applicable if the currently open dataset has a panel
	  structure. Computes the sum over time of variable
	  <argname>y</argname> for each cross-sectional unit; that is, 
	  \[ S_i = \sum_{t=1}^{T_i} y_{i,t}\] 
	  where $T_i$ is the number of valid observations for unit $i$.
	</para>
	<para>
	  If the optional second argument is provided then
	  observations for which the value of <argname>mask</argname>
	  is zero are ignored.
	</para>
	<para>
	  <seelist> 
	    <fncref targ="pmax"/>
	    <fncref targ="pmean"/>
	    <fncref targ="pmin"/>
	    <fncref targ="pnobs"/>
	    <fncref targ="psd"/>
	    <fncref targ="pxsum"/>
	    <fncref targ="pshrink"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pvalue" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="char">c</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs> 
      <examples>
	<example>p1 = pvalue(z, 2.2)</example>
	<example>p2 = pvalue(X, 3, 5.67)</example>
	<example>p2 = pvalue(F, 3, 30, 5.67)</example>
      </examples>
      <description>
	<para>
	  <math>P</math>-value calculator. Returns 
	  <equation status="inline" ascii="P(X > x)" tex="$P(X > x)$"/>,
	  where the distribution <math>X</math> is determined by the
	  character <argname>c</argname>. Between the arguments
	  <argname>c</argname> and <argname>x</argname>, zero or more
	  additional arguments are required to specify the parameters of
	  the distribution; see <fncref targ="cdf"/> for details.  The
	  distributions supported by the <lit>pval</lit> function are
	  the standard normal, <math>t</math>, Chi square, <math>F</math>,
	  gamma, binomial and Poisson.
	</para>
	<para>
	  <seelist>
	    <fncref targ="critical"/>
	    <fncref targ="invcdf"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pxsum" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Only applicable if the currently open dataset has a panel
	  structure. Returns a series holding the sum of the values
	  of <argname>y</argname> for each cross-sectional unit in
	  each period (the values being repeated for each unit).
	</para>
	<para context="tex">
	  Only applicable if the currently open dataset has a panel
	  structure. Computes the cross-sectional sum for variable
	  <argname>y</argname> in each period; that is, 
	  \[ \tilde{y}_t = \sum_{i=1}^{N} y_{i,t}\] 
	  where $N$ is the number of cross-sectional units.
	</para>
	<para>
	  If the optional second argument is provided then
	  observations for which the value of <argname>mask</argname>
	  is zero are ignored.
	</para>
	<para>
	  Note that this function works in a different dimension from
	  the <fncref targ="pmean"/> function.
	</para>
      </description>
    </function>

    <function name="qform" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">x</fnarg>
	<fnarg type="symmat">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes the quadratic form 
	  <equation status="inline" ascii="Y = xAx'"
	   tex="$Y = x A x'$"/>. Using this function instead of ordinary
	  matrix multiplication guarantees more speed and better accuracy.
	  If <argname>x</argname> and <argname>A</argname> are not
	  conformable, or <argname>A</argname> is not symmetric, an error
	  is returned.
	</para>
      </description>
    </function>

    <function name="qnorm" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce i quantili della normale standardizzata. Se
	  <argname>x</argname> non è fra 0 e 1, restituisce <lit>NA</lit>. 
	  <seelist>
	    <fncref targ="cnorm"/>
	    <fncref targ="dnorm"/>
	  </seelist>
	</para>
      </description>
    </function>  

    <function name="qrdecomp" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;R</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes the QR decomposition of an <by r="m" c="n"/> matrix
	  <argname>X</argname>, that is <math>X = QR</math> where
	  <math>Q</math> is an <by r="m" c="n"/> orthogonal matrix and
	  <math>R</math> is an <by r="n" c="n"/> upper triangular matrix. The
	  matrix <math>Q</math> is returned directly, while <math>R</math> can
	  be retrieved via the optional second argument.
	</para>
	<para>
	  <seelist>
	    <fncref targ="eigengen"/>
	    <fncref targ="eigensym"/>
	    <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="quadtable" section="stats" output="matrix">
      <fnargs>
	<fnarg type="scalar">n</fnarg>
	<fnarg type="scalar" optional="true">type</fnarg>
	<fnarg type="scalar" optional="true">a</fnarg>
	<fnarg type="scalar" optional="true">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns an <by r="n" c="2"/> matrix for use with Gaussian
	  quadrature (numerical integration). The first column holds
	  the nodes or abscissae, the second the weights.
	</para>
	<para>
	  The first argument specifies the number of points (rows) to
	  compute. The second argument codes for the type of
	  quadrature: use 1 for Gauss&ndash;Hermite (the default);
	  2 for Gauss&ndash;Legendre; or 3 for Gauss&ndash;Laguerre.
	  The significance of the optional parameters
	  <argname>a</argname> and <argname>b</argname> depends on the
	  selected <argname>type</argname>, as explained below.
	</para>
	<para context="notex">
	  Gaussian quadrature is a method of approximating numerically
	  the definite integral of some function of interest. Let the
	  function be represented as the product
	  <math>f(x)W(x)</math>. The types of quadrature differ in the
	  specification of the component <math>W(x)</math>: in the
	  Hermite case this is exp(&minus;<math>x</math><sup>2</sup>);
	  in the Laguerre case, exp(&minus;<math>x</math>); and in the
	  Legendre case simply <math>W(x)</math> = 1.
	</para>
	<para context="tex">
	  Gaussian quadrature is a method of approximating numerically
	  the definite integral of some function of interest. Let the
	  function be represented as the product $f(x)W(x)$. The types
	  of quadrature differ in the specification of the component
	  $W(x)$: in the Hermite case we have $W(x) = \exp(-x^2)$; in
	  the Laguerre case, $W(x) = \exp(-x)$; and in the Legendre
	  case simply $W(x) = 1$.
	</para>
	<para context="notex">
	  For each specification of <math>W</math>, one can compute a
	  set of nodes, <math>x</math><sub>i</sub>, and weights,
	  <math>w</math><sub>i</sub>, such that the sum from
	  <math>i</math>=1 to <math>n</math> of
	  <math>w</math><sub>i</sub><math>f</math>(<math>x</math><sub>i</sub>)
	  approximates the desired integral. The method of <cite
	  key="golub69">Golub and Welsch (1969)</cite> is used.
	</para>
	<para context="tex">
	  For each specification of $W(x)$, one can compute a set of
	  nodes, $x_i$, and weights, $w_i$, such that $\sum_{i=1}^n
	  f(x_i) w_i$ approximates the desired integral. The method of
	  <cite key="golub69">Golub and Welsch (1969)</cite> is used.
	</para>
	<para context="notex">
	  When the Gauss&ndash;Legendre type is selected, the 
	  optional arguments <argname>a</argname> and
	  <argname>b</argname> can be used to control the lower and
	  upper limits of integration, the default values being
	  &minus;1 and 1. (In Hermite quadrature the
	  limits are fixed at minus and plus infinity, while in
	  the Laguerre case they are fixed at 0 and infinity.)
	</para>
	<para context="tex">
	  When the Gauss&ndash;Legendre type is selected, the optional
	  arguments <argname>a</argname> and <argname>b</argname> can
	  be used to control the lower and upper limits of
	  integration, the default values being $-1$ and 1. (In Hermite
	  quadrature the limits are fixed at $-\infty$ and $+\infty$,
	  while in the Laguerre case they are fixed at 0 and $\infty$.)
	</para>
	<para context="notex">
	  In the Hermite case <argname>a</argname> and
	  <argname>b</argname> play a different role: they can be used
	  to replace the default form of
	  <math>W</math>(<math>x</math>) with the (closely related)
	  normal distribution with mean <argname>a</argname> and
	  standard deviation <argname>b</argname>. Supplying values of
	  0 and 1 for these parameters, for example, has the effect of
	  making <math>W</math>(<math>x</math>) into the standard
	  normal pdf, which is equivalent to multiplying the default
	  nodes by the square root of two and dividing the weights by
	  the square root of &pi;.
	</para>
	<para context="tex">
	  In the Hermite case <argname>a</argname> and
	  <argname>b</argname> play a different role: they can be used
	  to replace the default form of $W(x)$ with the
	  (closely related) normal distribution with mean
	  <argname>a</argname> and standard deviation
	  <argname>b</argname>. Supplying values of 0 and 1 for these
	  parameters, for example, has the effect of making
	  $W(x)$ into the standard normal pdf, which is equivalent
	  to multiplying the default $x_i$ values by $\sqrt{2}$
	  and dividing the default $w_i$ by $\sqrt{\pi}$.
	</para>
      </description>
    </function>    

    <function name="quantile" section="stats" output="scalar" altout="matrix">
      <fnargs>
	<fnarg type="series-or-mat">y</fnarg>
	<fnarg type="pscalar">p</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>y</argname> è una serie, restituisce il suo
	  <argname>p</argname>-esimo quantile. Ad sesmpio, se
	  <math>p</math> = 0.5, si avrà la mediana. 
	</para>
	<para>
	  Se l'argomento è invece una matrice, restituisce un vettore riga
	  contenente i <argname>p</argname>-esimi quantili per le
	  colonne di <argname>y</argname>; in pratica, ogni colonna è
	  trattata come se fosse una serie.
	</para>
	<para>
	  In addition, for matrix <argname>y</argname> an alternate form
	  of the second argument is supported: <argname>p</argname> may be
	  given as a vector. In that case the return value is an <by r="m"
	  c="n"/> matrix, where <repl>m</repl> is the number of elements
	  in <argname>p</argname> and <repl>n</repl> is the number of
	  columns in <argname>y</argname>.
	</para>
	<para context="tex">
	  For a series of length $n$, the $p$-quantile, $q$, is defined
	  as:
	  \[q = y_{[k]} + (n \cdot p - k) (y_{[k+1]} - y_{[k]})\] 
	  where $k$ is the integer part of $n \cdot p$ and 
	  $y_{[i]}$ is the $i$-th element of the series when
	  sorted from smallest to largest.
	</para>
      </description>
    </function>

    <function name="randgen" section="probdist" output="series">
      <fnargs>
	<fnarg type="char">c</fnarg>
	<fnarg type="scalar-or-series">a</fnarg>
	<fnarg type="scalar-or-series">b</fnarg>
      </fnargs>
      <examples>
	<example>series x = randgen(u, 0, 100)</example>
	<example>series t14 = randgen(t, 14)</example>
	<example>series y = randgen(B, 0.6, 30)</example>
	<example>series g = randgen(G, 1, 1)</example>
	<example>series P = randgen(P, mu)</example>
      </examples>
      <description>
	<para>
	  All-purpose random number generator. The parameter
	  <argname>c</argname> is a character, which specifies from which
	  distribution the pseudo-random numbers should be drawn. The
	  arguments <argname>a</argname> and (in some cases)
	  <argname>b</argname> provide the parameters of the selected
	  distribution. If these are given as scalars the output series is
	  identically distributed; if a series is given for
	  <argname>a</argname> or <argname>b</argname> the distribution is
	  conditional on the parameter value at each observation.
	</para>
	<para>
	  Specifics are given below: the character codes for each
	  distribution are shown in parentheses, followed by the
	  interpretation of the argument <argname>a</argname> and,
	  where applicable, <argname>b</argname>.
	</para>
	  
	<ilist context="notex">
	  <li>
	    <para>
	      Uniform (continuous) (c = u or U): minimum; maximum
	    </para>
	  </li>
	  <li>
	    <para>
	      Uniform (discrete) (c = i): minimum; maximum
	    </para>
	  </li>
	  <li>
	    <para>
	      Normal (c = z, n, or N): mean; standard deviation
	    </para>
	  </li>
	  <li>
	    <para>
	      Student's t (t): degrees of freedom
	    </para>
	  </li>
	  <li>
	    <para>
	      Chi square (c, x, or X): degrees of freedom
	    </para>
	  </li>
	  <li>
	    <para>
	      Snedecor's F (f or F): df (num.); df (den.)
	    </para>
	  </li>
	  <li>
	    <para>
	      Gamma (g or G): shape; scale
	    </para>
	  </li>	  
	  <li>
	    <para>
	      Binomial (b or B): probability; number of trials
	    </para>
	  </li>	  
	  <li>
	    <para>
	      Poisson (p or P): Mean
	    </para>
	  </li>	
	  <li>
	    <para>
	      Weibull (w or W): shape; scale
	    </para>
	  </li>	
	  <li>
	    <para>
	      Generalized Error (E): shape
	    </para>
	  </li>	
	</ilist>
	<para context="tex">
	  \begin{center}
	  \begin{tabular}{llll}
	  \textbf{Distribution} &amp; \textsl{c} &amp; \textsl{a} &amp; \textsl{b} \\[4pt]
	  Uniform (continuous) &amp; \texttt{u} or \texttt{U} &amp; minimum &amp; maximum\\
	  Uniform (discrete) &amp; \texttt{i} &amp; minimum &amp; maximum\\
	  Normal &amp; \texttt{z}, \texttt{n} or \texttt{N} &amp; mean &amp; standard deviation\\
	  Student's $t$ &amp; \texttt{t} &amp; degrees of freedom &amp; --\\
	  Chi square &amp; \texttt{c}, \texttt{x} or \texttt{X} &amp; degrees of freedom &amp; --\\
	  Snedecor's $F$ &amp; \texttt{f} or \texttt{F} &amp; df (num.) &amp; df (den.)\\
	  Gamma &amp; \texttt{g} or \texttt{G} &amp; shape &amp; scale \\
	  Binomial &amp; \texttt{b} or \texttt{B} &amp; $p$ &amp; $n$ \\
	  Poisson &amp; \texttt{p} or \texttt{P} &amp; mean &amp; -- \\
	  Weibull &amp; \texttt{w} or \texttt{W} &amp; shape &amp; scale \\
	  Generalized Error &amp; \texttt{e} or \texttt{E} &amp; shape &amp; -- 
	  \end{tabular}
	  \end{center}
	</para>
	<para>
	  <seelist>
	    <fncref targ="normal"/>
	    <fncref targ="uniform"/> 
	    <fncref targ="mrandgen"/>
	    <fncref targ="randgen1"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="randgen1" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="char">c</fnarg>
	<fnarg type="scalar">a</fnarg>
	<fnarg type="scalar">b</fnarg>
      </fnargs>
      <examples>
	<example>scalar x = randgen1(z, 0, 1)</example>
	<example>scalar g = randgen1(g, 3, 2.5)</example>
      </examples>
      <description>
	<para>
	  Works like <fncref targ="randgen"/> except that the return
	  value is a scalar rather than a series.
	</para>
	<para>
	  The first example above calls for a value from the standard
	  normal distribution, while the second specifies a drawing
	  from the Gamma distribution with shape 3 and scale 2.5.
	</para>
	<para>
	  <seelist>
	    <fncref targ="mrandgen"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="randint" section="probdist" output="int">
      <fnargs>
	<fnarg type="scalar">min</fnarg>
	<fnarg type="scalar">max</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a pseudo-random integer in the closed interval
	  [<argname>min</argname>, <argname>max</argname>]. 
	  <seelist>
	  <fncref targ="randgen"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="rank" section="linalg" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the rank of <argname>X</argname>, numerically computed
	  via the singular value decomposition. 
	  <seelist> 
	    <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ranking" section="stats" output="asinput">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a series with the ranks of <math>y</math>. The rank for
	  observation <math>i</math> is the number of elements in the
	  series that are less than <math>y</math><sub>i</sub> plus one
	  half the number of elements in the series that are equal to
	  <math>y</math><sub>i</sub>. (Intuitively, you may think of chess
	  points, where victory gives you one point and a draw gives you
	  half a point.) One is added so the lowest rank is 1 instead of
	  0.
	</para>
	<para context="tex">
	  Formally, 
	  \[ \mathrm{rank}(y_i) = 1 + \sum_{j \ne i} \left[
	  I(y_j &lt; y_i) + 0.5 \cdot I(y_j = y_i) \right] \] 
	  where $I$ denotes the indicator function.
	</para>
	<para>
	  <seelist>
	    <fncref targ="sort"/>
	    <fncref targ="sortby"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="rcond" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="symmat">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the reciprocal condition number for
	  <argname>A</argname>, which must be symmetric and positive
	  definite, with respect to the 1-norm.  In many circumstances,
	  this is a better measure of the sensitivity of
	  <argname>A</argname> to numerical operations such as inversion
	  than the determinant.
	</para>
	<para context="notex">
	  The value is computed as the reciprocal of the product, 1-norm
	  of <argname>A</argname> times 1-norm of
	  <argname>A</argname>-inverse.
	</para>
	<para context="tex">
	  Given that <math>A</math> is non-singular, we may define
	  \[\kappa(A) = ||A||_1 \cdot ||A^{-1}||_1\] 
	  This function returns $\kappa(A)^{-1}$.
	</para>
	<para>
	  <seelist>
	    <fncref targ="det"/>
	    <fncref targ="ldet"/>
	    <fncref targ="onenorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="readfile" section="strings" output="string">
      <fnargs>
	<fnarg type="string">fname</fnarg>
      </fnargs>    
      <description>
	<para>
	  If a file by the name of <argname>fname</argname> exists and
	  is readable, returns a string containing the content of
	  this file, otherwise flags an error.  
	</para>
	<para>
	  Also see the <fncref targ="sscanf"/> function.
	</para>
      </description>
    </function>

    <function name="regsub" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg type="string">match</fnarg>
	<fnarg type="string">repl</fnarg>
      </fnargs>  
      <description>
	<para>
	  Returns a copy of <argname>s</argname> in which all
	  occurrences of the pattern <argname>match</argname> are
	  replaced using <argname>repl</argname>. The arguments
	  <argname>match</argname> and <argname>repl</argname>
	  are interpreted as Perl-style regular expressions.
	</para>
	<para>
	  See also <fncref targ="strsub"/> for simple substitution of
	  literal strings.
	</para>
      </description>
    </function>

    <function name="remove" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">fname</fnarg>
      </fnargs>    
      <description>
	<para>
	  Se il file <argname>fname</argname> esiste e l'utente ha i
	  permessi di scrittura, lo cancella. Restituisce 0 se il comando
	  è andato a buon fine, non-zero se il file non esiste o non
	  può essere cancellato.
	</para>
      </description>
    </function>

    <function name="replace" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
	<fnarg type="scalar-or-vec">find</fnarg>
	<fnarg type="scalar-or-vec">subst</fnarg>
      </fnargs>    
      <description>
	<para>
	  Replaces each element of <argname>x</argname> equal to
	  the <math>i</math>-th element of <argname>find</argname>
	  with the corresponding element of <argname>subst</argname>.
	</para>
	<para>
	  If <argname>find</argname> is a scalar, <argname>subst</argname>
	  must also be a scalar.  If <argname>find</argname> and
	  <argname>subst</argname> are both vectors, they must have the same
	  number of elements.  But if <argname>find</argname> is a vector and
	  <argname>subst</argname> a scalar, then all matches will be replaced
	  by <argname>subst</argname>.
	</para>
	<para>
	  Example:
	</para>
	<code>
	  a = {1,2,3;3,4,5}
	  find = {1,3,4}
	  subst = {-1,-8, 0}
	  b = replace(a, find, subst)
	  print a b
	</code>
	<para>
	  produces
	</para>
	<code>
          a (2 x 3)
           
            1   2   3 
            3   4   5 
           
          b (2 x 3)
           
            -1    2   -8 
            -8    0    5 
	</code>
      </description>
    </function>

    <function name="resample" section="stats" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
      </fnargs>    
      <description>
	<para>
	  Resamples from <argname>x</argname> with replacement.  In the
	  case of a series argument, each value of the returned series,
	  <math>y</math><sub>t</sub>, is drawn from among all the values
	  of <math>x</math><sub>t</sub> with equal probability.  When
	  a matrix argument is given, each row of the returned matrix
	  is drawn from the rows of <argname>x</argname> with equal
	  probability.
	</para>
      </description>
    </function>

    <function name="round" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Rounds to the nearest integer. Note that when <math>x</math>
	  lies halfway between two integers, rounding is done "away
	  from zero", so for example 2.5 rounds to 3, but 
	  <lit>round(-3.5)</lit> gives &minus;4. This is a common
	  convention in spreadsheet programs, but other software may
	  yield different results.
	  <seelist>
	    <fncref targ="ceil"/>
	    <fncref targ="floor"/>
	    <fncref targ="int"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="rownames" section="matbuild" output="int">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="list-or-string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Attaches names to the rows of the <by r="m" c="n"/> matrix
	  <argname>M</argname>. If <argname>s</argname> is a named list, the
	  row names are copied from the names of the variables; the list
	  must have <math>m</math> members. If <argname>s</argname> is a
	  string, it should contain <math>m</math> space-separated
	  sub-strings.  The return value is 0 on successful completion,
	  non-zero on error. See also <fncref targ="colnames"/>.
	</para>
	<para>
      Example:
    </para>
    <code>
      matrix M = {1,2;2,1;4,1} 
      rownames(M, "Row1 Row2 Row3")
      print M      
    </code>
	  </description>
    </function>

    <function name="rows" section="matshape" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il numero di righe della matrice
	  <argname>X</argname>.
	  <seelist>
	    <fncref targ="cols"/>
	    <fncref targ="mshape"/>
	    <fncref targ="unvech"/> 
	    <fncref targ="vec"/>
	    <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sd" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
      </fnargs>     
      <description>
	<para>
	  Se <argname>x</argname> è una serie, restituisce l'errore
	  quadratico medio campionario (scalare), saltando i valori
	  mancanti.
	</para>
	<para>
	  Se, invece, <argname>x</argname> è una lista, restituisce una
	  serie <math>y</math> tale per cui <math>y</math><sub>t</sub>
	  l'errore quadratico medio delle variabili nella lista
	  all'osservazione <math>t</math>, o <lit>NA</lit> if there se
	  ci sono dei valori mancanti <math>t</math>.
	</para>
	<para>
	  <seelist> 
	    <fncref targ="var"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sdc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="scalar" optional="true">df</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the standard deviations of the columns of
	  <argname>X</argname>. If <argname>df</argname> is positive
	  it is used as the divisor for the column variances,
	  otherwise the divisor is the number of rows in
	  <argname>X</argname> (that is, no degrees of freedom
	  correction is applied).
	  <seelist>
	    <fncref targ="meanc"/>
	    <fncref targ="sumc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sdiff" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-or-list">y</fnarg>
      </fnargs>   
      <description>
	<para>
	  Computes seasonal differences: <equation status="inline" 
	  ascii="y(t) - y(t-k)"  tex="$y_t - y_{t-k}$"/>, where
	  <math>k</math> is the periodicity of the current dataset (see
	  <fncref targ="$pd"/>). Starting values are set to
	  <lit>NA</lit>.
	</para>
      </description>
    </function>

    <function name="selifc" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="rvec">b</fnarg>
      </fnargs>   
      <description>
	<para>
	  Seleziona da <argname>A</argname> solo le colonne per le
	  quali l'elemento corrispondente di <argname>b</argname> è
	  non-zero. <argname>b</argname> deve essere un vettore riga
	  con lo stesso numero di colonne di <argname>A</argname>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="selifr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="selifr" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="cvec">b</fnarg>
      </fnargs>   
      <description>
	<para>
	  Seleziona da <argname>A</argname> solo le righe per le quali
	  l'elemento corrispondente di <argname>b</argname> è
	  non-zero. <argname>b</argname> deve essere un vettore
	  colonna con lo stesso numero di righe di
	  <argname>A</argname>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="selifc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="seq" section="matbuild" output="rvec">
      <fnargs>
	<fnarg type="scalar">a</fnarg>
	<fnarg type="scalar">b</fnarg>
      </fnargs>   
      <description>
	<para>
	  Restituisce un vettore riga pieno di interi consecutivi, con
	  <argname>a</argname> come primo elemento e
	  <argname>b</argname> come ultimo. Se <argname>a</argname> è
	  maggiore di <argname>b</argname>, la sequenza sarà
	  decrescente. L'eventale parte non intera viene ignorata per
	  entrambi gli argomenti.
	</para>
	<para>
	  <seelist>
	    <fncref targ="ones"/>
	    <fncref targ="zeros"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="setnote" section="data-utils" output="int">
      <fnargs>
	<fnarg type="bundle">b</fnarg>
	<fnarg type="string">key</fnarg>
	<fnarg type="string">note</fnarg>
      </fnargs>   
      <description>
	<para>
	  Imposta una nota descrittiva per l'oggetto identificato
	  dalla chiave <argname>key</argname> nel bundle
	  <argname>b</argname>.  Essa verrà mostrata quando il comando
	  <lit>print</lit> viene applicato al bundle. Questa funzione
	  restituisce 0 se è andata a buon fine e non-zero in caso
	  contrario (ad esempio, se nel bundle <argname>b</argname> la
	  chiave <argname>key</argname> non c'è).
	</para>
      </description>
    </function>    

    <function name="simann" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="vector">b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="scalar" optional="true">maxit</fnarg>
      </fnargs>
      <description>
	<para>
	  Implements simulated annealing, which may be helpful in
	  improving the initialization for a numerical optimization
	  problem.
	</para>
	<para>
	  The first argument holds the intial value of a parameter
	  vector and the second argument specifies a function call
	  which returns the (scalar) value of the maximand. The
	  optional third argument specifies the maximum number of
	  iterations (which defaults to 1024). On successful
	  completion, <lit>simann</lit> returns the final value of the
	  maximand.
	</para>
	<para>
	  For more details and an example see the chapter on numerical
	  methods in <guideref targ="chap-numerical"/>.
	  <seelist>
	    <fncref targ="BFGSmax"/>
	    <fncref targ="NRmax"/>
	  </seelist>
	</para>

      </description>
    </function>

    <function name="sin" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>       
      <description>
	<para>
	  Funzione seno.  
	  <seelist>
	    <fncref targ="cos"/>
	    <fncref targ="tan"/>
	    <fncref targ="atan"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sinh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the hyperbolic sine of <argname>x</argname>.
	</para>
	<para context="tex">
	  \[ \sinh x = \frac{e^x - e^{-x}}{2}  \]
	</para>
	<para>
	  <seelist>
	    <fncref targ="asinh"/>
	    <fncref targ="cosh"/>
	    <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="skewness" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the skewness value for the series <argname>x</argname>,
	  skipping any missing observations.
	</para>
      </description>
    </function>

    <function name="sort" section="matshape" output="asinput">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>     
      <description>
	<para>
	  Sorts <argname>x</argname> in ascending order, skipping
	  observations with missing values when <math>x</math> is a
	  series.  
	  <seelist>
	    <fncref targ="dsort"/>
	    <fncref targ="values"/>
	  </seelist>
	  For matrices specifically, see <fncref targ="msortby"/>.
	</para>
      </description>
    </function>

    <function name="sortby" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y1</fnarg>
	<fnarg type="series">y2</fnarg>
      </fnargs>     
      <description>
	<para>
	  Returns a series containing the elements of
	  <argname>y2</argname> sorted by increasing value of the first
	  argument, <argname>y1</argname>. 
	  <seelist>
	    <fncref targ="sort"/>
	    <fncref targ="ranking"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sqrt" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>     
      <description>
	<para>
	  Square root of <argname>x</argname>; produces <lit>NA</lit> for
	  negative values.
	</para>
      </description>
    </function>

    <function name="sscanf" section="strings" output="int">
      <fnargs>
	<fnarg type="string">src</fnarg>
	<fnarg type="string">format</fnarg>
	<fnarg type="varargs"/>
      </fnargs>  
      <description>
      <para>
        Analizza una <repl>stringa</repl> seguendo il
        <repl>formato</repl> indicato, assegnando zero o più valori
        agli <repl>argomenti</repl> indicati. È una versione
        semplificata della funzione <lit>sscanf</lit> del linguaggio
        di programmazione C, e restituisce il numero di valori assegnati.
      </para>
      <para>
        La <repl>stringa</repl> può essere una stringa vera e propria,
	racchiusa tra virgolette doppie, o il nome di una variabile stringa
	predefinita. Il <repl>formato</repl> è definito in modo simile alla
	stringa di formato del comando <cmdref targ="printf"/> (si veda
	oltre). Gli <repl>argomenti</repl> sono una lista separata da virgole
	che contiene i nomi di variabili predefinite che verranno assegnate a
	seconda dei valori letti dalla <repl>stringa</repl>. Per chi conosce
	il C: è possibile prefissare con <lit>&amp;</lit> i nomi delle
	variabili numeriche, ma non è richiesto.
      </para>
      <para>
	Le regole specificate nel <repl>formato</repl> vengono usate per
        analizzare la <repl>stringa</repl>. Le specifiche iniziano con un
        carattere <lit>%</lit>, e comprendono
        <lit>%f</lit>, <lit>%g</lit> o <lit>%lf</lit> per i numeri in virgola
        mobile; <lit>%d</lit> per gli interi; <lit>%s</lit> per le stringhe, e
	<lit>%m</lit> per le matrici. È possibile inserire un numero intero
        positivo dopo il carattere percento, per impostare il numero massimo di
        caratteri da leggere per ogni tipo di specifica (o il massimo numero di
        righe nel caso di conversione in matrici). In alternativa è possibile
        inserire un carattere <lit>*</lit> dopo il percento per sopprimere la
        conversione di un certo numero di caratteri della stringa. Ad esempio,
	<lit>%3d</lit> converte i 3 caratteri successivi della <repl>stringa</repl>
        in un numero intero, se possibile; <lit>%*g</lit> salta tutti i caratteri
        nella <repl>stringa</repl> che potrebbero essere convertiti in un numero
        a virgola mobile.
      </para>
      <para>
	La conversione in matrici funziona nel modo seguente: viene letta ogni
        riga dell'input e vengono contati i campi numerici (separati da spazi o
        tab). In questo modo viene definito il numero di colonne della matrice.
        Vengono quindi lette tutte le righe seguenti che contengono lo stesso
        numero di colonne numeriche; è anche possibile limitare il numero
        massimo di righe da leggere.
      </para>
      <para>
        Oltre alla conversione <lit>%s</lit> per le stringhe, è disponibile
        anche una versione semplificata del formato C
        <lit>%</lit><repl>N</repl><lit>[</lit><repl>caratteri</repl><lit>]</lit>.
        In questo formato, <repl>N</repl> è il numero massimo di caratteri da
        leggere, e <repl>caratteri</repl> è un insieme di caratteri accettabili,
        racchiusi tra parentesi quadre; la lettura si ferma se si raggiunge il
        limite di <repl>N</repl> o se si incontra un carattere non compreso
        nell'insieme ammissibile. La funzione dell'insieme
	<repl>caratteri</repl> può essere invertita specificando un accento
        circonflesso <lit>^</lit> come primo carattere dell'insieme; in questo
        caso, la lettura si ferma se si incontra un carattere dell'insieme
        specificato. Al contrario del C, il carattere trattino non ha alcuna
        funzione speciale in questo contesto.
      </para>
      <para>
	Se la stringa non corrisponde esattamente al formato specificato, il
        numero di conversioni effettuate può risultare diverso dal numero di
        argomenti indicati. Per gretl questo non è necessariamente un errore,
        tuttavia può essere utile voler controllare questa corrispondenza; è
        possibile farlo usando la variabile scalare interna
	<lit>$nscan</lit>, il cui valore viene aggiornato ogni volta che si
        usa <lit>sscanf</lit>. In caso di uso interattivo viene mostrato anche
        il numero di conversioni effettuate.
      </para>
      <para>
	Ecco alcuni esempi:
      </para>
	<code>
	  scalar x
	  scalar y
	  sscanf("123456", "%3d%3d", x, y)

	  sprintf S, "1 2 3 4\n5 6 7 8"
	  S
	  matrix m
	  sscanf(S, "%m", m)
	  print m
	</code>
      </description>
    </function>

    <function name="sst" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>  
      <description>
	<para>
	  Somma dei quadrati degli scarti dalla media per le
	  osservazioni valide nella serie <argname>y</argname>.
	  <seelist> 
	    <fncref targ="var"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="strlen" section="strings" output="int">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>  
      <description>
	<para>
	  Returns the number of characters in <argname>s</argname>.
	</para>
      </description>
    </function>

    <function name="strncmp" section="strings" output="int">
      <fnargs>
	<fnarg type="string">s1</fnarg>
	<fnarg type="string">s2</fnarg>
	<fnarg optional="true" type="scalar">n</fnarg>
      </fnargs>  
      <description>
	<para>
	  Compares the two string arguments and returns an integer less
	  than, equal to, or greater than zero if <argname>s1</argname> is
	  found, respectively, to be less than, to match, or be greater
	  than <argname>s2</argname>, up to the first <argname>n</argname>
	  characters.  If <argname>n</argname> is omitted the comparison
	  proceeds as far as possible.
	</para>
	<para> Note that if you just want to compare two strings for
	  equality, that can be done without using a function, as in
	  <lit>if (s1 == s2) ...</lit>
	</para>
      </description>
    </function>

    <function name="strsplit" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg type="scalar">i</fnarg>
      </fnargs>  
      <description>
	<para>
	  Returns space-separated element <argname>i</argname> from
	  the string <argname>s</argname>. The index
	  <argname>i</argname> is 1-based, and it is an error if
	  <argname>i</argname> is less than 1. In case
	  <argname>s</argname> contains no spaces and
	  <argname>i</argname> equals 1, a copy of the entire input
	  string is returned; otherwise, in case <argname>i</argname>
	  exceeds the number of space-separated elements an empty
	  string is returned.
	</para>
      </description>
    </function>

    <function name="strstr" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s1</fnarg>
	<fnarg type="string">s2</fnarg>
      </fnargs>  
      <description>
	<para>
	  Searches <argname>s1</argname> for an occurrence of the string
	  <argname>s2</argname>.  If a match is found, returns a copy of the
	  portion of <argname>s1</argname> that starts with
	  <argname>s2</argname>, otherwise returns an empty string.
	</para>
      </description>
    </function>

    <function name="strstrip" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>  
      <description>
	<para>
	  Returns a copy of the argument <argname>s</argname> from
	  which leading and trailing white space have been removed.
	</para>
      </description>
    </function>

    <function name="strsub" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg type="string">find</fnarg>
	<fnarg type="string">subst</fnarg>
      </fnargs>  
      <description>
	<para>
	  Returns a copy of <argname>s</argname> in which all
	  occurrences of <argname>find</argname> are replaced by
	  <argname>subst</argname>.
	</para>
      </description>
    </function>

    <function name="sum" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>      
      <description>
	<para>
	  Somma dele osservazioni valide nella serie <argname>y</argname>.
	</para>
      </description>
    </function>

    <function name="sumall" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>      
      <description>
	<para>
	  Returns the sum of the observations of <argname>x</argname>
	  over the current sample range, or <lit>NA</lit> if there are
	  any missing values.
	</para>
      </description>
    </function>

    <function name="sumc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>     
      <description>
	<para>
	  Restituisce la somma per colonna di <argname>X</argname>.
	  <seelist>
	    <fncref targ="meanc"/>
	    <fncref targ="sumr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sumr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>  
      <description>
	<para>
	  Returns the sums of the rows of <argname>X</argname>.
	  <seelist> 
	    <fncref targ="meanr"/>
	    <fncref targ="sumc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="svd" section="linalg" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;V</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Performs the singular values decomposition of the matrix
	  <argname>X</argname>.
	</para>
	<para context="tex">
	  Performs the singular values decomposition of the $r \times c$
	  matrix $X$: 
	  \[ X = U \left[
	  \begin{array}{cccc} 
	  \sigma_1 \\ 
	  &amp; \sigma_2 \\ 
	  &amp; &amp; \ddots \\ 
	  &amp; &amp; &amp; \sigma_n ,
	  \end{array}
	  \right] V \] 
	  where $n = \min(r,c)$. $U$ is $r \times
	  n$ and $V$ is $n \times c$, with $U'U = I$ and $VV' = I$.
	</para>
	<para>
	  The singular values are returned in a row vector.  The left
	  and/or right singular vectors <math>U</math> and <math>V</math>
	  may be obtained by supplying non-null values for arguments 2 and
	  3, respectively.  For any matrix <lit>A</lit>, the code
	</para>
	<code>
	  s = svd(A, &amp;U, &amp;V) 
	  B = (U .* s) * V
	</code>
	<para>
	  should yield <lit>B</lit> identical to <lit>A</lit> (apart from
	  machine precision).
	</para>
	<para>
	  <seelist>
	    <fncref targ="eigengen"/>
	    <fncref targ="eigensym"/>
	    <fncref targ="qrdecomp"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="tan" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Funzione tangente
	  <seelist>
	    <fncref targ="atan"/>
	    <fncref targ="cos"/>
	    <fncref targ="sin"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="tanh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce la tangente iperbolica di <argname>x</argname>. 
	</para>
	<para context="tex">
	  \[ \tanh x = \frac{e^{2x} - 1}{e^{2x} + 1}  \]
	</para>
	<para>
	  <seelist>
	    <fncref targ="atanh"/>
	    <fncref targ="cosh"/>
	    <fncref targ="sinh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="toepsolv" section="linalg" output="cvec">
      <fnargs>
	<fnarg type="vector">c</fnarg>
	<fnarg type="vector">r</fnarg>
	<fnarg type="vector">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Solves a Toeplitz system of linear equations, that is
	  <math>Tx = b</math> where <math>T</math> is a square matrix
	  whose element <math>T</math><sub>i,j</sub> equals
	  <math>c</math><sub>i-j</sub> for <equation status="inline"
	  ascii="i&gt;=j" tex="$i\ge j$"/> and
	  <math>r</math><sub>j-i</sub> for <equation status="inline"
	  ascii="i&lt;=j" tex="$i\le j$"/>. Note that the first
	  elements of <math>c</math> and <math>r</math> must be equal,
	  otherwise an error is returned. Upon successful completion,
	  the function returns the vector <math>x</math>.
	</para>
	<para>
	  The algorithm used here takes advantage of the special
	  structure of the matrix <math>T</math>, which makes it much
	  more efficient than other unspecialized algorithms,
	  especially for large problems. Warning: in certain cases,
	  the function may spuriously issue a singularity error when
	  in fact the matrix <math>T</math> is nonsingular; this
	  problem, however, cannot arise when <math>T</math> is
	  positive definite.
	</para>
      </description>
    </function>

    <function name="tolower" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>    
      <description>
	<para>
	  Restituisce una copia di <argname>s</argname> in cui ogni
	  lettera maiuscola è convertita in minuscola.
	</para>
      </description>
    </function>

    <function name="toupper" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>    
      <description>
	<para>
	  Restituisce una copia di <argname>s</argname> in cui ogni
	  lettera minuscola è convertita in maiuscola.
	</para>
      </description>
    </function>

    <function name="tr" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>    
      <description>
	<para>
	  Restituisce la traccia della matrice <argname>A</argname>,
	  ovvero la somma degli elementi lungo la diagonale.
	  <seelist> 
	    <fncref targ="diag"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="transp" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>      
      <description>
	<para>
	  Matrix transposition. Note: this is rarely used; in order to get
	  the trasnpose of a matrix, in most cases you can just use the
	  prime operator: <lit>X'</lit>.
	</para>
      </description>
    </function>

    <function name="trimr" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="scalar">ttop</fnarg>
	<fnarg type="scalar">tbot</fnarg>
      </fnargs>   
      <description>
	<para>
	  Returns a matrix that is a copy of <argname>X</argname> with
	  <argname>ttop</argname> rows trimmed at the top and
	  <argname>tbot</argname> rows trimmed at the bottom.  The latter two
	  arguments must be non-negative, and must sum to less than the total
	  rows of <argname>X</argname>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="selifr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="typestr" section="data-utils" output="string">
      <fnargs>
	<fnarg type="scalar">code</fnarg>
      </fnargs>      
      <description>
	<para>
	  Returns the name of the gretl data-type corresponding to
	  <argname>code</argname>. This is intended for use in
	  conjunction with the function <fncref targ="inbundle"/>.
	  The value returned is one of <quote>scalar</quote>,
	  <quote>series</quote>, <quote>matrix</quote>,
	  <quote>string</quote>, <quote>bundle</quote> or
	  <quote>null</quote>.
	</para>
      </description>
    </function>

    <function name="uniform" section="probdist" output="series">
      <fnargs>
	<fnarg type="scalar">a</fnarg>
	<fnarg type="scalar">b</fnarg>
      </fnargs>     
      <description>
	<para>
	  Genera una serie di numeri pseudo-casuali uniformi
	  nell'intervallo (<argname>a</argname>,
	  <argname>b</argname>), oppure, in assenza di argomenti,
	  nell'intervallo (0,1). L'algoritmo usato è il Mersenne
	  Twister di Matsumoto e Nishimura (1998).
	</para>
	<para>
	  <seelist>
	    <fncref targ="randgen"/>
	    <fncref targ="normal"/>
	    <fncref targ="genpois"/>
	    <fncref targ="mnormal"/>
	    <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="uniq" section="stats" output="cvec">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>      
      <description>
	<para>
	  Returns a vector containing the distinct elements of
	  <argname>x</argname>, not sorted but in their order of
	  appearance. See <fncref targ="values"/> for a variant
	  that sorts the elements.
	</para>
      </description>
    </function>

    <function name="unvech" section="matbuild" output="smatrix">
      <fnargs>
	<fnarg type="vector">v</fnarg>
	<fnarg type="scalar">b</fnarg>
      </fnargs>      
      <description>
	<para>
	  Returns an <by r="n" c="n"/> symmetric matrix obtained by
	  rearranging the elements of <math>v</math>. The number of elements
	  in <math>v</math> must be a triangular integer &mdash; &ie;, a
	  number <math>k</math> such that an integer <math>n</math> exists
	  with the property <equation
	    status="inline" ascii="k = n(n+1)/2" 
	    tex="$k = n(n+1)/2$"/>. This is the inverse of the function
	  <fncref targ="vech"/>. 
	</para>
	<para>
	  <seelist>
	    <fncref targ="mshape"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="upper" section="matbuild" output="smatrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>  
      <description>
	<para context="notex">
	  Returns an <by r="n" c="n"/> upper triangular matrix: the elements
	  on and above the diagonal are equal to the corresponding elements of
	  <argname>A</argname>; the remaining elements are zero.
	</para>
	<para context="tex">
	  Returns an $n\times n$ upper triangular matrix <math>B</math>
	  for which $B_{ij} = A_{ij}$ if $i \le j$ and 0 otherwise.
	</para>
	<para>
	  <seelist>
	    <fncref targ="lower"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="urcpval" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="scalar">tau</fnarg>
	<fnarg type="scalar">n</fnarg>
	<fnarg type="scalar">niv</fnarg>
	<fnarg type="scalar">itv</fnarg>
      </fnargs>
      <description>
	<para>
	  <math>P</math>-values for the test statistic from the
	  Dickey&ndash;Fuller unit-root test and the
	  Engle&ndash;Granger cointegration test, as per <cite
	  key="mackinnon96">James MacKinnon (1996)</cite>.
	</para>
	<para>
	  The arguments are as follows: <argname>tau</argname> denotes the
	  test statistic; <argname>n</argname> is the number of
	  observations (or 0 for an asymptotic result);
	  <argname>niv</argname> is the number of potentially cointegrated
	  variables when testing for cointegration (or 1 for a univariate
	  unit-root test); and <argname>itv</argname> is a code for the
	  model specification: 1 for no constant, 2 for constant
	  included, 3 for constant and linear trend, 4 for constant and
	  quadratic trend.
	</para>
	<para>
	  Note that if the test regression is <quote>augmented</quote>
	  with lags of the dependent variable, then you should give an
	  <argname>n</argname> value of 0 to get an asymptotic result.
	</para>
	<para>
	  <seelist> 
	    <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="values" section="stats" output="cvec">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>      
      <description>
	<para>
	  Returns a vector containing the distinct elements of
	  <argname>x</argname> sorted in ascending order. Note: because of
	  its typical usage, <argname>x</argname> is assumed to contain
	  integer values only. If not, the fractional part is truncated,
	  so <lit>values(x)</lit> is always identical to
	  <lit>values(int(x))</lit>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="dsort"/>
	    <fncref targ="sort"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="var" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>     
      <description>
	<para>
	  Sample variance of the non-missing observations in
	  <math>y</math>; the sum of squared deviations from the mean is
	  divided by (<math>n</math> &minus; 1) for <math>n</math> &gt; 1.
	  If <math>n</math> = 1, zero is returned; if <math>n</math> = 0,
	  <lit>NA</lit> is returned. 
	</para>
	<para>
	  <seelist>
	    <fncref targ="sd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="varname" section="strings" output="string">
      <fnargs>
	<fnarg type="int-or-list">v</fnarg>
      </fnargs>     
      <description>
	<para>
	  If given a scalar argument, returns the name of the variable with ID
	  number <argname>v</argname>, or generates an error if there is no
	  such variable.
	</para>
	<para>
	  If given a list argument, returns a string containing the names of
	  the variables in the list, separated by commas.  If the supplied
	  list is empty, so is the returned string.
	</para>
      </description>
    </function>

    <function name="varnum" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">varname</fnarg>
      </fnargs>     
      <description>
	<para>
	  Returns the ID number of the variable called
	  <argname>varname</argname>, or NA is there is no such variable.
	</para>
      </description>
    </function>

    <function name="varsimul" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix">U</fnarg>
	<fnarg type="matrix">y0</fnarg>
      </fnargs>
      <description>
	<para>
	  Simulates a <math>p</math>-order <math>n</math>-variable
	  VAR, that is
	  <equation status="inline"
	  ascii="y(t) = A1 y(t-1) + ... + Ap y(t-p) + u(t)." 
	  tex="$y_t = \sum_{i=1}^p A_i y_{t-i} + u_t$."/>

	  The coefficient matrix <argname>A</argname> is composed by
	  horizontal stacking of the <math>A</math><sub>i</sub>
	  matrices; it is <by r="n" c="np"/>, with one row
	  per equation. This corresponds to the first <math>n</math>
	  rows of the matrix <lit>$compan</lit> provided by gretl's
	  <lit>var</lit> and <lit>vecm</lit> commands.
	</para>
	<para>
	  The <math>u_t</math> vectors are contained (as rows) in
	  <argname>U</argname> (<by r="T" c="n"/>). Initial values are in
	  <argname>y0</argname> (<by r="p" c="n"/>).
	</para>
	<para>
	  If the VAR contains deterministic terms and/or exogenous
	  regressors, these can be handled by folding them into the
	  <argname>U</argname> matrix: each row of <argname>U</argname>
	  then becomes 
	  <equation status="inline"
	  ascii="u(t) = B' x(t) + e(t)." 
	  tex="$u_t = B' x_t + e_t$."/>
	</para>
	<para>
	  The output matrix has <math>T</math> + <math>p</math> rows
	  and <math>n</math> columns; it holds the initial <math>p</math>
	  values of the endogenous variables plus <math>T</math>
	  simulated values.
	</para>
	<para>
	  <seelist> 
	    <fncref targ="$compan"/>
	    <cmdref targ="var"/>
	    <cmdref targ="vecm"/>
	  </seelist>
	</para>

      </description>
    </function>

    <function name="vec" section="matbuild" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>     
      <description>
	<para>
	  Stacks the columns of <argname>X</argname> as a column vector.
	  <seelist>
	    <fncref targ="mshape"/>
	    <fncref targ="unvech"/>
	    <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="vech" section="matbuild" output="cvec">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>    
      <description>
	<para>
	  Returns in a column vector the elements of <argname>A</argname>
	  on and above the diagonal. Typically, this function is used on
	  symmetric matrices; in this case, it can be undone by the
	  function <fncref targ="unvech"/>. 
	  <seelist> 
	    <fncref targ="vec"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="weekday" section="calendar" output="int">
      <fnargs>
	<fnarg type="scalar">year</fnarg>
	<fnarg type="scalar">month</fnarg>
	<fnarg type="scalar">day</fnarg>
      </fnargs>    
      <description>
	<para>
	  Returns the day of the week (Sunday = 0, Monday = 1, etc.) for the
	  date specified by the three arguments, or <lit>NA</lit> if the date
	  is invalid.
	</para>
      </description>
    </function>

    <function name="wmean" section="stats" output="series">
      <fnargs>
	<fnarg type="list">Y</fnarg>
	<fnarg type="list">W</fnarg>
      </fnargs>    
      <description>
	<para>
	  Returns a series <math>y</math> such that <math>y</math><sub>t</sub>
	  is the weighted mean of the values of the variables in list
	  <argname>Y</argname> at observation <math>t</math>, the respective
	  weights given by the values of the variables in list
	  <argname>W</argname> at <math>t</math>.  The weights can therefore
	  be time-varying. The lists <argname>Y</argname> and
	  <argname>W</argname> must be of the same length and the weights must
	  be non-negative.
	</para>
	<para>
	  <seelist> 
	    <fncref targ="wsd"/>
	    <fncref targ="wvar"/>
	  </seelist>
	</para> 
      </description>
    </function>

    <function name="wsd" section="stats" output="series">
      <fnargs>
	<fnarg type="list">Y</fnarg>
	<fnarg type="list">W</fnarg>
      </fnargs>    
      <description>
	<para>
	  Returns a series <math>y</math> such that <math>y</math><sub>t</sub>
	  is the weighted sample standard deviation of the values of the
	  variables in list <argname>Y</argname> at observation
	  <math>t</math>, the respective weights given by the values of the
	  variables in list <argname>W</argname> at <math>t</math>.  The
	  weights can therefore be time-varying. The lists
	  <argname>Y</argname> and <argname>W</argname> must be of the same
	  length and the weights must be non-negative.
	</para>
	<para>
	  <seelist> 
	    <fncref targ="wmean"/>
	    <fncref targ="wvar"/>
	  </seelist>
	</para> 
      </description>
    </function>

    <function name="wvar" section="stats" output="series">
      <fnargs>
	<fnarg type="list">X</fnarg>
	<fnarg type="list">W</fnarg>
      </fnargs>    
      <description>
	<para>
	  Returns a series <math>y</math> such that <math>y</math><sub>t</sub>
	  is the weighted sample variance of the values of the
	  variables in list <argname>X</argname> at observation
	  <math>t</math>, the respective weights given by the values of the
	  variables in list <argname>W</argname> at <math>t</math>.  The
	  weights can therefore be time-varying. The lists
	  <argname>Y</argname> and <argname>W</argname> must be of the same
	  length and the weights must be non-negative.
	</para>
	<para context="tex">
	  The weighted sample variance is computed as
	  \[ s^2_w = \frac{n'}{n'-1} \,
	  \frac{\sum_{i=1}^n w_i(x_i - \bar{x}_w)^2}{\sum_{i=1}^n w_i} \]
	  where $n'$ is the number of non-zero weights and $\bar{x}_w$ is
	  the weighted mean.
	</para>
	<para>
	  <seelist> 
	    <fncref targ="wmean"/>
	    <fncref targ="wsd"/>
	  </seelist>
	</para> 
      </description>
    </function>

    <function name="xmax" section="math" output="scalar">
      <fnargs>
	<fnarg type="scalar">x</fnarg>
	<fnarg type="scalar">y</fnarg>
      </fnargs>     
      <description>
	<para>
	  Returns the greater of <argname>x</argname> and
	  <argname>y</argname>, or <lit>NA</lit> if either value
	  is missing.  
	</para>
	<para>
	  <seelist> 
	    <fncref targ="xmin"/>
	    <fncref targ="max"/>
	    <fncref targ="min"/>
	  </seelist>
	</para> 
      </description>
    </function>

    <function name="xmin" section="math" output="scalar">
      <fnargs>
	<fnarg type="scalar">x</fnarg>
	<fnarg type="scalar">y</fnarg>
      </fnargs>     
      <description>
	<para>
	  Returns the lesser of <argname>x</argname> and
	  <argname>y</argname>, or <lit>NA</lit> if either value
	  is missing.
	</para>
	<para>
	  <seelist> 
	    <fncref targ="xmax"/>
	    <fncref targ="max"/>
	    <fncref targ="min"/>
	  </seelist>
	</para> 
      </description>
    </function>

    <function name="xpx" section="transforms" output="list">
      <fnargs>
	<fnarg type="list">L</fnarg>
      </fnargs>     
      <description>
	<para>
	  Returns a list that references the squares and cross-products
	  of the variables in list <argname>L</argname>.  Squares are
	  named on the pattern <lit>sq_</lit><repl>varname</repl> and
	  cross-products on the pattern 
	  <repl>var1</repl><lit>_</lit><repl>var2</repl>.  The input
	  variable names are truncated if need be, and the output
	  names may be adjusted in case of duplication
	  of names in the returned list.
	</para>
      </description>
    </function>

    <function name="zeromiss" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-series">x</fnarg>
      </fnargs>     
      <description>
	<para>
	  Converts zeros to <lit>NA</lit>s. If <argname>x</argname> is a
	  series, the conversion is done element by element.
	  <seelist>
	    <fncref targ="missing"/>
	    <fncref targ="misszero"/>
	    <fncref targ="ok"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="zeros" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="scalar">r</fnarg>
	<fnarg type="scalar">c</fnarg>
      </fnargs> 
      <description>
	<para>
	  Outputs a zero matrix with <math>r</math> rows and
	  <math>c</math> columns. 
	  <seelist> 
	    <fncref targ="ones"/>
	    <fncref targ="seq"/>
	  </seelist>
	</para>
      </description>
    </function>

  </funclist>
</funcref>
