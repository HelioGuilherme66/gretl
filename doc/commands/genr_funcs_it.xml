<?xml version="1.0" encoding="ISO-8859-1" ?>
<!DOCTYPE funcref SYSTEM "genr_funcs.dtd">

<funcref language="italian">

  <funclist name="Accessori" ref="accessors">

    <function name="$ahat" section="access" output="series">
      <description>
    <para>
          Deve seguire la stima di un modello panel a effetti fissi. Produce le
          stime degli effetti fissi individuali (intercette delle singole
          unità).
    </para>
      </description>
    </function>

    <function name="$aic" section="access" output="scalar">
      <description>
    <para>
      Produce il criterio di informazione di Akaike per l'ultimo modello
          stimato. Si veda <guideref targ="chap:criteria"/> per dettagli.
    </para>
      </description>
    </function>

    <function name="$bic" section="access" output="scalar">
      <description>
    <para>
      Produce il criterio di informazione bayesiana di Schwarz per l'ultimo
          modello stimato. Si veda <guideref targ="chap:criteria"/> per dettagli.
    </para>
      </description>
    </function>

    <function name="$chisq" section="access" output="scalar">
      <description>
    <para>
      Produce la statistica chi-quadro complessiva per l'ultimo
      modello stimato, se disponibile.
    </para>
      </description>
    </function>

    <function name="$coeff" section="access" output="matrix" altout="scalar">
      <fnargs>
    <fnarg optional="true" type="coeffname">s</fnarg>
      </fnargs>
      <description>
    <para>
      L'accessore <lit>$coeff</lit> può essere usato in due modi:
      senza argomenti produce un vettore colonna che contiene i
      coefficienti dell'ultimo modello stimato. Con l'argomento
      opzionale, produce uno scalare che corrisponde alla stima
      del coefficiente chiamato <argname>s</argname>.
      <seelist>
        <fncref targ="$stderr"/>
        <fncref targ="$vcv"/>
      </seelist>
    </para>
    <para>
      Esempio:
    </para>
    <code>
      open bjg
      arima 0 1 1 ; 0 1 1 ; lg 
      b = $coeff 
      macoef = $coeff(theta_1)
    </code>
    <para>
      Se il <quote>modello</quote> in questione è effettivamente
      un sistema (un VAR o un VECM, o un sistema di equazioni
      simultanee), <lit>$coeff</lit> senza parametri produce la
      matrice dei coefficienti, una colonna per equazione.
    </para>
      </description>
    </function>

    <function name="$command" section="access" output="string">
      <description>
    <para>
      Deve seguire la stima di un modello; restituisce la stringa
      del comando relativo, come ad esempio <lit>ols</lit> oppure
      <lit>probit</lit>.
    </para>
      </description>
    </function>

    <function name="$compan" section="access" output="matrix">
      <description>
    <para>
      Deve seguire la stima di un VAR o un VECM; produce la matrice
          compagna.
    </para>
      </description>
    </function>

    <function name="$datatype" section="access" output="scalar">
      <description>
    <para>
      Restituisce un intero corrispondente al tipo di dataset
      attualmente in memoria: 0 = nessun dato; 1 = dati
      cross-sezionali (non datati); 2 = serie storiche; 3 = panel.
    </para>
      </description>
    </function>

    <function name="$depvar" section="access" output="string">
      <description>
    <para>
      Deve seguire la stima di un modello ad equazione singola e
      restituisce il nome della variabile dipendente.
    </para>
      </description>
    </function>

    <function name="$df" section="access" output="scalar">
      <description>
    <para>
      Produce i gradi di libertà dell'ultimo modello stimato. Se
      questo consiste di un sistema di equazioni, viene restituito
      il numero dei gradi di libertà per equazione; se questo
      differisce da un'equazione all'altra, allora il valore
      restituito è pari al numero di osservazioni meno la media del
      numero di coefficienti per equazione (arrotondato all'intero
      più vicino).
    </para>
      </description>
    </function>

    <function name="$dwpval" section="access" output="scalar">
      <description>
    <para>
      Fornisce il p-value per la statistica Durbin&ndash;Watson
      relativa all'ultimo modello stimato, se disponibile. Tale
      valore è calcolato ramite la procedura di Imhof.
    </para>
	<para>
	  A causa della limitata precisione dell'aritmetica digitale,
	  l'integrale di Imhof può diventare negativo quando la
	  statistica di Durbin&ndash;Watson è vicina a 0. Se questo
	  accade, l'accessore restituisce <lit>NA</lit>. Poiché
	  qualsiasi altro malfunzionamento porta a un codice di
	  errore, si può ritenere con una certa sicurezza che un
	  valore NA indica che il p-value è
	  <quote>piccolissimo</quote>, benché gretl non sia in grado
	  di quantificarlo esattamente.
	</para>

      </description>
    </function>

    <function name="$ec" section="access" output="matrix">
      <description>
    <para>
      Deve seguire la stima di un VECM e restituisce una matrice
      contenente i termini di correzione d'errore.  La matrice
      restituita ha tante righe quante sono le osservazioni usate
      nella stima e un numero di colonne pari al rango di
      cointegrazione del sistema.
    </para>
      </description>
    </function>

    <function name="$error" section="access" output="scalar">
      <description>
    <para>
      Restituisce il codice interno di errore, che avrà un valore
      diverso da 0 se si è verificato un errore in presenza del
      modificatore <cmdref targ="catch"/>. Si noti che l'uso di
      questo accessore resetta il codice di errore interno a 0. Si
      veda anche <fncref targ="errmsg"/>. Per il messaggio
      d'errore associato a un dato codice, bisogna salvare il
      valore in una variabile temporanea; ad esempio:
    </para>
    <code>
      err = $error
      if (err) 
        printf "Errore %d (%s)\n", err, errmsg(err);
      endif
    </code>
    <para>
      <seelist>
        <cmdref targ="catch"/>
        <fncref targ="errmsg"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="$ess" section="access" output="scalar">
      <description>
    <para>
      Produce la somma dei quadrati degli errori dell'ultimo modello
          stimato.
    </para>
      </description>
    </function>

    <function name="$evals" section="access" output="matrix">
      <description>
    <para>
      Deve seguire la stima di un VECM; restituisce un vettore
      contenente gli autovalori usati nel calcolo del test traccia 
      per la cointegrazione.
    </para>
      </description>
    </function>

    <function name="$fcast" section="access" output="matrix">
      <description>
    <para>
      Deve seguire il comando <cmdref targ="fcast"/>; restituisce le
      previsioni sotto forma di matrice. Se il modello usato per
      le previsioni è un modello a più equazioni, ogni colonna
      corrisponde ad un'equazione; altrimenti, restituisce un vettore
      colonna.
    </para>
      </description>
    </function>

    <function name="$fcerr" section="access" output="matrix">
      <description>
    <para>
      Deve seguire il comando <cmdref targ="fcast"/>; restituisce gli
      errori standard per le previsioni sotto forma di matrice. Se
      il modello usato per le previsioni è un modello a più
      equazioni, ogni colonna corrisponde ad un'equazione;
      altrimenti, restituisce un vettore colonna.
    </para>
      </description>
    </function>

    <function name="$fevd" section="access" output="matrix">
      <description>
    <para>
      Deve seguire la stima di un VAR. Restituisce una matrice
      contenete la scomposizione della varianza dell'errore di
      previsione (FEVD). Questa avrà <math>h</math> righe, dove
      <math>h</math> è l'orizzonte di previsione, che può essere
      modificato tramite il comando <lit>set horizon</lit> o,
      altrimenti, viene fissato automaticamente sulla base della
      frequenza dei dati.  Per un VAR con <math>p</math>
      variabili, la matrice ha <math>p</math><sup>2</sup>
      colonne. La parte dell'errore di previsione sulla variabile
      <math>i</math> attribuibile allo shock alla variabile
      <math>j</math> si troverà nella colonna (<math>i</math> &minus;
      1)<math>p</math> + <math>j</math>.
    </para>
      </description>
    </function>

    <function name="$Fstat" section="access" output="scalar">
      <description>
    <para>
      Restituisce la statistica F complessiva per l'ultimo modello
      stimato, se disponibile.
    </para>
      </description>
    </function>

    <function name="$gmmcrit" section="access" output="scalar">
      <description>
    <para>
      Deve seguire un blocco <lit>gmm</lit>. Produce il valore della
          funzione obiettivo al suo minimo.
    </para>
      </description>
    </function>

    <function name="$h" section="access" output="series">
      <description>
    <para>
      Deve seguire un comando <lit>garch</lit>. Produce la
      varianza condizionale stimata.
    </para>
      </description>
    </function>

    <function name="$hausman" section="access" output="rvec">
      <description>
    <para>
      Deve seguire un comando <lit>tsls</lit> o <lit>panel</lit> con 
      l'opzione effetti casuali. Produce un vettore <by r="1"
      c="3"/> contenente nell'ordine: il valore della statistica del 
      test di Hausman, i corrispondenti gradi di libertà e p-value.
    </para>
      </description>
    </function>

    <function name="$hqc" section="access" output="scalar">
      <description>
    <para>
      Produce il criterio di informazione di Hannan-Quinn per l'ultimo
          modello stimato, se disponibile. Per maggiori dettagli sulla
          metodologia di calcolo, v. <guideref
          targ="chap:criteria"/>.
    </para>
      </description>
    </function>

    <function name="$huge" section="access" output="scalar">
      <description>
    <para>
      Restituisce un numero positivo molto grande. Per impostazione 
      predefinita è pari a 1.0E100, ma tale valore si può cambiare 
      usando il comando <cmdref targ="set"/>.
    </para>
      </description>
    </function>

    <function name="$jalpha" section="access" output="matrix">
      <description>
    <para>
      Deve seguire la stima di un VECM, e produce la matrice dei pesi, che
          contiene tante righe quante sono le variabili del VECM e tante colonne
          quanto è il rango di cointegrazione.
    </para>
      </description>
    </function>

    <function name="$jbeta" section="access" output="matrix">
      <description>
    <para>
      Deve seguire la stima di un VECM, e produce la matrice di
          cointegrazione, che contiene tante righe quante sono le 
          variabili del VECM (più il numero di eventuali variabili esogene 
          vincolate allo spazio di cointegrazione) e un numero di colonne 
          pari al rango di cointegrazione.
    </para>
      </description>
    </function>

    <function name="$jvbeta" section="access" output="smatrix">
      <description>
    <para>
      Deve seguire la stima di un VECM, e produce la matrice di covarianza
          stimata per gli elementi dei vettori di cointegrazione.
    </para>
    <para>
      Nel caso di stima non vincolata, ha un numero di righe pari al numero
          di elementi non vincolati nello spazio di cointegrazione dopo la
          normalizzazione di Phillips. Se però si stima un sistema vincolato 
          con il comando <lit>restrict</lit> e l'opzione <lit>--full</lit>, 
          verrà prodotta una matrice singolare con <math>(n+m)r</math> righe 
          (<math>n</math> è il numero delle variabili endogene, 
          <math>m</math> quello delle variabili esogene vincolate allo 
          spazio di cointegrazione e <math>r</math> è il 
          rango di cointegrazione).
    </para>
    <para>
      Esempio: il codice
    </para>
    <code>
      open denmark.gdt
      vecm 2 1 LRM LRY IBO IDE --rc --seasonals -q
      s0 = $jvbeta

      restrict --full
      b[1,1] = 1
      b[1,2] = -1
      b[1,3] + b[1,4] = 0
      end restrict
      s1 = $jvbeta

      print s0
      print s1
    </code>
    <para>
      produce il risultato seguente.
    </para>
    <code>
      s0 (4 x 4)

        0.019751     0.029816  -0.00044837     -0.12227 
        0.029816      0.31005     -0.45823     -0.18526 
     -0.00044837     -0.45823       1.2169    -0.035437 
        -0.12227     -0.18526    -0.035437      0.76062 

      s1 (5 x 5)

      0.0000       0.0000       0.0000       0.0000       0.0000 
      0.0000       0.0000       0.0000       0.0000       0.0000 
      0.0000       0.0000      0.27398     -0.27398    -0.019059 
      0.0000       0.0000     -0.27398      0.27398     0.019059 
      0.0000       0.0000    -0.019059     0.019059    0.0014180 
    </code>
      </description>
    </function>

    <function name="$llt" section="access" output="series">
      <description>
    <para>
      Per alcuni modelli stimati con massima verosimiglianza,
      produce la serie dei contributi alla log-verosimiglianza di tutte le
      osservazioni. Al momento, questo accessore funziona solo per
      logit e probit binari, tobit e heckit.
    </para>
      </description>
    </function>

    <function name="$lnl" section="access" output="scalar">
      <description>
    <para>
      Produce la log-verosimiglianza dell'ultimo modello stimato (dove
          possibile).
    </para>
      </description>
    </function>

    <function name="$macheps" section="access" output="scalar">
      <description>
    <para>
      Restituisce il valore dell'<quote>epsilon macchina</quote>,
      ossia un limite superiore all'errore relativo dovuto
      all'aritmetica a virgola mobile in doppia precisione.
    </para>
      </description>
    </function>

    <function name="$mnlprobs" section="access" output="matrix">
      <description>
    <para>
      Dopo la stima di un modello logit multinomiale, crea una
      matrice con le probabilità stimate di tutti i possibili
      esiti per tutte le osservazioni usate nella stima. Le
      osservazioni sono per riga e gli esiti per colonna.
    </para>
      </description>
    </function>

    <function name="$ncoeff" section="access" output="int">
      <description>
    <para>
      Produce il numero totale dei coefficienti stimati nell'ultimo modello.
    </para>
      </description>
    </function>

    <function name="$nobs" section="access" targ="dnobs" output="int">
      <description>
    <para>
      Produce il numero delle osservazioni nel campione selezionato.
    </para>
      </description>
    </function>

    <function name="$nvars" section="access" output="int">
      <description>
    <para>
    Produce il numero delle variabili nel dataset (inclusa la costante).
    </para>
      </description>
    </function>

    <function name="$obsdate" section="access" output="series">
      <description>
    <para>
      Applicabile quando il dataset corrente è una serie storica
      con frequenza decennale, annuale, trimestrale, mensile,
      settimanale o giornaliera, oppure è un panel in cui la
      variabile che indicizza i periodi ha la frequenza
      appropriata (si veda il comando <cmdref targ="setobs"/>).
      La variabile risultante ha 8 cifre con la struttura
      <lit>YYYYMMDD</lit> (formato <quote>base</quote> delle date
      secondo l'ISO 8601), che corrisponde al giorno
      di osservazione o al primo giorno del periodo di
      osservazione nel caso di serie storiche con frequenza minore
      di quella giornaliera.
    </para>
    <para>
      Questa variabile può essere utile quando si usa il comando 
      <cmdref targ="join"/>.
    </para>
      </description>
    </function>

    <function name="$obsmajor" section="access" output="series">
      <description>
    <para>
      Applicabile quando le osservazioni nel dataset aperto hanno
      una struttura maggiore:minore, come in serie storiche
      trimestrali (anno:trimestre), mensili (anno:mese), orarie
      (giorno:ora) e dati panel (individuo:periodo). Restituisce una
      variabile contenente la componente maggiore (a frequenza più
      bassa, come l'anno).
    </para>
    <para>
      <seelist>
        <fncref targ="$obsminor"/>
        <fncref targ="$obsmicro"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="$obsmicro" section="access" output="series">
      <description>
    <para>
      Applicabile quando le osservazioni nel dataset aperto hanno
      una struttura maggiore:minore:micro, come in serie storiche
      giornaliere (anno:mese:giorno). Restituisce una
      variabile contenente la componente micro (a frequenza più
      alta, come il giorno).
    </para>
    <para>
      <seelist>
        <fncref targ="$obsmajor"/>
        <fncref targ="$obsminor"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="$obsminor" section="access" output="series">
      <description>
    <para>
      Applicabile quando le osservazioni nel dataset aperto hanno
      una struttura maggiore:minore, come in serie storiche
      trimestrali (anno:trimestre), mensili (anno:mese), orarie
      (giorno:ora) e dati panel (individuo:periodo). Restituisce una
      variabile contenente la componente minore (a frequenza più
      alta, come il mese).
    </para>
    <para>
      <seelist>
        <fncref targ="$obsmajor"/>
        <fncref targ="$obsmicro"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="$pd" section="access" output="int">
      <description>
    <para>
      Produce la frequenza o la periodicità dei dati (es. 4 per dati
          trimestrali). Nel caso di dati panel il valore prodotto rappresenta
          la lunghezza della serie storica.
    </para>
      </description>
    </function>

    <function name="$pi" section="access" output="scalar">
      <description>
    <para>
      Restituisce il valore di &pi; in doppia precisione.
    </para>
      </description>
    </function>

    <function name="$pvalue" section="access" targ="dpvalue" output="scalar-or-matrix">
      <description>
    <para>
      Produce il p-value della statistica test generata
      dall'ultimo comando esplicito di test di ipotesi (es.
      <lit>chow</lit>).  Si veda <guideref
      targ="chap:genr"/> per ulteriori dettagli. 
    </para>
    <para>
      Nella maggior parte dei casi il valore prodotto è scalare ma talvolta 
      può essere costituito da una matrice (per esempio i p-value 
      delle statistiche della traccia e lambda-max del test di 
      cointegrazione di Johansen); in questo caso i valore contenuti
      nella matrice sono organizzati seguendo la stessa struttura con la 
      quale vengono riportati i risultati.
    </para>
    <para>
      <seelist>
        <fncref targ="$test"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="$rho" section="access" output="scalar">
      <fnargs>
    <fnarg optional="true" type="scalar">n</fnarg>
      </fnargs>
      <description>
    <para>
      Senza argomenti, produce il coefficiente autoregressivo del
          prim'ordine per i residui dell'ultimo modello. Dopo aver stimato un
          modello con il comando <lit>ar</lit>, la sintassi
      <lit>$rho(n)</lit> produce la corrispondente stima di
      &rgr;(<math>n</math>).
    </para>
      </description>
    </function>

    <function name="$rsq" section="access" output="scalar">
      <description>
    <para>
      Produce l'<math>R</math><sup>2</sup> non aggiustato
      dell'ultimo modello stimato.
    </para>
      </description>
    </function>

    <function name="$sample" section="access" output="series">
      <description>
    <para>
      Deve seguire la stima di un modello ad equazione
      singola. Restituisce una variabile binaria con 1 per le
      osservazioni usate nella stima, 0 per osservazioni incluse
      nel campione corrente ma non usate nella stima (ad esempio,
      per via di valori mancanti nella variabile dipendente) e NA
      per osservazioni al di fuori del campione corrente.
    </para>
    <para>
      Se fosse necessario calcolare statistiche basate sul
      campione usato per un certo modello, ad esempio, si potrebbe
      usare la seguente sintassi:
    </para>
    <code>
      ols y 0 xlist
      genr sdum = $sample
      smpl sdum --dummy
    </code>
      </description>
    </function>

    <function name="$sargan" section="access" output="rvec">
      <description>
    <para>
      Deve seguire un comando <lit>tsls</lit>. Produce un vettore <by
      r="1" c="3"/> che contiene nell'ordine: il valore della
      statistica del test di Sargan di sovraidentificazione, i
      corrispondenti gradi di libertà e il p-value. Se il modello è
      esattamente identificato, la statistica non è disponibile, e
      tentare di ottenerla provoca un errore.
    </para>
      </description>
    </function>

    <function name="$sigma" section="access" output="scalar-or-matrix">
      <description>
    <para>
      Richiede che sia stato stimato un modello. Se quest'ultimo consiste
      di un'unica equazione, restituisce uno scalare, lo Standard Error 
      della Regressione (in altre parole, lo scarto quadratico medio dei
      residui, con l'opportuna correzione per i gradi di libertà). Se il
      modello contiene un sistema di equazioni, la funzione restituisce 
      la matrice di covarianza dei residui delle diverse equazioni.
    </para>
      </description>
    </function>

    <function name="$stderr" section="access" output="matrix" altout="scalar">
      <fnargs>
    <fnarg optional="true" type="coeffname">s</fnarg>
      </fnargs>
      <description>
    <para>
      L'accessore <lit>$stderr</lit> restituisce un vettore colonna 
      contenente lo standard error dei coefficienti dell'ultimo modello. 
      Con il parametro opzionale, restituisce uno scalare contenente lo
      standard error del parametro <argname>s</argname>.
    </para>
    <para>
      Se il <quote>modello</quote> in questione è un sistema, il
      risultato dipende dalle sue caratteristiche: per sistemi VAR
      e VECM il valore restituito è una matrice con una colonna per
      equazione; altrimenti, è un vettore colonna contenente i
      coefficienti della prima equazione, seguiti da quelli della
      seconda, e così via.
    </para>
    <para>
      <seelist>
        <fncref targ="$coeff"/> 
        <fncref targ="$vcv"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="$stopwatch" section="access" output="scalar">
      <description>
    <para>
      Deve essere preceduto dal comando <lit>set stopwatch</lit>,
      che attiva la misurazione del tempo di CPU.  Il primo uso di
      questo accessore restituisce i secondi di CPU time trascorsi dal
      comando <lit>set stopwatch</lit>. Ad ogni accesso il
      cronometro viene riazzerato, cosicché l'uso successivo
      dell'accessore restituisce i secondi di CPU intercorsi dalla
      chiamata precedente.
    </para>
      </description>
    </function>

    <function name="$sysA" section="access" output="matrix">
      <description>
    <para>
      Deve seguire la stima di un sistema simultaneo.  Restituisce
      la matrice dei coefficienti delle endogene ritardate, se
      presenti nella forma strutturale. Si veda il comando <cmdref
      targ="system"/>.
    </para>
      </description>
    </function>

    <function name="$sysB" section="access" output="matrix">
      <description>
    <para>
      Deve seguire la stima di un sistema simultaneo.  Restituisce
      la matrice dei coefficienti delle esogene nella forma
      strutturale. Si veda il comando <cmdref targ="system"/>.
    </para>
      </description>
    </function>

    <function name="$sysGamma" section="access" output="matrix">
      <description>
    <para>
      Deve seguire la stima di un sistema simultaneo.  Restituisce
      la matrice dei coefficienti delle endogene contemporanee
      nella forma strutturale. Si veda il comando <cmdref
      targ="system"/>.
    </para>
      </description>
    </function>

    <function name="$sysinfo" section="access" output="bundle">
      <description>
    <para>
      Restituisce un bundle contenente informazioni sulle caratteristiche
      della versione di gretl e del sistema sul quale quest'ultimo viene 
      eseguito. I membri del bundle sono i seguenti:
    </para>
    <ilist>
      <li>
        <para>
          <lit>mpi</lit>: intero, pari a 1 se il sistema è compatibile con 
          MPI (Message Passing Interface), altrimenti è pari a 0.
        </para>
      </li>
      <li>
        <para>
          <lit>omp</lit>: intero, pari a 1 se la versione di gretl è 
          compatibile con Open MP, altrimenti è pari a 0.
        </para>
      </li>
      <li>
        <para>
          <lit>nproc</lit>: intero, il numero di processori disponibili.
        </para>
      </li>
      <li>
        <para>
          <lit>mpimax</lit>: intero, il numero massimo di processi MPI che 
          possono essere eseguiti in parallelo. Questo valore è nullo se 
          il sistema non è compatibile con MPI, altrimenti è pari al valore 
          locale <lit>nproc</lit> a meno che non sia stato specificato un
          file di MPI hosts; in questo caso esso è pari alla somma del
          numero dei processori o degli <quote>slots</quote> presenti
          su tutte le macchine elencate in quel file.
        </para>
      </li>
      <li>
        <para>
          <lit>wordlen</lit>: intero, pari a 32 o 64 rispettivamente 
          per sistemi a 32- o 64-bit.
        </para>
      </li>
      <li>
        <para>
          <lit>os</lit>: stringa contenente il sistema operativo: può
          essere pari a <lit>linux</lit>, <lit>osx</lit>,
          <lit>windows</lit> o <lit>other</lit>.
        </para>
      </li>
      <li>
        <para>
          <lit>hostname</lit>: il nome della macchina host sulla quale 
          viene eseguito il processo corrente di gretl (con il valore di 
          ripiego <lit>localhost</lit> nel caso in cui il nome non potesse
          essere individuato).
        </para>
      </li>   
    </ilist>
    <para>
      Si noti che i singoli elementi del bundle possono essere recuperati
      usando la notazione <quote>dot</quote> senza bisogno di copiare
      l'intero bundle con un nuovo nome specificato dall'utente. 
      Per esempio, 
    </para>
    <code>
      if $sysinfo.os == "linux"
        # effettua un'operazione specifica a linux
      endif
    </code>
      </description>
    </function>

    <function name="$T" section="access" output="int">
      <description>
    <para>
      Numero di osservazioni usato nella stima dell'ultimo
      modello.
    </para>
      </description>
    </function>

    <function name="$t1" section="access" output="int">
      <description>
    <para>
      Indice (a base 1) della prima osservazione nel campione
      attualmente selezionato.
    </para>
      </description>
    </function>

    <function name="$t2" section="access" output="int">
      <description>
    <para>
      Indice (a base 1) dell'ultima osservazione nel campione
      attualmente selezionato.
    </para>
      </description>
    </function>

    <function name="$test" section="access" output="scalar-or-matrix">
      <description>
    <para>
      Restituisce il valore della statistica test generata
      dall'ultimo comando esplicitamente volto al test di ipotesi
      (p. es: <lit>chow</lit>), se presente. Si veda <guideref
      targ="chap:genr"/> per maggiori dettagli.
    </para>
    <para>
      Nella maggior parte dei casi il valore restituito è uno scalare
      ma talvolta può trattarsi di una matrice (per esempio nel caso delle 
      statistiche della traccia e lambda-max del test di cointegrazione
      di Johansen); in questo caso gli elementi della matrice sono
      organizzati seguendo la stessa struttura utilizzata nella stampa
      dei risultati.
    </para>
    <para>
      <seelist>
        <fncref label="\$pvalue" targ="dpvalue"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="$trsq" section="access" output="scalar">
      <description>
    <para>
      Restituisce <math>TR</math><sup>2</sup> (numerosità campionaria
      per R quadro) dall'ultimo modello.
    </para>
      </description>
    </function>

    <function name="$uhat" section="access" output="series">
      <description>
    <para>
      Restituisce i residui dall'ultimo modello stimato. Cosa si
      intenda per 'residui' dipende dal modello che è stato
      stimato. Ad esempio, dopo una stima ARMA <lit>$uhat</lit>
      contiene gli errori di previsione a un passo; dopo un
      probit, i residui generalizzati.
    </para>
    <para>
      Se il modello in questione è multi-equazionale (un VAR o un
      VECM, o un sistema di equazioni simultanee), <lit>$uhat</lit> senza
      parametri restituisce una matrice contenente i residui nelle
      colonne.
    </para>
      </description>
    </function>

    <function name="$unit" section="access" output="series">
      <description>
    <para>
      Valido solo per dataset di tipo panel.  Restituisce una variabile
      con 1 per tutte le osservazioni della prima unità cross-sezionale, 
      2 per le osservazioni della seconda e così via.
    </para>
      </description>
    </function>

    <function name="$vcv" section="access" output="matrix" altout="scalar">
      <fnargs>
    <fnarg optional="true" type="coeffname">s1</fnarg>
    <fnarg optional="true" type="coeffname">s2</fnarg>
      </fnargs>
      <description>
    <para>
      Senza argomenti, <lit>$vcv</lit> restituisce una matrice quadrata 
      contenente le covarianze stimate dei coefficienti dell'ultimo modello.  
      Nel caso quest'ultimo contenesse una sola equazione è possibile
      indicare i nomi di due parametri fra parentesi per recuperare
      la covarianza stimata fra i parametri di nome
      <argname>s1</argname> e <argname>s2</argname>.
      <seelist>
        <fncref targ="$coeff"/> 
        <fncref targ="$stderr"/>
      </seelist>
    </para>
    <para>
      Questo accessore non è disponibile per modelli di tipo VAR o
      VECM; in tal caso, si veda piuttosto <fncref targ="$sigma"/> e
      <fncref targ="$xtxinv"/>.
    </para>
      </description>
    </function>

    <function name="$vecGamma" section="access" output="matrix">
      <description>
    <para>
      Deve seguire la stima di un VECM; restituisce una matrice in cui
      le matrici Gamma (cioè i coefficienti delle differenze
      ritardate) sono messe una fianco all'altra.  Ogni riga
      rappresenta un'equazione; per un VECM di ordine
      <math>p</math> ci sono <math>p</math> &minus; 1
      sottomatrici.
    </para>
      </description>
    </function>    

    <function name="$version" section="access" output="scalar">
      <description>
    <para>
      Restituisce un valore intero che codifica la versione del
      programma, sotto la forma <lit>x.y.z</lit> (ad esempio,
      1.7.6).  Il valore prodotto da questo accessore è pari a
      <lit>10000*x + 100*y + z</lit>, cosicché 1.7.6 diventa
      10706.
    </para>
      </description>
    </function>


    <function name="$vma" section="access" output="matrix">
      <description>
    <para>
      Deve seguire la stima di un VAR o di un VECM; restituisce
      una matrice contenente la rappresentazione VMA fino
      all'ordine specificato tramite il comando <lit>set
      horizon</lit>. Per maggiori dettagli, si veda <guideref
      targ="chap:var"/>.
    </para>
      </description>
    </function>

    <function name="$windows" section="access" output="int">
      <description>
    <para>
      Restituisce 1 se gretl sta girando sotto Windows e 0
      altrimenti. Questo accessore viene tipicamente usato per
      scrivere script portabili da un sistema operativo ad un
      altro.
    </para>
    <para>
      Si veda anche il comando <cmdref targ="shell"/>.
    </para>
      </description>
    </function>

    <function name="$xlist" section="access" output="list">
      <description>
    <para>
      Se l'ultimo modello stimato è un'equazione singola,
      restituisce la lista dei regressori. Se l'ultimo modello
      stimato è un sistema di equazioni, restituisce la lista
      <quote>globale</quote> delle variabili esogene e
      predeterminate (nello stesso ordine con cui compaiono in
      <fncref targ="$sysB"/>). Se l'ultimo modello è un VAR,
      restituisce la lista dei regressori esogeni, laddove
      presenti.
    </para>
      </description>
    </function>

    <function name="$xtxinv" section="access" output="matrix">
      <description>
    <para>
      Quando segue la stima di un VAR o di un VECM, restituisce
      <math>X'X</math><sup>-1</sup>, dove <math>X</math> è la
      matrice comune dei regressori usati in ciascuna delle
      equazioni. Questo accessore non è disponibile per un VECM
      stimato con una restrizione imposta su &agr;, la matrice dei
      <quote>loading</quote>.
    </para>
      </description>
    </function>

    <function name="$yhat" section="access" output="series">
      <description>
    <para>
      Restituisce i valori stimati dall'ultima regressione.
    </para>
      </description>
    </function>

    <function name="$ylist" section="access" output="list">
      <description>
    <para>
      Se l'ultimo modello stimato è un VAR, un VECM o un sistema
      di equazioni simultanee, restituisce la lista delle
      variabili endogene nel modello. Se l'ultimo modello stimato
      è un'equazione singola, questo accessore fornisce una lista
      di un solo elemento: la variabile dipendente. Nel caso
      particolare di un modello biprobit la lista contiene due
      elementi.
    </para>
      </description>
    </function>

  </funclist>

  <funclist name="Functions proper" ref="functions">

    <function name="abs" section="math" output="asinput">
      <fnargs>
    <fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
    <para>
      Valore assoluto di <argname>x</argname>.
    </para>
      </description>
    </function>

    <function name="acos" section="math" output="asinput">
      <fnargs>
    <fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
    <para>
      Arcocoseno di <argname>x</argname>, ossia il numero il cui
      coseno è <argname>x</argname>.  Il risultato è in radianti;
      l'argomento deve essere compreso fra &minus;1 e 1.
    </para>
      </description>
    </function>

    <function name="acosh" section="math" output="asinput">
      <fnargs>
    <fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce l'arcoseno iperbolico di <argname>x</argname>
      (soluzione positiva). <argname>x</argname> deve essere maggiore di 1;
      in caso contrario, viene restituito NA.
      <seelist>
        <fncref targ="cosh"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="aggregate" section="stats" output="matrix">
      <fnargs>
    <fnarg type="series-or-list">x</fnarg>
    <fnarg type="series-or-list">byvar</fnarg>
    <fnarg type="string">funcname</fnarg>   
      </fnargs>
      <description>
    <para>
      Nella versione più semplice, in cui sia <argname>x</argname>
      sia <argname>byvar</argname> sono singole variabili, questa
      funzione restituisce una matrice con tre colonne: la prima
      contiene i valori distinti di <argname>byvar</argname>,
      ordinati in senso crescente; la seconda contiene il numero
      delle osservazioni in cui <argname>byvar</argname> assume
      ciascuno di questi valori; la terza, infine, contiene i
      valori della statistica specificata da
      <argname>funcname</argname>, calcolata sulla variabile
      <argname>x</argname> usando solo quelle osservazioni per cui
      <argname>byvar</argname> assume il valore specificato nella
      prima colonna.
    </para>
    <para>
      Più in generale, se <argname>byvar</argname> è una lista di
      <math>n</math> elementi, allora le prime <math>n</math>
      colonne da sinistra contengono le combinazioni dei valori
      distinti di ciascuna delle <math>n</math> variabili, mentre la
      colonna immediatamente successiva contiene il numero delle
      osservazioni in cui ciascuna combinazione ricorre. Se
      <argname>x</argname> è una lista con <math>m</math>
      elementi, allora le <math>m</math> colonne più a destra
      contengono i valori della statistica specificata da
      <argname>funcname</argname> per ciascuna delle variabili
      <argname>x</argname>, calcolati sul sottocampione
      individuato dalle prime colonne.
    </para>
    <para>
      I seguenti valori di <argname>funcname</argname> sono
      supportati <quote>in modo nativo</quote>: <fncref
      targ="sum"/>, <fncref targ="sumall"/>, <fncref
      targ="mean"/>, <fncref targ="sd"/>, <fncref targ="var"/>,
      <fncref targ="sst"/>, <fncref targ="skewness"/>, <fncref
      targ="kurtosis"/>, <fncref targ="min"/>, <fncref
      targ="max"/>, <fncref targ="median"/>, <fncref targ="nobs"/>
      e <fncref targ="gini"/>. Ciascuna di queste funzioni accetta
      come argomento una variabile e restituisce uno scalare, e in tal
      senso può dirsi che <quote>aggrega</quote> la variabile in un
      qualche modo. È anche possibile inserire il nome di
      una funzione definita dall'utente come aggregatore; come le
      funzioni supportate in modo nativo, tale funzione deve
      accettare come argomento una singola variabile e ritornare uno
      scalare.
    </para>
    <para>
      Si noti che, benché il conteggio dei casi sia fornito
      automaticamente, la funzione <lit>nobs</lit> non è
      ridondante come aggregatore, poiché fornisce il numero di
      osservazioni valide (non-missing) in <argname>x</argname>
      per ciascuna combinazione <argname>byvar</argname>.
    </para>
    <para>
      Come semplice esempio, si supponga che <lit>region</lit> sia
      la codifica di regioni geografiche con valori interi da 1 ad
      <math>n</math> e <lit>income</lit> il reddito
      familiare. Allora quanto segue produrrà una matrice <by
      r="n" c="3"/> contenente: nella prima colonna, i codici
      delle regioni; nella seconda, il numero delle osservazioni
      in ciascuna regione; nella terza, il reddito familiare medio
      per regione:
    </para>
    <code>
      matrix m = aggregate(income, region, mean)
    </code>
    <para>
      Per un esempio che utilizza liste, si ipotizzi che
      <lit>gender</lit> sia una variabile dummy maschio/femmina e
      <lit>race</lit> una variabile categoriale con tre possibili
      valori. Allora quanto segue genererà una matrice con 6 righe
      e 5 colonne: le prime due colonne conterranno le
      combinazioni possibili gender/race; quella centrale
      il numero di osservazioni di ciascuna di queste combinazioni; e 
      le ultime due la deviazione standard campionaria di <lit>income</lit> e
      <lit>age</lit>:
    </para>
    <code>
      list BY = gender race
      list X = income age
      matrix m = aggregate(X, BY, sd)
    </code>
    <para>
      Si noti che, nel caso in cui <argname>byvar</argname> sia
      una lista, alcune combinazioni dei valori di
      <argname>byvar</argname> potrebbero non essere presenti nei
      dati (il numero di osservazioni sarà zero). In tal caso, il
      valore delle statistiche per <argname>x</argname> viene
      registrato come <lit>NaN</lit> (Not a Number). Nel caso si
      voglia non considerare tali casi, si può utilizzare la
      funzione <fncref targ="selifr"/> per selezionare solo le
      righe associate ad un numero di osservazioni diverso da
      zero. Nel caso in cui <argname>byvar</argname> contenga
      <math>n</math> elementi, la colonna da testare sarà quella
      immediatamente a destra delle prime <math>n</math> colonne
      partendo da sinistra. Possiamo quindi eseguire il seguente
      codice:
    </para>
    <code>
      matrix m = aggregate(X, BY, sd)
      scalar c = nelem(BY)
      m = selifr(m, m[,c+1])
    </code>
      </description>
    </function>

    <function name="argname" section="strings" output="string">
      <fnargs>
    <fnarg type="string">s</fnarg>
      </fnargs>
      <description>
    <para>
      Per <argname>s</argname>, il nome di un parametro in una
      funzione definita dall'utente, restituisce il nome del
      corrispondente argomento, o una stringa vuota se l'argomento
      era anonimo.
    </para>
      </description>
    </function>

    <function name="array" section="data-utils" output="seebelow">
      <fnargs>
	<fnarg type="int">n</fnarg>
      </fnargs>
      <description>
	<para>
	  Funzione <quote>costruttrice</quote> di base per una nuova
	  variabile di tipo array. Nell'uso di questa funzione, si
	  deve specificare un tipo (in forma plurale) per l'array:
	  <lit>strings</lit>, <lit>matrices</lit>, <lit>bundles</lit>
	  oppure <lit>lists</lit>.  Il valore prodotto è un array del
	  tipo specificato con <argname>n</argname> elementi, ognuno
	  dei quali è inizializzato come <quote>vuoto</quote> (ad
	  esempio, stringhe nulle, matrici 0x0). Esempi d'uso:
	</para>
	<code>
	  strings S = array(5)
	  matrices M = array(3)
	</code>
	<para>
	  Vedi anche <fncref targ="defarray"/>.
	</para>
      </description>
    </function>    

    <function name="asin" section="math" output="asinput">
      <fnargs>
    <fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce l'arcoseno di <argname>x</argname>, cioè, il
      valore il cui seno è <argname>x</argname>.  Il risultato è
      in radianti; l'input deve essere tra &minus;1 e 1, estremi
      compresi.
    </para>
      </description>
    </function>

    <function name="asinh" section="math" output="asinput">
      <fnargs>
    <fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce l'arcoseno iperbolico di <argname>x</argname>.
      <seelist>
        <fncref targ="sinh"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="atan" section="math" output="asinput">
      <fnargs>
    <fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
    <para>
      Funzione arcotangente di <argname>x</argname>, ossia il valore
      la cui tangente è <argname>x</argname>.  Il risultato è in
      radianti.
      <seelist>
        <fncref targ="cos"/>
        <fncref targ="sin"/>
        <fncref targ="tan"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="atanh" section="math" output="asinput">
      <fnargs>
    <fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce l'arcotangente iperbolica di <argname>x</argname>.
      <seelist>
        <fncref targ="tanh"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="atof" section="strings" output="scalar">
      <fnargs>
    <fnarg type="string">s</fnarg>
      </fnargs>
      <description>
    <para>
      Analoga alla funzione della libreria C con lo stesso
      nome. Restituisce il risultato della conversione della stringa
      <argname>s</argname> (o della porzione di essa che segue
      qualsiasi spazio iniziale) in un numero a virgola mobile. In
      modo diverso dalla funzione <lit>atof</lit> in C, comunque, per
      questioni di portabilità, si assume sempre che il carattere
      decimale sia <quote><lit>.</lit></quote>. Qualsiasi carattere
      che segue la porzione di <argname>s</argname> convertita in
      numero decimale a virgola mobile sotto questa assunzione è
      ignorata.
    </para>
    <para>
      Se nessuna porzione di <argname>s</argname> (che segue
      qualsiasi spazio iniziale) risulta convertibile sotto le
      suddette assunzioni, la funzione restituisce <lit>NA</lit>.
    </para>
    <code>
      # examples
      x = atof("1.234") # gives x = 1.234 
      x = atof("1,234") # gives x = 1
      x = atof("1.2y")  # gives x = 1.2
      x = atof("y")     # gives x = NA
      x = atof(",234")  # gives x = NA
    </code> 
    <para>
      Si veda anche <fncref targ="sscanf"/> per modalità più flessibili di 
      conversione da stringa a numero.
    </para>
      </description>
    </function>

    <function name="bessel" section="math" output="asinput">
      <fnargs>
    <fnarg type="char">type</fnarg>
    <fnarg type="scalar">v</fnarg>
    <fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
    <para>
      Calcola una delle varianti della funzione di Bessel di
      ordine <argname>v</argname> con argomento
      <argname>x</argname>. Il valore restituito è dello stesso
      tipo dell'argomento <argname>x</argname>. La variante
      specifica della funzione è selezionata sulla base del primo
      argomento, che deve essere <lit>J</lit>, <lit>Y</lit>,
      <lit>I</lit>, o <lit>K</lit>.  Una buona discussione delle
      funzioni di Bessel si trova su Wikipedia; qui forniamo una
      breve sintesi.
    </para>
    <para>
      caso <lit>J</lit>: Funzione di Bessel del primo
      tipo. Ricorda un'onda sinusoidale smorzata. Definita per
      reali. Tuttavia, se <argname>x</argname> è negativo,
      <argname>v</argname> deve essere un numero intero.
    </para>
    <para>
      caso <lit>Y</lit>: Funzione di Bessel del secondo
      tipo. Definita per <argname>v</argname> e
      <argname>x</argname> reali, ma ha una singolarità a
      <argname>x</argname> = 0.
    </para>
    <para>
      caso <lit>I</lit>: Funzione di Bessel modificata del primo
      tipo. Una funzione con crescita esponenziale. Gli argomenti
      accettati sono gli stessi del caso <lit>J</lit>.
    </para>
    <para>
      caso <lit>K</lit>: Funzione di Bessel modificata del secondo
      tipo. Una funzione con decadimento esponenziale. Diverge a
      <argname>x</argname> = 0 e non è definita per valori
      negativi di <argname>x</argname>. È simmetrica
      attorno a <argname>v</argname> = 0.
    </para>
      </description>
    </function>

    <function name="BFGSmax" section="numerical" output="scalar">
      <fnargs>
    <fnarg type="vector">b</fnarg>
    <fnarg type="fncall">f</fnarg>
    <fnarg type="fncall" optional="true">g</fnarg>
      </fnargs>
      <description>
    <para>
      Massimizzazione numerica con il metodo di Broyden, Fletcher,
      Goldfarb e Shanno. Il vettore <argname>b</argname> deve
      contenere i valori iniziali di un insieme di parametri,
      mentre la stringa <argname>s</argname> deve specificare la
      chiamata a una funzione che calcola il criterio (scalare) da
      massimizzare, dati i valori correnti dai parametri e
      qualsiasi altro dato rilevante. Se l'oggetto è di fatto una
      minimizzazione, è sufficiente ridefinire la funzione
      chiamata in modo che restituisca il criterio cambiato di
      segno. In caso di successo, <lit>BFGSmax</lit> restituisce
      il valore massimizzato del criterio, e <argname>b</argname>
      contiene i valori dei parametri associati al valore del
      criterio restituito.
    </para>
    <para>
      Il terzo argomento opzionale permette di fornire le derivate analitiche
      (in caso contrario il gradiente è calcolato numericamente). La 
      chiamata della funzione del gradiente <argname>g</argname> deve avere
      come primo argomento una matrice predefinita con dimensioni identiche
      a quelle del gradiente, indicata con un puntatore. Inoltre deve 
      accettare il vettore dei parametri fra gli argomenti (come puntatore
      o altro). Gli altri argomenti sono opzionali.
    </para>
    <para>
      Per maggiori dettagli ed esempi, si veda il capitolo sui metodi 
      numerici in <guideref targ="chap:numerical"/>.
      <seelist>
        <fncref targ="NRmax"/>
        <fncref targ="fdjac"/>
        <fncref targ="simann"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="bkfilt" section="filters" output="series">
      <fnargs>
    <fnarg type="series">y</fnarg>
    <fnarg type="int" optional="true">f1</fnarg>
    <fnarg type="int" optional="true">f2</fnarg>
    <fnarg type="int" optional="true">k</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce il risultato dell'applicazione del filtro passa banda di
      Baxter&ndash;King alla variabile <argname>y</argname>. I parametri
      opzionali <argname>f1</argname> e <argname>f2</argname>
      rappresentano, rispettivamente, i limiti inferiore e
      superiore delle frequenze da estrarre, mentre
      <argname>k</argname> è l'ordine dell'approssimazione da
      usare.
    </para>
    <para>
      Se questi argomenti non sono forniti dall'utente, i valori di
      default dipendono dalla periodicità del dataset. Per dati
      annuali, i valori di default per <argname>f1</argname>,
      <argname>f2</argname> e <argname>k</argname> sono
      rispettivamente 2, 8 e 3; per dati trimestrali, 6, 32 e 12; per
      dati mensili, 18, 96 e 36. Questi valori sono scelti in modo da
      rispettare la scelta più comune fra gli economisti applicati, e
      cioè di usare questo filtro per estrarre la componente alla
      frequenza di <quote>business cycle</quote>; questa, a sua volta,
      è di solito definita come compresa fra 18 mesi e 8 anni. Il
      filtro, come impostazione predefinita, usa 3 anni di dati.
    </para>
    <para>
      Se <argname>f2</argname> è maggiore o uguale del numero di
      osservazioni disponibili, verrà usata la versione "passa-basso"
      del filtro e il risultato deve essere interpretato come una
      stima del trend, anziché del ciclo.
      <seelist>
        <fncref targ="bwfilt"/>
        <fncref targ="hpfilt"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="boxcox" section="filters" output="series">
      <fnargs>
    <fnarg type="series">y</fnarg>
    <fnarg type="scalar">d</fnarg>
      </fnargs>    
      <description>
    <para>
      Restituisce la trasformazione Box&ndash;Cox con parametro
      <argname>d</argname> della variabile positiva
      <argname>y</argname>.
    </para>   
    <para context="tex">
      \[ y_t^{(d)} = \left\{ \begin{array}{ll} \frac{y_t^d - 1}{d} &amp;
      {\rm if}\quad d\neq 0 \\ \log (y_t) &amp; {\rm if}\quad d=0
      \end{array} \right. \]
    </para>
    <para context="notex">
      La variabile trasformata è (<math>y</math><sup>d</sup> - 1)/<math>d</math> 
      per <math>d</math> diverso da zero, o log(<math>y</math>) per 
      <math>d</math> = 0.
    </para>
      </description>
    </function>

    <function name="bread" section="data-utils" output="bundle">
      <fnargs>
    <fnarg type="string">nomefile</fnarg>
    <fnarg optional="true" type="bool">import</fnarg>
      </fnargs>
      <description>
    <para>
      Legge un bundle da un file di testo. la stringa
      <argname>nomefile</argname> deve contenere il nome del file da
      cui deve essere letta il bundle. Se questo nome ha estensione
      <quote><lit>.gz</lit></quote>, si assume che il file sia stato
      creato con compressione gzip.
    </para>
    <para>
      Il file in questione dev'essere un file XML appropriatamente
      definito: esso deve contenere un elemento
      <lit>gretl-bundle</lit>, usato a sua volta per contenere zero o
      più elementi <lit>bundled-item</lit>. Ad esempio:
    </para>
    <code>
      &lt;?xml version="1.0" encoding="UTF-8"?&gt;
      &lt;gretl-bundle name="temp"&gt;
        &lt;bundled-item key="s" type="string"&gt;moo&lt;/bundled-item&gt;
        &lt;bundled-item key="x" type="scalar"&gt;3&lt;/bundled-item&gt;
      &lt;/gretl-bundle&gt;
    </code>
    <para>
      Come ci si può aspettare, file di questo tipo vengono generati
      automaticamente dalla funzione complementare <fncref targ="bwrite"/>.
    </para>
    <para>
      Se viene indicato un valore non nullo per l'argomento opzionale
      <argname>import</argname>, la ricerca del file di input avviene
      all'interno della directory <quote>dot</quote> dell'utente. In
      questo caso l'argomento <argname>fname</argname> dovrebbe essere
      semplicemente un nome di file, senza indicazione del percorso.
    </para>
    <para>
      Se dovesse verificarsi un errore (per esempio dovuto al fatto
      che il file è inaccessibile o mal formattato) l'accessore
      <fncref targ="$error"/> risulterà non-zero.
    </para>
    <para>
      <seelist>
        <fncref targ="mread"/>
        <fncref targ="bwrite"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="bwfilt" section="filters" output="series">
      <fnargs>
    <fnarg type="series">y</fnarg>
    <fnarg type="int">n</fnarg>
    <fnarg type="scalar">omega</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce il risultato dell'applicazione di un filtro
      passa-basso Butterworth di ordine <argname>n</argname> e
      frequenza di taglio <argname>omega</argname> alla variabile
      <argname>y</argname>. La frequenza di taglio è espressa in
      gradi e deve essere maggiore di 0 e minore di 180. Frequenze
      di taglio minori restringono il passa banda alle frequenze
      minori e quindi producono trend più smussati. Valori
      maggiori di <argname>n</argname> producono un taglio più
      netto, al costo di una possibile instabilità numerica.
    </para>
    <para>
      L'esame del periodogramma della variabile target è un passo 
      preliminare utile quando si vuole applicare questa 
      funzione. Si veda <guideref targ="chap:tsfilter"/> per i
      dettagli.
      <seelist>
        <fncref targ="bkfilt"/>
        <fncref targ="hpfilt"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="bwrite" section="data-utils" output="int">
      <fnargs>
    <fnarg type="bundle">B</fnarg>
    <fnarg type="string">fname</fnarg>
    <fnarg optional="true" type="bool">export</fnarg>
      </fnargs>
      <description>
    <para>
      Copia il bundle <argname>B</argname> in un file XML di nome 
      <argname>fname</argname>. Per una sommaria descrizione del suo
      formato, si veda la funzione <fncref targ="bread"/>.
      Se il file <argname>fname</argname> esiste già verrà sovrascritto.
      Il valore restituito è 0 in caso l'esecuzione venga portata a termine
      correttamente; se si verifica un errore, per esempio dovuto al
      fatto che il file non può essere sovrascritto, il valore restituito 
      sarà non nullo.
    </para>
    <para>
      Se viene indicato un valore non nullo per l'argomento
      <argname>export</argname>, il file di output sarà salvato nella
      directory <quote>dot</quote> dell'utente. In questo caso è
      necessario indicare come secondo argomento il nome del file
      privo del percorso.
    </para>
    <para>
      <seelist>
        <fncref targ="bread"/>
        <fncref targ="mwrite"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="cdemean" section="stats" output="matrix">
      <fnargs>
    <fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
    <para>
      Centra le colonne della matrice <argname>X</argname> attorno
      alla loro media.
    </para>
      </description>
    </function>

    <function name="cdf" section="probdist" output="asinput">
      <fnargs>
    <fnarg type="char">c</fnarg>
    <fnarg type="seebelow">&hellip;</fnarg>
    <fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <examples>
    <example>p1 = cdf(N, -2.5)</example>
    <example>p2 = cdf(X, 3, 5.67)</example>
    <example>p3 = cdf(D, 0.25, -1, 1)</example>
      </examples>
      <description>
    <para>
      Calcola funzioni di ripartizione. Restituisce <equation
      status="inline" ascii="P(X &lt; x)" tex="$P(X \le x)$"/>,
      dove la distribuzione di <math>X</math> è determinata dal
      carattere <argname>c</argname>. Tra gli argomenti
      <argname>c</argname> e <argname>x</argname>, possono essere
      richiesti parametri aggiuntivi a seconda della
      distribuzione, come specificato qui di seguito.
    </para>
    <ilist context="notex">
      <li>
        <para>
          Normale standard (c = z, n, or N): nessun argomento supplementare
        </para>
      </li>
      <li>
        <para>
          Normale bivariata (D): coefficiente di correlazione
        </para>
      </li>
      <li>
        <para>
          t di Student (t): gradi di libertà 
        </para>
      </li>
      <li>
        <para>
          Chi quadro (c, x, or X): gradi di libertà
        </para>
      </li>
      <li>
        <para>
          F di Snedecor (f or F): gradi di libertà (num.); gradi
          di libertà (den.)
        </para>
      </li>
      <li>
        <para>
          Gamma (g or G): forma; scala
        </para>
      </li>   
      <li>
        <para>
          Binomiale (b or B): probabilità; numero di prove
        </para>
      </li>   
      <li>
        <para>
          Poisson (p or P): Media
        </para>
      </li>   
      <li>
        <para>
          Weibull (w or W): forma; scala
        </para>
      </li> 
      <li>
        <para>
          Generalized Error (E): forma
        </para>
      </li>
      <li>
	<para>
	  Chi-quadro non centrale (ncX): gdl, parametro di non
	  centralità
	</para>
      </li>
      <li>
	<para>
	  F non centrale (ncF): gdl (num.), gdl (den.), parametro di
	  non centralità
	</para>
      </li>
      <li>
	<para>
	  t non centrale (nct): gdl, parametro di non centralità
	</para>
      </li>	  
    </ilist>
    <para context="tex">
      \begin{center} 
      \begin{tabular}{llll} 
      \textit{Distribuzione} &amp; \textsl{c} &amp;
      \textit{Arg} 2 &amp; \textit{Arg} 3 \\[4pt] 
      Normale standardizzata &amp; \texttt{z}, \texttt{n} or \texttt{N} &amp; 
      -- &amp; -- \\ 
      Normale bivariata &amp; \texttt{D} &amp; 
      $\rho$ &amp; -- \\ 
      $t$ di Student (centrale) &amp; \texttt{t} &amp;  
      gradi di libertà &amp; -- \\ 
      Chi quadro &amp; \texttt{c}, \texttt{x} or \texttt{X} &amp; 
      gradi di libertà &amp; -- \\ 
      $F$ di Snedecor &amp; \texttt{f} or \texttt{F} &amp;
      gdl (num.) &amp; gdl (den.) \\ 
      Gamma &amp; \texttt{g} o \texttt{G} &amp;
      forma &amp; scala \\ 
      Binomiale &amp; \texttt{b} o \texttt{B} &amp;
      probabilit\`a &amp; prove \\ 
      Poisson &amp; \texttt{p} o \texttt{P} &amp; 
      media &amp; -- \\
      Weibull &amp; \texttt{w} or \texttt{W} &amp; 
      forma &amp; scala &amp; --\\
      Generalized Error &amp; \texttt{E} &amp; 
      forma &amp; -- &amp; --\\
      $\chi^2$ non centrale &amp; \texttt{ncX} &amp; 
      gdl &amp; non centralit{\`a} &amp; -- \\
      $F$  non centrale &amp; \texttt{ncF} &amp; 
      gdl (num.) &amp; gdl (den.) &amp; non centralit{\`a}  \\
      $t$  non centrale &amp; \texttt{nct} &amp; 
      gdl &amp; non centralit{\`a} &amp; -- \\
      \end{tabular}
      \end{center}
    </para>
    <para>
      La maggior parte delle distribuzioni usano degli alias per
      rendere più agevole la memorizzazione dei codici.  Il caso
      della normale bivariata è particolare: la sintassi è <lit>x
      = cdf(D, rho, z1, z2)</lit> dove <lit>rho</lit> è la
      correlazione fra <lit>z1</lit> e <lit>z2</lit>.
    </para>
    <para context="tex">
      La parametrizzazione che \app{gretl} adotta per la
      v.c. Gamma implica che la funzione di densità possa essere
      scritta come 
      \[ 
      f(x; k, \theta) = \frac{x^{k-1}}{\theta^k}
      \frac{e^{-x/\theta}}{\Gamma(k)} 
      \] 
      dove $k>0$ è il parametro
      di forma e $\theta>0$ il parametro di scala.
    </para>
    <para>
      <seelist>
        <fncref targ="pdf"/>
        <fncref targ="critical"/>
        <fncref targ="invcdf"/>
        <fncref targ="pvalue"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="cdiv" section="linalg" output="matrix">
      <fnargs>
    <fnarg type="matrix">X</fnarg>
    <fnarg type="matrix">Y</fnarg>
      </fnargs>
      <description>
    <para>
      Divisione complessa. I due argomenti devono avere lo stesso
      numero di righe, <math>n</math>, e una o due colonne.  La
      prima colonna contiene la parte reale e l'eventuale seconda
      quella immaginaria.  Restituisce una matrice <by r="n" c="2"/>
      oppure, se la parte immaginaria del risultato è nulla, un
      vettore a <math>n</math> elementi.
      <seelist>
        <fncref targ="cmult"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="ceil" section="math" output="asinput">
      <fnargs>
    <fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
    <para>
      Parte intera superiore: restituisce il più piccolo numero
      intero maggiore o uguale a <argname>x</argname>.
      <seelist> 
        <fncref targ="floor"/>
        <fncref targ="int"/>
      </seelist>
    </para>
      </description>
    </function>  

    <function name="cholesky" section="linalg" output="smatrix">
      <fnargs>
    <fnarg type="pdmat">A</fnarg>
      </fnargs>
      <description>
    <para>
      Esegue la decomposizione di Cholesky della matrice
      <argname>A</argname>, assunta simmetrica e
      definita positiva. Il risultato è una matrice triangolare
      inferiore <math>K</math> che soddisfa <equation
      status="inline" ascii="A = KK'" tex="$A = KK'$"/>. La
      funzione restituisce un errore se <argname>A</argname> non è
      simmetrica o definita positiva.
    </para>
      </description>
    </function>

    <function name="chowlin" section="transforms" output="matrix">
      <fnargs>
    <fnarg type="matrix">Y</fnarg>
    <fnarg type="int">xfac</fnarg>
    <fnarg type="matrix" optional="true">X</fnarg>
      </fnargs>
      <description>
    <para>
      Espande i dati in ingresso, <argname>Y</argname>, a una frequenza
      maggiore, usando il metodo di interpolazione di <cite
      key="chowlin71">Chow e Lin (1971)</cite>. Si assume che le
      colonne di <argname>Y</argname> rappresentino serie di dati;
      la matrice restituita ha tante colonne quante sono le
      colonne di <argname>Y</argname> e tante righe quante sono
      quelle di <argname>Y</argname> moltiplicate per
      <argname>xfac</argname>.
    </para>
    <para>
      Il secondo argomento rappresenta il fattore di espansione:
      deve essere 3 per espandere la frequenza della serie da
      trimestrale a mensile, o 4 per espansioni da annuale a
      trimestrale. Questi sono gli unici fattori di espansione
      supportati. Il terzo argomento opzionale può essere
      utilizzato per generare una matrice di regressori con una
      frequenza (obiettivo) maggiore.
    </para>
    <para>
      I regressori utilizzati di default sono una costante e un
      trend quadratico. Se viene fornita <argname>X</argname>, le
      sue colonne sono utilizzate come regressori addizionali; è
      un errore se il numero di righe in <argname>X</argname> non
      è uguale a <argname>xfac</argname> per il numero di righe in
      <argname>Y</argname>.
    </para>
      </description>
    </function>

    <function name="cmult" section="linalg" output="matrix">
      <fnargs>
    <fnarg type="matrix">X</fnarg>
    <fnarg type="matrix">Y</fnarg>
      </fnargs>
      <description>
    <para>
      Moltiplicazione complessa. I due argomenti devono avere lo
      stesso numero di righe, <math>n</math>, e una o due colonne.
      La prima colonna contiene la parte reale e l'eventuale
      seconda quella immaginaria.  Restituisce una matrice <by r="n"
      c="2"/> oppure, se la parte immaginaria del risultato è
      nulla, un vettore a <math>n</math> elementi.
      <seelist>
        <fncref targ="cdiv"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="cnorm" section="probdist" output="asinput">
      <fnargs>
    <fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce la funzione di distribuzione cumulativa di una normale 
      standard. 
      <seelist>
        <fncref targ="dnorm"/>
        <fncref targ="qnorm"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="colname" section="strings" output="string">
      <fnargs>
    <fnarg type="matrix">M</fnarg>
    <fnarg type="int">col</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il nome della colonna <argname>col</argname>
	  della matrice <argname>M</argname>. Se <argname>M</argname>
	  non ha nomi associati alle colonne, la funzione restituisce
	  una stringa vuota; se <argname>col</argname> è fuori dai
	  limiti per la matrice data, viene restituito un messaggio di
	  errore. Si veda anche <fncref targ="colnames"/>.
	</para>
    	<para>
	  Esempio:
	</para>
	<code>
	  matrix A = { 11, 23, 13 ; 54, 15, 46 }
	  colnames(A, "Col_A Col_B Col_C")
	  string name = colname(A, 3)
	  print name
	</code>
      </description>
    </function>

    <function name="colnames" section="matbuild" output="scalar">
      <fnargs>
    <fnarg type="matrix">M</fnarg>
    <fnarg type="list-or-string">s</fnarg>
      </fnargs>
      <description>
    <para>
      Attribuisce dei nomi alle colonne della matrice
      <argname>M</argname> di dimensioni <by r="T" c="k"/>. 
      Se <argname>s</argname> è una lista, i
      nomi sono copiati da quelli delle variabili; la lista deve
      avere tanti elementi quante sono le colonne di
      <argname>M</argname>. Se <argname>s</argname> è una stringa,
      deve contenere un numero appropriato di sub-stringhe
      separate da spazi.  Restituisce 0 se la funzione è andata a
      buon fine, non-zero altrimenti. Si veda anche <fncref
      targ="rownames"/>.
    </para>
    <para>
      Esempio:
    </para>
    <code>
      matrix M = {1,2;2,1;4,1}
      colnames(M, "Col1 Col2")
      print M
    </code>
      </description>
    </function>

    <function name="cols" section="matshape" output="int">
      <fnargs>
    <fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
    <para>
      Il numero di colonne di <argname>X</argname>. 
      <seelist> 
        <fncref targ="mshape"/>
        <fncref targ="rows"/>
        <fncref targ="unvech"/>
        <fncref targ="vec"/> 
        <fncref targ="vech"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="corr" section="stats" output="scalar">
      <fnargs>
    <fnarg type="series-or-vec">y1</fnarg>
    <fnarg type="series-or-vec">y2</fnarg>
      </fnargs>
      <description>
    <para>
      Calcola il coefficiente di correlazione fra
      <argname>y1</argname> e <argname>y2</argname>. Gli argomenti dovrebbero
      essere due variabili o due vettori con la stessa lunghezza.
      <seelist> 
        <fncref targ="cov"/>
        <fncref targ="mcov"/>
        <fncref targ="mcorr"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="corrgm" section="stats" output="matrix">
      <fnargs>
    <fnarg type="smlist">x</fnarg>
    <fnarg type="int">p</fnarg>
    <fnarg optional="true" type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
    <para>
      Se sono forniti solo i primi due argomenti, calcola il
      correlogramma di <argname>x</argname> con ritardi da 1 a
      <argname>p</argname>. Il valore restituito è una matrice con
      <argname>p</argname> righe e 2<math>k</math> colonne, dove
      <math>k</math> è il numero di elementi di
      <argname>x</argname>, ovvero: 1 se <argname>x</argname> è
      una variabile; il numero di colonne di <argname>x</argname> se
      <argname>x</argname> è una matrice; il numero degli elementi
      di <argname>x</argname> se <argname>x</argname> è una
      lista. Le prime <math>k</math> colonne della matrice
      restituita contengono le autocorrelazioni, mentre le
      restanti colonne le rispettive autocorrelazioni parziali.
    </para>
    <para>
      Se è fornito un terzo argomento, questa funzione calcola il
      correlogramma incrociato per ciascuno dei <math>k</math>
      elementi di <argname>x</argname> e <argname>y</argname>,
      dagli anticipi (<quote>lead</quote>) di ordine
      <argname>p</argname> fino ai ritardi (<quote>lag</quote>) di
      ordine <argname>p</argname>. La matrice restituita ha
      2<math>p</math> + 1 righe e <math>k</math> colonne. Se
      <argname>x</argname> è una variabile o una lista e
      <argname>y</argname> un vettore, il vettore deve avere tante
      righe quante sono le osservazioni nell'intervallo del
      campione corrente.
    </para>
      </description>
    </function>

    <function name="cos" section="math" output="asinput">
      <fnargs>
    <fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce il coseno di <argname>x</argname>.
      <seelist>
        <fncref targ="sin"/>
        <fncref targ="tan"/>
        <fncref targ="atan"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="cosh" section="math" output="asinput">
      <fnargs>
    <fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce il coseno iperbolico di <argname>x</argname>.
    </para>
    <para context="tex">
      \[ \cosh x = \frac{e^x + e^{-x}}{2}  \]
    </para>
    <para>
      <seelist>
        <fncref targ="acosh"/>
        <fncref targ="sinh"/>
        <fncref targ="tanh"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="cov" section="stats" output="scalar">
      <fnargs>
    <fnarg type="series-or-vec">y1</fnarg>
    <fnarg type="series-or-vec">y2</fnarg>
      </fnargs>
      <description>
    <para>
      Calcola la covarianza fra <argname>y1</argname> e
      <argname>y2</argname>. Gli argomenti dovrebbbero essere due variabili o due
      vettori con lo stesso numero di elementi.
      <seelist> 
        <fncref targ="corr"/> 
        <fncref targ="mcov"/>
        <fncref targ="mcorr"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="critical" section="probdist" output="asinput">
      <fnargs>
    <fnarg type="char">c</fnarg>
    <fnarg type="seebelow">&hellip;</fnarg>
    <fnarg type="anyfloat">p</fnarg>
      </fnargs>
      <examples>
    <example>c1 = critical(t, 20, 0.025)</example>
    <example>c2 = critical(F, 4, 48, 0.05)</example>
      </examples>
      <description>
    <para>
      Calcola i valori critici, ossia <math>x</math> tale che
      <equation status="inline" ascii="P(X &gt; x) = p" tex="$P(X
      &gt; x) = p$"/>, dove la distribuzione di <math>X</math> è
      determinata dal carattere <argname>c</argname>. Tra gli
      argomenti <argname>c</argname> e <argname>x</argname>,
      possono essere richiesti parametri aggiuntivi a seconda
      della distribuzione, come specificato qui di seguito.
    </para>
    <ilist context="notex">
      <li>
        <para>
          Normale standard (c = z, n, or N): nessun argomento addizionale
        </para>
      </li>
      <li>
        <para>
          t di Student (t): gradi di libertà 
        </para>
      </li>
      <li>
        <para>
          Chi quadro (c, x, or X): gradi di libertà
        </para>
      </li>
      <li>
        <para>
          F di Snedecor (f or F): gradi di libertà (num.); gradi
          di libertà (den.)
        </para>
      </li>
      <li>
        <para>
          Binomiale (b or B): probabilità; numero di prove
        </para>
      </li>   
      <li>
        <para>
          Poisson (p or P): Media
        </para>
      </li>   
    </ilist>
    <para context="tex">
      \begin{center} 
      \begin{tabular}{llll} 
      \textit{Distribuzione} &amp; \textsl{c} &amp;
      \textit{Arg} 2 &amp; \textit{Arg} 3 \\[4pt]
      Normale standard &amp; \texttt{z}, \texttt{n} or \texttt{N} &amp;
      -- &amp; -- \\ 
      $t$ di Student (centrale) &amp; \texttt{t} &amp; 
      gradi di libert\`a &amp; -- \\ 
      Chi quadro &amp; \texttt{c}, \texttt{x} o \texttt{X} &amp; 
      gradi di libert\`a &amp; -- \\
      $F$ di Snedecor &amp; \texttt{f} o \texttt{F} &amp; 
      gdl (num.) &amp; gdl (den.) \\ 
      Binomiale &amp; \texttt{b} o \texttt{B} &amp; 
      $p$ &amp; $n$ \\ 
      Poisson &amp; \texttt{p} o \texttt{P} &amp; 
      $\lambda$ &amp; -- \\ 
      \end{tabular}
      \end{center}
    </para>
    <para>
      <seelist>
        <fncref targ="cdf"/>
        <fncref targ="invcdf"/>
        <fncref targ="pvalue"/>
      </seelist>
    </para>
      </description>
    </function>  

    <function name="cum" section="transforms" output="asinput">
      <fnargs>
    <fnarg type="series-or-mat">x</fnarg>
      </fnargs>
      <description>
    <para context="notex">
      Calcola la somma cumulata di <argname>x</argname>. Se
      <argname>x</argname> è una variabile, restituisce una variabile
      <math>y</math> in cui ciascuno degli elementi è la somma dei
      valori di <argname>x</argname> fino a quel punto; il primo
      termine della somma è la prima osservazione non mancante
      (non-missing) nel campione corrente. Se <argname>x</argname>
      è una matrice, la somma cumulata viene calcolata per
      ciascuna delle colonne.
    </para>
    <para context="tex">
      Calcola la somma cumulata di <argname>x</argname>. Se
      <math>x</math> è una variabile, produce una variabile $y_t =
      \sum_{s=m}^t x_s$. Il punto iniziale della sommatoria,
      <math>m</math>, è la prima osservazione non mancante
      nel campione corrente. Se la funzione incontra
      valori mancanti in <math>x</math>, i valori
      successivi in <math>y</math> saranno mancanti. Quando
      <argname>x</argname> è una matrice, gli elementi vengono
      sommati per colonna.
    </para>
    <para>
      <seelist>
        <fncref targ="diff"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="curl" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="bundleref">&amp;b</fnarg>
      </fnargs>
      <description>
	<para>
	  Questa funzione dà modo all'utente di riempire un buffer di
	  testo con dati provenienti da un server di rete usando
	  libcurl. Il bundle di input <argname>b</argname> deve
	  contenere una stringa di nome <lit>URL</lit> con l'indirizzo
	  completo dell'host da cui scaricare i dati. Seguono altri
	  elementi, tutti opzionali.
	</para>
	<ilist>
	  <li>
	    <para> 
	      <quote><lit>header</lit></quote>: una stringa contenente
	      un header HTTP da mandare al server.
	    </para>
	  </li>
	  <li>
	    <para> 
	      <quote><lit>postdata</lit></quote>: una stringa
	      contenente dati da mandare al server.
	    </para>
	  </li>
	</ilist>
	<para>
	  I campi <lit>header</lit> e <lit>postdata</lit> vengono
	  usati in congiunzione con una richiesta HTTP
	  <lit>POST</lit>; se <lit>postdata</lit> è presente, allora
	  il metodo <lit>POST</lit>è implicito, altrimenti lo è il
	  metodo <lit>GET</lit>. (Si noti però che per semplici
	  richieste di tipo <lit>GET</lit>, la funzione <fncref
	  targ="readfile"/> fornisce un'interfaccia più snella.)
	</para>
	<para>
	  In più, è possibile includere nel bundle un altro elemento
	  opzionale: uno scalare di nome <lit>include</lit>, che è
	  interpretato, se non-zero, come una richiesta di includere
	  lo header dal server insieme al corpo del messaggio.
	</para>
	<para>
	  Se la richiesta va a buon fine, il testo ricevuto dal server
	  è aggiunto al bundle sotto il nome
	  <quote><lit>output</lit></quote>.
	</para>
	<para>
	  Se si verifica un qualche errore (ad esempio la
	  <lit>URL</lit> è irraggiungibile) la funzione ritorna un
	  valore non-zero, nel qual caso il messaggio di errore di
	  curl viene aggiunto al bundle sotto la chiave
	  <quote><lit>errmsg</lit></quote>.  Si noti, tuttavia, che
	  <quote>a buon fine</quote> in questo senso non implica che
	  tutti i dati desiderati siano stati scaricati, ma solo che
	  il server ha dato una qualche risposta. È reposnsabilità
	  dell'utente controllare il contenuto del buffer di output
	  (che per esempio potrebbe contenere semplicemente il testo
	  <quote>Page not found</quote>).
	</para>
	<para>
	  A seguire, un esempio, in cui scharicheremo dei dati dal
	  sito dell'US Bureau of Labor Statistics; a tal fine, bisogna
	  formulare una query JSON. Si noti l'uso di <cmdref
	  targ="sprintf"/> per inserire il carattere <lit>"</lit> nei
	  dati <lit>POST</lit>.
	</para>
	<code>
	  bundle req
	  req.URL = "http://api.bls.gov/publicAPI/v1/timeseries/data/"
	  req.include = 1
	  req.header = "Content-Type: application/json"
	  string s = sprintf("{\"seriesid\":[\"LEU0254555900\"]}")
	  req.postdata = s
	  err = curl(&amp;req)
	  if err == 0
	      s = req.output
	      string line
	      loop while getline(s, line) --quiet
	          printf "%s\n", line
	      endloop
	  endif
	</code>
	<para>
	  Vedi anche la funzione <fncref targ="jsonget"/> per poi
	  elaborare i dati JSON in entrata.
	</para>
      </description>
    </function>

    <function name="defarray" section="data-utils" output="seebelow">
      <fnargs>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Permette la definizione di una variabile array per
	  esteso. Per usare questa funzione bisogna specificare un
	  tipo (in forma plurale) per l'array: <lit>strings</lit>,
	  <lit>matrices</lit>, <lit>bundles</lit> oppure
	  <lit>lists</lit>. Ognuno degli argomenti deve risultare un
	  oggetto del tipo specificato. Se la funzione va a buon fine,
	  il valore restituito sarà un array di <math>n</math>
	  elementi, dove <math>n</math> è il numero di argomenti.
	</para>
	<code>
	  strings S = defarray("foo", "bar", "baz")
	  matrices M = defarray(I(3), X'X, A*B, P[1:])
	</code>
	<para>
	  Vedi anche <fncref targ="array"/>.
	</para>
      </description>
    </function>        

    <function name="deseas" section="filters" output="series">
      <fnargs>
    <fnarg type="series">x</fnarg>
    <fnarg optional="true" type="char">c</fnarg>
      </fnargs>
      <description>
    <para>
      Richiede che TRAMO/SEATS o X-12-ARIMA siano
      installati. Restituisce la serie <argname>x</argname>
      destagionalizzata. La serie in ingresso <argname>x</argname>
      deve essere trimestrale o mensile. Per
      usare X-12-ARIMA inserire <lit>X</lit> come secondo
      argomento; per usare TRAMO inserire <lit>T</lit>. Se il
      secondo argomento è omesso, è utilizzato X-12-ARIMA.
    </para>
    <para>
      Se la variabile in ingresso non possiede una componente
      stagionale identificabile, la funzione fallisce. Si noti che
      sia TRAMO/SEATS sia X-12-ARIMA hanno numerose opzioni;
      <lit>deseas</lit> richiama i due programmi con tutte le
      opzioni ai valori predefiniti. In entrambi i programmi i
      fattori stagionali sono calcolati sulla base di un modello
      ARIMA selezionato automaticamente. Una differenza tra i due
      programmi, che a volte produce differenze sostanziali nei
      risultati, è che per impostazione predefinita TRAMO compie
      un aggiustamento preventivo per gli outlier, al contrario di
      X-12-ARIMA che non lo fa.
    </para>
      </description>
    </function>

    <function name="det" section="linalg" output="scalar">
      <fnargs>
    <fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce il determinante di <argname>A</argname>,
      calcolato tramite la scomposizione LU.
      <seelist> 
        <fncref targ="ldet"/>
        <fncref targ="rcond"/>
      </seelist>
    </para>
      </description>
    </function>  

    <function name="diag" section="matbuild" output="matrix">
      <fnargs>
    <fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce la diagonale principale di <argname>X</argname> in
      un vettore colonna. Nota: se <argname>X</argname> è una
      matrice <by r="m" c="n"/>, il numero di elementi del vettore
      risultato è min(<math>m</math>, <math>n</math>).
      <seelist>
        <fncref targ="tr"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="diagcat" section="matbuild" output="matrix">
      <fnargs>
    <fnarg type="matrix">A</fnarg>
    <fnarg type="matrix">B</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce la somma diretta di <argname>A</argname> e
      <argname>B</argname>, ossia una matrice che ha
      <argname>A</argname> nell'angolo nord-ovest e
      <argname>B</argname> in quello sud-est. Se
      <argname>A</argname> e <argname>B</argname> sono entrambe
      quadrate, la matrice risultato è diagonale a blocchi.
    </para>
      </description>
    </function>

    <function name="diff" section="transforms" output="asinput">
      <fnargs>
    <fnarg type="smlist">y</fnarg>
      </fnargs>
      <description>
    <para>
      Calcola le differenze prime. Se <argname>y</argname> è una
      variabile, o una lista di variabili, i valori iniziali restituiti
      sono <lit>NA</lit>. Se <argname>y</argname> è una matrice,
      le differenze prime sono calcolate per colonna e i valori
      iniziali restituiti sono 0.
    </para>
    <para>
      <seelist>
        <fncref targ="cum"/>
        <fncref targ="ldiff"/>
        <fncref targ="sdiff"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="digamma" section="math" output="asinput">
      <fnargs>
    <fnarg type="anyfloat">x</fnarg>
      </fnargs>    
      <description>
    <para context="notex">
      Restituisce la funzione digamma (o Psi) di
      <argname>x</argname>, cioè la derivata del logaritmo della
      funzione Gamma.
    </para>
    <para context="tex">
      Restituisce la funzione digamma (o Psi) di $x$, cioè
      $\frac{\mathrm{d} \Gamma(x)}{\mathrm{d} x}$.
    </para>
      </description>
    </function>

    <function name="dnorm" section="probdist" output="asinput">
      <fnargs>
    <fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce la funzione di densità di una normale standard in  
      <argname>x</argname>. Per calcolare la densità di una distribuzione normale
      non standardizzata in <math>x</math>, applicate la funzione 
      To get the density for a non-standard <lit>dnorm</lit> allo 
      <math>z</math>-score di <math>x</math> e moltiplicate il risultato così
      ottenuto per lo Jacobiano della trasformazione <math>z</math>, 
      1/&sigma;, come illustrato nell'esempio seguente:
    </para>
    <code>
      mu = 100
      sigma = 5
      x = 109
      fx = (1/sigma) * dnorm((x-mu)/sigma)
    </code>
    <para>
      <seelist>
        <fncref targ="cnorm"/>
        <fncref targ="qnorm"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="dropcoll" section="transforms" output="list">
      <fnargs>
	<fnarg type="list">X</fnarg>
	<fnarg optional="true" type="scalar">epsilon</fnarg>
      </fnargs>     
      <description>
	<para>
	  Restituisce una lista con gli stessi elementi di
	  <argname>X</argname>, fuorché le serie collineari. Qunidi,
	  se tutte le serie in <argname>X</argname>
	  sono linearmente indipendenti, la lista risultato è
	  semplicemente una copia di <argname>X</argname>.
	</para>
	<para>
	  L'algoritmo adopera la scomposizione QR (trasformazione di
	  Householder), per cui è soggetto ad un errore derivante
	  dalla precisione macchina. Per aggiustare la sensibilità
	  dell'algoritmo, si può usare un secondo parametro opzionale
	  <argname>epsilon</argname> per rendere il test di
	  collinearità più o meno stringente. Il valore di default per
	  <argname>epsilon</argname> è 1.0e-8. Incrementando tale
	  valore, la probabilità che una serie venga omessa aumenta.
	</para>
	<para>
	  Esempio:
	</para>
	<code>
	  nulldata 20
	  set seed 9876
	  series foo = normal()
	  series bar = normal()
	  series foobar = foo + bar
	  list X = foo bar foobar
	  list Y = dropcoll(X)
	  list print X
	  list print Y
	  # imposta epsilon ad un valore assurdamente piccolo
	  list Y = dropcoll(X, 1.0e-30)
	  list print Y
	</code>
	<para>
	  produce
	</para>
	<code>
	  ? list print X
	  foo bar foobar 
	  ? list print Y
	  foo bar 
	  ? list Y = dropcoll(X, 1.0e-30)
	  Replaced list Y
	  ? list print Y
	  foo bar foobar 
	</code>
      </description>
    </function>    

    <function name="dsort" section="matshape" output="asinput">
      <fnargs>
    <fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
    <para>
      Ordina <argname>x</argname> in ordine discendente, saltando
      le osservazioni con valori mancanti se <argname>x</argname> è
      una variabile. 
      <seelist> 
        <fncref targ="sort"/>
        <fncref targ="values"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="dummify" section="transforms" output="list">
      <fnargs>
    <fnarg type="series">x</fnarg>
    <fnarg optional="true" type="scalar">omitval</fnarg>
      </fnargs>
      <description>
    <para>
      L'argomento <argname>x</argname> deve essere una variabile
      discreta. Questa funzione crea un insieme di variabili dummy
      (o binarie) che codificano i valori distinti della
      variabile. Per impostazione predefinita, il valore più piccolo
      della variabile originale è preso come categoria di riferimento
      e per tale valore non viene restituita alcuna dummy.
    </para>
    <para>
      Il secondo argomento, opzionale, rappresenta il valore di
      <argname>x</argname> che deve essere assunto come categoria
      di riferimento, e quindi da omettere. L'effetto che si
      ottiene inserendo un solo argomento e tralasciando quello
      opzionale è equivalente a <lit>dummify(x, min(x))</lit>. Al
      fine di generare l'insieme completo delle dummy, non
      omettendo alcuna categoria, è possibile utilizzare il
      comando <lit>dummify(x, NA)</lit>.
    </para>
    <para> 
      Le variabili generate sono nominate in modo automatico
      secondo lo schema
      <lit>D</lit><repl>varname</repl><lit>_</lit><repl>i</repl>,
      dove <repl>varname</repl> è il nome della variabile originale e
      <repl>i</repl> un indice in cui il valore iniziale è 1
      (<quote>1-based index</quote>). Il nome originale della
      variabile è troncato se necessario e può essere modificato in
      caso di non unicità nell'insieme dei nomi così generato.
    </para>
      </description>
    </function>

    <function name="easterday" section="calendar" output="asinput">
      <fnargs>
    <fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
    <para>
      Dato l'anno in <argname>x</argname>, ritorna la data di
      Pasqua nel calendario gregoriano sotto forma dello scalare
      <math>mese + giorno/100</math>. Si not che, per questa
      convenzione, il 10 aprile è 4.1; quindi, 4.2 sarà il 20
      aprile, non il 2 (che sarebbe 4.02).
    </para>
    <code>
      scalar e = easterday(2014)
      scalar m = floor(e)
      scalar d = 100*(e-m)
    </code>
      </description>
    </function>

    <function name="eigengen" section="linalg" output="matrix">
      <fnargs>
    <fnarg type="smatrix">A</fnarg>
    <fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
    <para>
      Calcola gli autovalori, e, se richiesto, gli autovettori
      destri della matrice <by r="n" c="n"/>
      <argname>A</argname>. Se tutti gli autovalori sono reali, la
      funzione restituisce una matrice <by r="n" c="1"/>; in caso
      contrario, il risultato è una matrice <by r="n" c="2"/>,
      dove la prima colonna contiene le parti reali degli
      autovalori, mentre la seconda le corrispondenti parti
      immaginarie. Non c'è alcuna garanzia sul fatto che gli
      autovalori siano ordinati in alcun modo particolare.
    </para>
    <para>
      Il secondo argomento può essere il nome di una matrice
      esistente preceduto da <lit>&amp;</lit> (per indicare
      l'<quote>indirizzo</quote> della matrice in questione), e in tal caso gli
      autovettori destri vengono scritti in questa matrice, oppure
      la parola chiave <lit>null</lit>, e in tal caso gli
      autovettori non vengono riportati.
    </para>
    <para>
      Quando il secondo argomento è diverso da <lit>null</lit>, la
      matrice stessa è sovrascritta (non è necessario abbia la
      dimensione giusta per ricevere il risultato). La matrice
      risultante è organizzata come segue:
    </para>
    <ilist>
      <li>
        <para>
          Se l'<math>i</math>-esimo autovalore è reale,
          l'<math>i</math>-esima colonna di <math>U</math>
          conterrà l'autovettore corrispondente;
        </para>
      </li>
      <li>
        <para>
          Se l'<math>i</math>-esimo autovalore è complesso,
          l'<math>i</math>-esima colonna di <argname>U</argname>
          conterrà la parte reale dell'autovettore corrispondente
          e la colonna successiva la parte
          immaginaria. L'autovettore associato all'autovalore
          coniugato è il coniugato dell'autovettore.
        </para>
      </li>
    </ilist>
    <para>
      In altre parole, gli autovettori compaiono nello stesso
      ordine degli autovalori, ma gli autovettori reali occupano
      una colonna, mentre quelli complessi ne occupano due (la
      parte reale è la prima); il numero totale di colonne è
      comunque <math>n</math>, perché l'autovettore coniugato è
      tralasciato.
    </para>
    <para>
      <seelist>
        <fncref targ="eigensym"/>
        <fncref targ="eigsolve"/>
        <fncref targ="qrdecomp"/>
        <fncref targ="svd"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="eigensym" section="linalg" output="matrix">
      <fnargs>
    <fnarg type="symmat">A</fnarg>
    <fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
    <para>
      Funziona esattamente come <fncref targ="eigengen"/>, ma
      l'argomento <argname>A</argname> deve essere una matrice
      simmetrica (in questo caso i calcoli possono essere
      semplificati). A differenza di <fncref targ="eigengen"/>, gli
      autovalori sono ordinati in senso crescente.
    </para>
    <para>
      Notare che nel calcolo degli autovalori ed autovettori di una
      matrice del tipo <math>X'X</math>, ove <math>X</math> sia di
      dimensioni elevate, è preferibile utilizzare la forma
      <lit>X'X</lit> invece della più generale sintassi
      <lit>X'*X</lit>. La prima espressione utilizza infatti un
      algoritmo specifico che presenta il duplice vantaggio di essere
      più efficiente dal punto di vista computazionale e di assicurare
      come risultato una matrice priva per costruzione di
      approssimazioni indotte dalla precisione macchina, che possono
      renderlo numericamente non simmetrico.
    </para>
      </description>
    </function>

    <function name="eigsolve" section="linalg" output="matrix">
      <fnargs>
    <fnarg type="symmat">A</fnarg>
    <fnarg type="symmat">B</fnarg>
    <fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
    <para>
      Risolve il problema degli autovalori generalizzati
      |<math>A</math> &minus; &lgr;<math>B</math>| = 0, dove sia
      <math>A</math> sia <math>B</math> sono matrici simmetriche e
      <math>B</math> è definita positiva. Gli autovalori vengono
      restituiti direttamente, ordinati in senso crescente. Il
      terzo argomento opzionale deve essere il nome di una matrice
      esistente preceduto da <lit>&amp;</lit>. In tal caso, la
      funzione calcola anche gli autovettori generalizzati, che
      vengono salvati nella suddetta matrice.
    </para>
      </description>
    </function>

    <function name="epochday" section="calendar" output="scalar-or-series">
      <fnargs>
    <fnarg type="scalar-or-series">anno</fnarg>
    <fnarg type="scalar-or-series">mese</fnarg>
    <fnarg type="scalar-or-series">giorno</fnarg>
      </fnargs>
      <description>
    <para>
      Ha come argomenti l'anno, il mese e il giorno e restituisce
      il numero di giorni nell'epoca corrente (che è uguale ad 1
      per il 1 gennaio dell'anno 1 d.C.), ed è pari a 733786 al
      01-01-2010. Se qualcuno degli argomenti è fornito sotto forma di variabile
      il valore restituito è una variabile, in caso contrario uno scalare.
    </para>
    <para>
      Per la funzione inversa, v. <fncref targ="isodate"/>.
    </para>
      </description>
    </function>

    <function name="errmsg" section="strings" output="string">
      <fnargs>
    <fnarg type="int">errno</fnarg>
      </fnargs>
      <description>
    <para>
      Recupera il messaggio di errore di gretl associato a
      <argname>errno</argname>. Si veda anche <fncref
      targ="$error"/>.
    </para>
      </description>
    </function>

    <function name="exists" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">name</fnarg>
      </fnargs>
      <description>
	<para>
	  Ritorna 1 se <argname>name</argname> è l'identificativo di
	  un oggetto definito, che sia uno scalare, una serie, una
	  matrice, lista, stringa, bundle o array; altrimenti, ritorna
	  0.
	</para>
      </description>
    </function>    

    <function name="exp" section="math" output="asinput">
      <fnargs>
    <fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce <math>e</math><sup>x</sup>. 
      Si noti che nel caso di una matrice la funzione è
      calcolata elemento per elemento. Per il calcolo
      dell'esponenziale di una matrice, si veda <fncref
      targ="mexp"/>.
    </para>
      </description>
    </function>

    <function name="fcstats" section="stats" output="matrix">
      <fnargs>
    <fnarg type="series-or-vec">y</fnarg>
    <fnarg type="series-or-vec">f</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce un vettore colonna contenente diverse
      statistiche utili per valutare la variabile <argname>f</argname>
      come previsione della variabile <argname>y</argname> nel
      campione corrente. Al posto delle due variabili, la funzione
      accetta come argomenti anche due vettori della stessa
      lunghezza.
    </para>
    <para>
      La struttura del vettore restituito è la seguente:
    </para>
    <code>
      1  Errore Medio (Mean Error, ME)
      2  Errore Quadratico Medio (Mean Squared Error, MSE)
      3  Errore Medio Assoluto (Mean Absolute Error, MAE)
      4  Errore Medio Percentuale (Mean Percentage Error, MPE)
      5  Errore Medio Assoluto Percentuale (Mean Absolute Percentage Error, MAPE)
      6  Coefficiente U di Theil (Theil's U) 
      7  Proporzione della distorsione (Bias proportion, UM)
      8  Proporzione della regressione (Regression proportion, UR)
      9  Proporzione del disturbo (Disturbance proportion, UD)
    </code>
    <para>
      Per maggiori dettagli sul calcolo di queste statistiche e
      l'interpretazione dei valori del coefficiente
      <math>U</math>, si veda <guideref targ="chap:forecast"/>.
    </para>
      </description>
    </function>

    <function name="fdjac" section="numerical" output="matrix">
      <fnargs>
    <fnarg type="cvec">b</fnarg>
    <fnarg type="fncall">fcall</fnarg>
      </fnargs> 
      <description>
    <para>
          Calcola un'approssimazione numerica allo jacobiano associato
          al vettore <argname>b</argname> (con <math>n</math>elementi)
          e la trasformazione definita dall'argomento
          <argname>fcall</argname>. Questa funzione deve avere
          <argname>b</argname> come suo primo argomento (in forma di
          puntatore o no), seguito da eventuali altri parametri, se
          necessario; deve restituire una matrice <by r="m"
          c="1"/>. Se il comando va a buon fine, verrà restituita una
          matrice <by r="m" c="n"/> contenente lo jacobiano. Ad
          esempio:
    </para>
    <code>
      matrix J = fdjac(theta, myfunc(&amp;theta, X))
    </code>
    <para>
      La funzione può usare tre metodi diversi: differenza in
      avanti, differenza bilaterale o un'estrapolazione di
      Richardson a 4 nodi. Rispettivamente:
    </para>
    <para context="tex">
      \[ J_0 = \frac{f(x + h) - f(x)}{h} \]
    </para>
    <para context="tex">
      \[ J_1 = \frac{f(x + h) - f(x - h)}{2h} \]
    </para>
    <para context="tex">
      \[ J_2 = \frac{8(f(x+h) - f(x-h)) - (f(x+2h) - f(x-2h))}{12h} \]
    </para>
    <para context="notex">
      <math>J</math><sub>0</sub> = <math>(f(x+h) - f(x))/h</math>
    </para>
    <para context="notex">
      <math>J</math><sub>1</sub> = <math>(f(x+h) - f(x-h))/2h</math>
    </para>
    <para context="notex">
      <math>J</math><sub>2</sub>  = <math>[8 (f(x+h) -  f(x-h)) -
      (f(x+2h) - f(x-2h))] /12h</math>
    </para>
    <para>
      Queste tre alternative, in generale, rappresentano un
      compromesso diverso fra velocità e accuratezza. Per
      scegliere quale metodo usare, il comando <cmdref
      targ="set"/> consente di impostare a 0, 1 o 2 la variabile
      <lit>fdjac_quality</lit>.
    </para>
    <para>
      Per maggiori dettagli ed esempi si veda il capitolo sulle
      funzioni speciali in <lit>genr</lit> in <guideref
      targ="chap:genr"/>.
    </para>
    <para>
      <seelist>
        <fncref targ="BFGSmax"/>
        <cmdref targ="set"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="fft" section="linalg" output="matrix">
      <fnargs>
    <fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
    <para>
      Trasformata discreta reale di Fourier. Se la matrice di input
      <argname>X</argname> ha <math>n</math> colonne, l'output
      avrà 2<math>n</math> colonne, dove le parti reali sono
      salvate nelle colonne dispari e le parti complesse nelle
      colonne pari.
    </para>
    <para>
      Se fosse necessario calcolare la trasformata di Fourier su
      diversi vettori con lo stesso numero di elementi, è
      numericamente più efficiente raggrupparli in una matrice
      piuttosto che invocare <lit>fft</lit> separatamente per
      ciascuno di essi.
      <seelist>
        <fncref targ="ffti"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="ffti" section="linalg" output="matrix">
      <fnargs>
    <fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
    <para>
      Trasformata discreta reale di Fourier inversa. Si assume che
      <argname>X</argname> contenga <math>n</math> vettori colonna
      complessi, con la parte reale nelle colonne pari e la parte
      immaginaria nelle colonne dispari: il numero totale di
      colonne sarà quindi pari a 2<math>n</math>. Il risultato è
      una matrice con <math>n</math> colonne.
    </para>
    <para>
      Se si desidera calcolare la trasformata di Fourier inversa
      su diversi vettori con lo stesso numero di elementi, è
      numericamente più efficiente raggrupparli in una matrice
      piuttosto che invocare <lit>ffti</lit> separatamente per
      ciascuno di essi.
      <seelist>
        <fncref targ="fft"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="filter" section="filters" output="series">
      <fnargs>
    <fnarg type="series-or-mat">x</fnarg>
    <fnarg optional="true" type="scalar-or-vec">a</fnarg>
    <fnarg optional="true" type="scalar-or-vec">b</fnarg>
    <fnarg optional="true" type="scalar">y0</fnarg>
      </fnargs>
      <description>
    <para>
    Applica un filtro di tipo ARMA all'argomento
    <argname>x</argname>. In formule, la trasformazione è
    </para>
    <para context="tex">
      \[ y_t = \sum_{i=0}^q a_i x_{t-i} + \sum_{i=1}^p b_i y_{t-i} \]
    </para>
    <para context="notex">
      <math>y</math><sub>t</sub> = 
      <math>a</math><sub>0</sub> <math>x</math><sub>t</sub> +
      <math>a</math><sub>1</sub> <math>x</math><sub>t-1</sub> +
      ...
      <math>a</math><sub>q</sub> <math>x</math><sub>t-q</sub> +
      <math>b</math><sub>1</sub> <math>y</math><sub>t-1</sub> +
      ...
      <math>b</math><sub>p</sub> <math>y</math><sub>t-p</sub>
    </para>
    <para>
      Se l'argomento <argname>x</argname> è una variabile, il
      risultato sarà esso stesso una variabile. Se invece
      <argname>x</argname> è una matrice con <math>T</math> righe
      e <math>k</math> colonne, il risultato sarà una matrice
      delle stesse dimensioni, in cui il filtraggio vien fatto
      colonna per colonna.
    </para>
    <para>
      I due argomenti <argname>a</argname> e <argname>b</argname>
      sono opzionali. Possono essere scalari, vettori o la parola chiave 
      <lit>null</lit>.
    </para>
    <para>
      Se <argname>a</argname> è uno scalare, viene usato come
      <math>a</math><sub>0</sub> e implica <math>q=0</math>; se è
      un vettore di <math>q+1</math> elementi, contiene i
      coefficienti da <math>a</math><sub>0</sub> ad
      <math>a</math><sub>q</sub>. Se <argname>a</argname> è
      <lit>null</lit> oppure omesso, è equivalente ad
      <math>a</math><sub>0</sub><math>=1</math> e
      <math>q=0</math>.
    </para>
    <para>
      Se <argname>b</argname> è uno scalare, viene usato come
      <math>b</math><sub>1</sub> ed implica <math>p=1</math>; se è
      un vettore di <math>p</math> elementi, essi sono
      interpretati come i coefficienti da
      <math>b</math><sub>1</sub> a <math>b</math><sub>p</sub>. Se
      <argname>b</argname> è <lit>null</lit> oppure omesso, è
      equivalente a <math>B(L)=1</math>.
    </para>
    <para>
      L'argomento scalare opzionale <argname>y0</argname>
      rappresenta i valori di <math>y</math> antecedenti
      all'inizio del campione (usato solo se <math>p>0</math>). Se
      omesso, si intende 0.  Valori di <argname>x</argname>
      antecedenti all'inizio del campione sono sempre considerati
      0.
    </para>
    <para>
      <seelist> 
        <fncref targ="bkfilt"/>
        <fncref targ="bwfilt"/>
        <fncref targ="fracdiff"/>
        <fncref targ="hpfilt"/>
        <fncref targ="movavg"/>
        <fncref targ="varsimul"/>
      </seelist>
    </para>
    <para>
      Esempio:
    </para>
    <code>
      nulldata 5
      y = filter(index, 0.5, -0.9, 1)
      print index y --byobs
      x = seq(1,5)' ~ (1 | zeros(4,1))
      w = filter(x, 0.5, -0.9, 1)
      print x w
    </code>
    <para>
      produce
    </para>
    <code>
                   index            y   
                          
          1            1     -0.40000   
          2            2      1.36000   
          3            3      0.27600   
          4            4      1.75160   
          5            5      0.92356   

          x (5 x 2)
           
            1   1 
            2   0 
            3   0 
            4   0 
            5   0 
           
          w (5 x 2)
           
              -0.40000     -0.40000 
                1.3600      0.36000 
               0.27600     -0.32400 
                1.7516      0.29160 
               0.92356     -0.26244 
    </code>
      </description>
    </function>

    <function name="firstobs" section="data-utils" output="int">
      <fnargs>
    <fnarg type="series">y</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce il primo valore non-mancante della variabile
      <argname>y</argname>. Si noti che se si sta operando su un
      sottocampione ristretto, il valore ottenuto può essere più
      piccolo della variabile dollaro <fncref targ="$t1"/>.
      <seelist> 
        <fncref targ="lastobs"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="fixname" section="strings" output="string">
      <fnargs>
    <fnarg type="string">rawname</fnarg>
      </fnargs>
      <description>
    <para>
      Destinato all'uso in relazione al comando <cmdref
      targ="join"/>.  Restituisce il risultato della conversione
      di <argname>rawname</argname> in un identificatore gretl
      valido, che deve inizione con un carattere alfabetico,
      contenere esclusivamente caratteri (ASCII), numeri e trattino
      basso, e non deve eccedere i 31 caratteri. Le regole
      utilizzate per la conversione sono:
    </para>
    <para>
      1. Eliminare qualsiasi carattere iniziale che non sia un
      carattere alfabetico.
    </para>
    <para>
      2. Fino al limite dei 31 caratteri o al completamento
      dell'input: trascrivere i caratteri <quote>legali</quote>;
      saltare i caratteri <quote>illegali</quote> esclusi gli
      spazi; e sostituire uno o più spazi consecutivi con un
      trattino basso, a meno che il precedente carattere
      trascritto sia un trattino, nel qual caso lo spazio è
      saltato.
    </para>
      </description>
    </function>

    <function name="floor" section="math" output="asinput">
      <fnargs>
    <fnarg type="anyfloat">y</fnarg>
      </fnargs>    
      <description>
    <para>
      Restituisce il più grande intero minore o uguale di
      <argname>x</argname>. Nota: <fncref targ="int"/> e
      <lit>floor</lit> differiscono nel loro effetto su argomenti
      negativi: <lit>int(-3.5)</lit> restituisce &minus;3, mentre
      <lit>floor(-3.5)</lit> produce &minus;4.
    </para>
      </description>
    </function>

    <function name="fracdiff" section="filters" output="series">
      <fnargs>
    <fnarg type="series">y</fnarg>
    <fnarg type="scalar">d</fnarg>
      </fnargs>    
      <description>
    <para context="notex">
      Restituisce la differenza frazionale di ordine
      <argname>d</argname> per la variabile <argname>y</argname>.
    </para>   
    <para context="tex">
        \[
        \Delta^d y_t = y_t - \sum_{i=1}^{\infty} \psi_i y_{t-i}
        \]
      where
        \[\psi_i = \frac{\Gamma(i-d)}{\Gamma(-d) \Gamma(i+1)}\]
    </para>
    <para>
      Si noti che in teoria la differenziazione frazionale
      corrisponde ad un filtro infinitamente lungo. In pratica, i
      valori di <math>y</math><sub>t</sub> precedenti al campione
      estratto sono posti pari a zero.
    </para>
    <para>
      L'argomento <argname>d</argname> può essere negativo, nel qual
      caso si può parlare di integrazione frazionale anziché
      differenziazione.
    </para>
      </description>
    </function>

    <function name="gammafun" section="math" output="asinput">
      <fnargs>
    <fnarg type="anyfloat">x</fnarg>
      </fnargs>    
      <description>
    <para>
      Restituisce la funzione gamma di <argname>x</argname>. 
    </para>
      </description>
    </function>

    <function name="genseries" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="string">varname</fnarg>
	<fnarg type="series">rhs</fnarg>
      </fnargs>    
      <description>
	<para>
	  Questa funzione è pensata principalmente per gli autori di
	  script: fornisce un metodo per generare serie i cui nomi
	  non siano noti a priori, e/o creare una serie ed aggiungerla
	  ad una lista con un solo comando.
	</para>
	<para>
	  Il primo argomento specifica l'identificativo della serie da
	  creare (o modificare); questo può essere una stringa fissa,
	  una variabile di tipo stringa, o un'espressione che risulta
	  in una stringa.  Il secondo argomento,
	  <argname>rhs</argname> (<quote>right-hand side</quote>),
	  definisce la serie origine: l'identificativo di una serie
	  pre-esistente o un'espressione che risulta in una serie,
	  così come apparirebbe alla destra del segno di uguale quando
	  si assegnano valori alle serie nel solito modo.
	</para>
	<para>
	  Il valore ritornato da questa funzione è il numero ID della
	  serie nel dataset, che può essere incluso in una lista (o
	  &minus;1 in caso di errore).
	</para>
	<para>
	  Per esempio, immaginiamo di voler aggiungere <math>n</math>
	  serie casuali normali al dataset e raccoglierle tutte in una
	  lista:
	</para>
	<code>
	  list Normals = null
	  loop i=1..n --quiet
	      Normals += genseries(sprintf("norm%d", i), normal())
	  endloop
	</code>
	<para>
	  Alla fine del ciclo, <lit>Normals</lit> conterrà le serie
	  <lit>norm1</lit>, <lit>norm2</lit> e così via.
	</para>
      </description>
    </function>

    <function name="getenv" section="strings" output="string">
      <fnargs>
    <fnarg type="string">s</fnarg>
      </fnargs>    
      <description>
    <para>
      Se è definita una variabile di ambiente di nome 
      <argname>s</argname>, questa funzione restituisce una stringa 
      contenente il valore di quella variabile, 
      altrimenti restituisce una stringa vuota.
      Si veda anche <fncref targ="ngetenv"/>.
    </para>
      </description>
    </function>

    <function name="getline" section="strings" output="scalar">
      <fnargs>
    <fnarg type="string">source</fnarg>
    <fnarg type="string">target</fnarg>
      </fnargs>    
      <description>
    <para>
      Questa funzione è usata per leggere righe successiva da
      <argname>source</argname>, che dovrebbe essere una variabile
      stringa. Ad ogni chiamata una linea della fonte è scritta in
      <argname>target</argname> (anch'essa una variabile
      stringa), privata del carattere che produce una nuova
      linea. Il risultato è 1 se non c'è ancora qualcosa da
      leggere (incluse linee vuote), 0 se la lettura dalla fonte è
      stata completata.
    </para>
    <para>
      Questo è un esempio in cui il contenuto di un file di testo è riportato
      su più righe:
    </para>
    <code>
      string s = readfile("data.txt")
      string line
      scalar i = 1
      loop while getline(s, line)
        printf "line %d = '%s'\n", i++, line
          endloop
    </code>
    <para>
      In questo esempio possiamo essere sicuri che la fonte è
      stata esaurita quando termina il ciclo. Se la fonte non può
      essere completata le chiamate di <lit>getline</lit>
      dovrebbero essere seguite da una chiamata di <quote>clean
      up</quote>, in cui <argname>target</argname> è sostituito da
      <lit>null</lit> (o omesso) come segue
    </para>
    <code>
      getline(s, line)
      getline(s, null)
    </code>
    <para>
      Si noti che, anche se la posizione di lettura avanza ad ogni chiamata di 
      <lit>getline</lit>, questa funzione non modifica <argname>source</argname> 
      ma solo <argname>target</argname>.
    </para>
      </description>
    </function>

    <function name="ghk" section="stats" output="matrix">
      <fnargs>
    <fnarg type="matrix">C</fnarg>
    <fnarg type="matrix">A</fnarg>
    <fnarg type="matrix">B</fnarg>
    <fnarg type="matrix">U</fnarg>
      </fnargs>
      <description>
    <para>
      Calcola l'approssimazione basata sull'algoritmo GHK (Geweke,
      Hajivassiliou, Keane) della funzione di ripartizione della
      normale multivariata; si veda <cite key="geweke91">Geweke
      (1991)</cite>. Il valore prodotto è un vettore <by r="n"
      c="1"/> di probabilità.
    </para>
    <para>
      L'argomento <argname>C</argname> (<by r="m" c="m"/>) deve
      contenere la scomposizione di Cholesky (triangolare inferiore)
      della matrice di covarianza delle <math>m</math>
      variabili normali.  Gli argomenti <argname>A</argname> e
      <argname>B</argname> dovrebbero essere entrambi <by r="n"
      c="m"/>, fornendo rispettivamente il limite inferiore e
      superiore da applicare alle variabili per ciascuna delle
      <math>n</math> osservazioni. Nel caso in cui le variabili
      siano illimitate, è necessario indicarlo 
      utilizzando la costante <fncref targ="$huge"/> o il suo
      opposto.
    </para>
    <para>
      La matrice <argname>U</argname> deve essere di dimensione
      <by r="m" c="r"/>, dove <math>r</math> è il numero di
      estrazioni pseudo-casuali dalla distribuzione uniforme;
      funzioni idonee alla creazione di <argname>U</argname> sono
      <fncref targ="muniform"/> e <fncref targ="halton"/>.
    </para>
    <para>
      Nel seguente esempio, le variabili <argname>P</argname> e
      <argname>Q</argname> dovrebbero essere numericamente molto
      simili l'una all'altra, essendo <argname>P</argname> la
      "vera" probabilità e <argname>Q</argname> la sua
      approssimazione basata sull'algoritmo GHK:
    </para>
    <code>
      nulldata 20
      series inf1 = -2*uniform()
      series sup1 = 2*uniform()
      series inf2 = -2*uniform()
      series sup2 = 2*uniform()

      scalar rho = 0.25
      matrix V = {1, rho; rho, 1}

      series P = cdf(D, rho, inf1, inf2) - cdf(D, rho, sup1, inf2) \
      - cdf(D, rho, inf1, sup2) + cdf(D, rho, sup1, sup2)

      C = cholesky(V)
      U = muniform(2, 100)

      series Q = ghk(C, {inf1, inf2}, {sup1, sup2}, U)
    </code>
      </description>
    </function>

    <function name="gini" section="stats" output="scalar">
      <fnargs>
    <fnarg type="series">y</fnarg>
      </fnargs>    
      <description>
    <para>
      Produce l'indice di Gini per la variabile <argname>y</argname>.
    </para>
      </description>
    </function>

    <function name="ginv" section="linalg" output="matrix">
      <fnargs>
    <fnarg type="matrix">A</fnarg>
      </fnargs>    
      <description>
    <para>
      Restituisce <math>A</math><sup>+</sup>, l'inversa di
      Moore&ndash;Penrose o inversa generalizzata di
      <argname>A</argname>, calcolata attraverso la scomposizione
      per valori singolari.
    </para>
    <para context="notex">
      Questa matrice gode delle proprietà seguenti: 
      <math>A</math> <math>A</math><sup>+</sup> <math>A</math>
      = <math>A</math> e <math>A</math><sup>+</sup>
       <math>A</math>  <math>A</math><sup>+</sup>
      = <math>A</math><sup>+</sup> .
      I prodotti <math>A</math>
       <math>A</math><sup>+</sup> e <math>A</math><sup>+</sup>
       <math>A</math>, inoltre, sono simmetrici per costruzione.
    </para>
    <para context="tex">
      Questa matrice gode delle seguenti proprietà
      \begin{eqnarray*}
      A A^+ A &amp; = &amp; A \\
      A^+ A A^+ &amp; = &amp; A^+ 
      \end{eqnarray*}
      I prodotti $A^+ A$ e $A A^+$, inoltre, sono simmetrici per costruzione.
    </para>
    <para>
      <seelist>
        <fncref targ="inv"/>
        <fncref targ="svd"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="halton" section="stats" output="matrix">
      <fnargs>
    <fnarg type="int">m</fnarg>
    <fnarg type="int">r</fnarg>
    <fnarg optional="true" type="int">offset</fnarg>
      </fnargs>
      <description>
    <para>
      Produce una matrice <by r="m" c="r"/> contenente
      <math>m</math> sequenze di Halton di lunghezza
      <math>r</math>; <math>m</math> è limitata ad un massimo di
      40. Le sequenze sono costruite utilizzando i primi
      <math>m</math> numeri primi. Se non diversamente
      specificato, i primi 10 elementi di ogni sequenza sono
      scartati: questo valore può essere modificato specificando
      l'argomento opzionale <argname>offset</argname> (che deve
      essere un numero intero non-negativo). Si veda
      <cite key="halton64">Halton and Smith (1964)</cite>.
    </para>
      </description>
    </function>

    <function name="hdprod" section="linalg" output="matrix">
      <fnargs>
    <fnarg type="matrix">X</fnarg>
    <fnarg type="matrix">Y</fnarg>
      </fnargs>
      <description>
    <para>
      Prodotto diretto orizzontale. I due argomenti devo avere lo stesso
      numero di righe, <math>r</math>. Il risultato è una matrice
      con <math>r</math> righe, in cui la riga
      <math>i</math>-esima è il prodotto di Kronecker 
      delle corrispondenti righe di <argname>X</argname> e
      <argname>Y</argname>.
    </para>
    <para context="tex">
      In altri termini, se $X$ è una matrice $r \times k$, $Y$ è una matrice
      $r \times m$ e $Z$ è il risultato del
      prodotto diretto orizzontale di $X$ per $Y$, allora $Z$ avrà
      $r$ righe e $k\cdot m$ colonne. Inoltre, 
      \[ 
      Z_{in} = X_{ij} Y_{il} 
      \]
      dove $n = (j-1) m + l$.
    </para>
    <para>
      Non siamo a conoscenza di un nome standard per questa
      operazione nell'algebra delle matrici. "Prodotto diretto
      orizzontale" ("Horizontal direct product") è il modo con cui
      questa operazione viene chiamata nel linguaggio di
      programmazione GAUSS.
    </para>
    <para>
      Esempio: il codice
    </para>
    <code>
      A = {1,2,3; 4,5,6}
      B = {0,1; -1,1}
      C = hdprod(A, B)
    </code>
    <para>
      produce la matrice seguente:
    </para>
    <code>
         0    1    0    2    0    3 
        -4    4   -5    5   -6    6 
    </code>
      </description>
    </function>

    <function name="hpfilt" section="filters" output="series">
      <fnargs>
    <fnarg type="series">y</fnarg>
    <fnarg type="scalar" optional="true">lambda</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce la componente ciclica ottenuta dall'applicazione
      del filtro di Hodrick&ndash;Prescott alla variabile
      <argname>y</argname>. Se il parametro di lisciaggio 
      <argname>lambda</argname> non viene fornito questo viene
      automaticamente calcolato sulla base dei dati a
      disposizione: viene posto uguale 100 volte il quadrato della
      periodicità dei dati (100 per dati annuali, 1600 per dati
      trimestrali, e così via).
      <seelist> 
        <fncref targ="bkfilt"/>
        <fncref targ="bwfilt"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="I" section="matbuild" output="smatrix">
      <fnargs>
    <fnarg type="int">n</fnarg>
      </fnargs>
      <description>
    <para>
      Produce la matrice identità con <argname>n</argname> righe e
      colonne.
    </para>
      </description>
    </function>

    <function name="imaxc" section="stats" output="rvec">
      <fnargs>
    <fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce un vettore contenente gli indici riga dei massimi
      delle colonne di <argname>X</argname>.
      <seelist> 
        <fncref targ="imaxr"/> 
        <fncref targ="iminc"/>
        <fncref targ="maxc"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="imaxr" section="stats" output="cvec">
      <fnargs>
    <fnarg type="matrix">X</fnarg>
      </fnargs>    
      <description>
    <para>
      Restituisce un vettore contenente gli indici colonna dei massimi
      delle righe di <argname>X</argname>.
      <seelist> 
        <fncref targ="imaxc"/>
        <fncref targ="iminr"/>
        <fncref targ="maxr"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="imhof" section="probdist" output="scalar">
      <fnargs>
    <fnarg type="matrix">M</fnarg>
    <fnarg type="scalar">x</fnarg>
      </fnargs>    
      <description>
    <para context="notex">
      Calcola Prob(<math>u'Au</math> &lt; <math>x</math>) per una
      forma quadratica di variabili normali standard,
      <math>u</math>, utilizzando la procedura sviluppata da <cite
      key="imhof61">Imhof (1961)</cite>.
    </para>
    <para context="tex">
      Calcola ${\rm Prob}(u'Au &lt; x)$ per una forma
      quadratica di variabili normali standard, $u$, utilizzando la procedura
      sviluppata da <cite key="imhof61">Imhof (1961)</cite>.
    </para>
    <para>
      Il primo argomento, <argname>M</argname>, può essere una
      matrice quadrata o un vettore colonna, altrimenti viene
      visualizzato un messaggio di errore.  Nel primo caso
      <argname>M</argname> è utilizzato per specificare
      <math>A</math>, nel secondo caso <argname>M</argname> viene
      considerato il vettore contenente gli autovalori di
      <math>A</math>.
    </para>
    <para>
      <seelist>
        <fncref targ="pvalue"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="iminc" section="stats" output="rvec">
      <fnargs>
    <fnarg type="matrix">X</fnarg>
      </fnargs>    
      <description>
    <para>
      Restituisce un vettore contenente gli indici riga dei minimi
      delle colonne di <argname>X</argname>.
      <seelist>
        <fncref targ="imaxc"/>
        <fncref targ="iminr"/>
        <fncref targ="minc"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="iminr" section="stats" output="cvec">
      <fnargs>
    <fnarg type="matrix">X</fnarg>
      </fnargs>    
      <description>
    <para>
      Restituisce un vettore contenente gli indici colonna dei minimi
      delle righe di <argname>X</argname>.
      <seelist>
        <fncref targ="imaxr"/> 
        <fncref targ="iminc"/>
        <fncref targ="minr"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="inbundle" section="data-utils" output="int">
      <fnargs>
    <fnarg type="bundle">b</fnarg>
    <fnarg type="string">chiave</fnarg>
      </fnargs>    
      <description>
    <para>
      Controlla se il bundle  <argname>b</argname> contiene un elemento di nome 
      <argname>key</argname>. Il valore restituito è un intero diverso a seconda del
      tipo di elemento: 0 indica nessun elemento, 1 scalare, 2 variabile, 
      3 matrice, 4 stringa e 5 bundle. Per recuperare la stringa associata 
      al codice può essere utilizzata la funzione <fncref
      targ="typestr"/>.
    </para>   
      </description>
    </function>   

    <function name="infnorm" section="linalg" output="scalar">
      <fnargs>
    <fnarg type="matrix">X</fnarg>
      </fnargs>    
      <description>
    <para context="notex">
      Restituisce la norma infinito di <argname>X</argname>, ovvero
      il massimo valore, lungo le righe di <argname>X</argname>, 
      della somma dei valori assoluti degli elementi nelle righe.
    </para>
    <para context="tex">
      Restiuisce la norma-$\infty$ di una matrice $r\times c$ 
      <argname>X</argname>: 
        \[\| X \|_{\infty} = \max_i \sum_{j=1}^c |X_{ij}|\]
    </para>
    <para>
      <seelist>
        <fncref targ="onenorm"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="inlist" section="data-utils" output="int">
      <fnargs>
    <fnarg type="list">L</fnarg>
    <fnarg type="series">y</fnarg>
      </fnargs>    
      <description>
    <para>
      Restituisce la posizione di <argname>y</argname> (a partire
      dalla prima posizione) nella lista <argname>L</argname>, o 0
      se <argname>y</argname> non è presente in
      <argname>L</argname>. Il secondo argomento può essere il
      nome di una variabile o il suo identificativo numerico (intero).
    </para>
      </description>
    </function>

    <function name="int" section="math" output="asinput">
      <fnargs>
    <fnarg type="anyfloat">x</fnarg>
      </fnargs>  
      <description>
    <para>
      Tronca la parte frazionaria di <argname>x</argname>. Si noti
      che <lit>int</lit> e <fncref targ="floor"/> differiscono in
      termini di risultato sui numeri negativi:
      <lit>int(-3.5)</lit> restituisce &minus;3, mentre
      <lit>floor(-3.5)</lit> produce &minus;4.
      <seelist> 
        <fncref targ="ceil"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="inv" section="linalg" output="matrix">
      <fnargs>
    <fnarg type="smatrix">A</fnarg>
      </fnargs>  
      <description>
    <para>
      Restituisce l'inversa di <argname>A</argname>. Se
      <argname>A</argname> è singolare o non quadrata viene
      visualizzato un messaggio di errore e non viene prodotto
      alcun risultato. Si noti che gretl controlla automaticamente
      la struttura di <argname>A</argname> e utilizza la procedura
      numerica più efficiente per il calcolo dell'inversa.
    </para>
    <para>
      I tipi di matrice che sono controllati da gretl sono: identità;
      diagonale; simmetrica e positiva definita; simmetrica ma non
      positiva definita; triangolare.
    </para>
    <para>
      Notare che ha senso utilizzare questa funzione solamente se si
      intende usare l'inversa di <argname>A</argname> più di una
      volta. Se serve semplicemente calcolare un'espressione del tipo
      <math>A</math><sup>-1</sup><math>B</math> conviene decisamente
      utilizzare gli operatori di <quote>divisione matriciale</quote>,
      <lit>\</lit> e <lit>/</lit>. Per ulteriori dettagli vedere
      <guideref targ="chap:matrices"/>.
    </para>
    <para>
      <seelist>
        <fncref targ="ginv"/>
        <fncref targ="invpd"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="invcdf" section="probdist" output="asinput">
      <fnargs>
    <fnarg type="char">c</fnarg>
    <fnarg type="seebelow">&hellip;</fnarg>
    <fnarg type="anyfloat">p</fnarg>
      </fnargs>
      <description>
    <para>
      Funzione di distribuzione inversa. Restituisce il valore
      <math>x</math> tale che <equation status="inline" ascii="P(X
      &lt; x) = p" tex="$P(X \le x) = p$"/>, dove la distribuzione
      di <math>X</math> è determinata dal carattere
      <argname>c</argname>. Tra i due argomenti
      <argname>c</argname> e <argname>p</argname>, zero o più
      argomenti addizionali sono richiesti al fine di specificare
      i parametri della distribuzione, secondo le regole seguenti:
    </para>
    <ilist context="notex">
      <li>
        <para>
          Normale standardizzata (c = z, n, or N): nessun argomento addizionale
        </para>
      </li>
      <li>
        <para>
          Gamma (g o G): forma; scala
        </para>
      </li>
      <li>
        <para>
          T di Student (t): numero di gradi di libertà
        </para>
      </li>
      <li>
        <para>
          Chi-quadrato (c, x, o X): numero di gradi di libertà
        </para>
      </li>
      <li>
        <para>
          F di Snedecor (f o F): gradi di libertà (num.); gradi di libertà (den.)
        </para>
      </li>
      <li>
        <para>
          Binomiale (b o B): probabilità; numero di prove
        </para>
      </li>
      <li>
        <para>
          Poisson (p o P): media
        </para>
      </li>
      <li>
        <para>
          GED standardizzata (E): forma
        </para>
      </li>
      <li>
	<para>
	  Chi-quadro non centrale (ncX): gdl, parametro di non
	  centralità
	</para>
      </li>
      <li>
	<para>
	  F non centrale (ncF): gdl (num.), gdl (den.), parametro di
	  non centralità
	</para>
      </li>
      <li>
	<para>
	  t non centrale (nct): gdl, parametro di non centralità
	</para>
      </li>	  
     </ilist>
    <para context="tex">
      \begin{center} 
      \begin{tabular}{lllll} 
      \textit{Distribuzione} &amp; codice, $c$ &amp;
      \textit{Arg.} 2 &amp; \textit{Arg.} 3 &amp; \textit{Arg.} 4 \\[4pt] 
      Normale Standard &amp; \texttt{z}, \texttt{n} or \texttt{N} &amp;
      -- &amp; -- &amp; -- \\ 
      Gamma &amp; \texttt{g} o \texttt{G} &amp;
      forma &amp; scala &amp; -- \\ 
      $t$ di Student (centrata) &amp; \texttt{t} &amp; 
      gradi di libertà &amp; -- &amp; -- \\ 
      Chi-quadrato &amp; \texttt{c}, \texttt{x} o \texttt{X} &amp; 
      gradi di libertà &amp; -- &amp; -- \\
      $F$ di Snedecor &amp; \texttt{f} o \texttt{F} &amp; 
      gradi di libertà (num.) &amp; gradi di libertà (den.) \\ 
      Binomiale &amp; \texttt{b} or \texttt{B} &amp; 
      $p$ &amp; $n$ &amp; -- \\
      Poisson &amp; \texttt{p} o \texttt{P} &amp;
          $\lambda$ &amp; -- &amp; -- \\ 
      GED standardizzata &amp; \texttt{E} &amp; forma &amp; -- &amp; -- \\
      $\chi^2$ non centrale &amp; \texttt{ncX} &amp; 
      gdl &amp; non centralit{\`a} &amp; -- \\
      $F$  non centrale &amp; \texttt{ncF} &amp; 
      gdl (num.) &amp; gdl (den.) &amp; non centralit{\`a}  \\
      $t$  non centrale &amp; \texttt{nct} &amp; 
      gdl &amp; non centralit{\`a} &amp; -- \\
      \end{tabular}
      \end{center}
    </para>
    <para>
      <seelist>
        <fncref targ="cdf"/>
        <fncref targ="critical"/>
        <fncref targ="pvalue"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="invmills" section="probdist" output="asinput">
      <fnargs>
    <fnarg type="anyfloat">x</fnarg>
      </fnargs>  
      <description>
    <para>
      Produce il reciproco del rapporto di Mills calcolato in
      <argname>x</argname>, ossia il rapporto tra la densità della
      normale standard e il complemento della funzione di
      distribuzione della normale standard, entrambe valutate in
      <argname>x</argname>.
    </para>
    <para>
      Questa funzione utilizza un algoritmo dedicato che produce
      maggiore accuratezza rispetto al calcolo utilizzando <fncref
      targ="dnorm"/> e <fncref targ="cnorm"/>, ma la differenza
      tra i due metodi è apprezzabile solo per valori di
      <argname>x</argname> negativi e molto grandi.
    </para>
    <para>
      <seelist>
        <fncref targ="cdf"/>
        <fncref targ="cnorm"/>
        <fncref targ="dnorm"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="invpd" section="linalg" output="smatrix">
      <fnargs>
    <fnarg type="pdmat">A</fnarg>
      </fnargs>  
      <description>
    <para>
      Restituisce l'inversa di una matrice simmetrica, definita
      positiva <argname>A</argname>.  Questa funzione è leggermente più veloce
      di <fncref targ="inv"/> per grandi matrici poichè non viene
      effettuato nessun controllo per la simmetria; per questa
      ragione deve essere utilizzata con attenzione.
    </para>
    <para>
      Notare che nel calcolo dell'inversa di una matrice del tipo
      <math>X'X</math>, ove <math>X</math> sia di dimensioni elevate,
      è preferibile utilizzare la forma <lit>X'X</lit> invece della
      più generale sintassi <lit>X'*X</lit>. La prima espressione
      utilizza infatti un algoritmo specifico che presenta il duplice
      vantaggio di essere più efficiente dal punto di vista
      computazionale e di assicurare come risultato una matrice priva
      per costruzione di approssimazioni indotte dalla precisione
      macchina, che possono renderlo numericamente non simmetrico.
    </para>
      </description>
    </function>

    <function name="irf" section="stats" output="matrix">
      <fnargs>
    <fnarg type="int">target</fnarg>
    <fnarg type="int">shock</fnarg>
    <fnarg type="pscalar" optional="true">alpha</fnarg>
      </fnargs>  
      <description>
    <para>
      Questa funzione è disponibile solo quando l'ultimo modello
      stimato è un VAR o VECM. Produce una matrice contenente le
      risposte stimate della variabile <argname>target</argname>
      ad un impulso di una deviazione standard nella variabile
      <argname>shock</argname>. Queste variabili sono identificate
      dalla loro posizione nella specificazione VAR: ad esempio,
      se <argname>target</argname> e <argname>shock</argname> sono
      rispettivamente pari a 1 e 3, la matrice che ne risulta
      fornisce le risposte della prima variabile nella
      specificazione VAR ad uno shock nella terza variabile.
    </para>
    <para>
      Se si specifica l'argomento opzionale
      <argname>alpha</argname>, la matrice dei risultati ha tre
      colonne: le stime puntuali delle risposte, seguite dai
      limiti superiore e inferiore dell'intervallo di confidenza
      per 1 &minus; &agr; ottenuti attraverso bootstrap.  (Quindi
      <argname>alpha</argname> = 0.1 corrisponde a un intervallo
      di confidenza al 90 percento.) Se <argname>alpha</argname> è
      omesso o posto pari a zero, il risultato contiene solo le
      stime puntuali.
    </para>
    <para>
      Il numero di periodi (righe) su cui sono calcolate le
      risposte è determinato automaticamente sulla base della
      frequenza delle osservazioni, ma questa impostazione può
      essere modificata attraverso il comando <cmdref
      targ="set"/>, ad esempio <lit>set horizon 10</lit>.
    </para>
      </description>
    </function>

    <function name="irr" section="math" output="scalar">
      <fnargs>
    <fnarg type="series-or-vec">x</fnarg>
      </fnargs>  
      <description>
    <para>
      Restituisce il tasso interno di rendimento (Internal Rate of
      Return) per <argname>x</argname>, considerata come una
      sequenza di pagamenti (valori negativi) e riscossioni
      (valori positivi).
      <seelist>
        <fncref targ="npv"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="isconst" section="data-utils" output="int">
      <fnargs>
    <fnarg type="series-or-vec">y</fnarg>
    <fnarg type="int" optional="true">panel-code</fnarg>
      </fnargs>
      <description>
    <para>
      Quando il secondo argomento (opzionale) non è specificato,
      produce 1 se <argname>y</argname> ha un valore costante per
      il campione corrente (o lungo tutta la sua lunghezza se
      <argname>y</argname> è un vettore), 0 altrimenti.
    </para>
    <para>
      Il secondo argomento è accettato solo nel caso in cui il
      dataset corrente sia un panel e <argname>y</argname> sia una
      variabile.  In questo caso un valore
      <argname>panel-code</argname> pari a 0 richiede un controllo
      per invarianza nel tempo, mentre un valore pari a 1 richiede
      un controllo di invarianza tra le unità cross-section
      (ossia, in ciascun istante temporale il valore di
      <argname>y</argname> è lo stesso per tutti i gruppi).
    </para>
    <para>
      Se <argname>y</argname> è una variabile, i valori mancanti
      sono ignorati durante il controllo.
    </para>
      </description>
    </function>

    <function name="isdiscrete" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">nome</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>nome</argname> è l'identificatore per una serie
	  esistente, ritorna 1 se la serie è stata dichiarata come
	  discreta e 0 altrimenti. Se <argname>nome</argname>
	  non identifica una serie, ritorna <lit>NA</lit>.
	</para>
      </description>
    </function>

    <function name="isdummy" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Se tutti i valori contenuti in <argname>x</argname> sono 0 o
	  1 (o mancanti), ritorna il numero di 1, altrimenti 0.
	</para>
      </description>
    </function>

    <function name="isnan" section="data-utils" output="asinput">
      <fnargs>
    <fnarg type="scalar-or-matrix">x</fnarg>
      </fnargs>
      <description>
    <para>
      Dato un argomento scalare, restituisce 1 se
      <argname>x</argname> è <quote>Not a Number</quote> (NaN), 0
      altrimenti. Se l'argomento è una matrice produce una matrice
      delle stesse dimensioni contenente 1 nelle posizioni in cui
      l'elemento corrispondente della matrice di input è NaN e 0
      altrimenti.
    </para>
      </description>
    </function>

    <function name="isnull" section="data-utils" output="int">
      <fnargs>
    <fnarg type="string">nome</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce 0 se <argname>nome</argname> è l'identificativo di
      un oggetto già definito, che può essere uno scalare, una
      variabile, una matrice, una lista o un bundle; in caso contrario restituisce 1.
    </para>
      </description>
    </function>  

    <function name="isoconv" section="calendar" output="scalar">
      <fnargs>
    <fnarg type="series">date</fnarg>
    <fnarg type="seriesref">&amp;year</fnarg>
    <fnarg type="seriesref">&amp;month</fnarg>
    <fnarg type="seriesref" optional="true">&amp;day</fnarg>
      </fnargs>
      <description>
    <para>
      Data una variabile <argname>date</argname> contenente date
      nel formato <quote>base</quote> ISO 8601
      (<lit>YYYYMMDD</lit>), questa funzione scrive l'anno, il
      mese e (opzionale) il giorno corrispondenti nella variabile
      nominata nel secondo e nei successivi argomenti.  Un
      esempio, assumendo che la variabile <lit>dates</lit>
      contenga valori a 8 cifre appropriati:
    </para>
    <code>
      series y, m, d
      isoconv(dates, &amp;y, &amp;m, &amp;d)
    </code>
    <para>
      Il valore prodotto da questa funzione è 0 se completata con successo,
      non-zero nel caso di errori.
    </para>
      </description>
    </function>

    <function name="isodate" section="calendar" output="seebelow">
      <fnargs>
    <fnarg type="scalar-or-series">ed</fnarg>
    <fnarg type="bool" optional="true">as-string</fnarg>
      </fnargs>
      <description>
    <para>
      L'argomento <argname>ed</argname> è interpretato come una
      data in formato <quote>epoch</quote> (uguale a 1 per il
      primo gennaio nell'anno 1 AD). Il risultato di default
      &mdash; dello stesso tipo di <argname>ed</argname> &mdash; è
      un numero a 8 cifre, o una serie di tali numeri, del tipo
      <lit>YYYYMMDD</lit> (formato <quote>base</quote> ISO 8601),
      che fornisce la data di calendario corrispondente al giorno
      epoch.
    </para>
    <para>
      Se <argname>ed</argname> è uno scalare (solo) e il secondo
      argomento opzionale <argname>as-string</argname> è diverso
      da zero, il risultato non è numerico ma una stringa del tipo
      <lit>YYYY-MM-DD</lit> (formato ISO 8601
      <quote>esteso</quote>).
    </para>
    <para>
      Per la funzione inversa, si veda <fncref targ="epochday"/>.
    </para>
      </description>
    </function>

    <function name="iwishart" section="stats" output="matrix">
      <fnargs>
    <fnarg type="symmat">S</fnarg>
    <fnarg type="int">v</fnarg>
      </fnargs>
      <description>
    <para>
      Data <argname>S</argname> (una matrice positiva definita <by r="p"
      c="p"/>), restituisce un'estrazione dalla distribuzione inversa di 
      Wishart con <argname>v</argname> gradi di 
      libertà. La matrice che ne risulta è anch'essa <by r="p" c="p"/>.  
      Utilizza l'algoritmo di <cite key="odell-feiveson66">Odell and Feiveson
      (1966)</cite>.
    </para>
      </description>
    </function>

    <function name="jsonget" section="data-utils" output="string">
      <fnargs>
	<fnarg type="string">buf</fnarg>
	<fnarg type="string">path</fnarg>
      </fnargs>
      <description>
	<para>
	  L'argomento <argname>buf</argname> deve essere un buffer
	  JSON, così come vien letto da un server attraverso la
	  funzione <fncref targ="curl"/>, mentre l'argomento
	  <argname>path</argname> dev'essere una specificazione
	  JsonPath.
	</para>
	<para>
	  Questa funzione restituisce una stringa con i dati trovati
	  nel buffer al path specificato. Sono supportati i tipi di
	  dato <quote>double</quote> (decimale), <quote>int</quote>
	  (intero) and <quote>string</quote> (stringa). Nel caso di
	  argomenti numerici, viene restituita la loro
	  rappresentazione stringa (con le convenzioni
	  <quote>C</quote> per i double).  Se l'oggetto a cui
	  <argname>path</argname> fa riferimento è un array, i suoi
	  membri vengono stampati uno per linea nella stringa
	  risultato.
	</para>
	<para>
	  Per maggiori dettagli sulla sintassi JsonPath, si veda ad
	  esempio <url>http://goessner.net/articles/JsonPath/</url>.
	</para>
      </description>
    </function>    

   <function name="kdensity" section="stats" output="matrix">
      <fnargs>
    <fnarg type="series">x</fnarg>
    <fnarg type="scalar" optional="true">scale</fnarg>
    <fnarg type="bool" optional="true">control</fnarg>
      </fnargs>
      <description>
    <para>
      Calcola la stima della densità kernel per la variabile 
      <argname>x</argname>. La matrice che ne risulta ha due
      colonne: la prima contiene un insieme di valori in ascissa
      equispaziati e la seconda colonna riporta le stime
      della densità in ciascuno di questi punti.
    </para>
    <para>
      Il parametro opzionale <argname>scale</argname> può essere
      utilizzato per adattare il grado di lisciaggio rispetto al
      valore di default di 1.0 (valori più elevati producono un
      risultato più liscio). Il parametro
      <argname>control</argname> funziona come un booleano: si
      utilizza il kernel Gaussiano quando
      <argname>control</argname> è pari 0 (il valore di default);
      con un valore diverso da zero si utilizza il kernel di
      Epanechnikov.
    </para>
    <para>
      Un grafico del risultato può essere ottenuto utilizzando il comando <cmdref
      targ="gnuplot"/>, come segue
    </para>
    <code>
      matrix d = kdensity(x)
      gnuplot 2 1 --matrix=d --with-lines --suppress-fitted
    </code>
      </description>
    </function>

    <function name="kdsmooth" section="sspace" output="scalar">
      <fnargs>
	<fnarg type="bundleref">&amp;Mod</fnarg>
	<fnarg type="bool" optional="true">MSE</fnarg>
      </fnargs>
      <description>
	<para>
	  Performs disturbance smooting for a Kalman bundle previously
	  set up by means of the <fncref targ="ksetup"/> and returns 0
	  on successful completion or 1 if numerical problems are
	  encountered.
	</para>
	<para>
	  On succession completion, the smoothed disturbances will be
	  available as <lit>Mod.smdist</lit>.
	</para>
	<para>
	  The optional <argname>MSE</argname> argument determines the
	  contents of the <lit>Mod.smdisterr</lit> key. If 0 or
	  omitted, this matrix will contain the unconditional standard
	  errors of the smoothed residuals, which are normally used to
	  compute the so-called <it>auxiliary
	  residuals</it>. Otherwise, <lit>Mod.smdisterr</lit> will
	  contain the estimated root mean square deviations of the
	  auxiliary residuals from their true value.
	</para>
	<para>
	  For more details see <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="ksetup"/>
            <fncref targ="kfilter"/>
            <fncref targ="ksmooth"/>
            <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function> 

    <function name="kfilter" section="sspace" output="scalar">
      <fnargs>
	<fnarg type="bundleref">&amp;Mod</fnarg>
      </fnargs>
      <description>
	<para>
	  Performs a forward, filtering pass on a Kalman bundle
	  previously set up by means of the <fncref targ="ksetup"/>
	  and returns 0 on successful completion or 1 if numerical
	  problems are encountered.
	</para>
	<para>
	  On succession completion, the one-step-ahead prediction
	  errors will be available as <lit>Mod.prederr</lit> and the
	  sequence of their covariance matrices as
	  <lit>Mod.pevar</lit>, respectively. Moreover, the key
	  <lit>Mod.llt</lit> gives access to a T-vector, containing
	  the log-likelihood by observation.
	</para>
	<para>
	  For more details see <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="kdsmooth"/>
            <fncref targ="ksetup"/>
            <fncref targ="ksmooth"/>
            <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="kpsscrit" section="stats" output="matrix">
      <fnargs>
	<fnarg type="scalar">T</fnarg>
	<fnarg type="bool">trend</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce un vettore riga contenente i valori critici al
	  10, 5 e 1 percento per il test di stazionarietà
	  KPSS. <argname>T</argname> deve contenere il numero di
	  osservazioni e <argname>trend</argname> dev'essere 1 se il
	  test include un trend e 0 altrimenti.
	</para>
	<para>
	  I valori critici sono basati sulle superfici di risposta
	  stimated da <cite key="sephton95">Sephton (Economics
	  Letters, 1995)</cite>. Vedi anche il comando <cmdref
	  targ="kpss"/>.
 	</para>
      </description>
    </function> 

    <function name="ksetup" section="sspace" output="bundle">
      <fnargs>
	<fnarg type="smlist">Y</fnarg>
	<fnarg type="scalar-or-matrix">H</fnarg>
	<fnarg type="scalar-or-matrix">F</fnarg>
	<fnarg type="scalar-or-matrix">Q</fnarg>
	<fnarg optional="true" type="matrix">C</fnarg>
      </fnargs>
      <description>
	<para>
	  Sets up a Kalman bundle, that is an object which contains
	  all the information needed to define a linear state space
	  model of the form
	  <equation status="display" 
		    tex="\[y_t=H'\alpha_t\]"
		    ascii="y(t) = H'a(t)"
		    graphic="kalman1"/> 
	  and state transition equation
	  <equation status="display" 
		    tex="\[\alpha_{t+1}=F \alpha_t + u_t\]"
		    ascii="a(t+1) = F a(t) + u(t)"
		    graphic="kalman2"/> 
	  where <math>V(u) = Q</math>.
	</para>
	<para>
	  Objects created via this function can be later used via the
	  dedicated functions <fncref targ="kfilter"/> for filtering,
	  <fncref targ="ksmooth"/> and <fncref targ="kdsmooth"/> for
	  smoothing and <fncref targ="ksimul"/> for performing
	  simulations.
	</para>
	<para>
	  The class of models that gretl can handle is in fact much
	  wider than the one implied by the representation above: it
	  is possible to have time-varying models, models with diffuse
	  priors and exogenous variable in the measurement equation
	  and models with cross-correlated innovations. For further
	  details, see <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="kdsmooth"/>
            <fncref targ="kfilter"/>
            <fncref targ="ksmooth"/>
            <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function> 

    <function name="ksimul" section="sspace" output="scalar">
      <fnargs>
	<fnarg type="bundleref">&amp;Mod</fnarg>
      </fnargs>
      <description>
	<para>
	  Uses a Kalman bundle previously set up by means of the
	  <fncref targ="ksetup"/> to simulate data.
	</para>
	<para>
	  For details see <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="ksetup"/>
            <fncref targ="kfilter"/>
            <fncref targ="ksmooth"/>
	  </seelist>
	</para>
      </description>
    </function> 

    <function name="ksmooth" section="sspace" output="matrix">
      <fnargs>
	<fnarg type="bundleref">&amp;Mod</fnarg>
      </fnargs>
      <description>
	<para>
	  Performs a fixed-point smoothing (backwards) pass on a
	  Kalman bundle previously set up by means of the <fncref
	  targ="ksetup"/> and returns 0 on successful completion or 1
	  if numerical problems are encountered.  
	</para>
	<para>
	  On succession completion, the smoothed states will be
	  available as <lit>Mod.state</lit> and the sequence of their
	  covariance matrices as <lit>Mod.stvar</lit>, respectively.
	  For more details see <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="kdsmooth"/>
            <cmdref targ="kalman"/>
            <fncref targ="kfilter"/>
            <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function> 

    <function name="kurtosis" section="stats" output="scalar">
      <fnargs>
    <fnarg type="series">x</fnarg>
      </fnargs>
      <description>
    <para>
      Produce il coefficiente di curtosi (in eccesso) della
      variabile <argname>x</argname>, calcolato non considerando i
      valori mancanti.
    </para>
      </description>
    </function>

    <function name="lags" section="transforms" output="list">
      <fnargs>
    <fnarg type="int">p</fnarg>
    <fnarg type="series-or-list">y</fnarg>
    <fnarg type="bool" optional="true">bylag</fnarg>
      </fnargs>
      <description>
    <para>
      Genera i ritardi da 1 a <argname>p</argname> della variabile
      <argname>y</argname>, o se <argname>y</argname> è una lista, di tutte le variabili
      nella lista.  Se <argname>p</argname> = 0, il numero massimo di ritardi
      è scelto sulla base della periodicità dei dati; altrimenti 
      <argname>p</argname> deve essere positivo.
    </para>
    <para> 
      Alle variabili così generate è automaticamente attribuito un
      nome sulla base del formato
      <repl>varname</repl><lit>_</lit><repl>i</repl> dove
      <repl>varname</repl> è il nome della variabile originale e
      <repl>i</repl> è il valore del ritardo.  Se necessario la parte originale
      del nome è troncata e può essere aggiustata
      in caso di ripetizioni nell'insieme dei nomi delle variabili
      così costruite.
    </para>
    <para>
      Quando <argname>y</argname> è una lista e l'ordine di ritardo è
      maggiore di 1, l'ordinamento di default dei termini della lista
      che ne risulta è per variabile: tutti i ritardi della prima variabile
      nella lista in input sono seguiti da tutti i ritardi della seconda variabile,
      e così via. Il terzo argomento (opzionale) può essere utilizzato
      per cambiare tale impostazione: se <argname>bylag</argname> è diverso da zero
      i termini sono ordinati per ritardo: il primo ritardo di tutte le variabili in input,
      poi il secondo ritardo, e così via.
    </para>
      </description>
    </function>

    <function name="lastobs" section="data-utils" output="int">
      <fnargs>
    <fnarg type="series">y</fnarg>
      </fnargs>
      <description>
    <para>
      Ultimo valore non-mancante per la variabile
      <argname>y</argname>. Si noti che se si sta operando su un
      sottocampione ristretto, il valore prodotto può essere
      maggiore della variabile dollaro <fncref targ="$t2"/>.
      <seelist>
        <fncref targ="firstobs"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="ldet" section="linalg" output="scalar">
      <fnargs>
    <fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
    <para>
      Produce il logaritmo naturale del determinante di <math>A</math>,
      calcolato attraverso la fattorizzazione LU.
      <seelist> 
        <fncref targ="det"/>
        <fncref targ="rcond"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="ldiff" section="transforms" output="asinput">
      <fnargs>
    <fnarg type="series-or-list">y</fnarg>
      </fnargs>
      <description>
    <para>
      Calcola le differenze logaritmiche; i valori iniziali sono posti uguali a
      <lit>NA</lit>.
    </para>
    <para> 
      Quando viene restituita una lista alle singole variabili così generate 
      è automaticamente attribuito un nome sulla base del formato
      <lit>ld_</lit><repl>varname</repl> dove
      <repl>varname</repl> è il nome della variabile originale. 
      Se necessario il nome viene troncato e può essere modificato 
      in caso di ripetizioni nell'insieme dei nomi delle variabili
      così costruite.
    </para> 
    <para>
      <seelist> 
        <fncref targ="diff"/>
        <fncref targ="sdiff"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="lincomb" section="transforms" output="series">
      <fnargs>
    <fnarg type="list">L</fnarg>
    <fnarg type="vector">b</fnarg>
      </fnargs>
      <description>
    <para>
      Calcola una nuova variabile ottenuta come combinazione
      lineare delle variabili nella lista <argname>L</argname>.  I
      coefficienti sono dati dal vettore <argname>b</argname>, che
      deve avere lunghezza uguale al numero di variabili in
      <argname>L</argname>.
    </para>
    <para>
      <seelist> 
        <fncref targ="wmean"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="linearize" section="filters" output="series">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Richiede che TRAMO sia installato. Restituisce una versione
	  <quote>linearizzata</quote> della serie in input, ossia una
	  serie in cui le osservazioni mancanti vengono sostituite da
	  valori interpolati e gli outlier vengono aggiustati. A tal
	  fine, viene usato il meccanismo automatico di TRAMO'; per
	  maggiori dettagli, si consulti la documentazione di TRAMO.
	</para>
	<para>
	  Si noti che, se la serie in input non contiene osservazioni
	  mancanti né valori che TRAMO considera outlier, la funzione
	  ritorna una copia della serie originale.
	</para>
      </description>
    </function>
    
    <function name="ljungbox" section="stats" output="scalar">
      <fnargs>
    <fnarg type="series">y</fnarg>
    <fnarg type="int">p</fnarg>
      </fnargs>
      <description>
    <para>
      Calcola la statistica Q di Ljung&ndash;Box per la serie y
      <argname>y</argname> usando <argname>p</argname> ritardi e
      il campione corrente. L'ordine di ritardo deve essere maggiore o uguale a 1 e
      inferiore al numero di osservazioni disponibili.
    </para>
    <para>
      Questa statistica può essere confrontata con la distribuzione chi-quadro con
      <argname>p</argname> gradi di libertà per sottoporre a test
      l'ipotesi che la variabile <argname>y</argname> sia
      serialmente incorrelata.
      <seelist>
        <fncref targ="pvalue"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="lngamma" section="math" output="asinput">
      <fnargs>
    <fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
    <para>
      Logaritmo della funzione gamma di <argname>x</argname>.
    </para>
      </description>
    </function>

    <function name="log" section="math" output="asinput">
      <fnargs>
    <fnarg type="anyfloat-or-list">x</fnarg>
      </fnargs>
      <description>
    <para>
      Logaritmo naturale di <argname>x</argname>; genera <lit>NA</lit> per valori non
      positivi. Nota: <lit>ln</lit> può essere usato al posto di 
      di <lit>log</lit>.
    </para>
    <para> 
      Quando restituisce una lista alle singole variabili viene automaticamente 
      assegnato un nome sulla base del formato
      <lit>l_</lit><repl>varname</repl> dove
      <repl>varname</repl> è il nome della variabile originale. 
      Se necessario il nome viene troncato e può essere modificato 
      in caso di ripetizioni nell'insieme dei nomi delle variabili
      così costruite.
    </para> 
      </description>
    </function>

    <function name="log10" section="math" output="asinput">
      <fnargs>
    <fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
    <para>
      Logaritmo in base 10 di <argname>x</argname>; produce <lit>NA</lit> per valori
      non positivi.
    </para>
      </description>
    </function>

    <function name="log2" section="math" output="asinput">
      <fnargs>
    <fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
    <para>
      Logaritmo in base 2 di <argname>x</argname>; produce <lit>NA</lit> per valori
      non positivi.
    </para>
      </description>
    </function>

    <function name="loess" section="stats" output="series">
      <fnargs>
    <fnarg type="series">y</fnarg>
    <fnarg type="series">x</fnarg>
    <fnarg optional="true" type="int">d</fnarg>
    <fnarg optional="true" type="scalar">q</fnarg>
    <fnarg optional="true" type="bool">robust</fnarg>
      </fnargs>
      <description>
    <para>
      Effettua una regressione polinomiale ponderata localmente e
      restituisce una variabile contenente i valori previsti di
      <argname>y</argname> per ogni elemento non mancante di
      <argname>x</argname>.  Viene usato il metodo descritto in
      <cite key="cleveland79">William Cleveland (1979)</cite>.
    </para>
    <para>
      Gli argomenti opzionali <argname>d</argname> e
      <argname>q</argname> specificano rispettivamente l'ordine
      del polinomio in <argname>x</argname> e la proporzione di
      punti da usare nella stima locale.  I valori predefiniti
      sono <argname>d</argname> = 1 e <argname>q</argname> =
      0.5. Gli altri valori consentiti per <argname>d</argname>
      sono 0 e 2. Con <argname>d</argname> = 0 la regressione
      locale si riduce a una forma di media mobile. Il valore di
      <argname>q</argname> dev'essere compreso fra 0 e 1; più
      grande è il valore, più liscia sarà la stima.
    </para>
    <para>
      Assegnando all'argomento <argname>robust</argname> un valore
      non-zero, le regressioni locali sono effettuate due volte,
      con pesi modificati sulla base dei residui dell'iterazione
      precedente per ridurre l'effetto degli outlier.
    </para>
    <para>
      Si vedano anche <fncref targ="nadarwat"/> e <guideref
      targ="chap:nonparam"/> per maggiori dettagli sui metodi
      nonparametrici.
    </para>
      </description>
    </function>

    <function name="logistic" section="math" output="asinput">
      <fnargs>
    <fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
    <para context="tex">
      Restituisce la funzione logistica calcolata nell'argomento
      <argname>x</argname>: $\Lambda(x) = e^x/(1+e^x)$. Se
      <argname>x</argname> è una matrice, la funzione è applicata
      elemento per elemento.
    </para>
    <para context="notex">
      Restituisce la funzione logistica calcolata nell'argomento
      <argname>x</argname>: <math>e</math><sup>x</sup>/(1 +
      <math>e</math><sup>x</sup>).  Se <argname>x</argname> è una
      matrice, la funzione è applicata elemento per elemento.
    </para>
      </description>
    </function>

    <function name="lower" section="matbuild" output="smatrix">
      <fnargs>
    <fnarg type="matrix">A</fnarg>
      </fnargs>
      <description>
    <para context="notex">
      Restituisce una matrice <by r="n" c="n"/> triangolare inferiore: gli elementi
      sulla diagonale o sotto di essa sono uguali al valore corrispondente in 
      <argname>A</argname>; i restanti valori sono pari a zero.
    </para>
    <para context="tex">
      Restituisce una matrice $n\times n$ triangolare inferiore <math>B</math>
      tale che $B_{ij} = A_{ij}$ se $i \ge j$, e 0 altrimenti.
    </para>
    <para>
      <seelist>
        <fncref targ="upper"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="lrvar" section="filters" output="scalar">
      <fnargs>
    <fnarg type="series-or-vec">y</fnarg>
    <fnarg type="int">k</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce la varianza di lungo periodo di
      <argname>y</argname> calcolata utilizzando il kernel di
      Bartlett con finestra <argname>k</argname>.
    </para>
    <para context="tex">
      In formule: 
      \[ \hat{\omega}^2(k) = \frac{1}{T} \sum_{t=k}^{T-k}
      \left[ \sum_{i=-k}^k w_i (y_t - \bar{X}) (y_{t-i} - \bar{Y})
      \right] \] 
      con 
      \[ w_i = 1 - \frac{|i|}{k + 1} \]
    </para>
      </description>
    </function>

    <function name="max" section="stats" output="scalar-or-series">
      <fnargs>
    <fnarg type="series-or-list">y</fnarg>
      </fnargs>
      <description>
    <para>
      Se l'argomento <argname>y</argname> è una variabile,
      restituisce il massimo valore (scalare) tra le osservazioni
      non-mancanti della serie.  Se l'argomento è una lista,
      restituisce una variabile i cui elementi corrispondono al
      massimo dei valori delle variabili nella lista per ciascuna
      osservazione.
    </para>
    <para>
      <seelist>
        <fncref targ="min"/>
        <fncref targ="xmax"/>
        <fncref targ="xmin"/>
      </seelist>
    </para> 
      </description>
    </function>

    <function name="maxc" section="stats" output="rvec">
      <fnargs>
    <fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce i massimi per colonna di <argname>X</argname>.
      <seelist>
        <fncref targ="imaxc"/>
        <fncref targ="maxr"/>
        <fncref targ="minc"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="maxr" section="stats" output="cvec">
      <fnargs>
    <fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce i massimi per riga di <argname>X</argname>. 
      <seelist>
        <fncref targ="imaxr"/>
        <fncref targ="maxc"/> 
        <fncref targ="minr"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="mcorr" section="stats" output="matrix">
      <fnargs>
    <fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
    <para>
      Calcola la matrice di correlazione considerando ogni colonna di 
      <argname>X</argname> come una variabile.
      <seelist> 
        <fncref targ="corr"/>
        <fncref targ="cov"/>
        <fncref targ="mcov"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="mcov" section="stats" output="matrix">
      <fnargs>
    <fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
    <para>
      Calcola la matrice di covarianza considerando ogni colonna di 
      <argname>X</argname> come una variabile. 
      <seelist> 
        <fncref targ="corr"/>
        <fncref targ="cov"/>
        <fncref targ="mcorr"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="mcovg" section="stats" output="matrix">
      <fnargs>
    <fnarg type="matrix">X</fnarg>
    <fnarg optional="true" type="vector">u</fnarg>
    <fnarg optional="true" type="vector">w</fnarg>
    <fnarg type="int">p</fnarg>
      </fnargs>
      <description>
    <para> 
      Restituisce la matrice covariogramma corrispondente a una
      matrice <by r="T" c="k"/> <argname>X</argname> (di solito 
      contenente regressori), un vettore (opzionale)
      <math>T</math>-variato <argname>u</argname> (di solito 
      contenente i residui), un vettore (opzionale) di dimensione
      (<math>p</math>+1) di pesi <argname>w</argname> e un
      ordine di ritardo scalare <argname>p</argname> che deve
      essere maggiore o uguale a 0.
    </para>
    <para context="tex">
      La matrice prodotta è data da
      \[\sum_{j=-p}^{p} \sum_j w_{|j|} (X_t' u_t
      u_{t-j} X_{t-j})\]
    </para>
    <para context="notex">
      La matrice prodotta è data da
    </para>
    <para context="notex">  
      sum_{j=-p}^p sum_j w_{|j|} (X_t' u_t u_{t-j} X_{t-j})
    </para>
    <para>
      Se <argname>u</argname> è specificato come <lit>null</lit>
      il termine <math>u</math> è omesso, e se
      <argname>w</argname> è <lit>null</lit> tutti i pesi
      sono considerati pari a 1.0.
    </para>
      </description>
    </function>

    <function name="mean" section="stats" output="scalar-or-series">
      <fnargs>
    <fnarg type="series-or-list">x</fnarg>
      </fnargs>
      <description>
    <para>
      Se <argname>x</argname> è una variabile, restituisce la
      media campionaria (scalare) calcolata non considerando le
      osservazioni mancanti (se presenti).
    </para>
    <para>
      Se <argname>x</argname> è una lista, produce una variabile
      <math>y</math> tale che <math>y</math><sub>t</sub> è la
      media dei valori delle variabili nella lista per
      l'osservazione <math>t</math>, o <lit>NA</lit> se ci sono
      valori mancanti in <math>t</math>.
    </para>
      </description>
    </function>

    <function name="meanc" section="stats" output="rvec">
      <fnargs>
    <fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
    <para>
      Calcola le medie per colonna di <argname>X</argname>. 
      <seelist>
        <fncref targ="meanr"/>
        <fncref targ="sumc"/>
        <fncref targ="sdc"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="meanr" section="stats" output="cvec">
      <fnargs>
    <fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
    <para>
      Calcola le medie per riga di <argname>X</argname>. 
      <seelist>
        <fncref targ="meanc"/>
        <fncref targ="sumr"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="median" section="stats" output="scalar">
      <fnargs>
    <fnarg type="series">y</fnarg>
      </fnargs>
      <description>
    <para>
      Calcola la mediana delle osservazioni non mancanti della variabile
      <argname>y</argname>. 
      <seelist>
        <fncref targ="quantile"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="mexp" section="linalg" output="smatrix">
      <fnargs>
    <fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
    <para context="notex">
      Calcola l'esponenziale della matrice <argname>A</argname>, usando
      l'algoritmo 11.3.1 di <cite key="golub96">Golub and
      Van Loan (1996)</cite>.
    </para>
    <para context="tex">
      Esponenziale di una matrice,
      \[ e^A = \sum_{k=0}^{\infty} \frac{A^k}{k!}
      = \frac{I}{0!} + \frac{A}{1!} + \frac{A^2}{2!} + \frac{A^3}{3!}
      + \cdots\] 
      (La convergenza di questa serie è garantita.) La funzione 
      usa l'algoritmo 11.3.1 di <cite key="golub96">Golub and
      Van Loan (1996)</cite>.
    </para>
      </description>
    </function>

    <function name="min" section="stats" output="scalar-or-series">
      <fnargs>
    <fnarg type="series-or-list">y</fnarg>
      </fnargs>
      <description>
    <para>
      Se l'argomento <argname>y</argname> è una variabile calcola
      il minimo (scalare) delle osservazioni non mancanti della variabile.
      Se l'argomento è una lista, restituisce una variabile i cui elementi
      sono il minimo dei valori delle variabili incluse nella lista
      in corrispondenza di ciascuna osservazione.
    </para>
    <para>
      <seelist>
        <fncref targ="max"/>
        <fncref targ="xmax"/>
        <fncref targ="xmin"/>
      </seelist>
    </para> 
      </description>
    </function>

    <function name="minc" section="stats" output="rvec">
      <fnargs>
    <fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
    <para>
      Calcola i minimi delle colonne di <argname>X</argname>.
      <seelist>
        <fncref targ="iminc"/>
        <fncref targ="maxc"/> 
        <fncref targ="minr"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="minr" section="stats" output="cvec">
      <fnargs>
    <fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
    <para>
      Calcola i minimi delle righe di <argname>X</argname>. 
      <seelist>
        <fncref targ="iminr"/>
        <fncref targ="maxr"/> 
        <fncref targ="minc"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="missing" section="data-utils" output="asinput">
      <fnargs>
    <fnarg type="sslist">x</fnarg>
      </fnargs>
      <description>
    <para>
      Crea una variabile binaria uguale a 1 se
      <argname>x</argname> è <lit>NA</lit>. Se
      <argname>x</argname> è una variabile, il confronto viene
      effettuato elemento per elemento; se <argname>x</argname> è
      una lista di variabili, il risultato è una variabile con
      elementi pari a 1 per le osservazioni per le quali almeno
      una delle variabili incluse nella lista ha valore mancante,
      e 0 altrimenti.
    </para>
    <para>
      <seelist> 
        <fncref targ="misszero"/>
        <fncref targ="ok"/>
        <fncref targ="zeromiss"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="misszero" section="data-utils" output="asinput">
      <fnargs>
    <fnarg type="scalar-or-series">x</fnarg>
      </fnargs>
      <description>
    <para>
      Converte gli <lit>NA</lit> in zeri. Se <argname>x</argname>
      è una variabile la conversione è effettuata elemento per
      elemento.
      <seelist>
        <fncref targ="missing"/>
        <fncref targ="ok"/>
        <fncref targ="zeromiss"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="mlag" section="stats" output="matrix">
      <fnargs>
    <fnarg type="matrix">X</fnarg>
    <fnarg type="scalar-or-vec">p</fnarg>
    <fnarg type="scalar" optional="true">m</fnarg>
      </fnargs>
      <description>
    <para context="notex">
      Sposta in alto o in basso le righe di <argname>X</argname>. Se
      <argname>p</argname> è uno scalare positivo, restituisce una matrice
      nella quale le colonne di <argname>X</argname> sono spostate verso
      il basso di <argname>p</argname> righe e le prime 
      <argname>p</argname> righe sono riempite con il valore 
      <argname>m</argname>. Se <argname>p</argname> è un numero negativo, 
      <argname>X</argname> è spostata verso l'alto e le ultime righe
      sono riempite con il valore <argname>m</argname>. Se
      <argname>m</argname> viene omesso, al suo posto si utilizza un
      valore nullo.
    </para>
    <para context="tex">
      Sposta in alto o in basso le righe di <argname>X</argname>. Se
      $p$ è uno scalare positivo, il risultato è una matrice $Y$ di elementi
      $Y_{i,j} = X_{i-p,j}$ per $i \ge p$ e zero altrimenti. In
      altre parole, le colonne di 
      <argname>X</argname> vengono spostate verso il basso di 
      <argname>p</argname> righe e le prime <argname>p</argname>
      righe sono riempite con il valore <argname>m</argname>. Se 
      <argname>p</argname> è un numero negativo,
      <argname>X</argname> viene spostata verso l'alto e le ultime righe 
      sono riempite con il valore <argname>m</argname>. Se 
      <argname>m</argname> è omesso, al suo posto si utilizza
      lo zero.
    </para>
    <para context="notex">
      Se <argname>p</argname> è un vettore, l'operazione precedente
      è svolta per ciascun elemento di <argname>p</argname>,
      unendo le matrici così ottenute in senso orizzontale.
    </para>
    <para context="tex">
      Se $p$ è un vettore, l'operazione precedente è svolta
      per ciascun elemento di $p$, unendo le matrici così ottenute
      in senso orizzontale.
    </para>
      </description>
    </function>

    <function name="mnormal" section="matbuild" output="matrix">
      <fnargs>
    <fnarg type="int">r</fnarg>
    <fnarg type="int">c</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce una matrice di <argname>r</argname> righe e
      <argname>c</argname> colonne, contenene numeri pseudocasuali
      generati da una normale standardizzata.
      <seelist> 
        <fncref targ="normal"/>
        <fncref targ="muniform"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="mols" section="stats" output="matrix">
      <fnargs>
    <fnarg type="matrix">Y</fnarg>
    <fnarg type="matrix">X</fnarg>
    <fnarg type="matrixref" optional="true">&amp;U</fnarg>
    <fnarg type="matrixref" optional="true">&amp;V</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce una matrice <by r="k" c="n"/> di stime di
      parametri ottenute con la regressione dei minimi quadrati
      ordinari della matrice <by r="T" c="n"/>
      <argname>Y</argname> sulla matrice <by r="T" c="k"/>
      <argname>X</argname>.
    </para>
    <para>
      Se il terzo argomento non è <lit>null</lit>, la matrice <by
      r="T" c="n"/> <argname>U</argname> contiene i residui. Se
      l'ultimo argomento viene indicato e non è <lit>null</lit>,
      la matrice <by r="k" c="k"/> <argname>V</argname> conterrà
      (a) la matrice di covarianza delle stime dei parametri, se
      <argname>Y</argname> ha una sola colonna, o (b)
      <math>X'X</math><sup>-1</sup> se <argname>Y</argname> ha più
      colonne.
    </para>
    <para>
      Di default, le stime sono ottenute usando una scomposizione
      di Cholesky, ricorrendo alla scomposizione QR se le colonne
      di <argname>X</argname> sono quasi collineari.  E' possibile
      imporre l'uso della scomposizione SVD usando il comando
      <lit>set svd on</lit>.
    </para>
    <para>
      <seelist> 
        <fncref targ="mpols"/>
        <fncref targ="mrls"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="monthlen" section="calendar" output="int">
      <fnargs>
    <fnarg type="int">mese</fnarg>
    <fnarg type="int">anno</fnarg>
    <fnarg type="int">gioset</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce il numero di giorni (rilevanti) in un dato mese
      e anno; l'argomento <argname>gioset</argname> può essere
      5, 6 o 7, e indica il numero di giorni nella settimana da
      contare (il 6 omette le domeniche, il 5 anche i sabati).
    </para>
      </description>
    </function>

    <function name="movavg" section="filters" output="series">
      <fnargs>
    <fnarg type="series">x</fnarg>
    <fnarg type="scalar">p</fnarg>
    <fnarg type="int" optional="true">control</fnarg>
      </fnargs>
      <description>
    <para>
      A seconda del parametro 
      <argname>p</argname>, calcola una media mobile semplice o con pesi 
      esponenziali della variabile input
      <argname>x</argname>.
    </para>
    <para context="notex">
      Se <argname>p</argname> &gt; 1, viene calcolata una media
      mobile semplice a <argname>p</argname> termini; in altre
      parole, la media aritmetica da x(t) a x(t+p-1). Se viene
      indicato un valore non nullo per il parametro opzionale
      <argname>control</argname> la media mobile è centrata, in
      caso contrario è <quote>retrospettiva</quote> (usa solo
      l'osservazione corrente e quelle passate, ma non quelle
      future).
    </para>
    <para context="tex">
      Se $p&gt;1$, viene calcolata una media mobile semplice a
      <argname>p</argname> termini, in altre parole $\frac{1}{p}
      \sum_{i=0}^{p-1} x_{t-i}$. Se viene indicato un valore non
      nullo per il parametro opzionale <argname>control</argname>
      la media mobile è centrata, altrimenti è
      <quote>retrospettiva</quote> (usa solo l'osservazione
      corrente e quelle passate, ma non quelle future).
    </para>
    <para context="notex">
      Se <argname>p</argname> è una frazione positiva viene
      calcolata una media mobile esponenziale: y(t) = p*x(t) +
      (1-p)*y(t-1). Di default la variabile calcolata, y, è
      inizializzata usando il primo valore valido di
      <argname>x</argname>, ma il parametro
      <argname>control</argname> può essere usato per specificare
      il numero di osservazioni iniziali che dovrebbero essere
      incluse nella media usata per calcolare y(0).  Un valore
      nullo di <argname>control</argname> indica che dovrebbero
      essere usate tutte le osservazioni.
    </para>
    <para context="tex">
      Se $0 &lt; p &lt; 1$, viene calcolata una media mobile
      esponenziale: $y_t = p x_t + (1-p)y_{t-1}$. Di default la
      variabile calcolata, $y$, è inizializzata usando il primo
      valore valido di $x$, ma il parametro
      <argname>control</argname> può essere usato per specificare
      il numero di osservazioni iniziali che dovrebbero essere
      incluse nella media usata per calcolare $y_0$.  Un valore
      nullo di <argname>control</argname> indica che devono essere
      usate tutte le osservazioni.
      </para>   
    </description>
    </function>

    <function name="mpols" section="stats" output="matrix">
      <fnargs>
    <fnarg type="matrix">Y</fnarg>
    <fnarg type="matrix">X</fnarg>
    <fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
    <para>
      Funziona esattamente come <fncref targ="mols"/>, tranne che i calcoli
      sono effettuati in precisione multipla usando la libreria GMP.
    </para>
    <para>
      Di default GMP usa 256 bit per ogni numero a virgola mobile, ma
      questa convenzione può essere modificata usando la variabile d'ambiente
      <lit>GRETL_MP_BITS</lit>, &eg; <lit>GRETL_MP_BITS=1024</lit>.
    </para>
      </description>
    </function>

    <function name="mrandgen" section="probdist" output="matrix">
      <fnargs>
    <fnarg type="string">d</fnarg>
    <fnarg type="scalar">p1</fnarg>
    <fnarg type="scalar" conditional="true">p2</fnarg>
    <fnarg type="scalar" conditional="true">p3</fnarg>
    <fnarg type="int">rows</fnarg>
    <fnarg type="int">cols</fnarg>
      </fnargs>
      <examples>
    <example>matrix mx = mrandgen(u, 0, 100, 50, 1)</example>
    <example>matrix mt14 = mrandgen(t, 14, 20, 20)</example>
      </examples>
      <description>
    <para>
      Funziona come <fncref targ="randgen"/> tranne che il valore
      calcolato è una matrice anzichè una variabile. Gli argomenti
      iniziali di questa funzione (il cui numero dipende dalla
      distribuzione specificata) sono come quelli descritti per
      <lit>randgen</lit>, ma devono essere seguiti da due interi
      per specificare il numero di righe (<argname>r</argname>) e
      colonne (<argname>c</argname>) della matrice casuale
      desiderata.
    </para>
    <para>
      Il primo esempio fornito sopra calcola un vettore colonna
      casuale uniforme di 50 elementi, mentre il secondo specifica
      una matrice casuale <by r="20" c="20"/> con elementi tratti
      dalla distribuzione <math>t</math> con 14 gradi di libertà.
    </para>
    <para>
      <seelist>
        <fncref targ="mnormal"/>
        <fncref targ="muniform"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="mread" section="matbuild" output="matrix">
      <fnargs>
    <fnarg type="string">nomefile</fnarg>
    <fnarg optional="true" type="bool">import</fnarg>
      </fnargs>
      <description>
    <para>
      Legge una matrice da un file di testo. La stringa 
      <argname>nomefile</argname> deve contenere il nome del file da cui
      deve essere letta la matrice. Se questo nome ha estensione 
      <quote><lit>.gz</lit></quote>, si assume che il file sia stato creato
      con compressione gzip.
    </para>
    <para>
      Il file in questione può iniziare con un numero
      di commenti qualsiasi, definiti come linee che iniziano 
      con il carattere <lit>#</lit>; queste linee sono ignorate. 
      A parte questo, il contenuto deve rispettare le regole seguenti:
    </para>
    <ilist>
      <li>
        <para>
          La prima riga non commentata deve contenere due interi,
          separati da uno spazio o un tabulatore, che indicano
          rispettivamente il numero di righe e di colonne.
        </para>
      </li>
      <li>
        <para>
          Le colonne devono essere separate da spazi o caratteri.
        </para>
      </li>
      <li>
        <para>
          Il separatore decimale deve essere il punto, 
          <quote><lit>.</lit></quote>.
        </para>
      </li>
    </ilist>
    <para>
      Se viene indicato un valore non nullo per l'argomento
      opzionale <argname>import</argname>, la ricerca del file di
      input avviene all'interno della directory <quote>dot</quote>
      dell'utente. Questa funzione è pensata per essere usata in
      combinazione con le funzioni che esportano matrici
      illustrate nel contesto del comando <cmdref
      targ="foreign"/>.  In questo caso l'argomento
      <argname>fname</argname> dovrebbe essere semplicemente un
      nome di file, senza indicazione del percorso.
    </para>
    <para>
      Se dovesse verificarsi un errore (per esempio dovuto al
      fatto che il file è inaccessibile o mal formattato) la
      funzione restituisce una matrice vuota.
    </para>
    <para>
      <seelist>
        <fncref targ="mwrite"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="mreverse" section="matshape" output="matrix">
      <fnargs>
    <fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce una matrice contenente le righe di
      <argname>X</argname> in ordine inverso. Per ottenere una
      matrice in cui le colonne di <argname>X</argname> appaiano
      in ordine inverso si usi:
    </para>
    <code>
      matrix Y = mreverse(X')'
    </code>
      </description>
    </function>  

    <function name="mrls" section="stats" output="matrix">
      <fnargs>
    <fnarg type="matrix">Y</fnarg>
    <fnarg type="matrix">X</fnarg>
    <fnarg type="matrix">R</fnarg>
    <fnarg type="cvec">q</fnarg>
    <fnarg type="matrixref" optional="true">&amp;U</fnarg>
    <fnarg type="matrixref" optional="true">&amp;V</fnarg>
      </fnargs>
      <description>
    <para>
      Minimi quadrati vincolati: calcola una matrice <by r="k" c="n"/> 
      di stime dei parametri ottenute regredendo con il metodo dei 
      minimi quadrati
      la matrice <by r="T" c="n"/> <argname>Y</argname> sulla matrice 
      <by r="T" c="k"/> m<argname>X</argname> sotto i vincoli lineari 
      <math>RB</math> = <math>q</math>, dove 
      <math>B</math> indica il vettore dei coefficienti incolonnati.
      <argname>R</argname> deve avere <math>k</math> *
      <math>n</math> colonne; ogni riga della matrice rappresenta 
      un vincolo lineare. Il numero di righe di <argname>q</argname>
      deve essere pari al numero di righe di <argname>R</argname>.
    </para>
    <para>
      Se il quinto argomento non è <lit>null</lit>, la matrice <by r="T"
      c="n"/> <argname>U</argname> contiene i residui. Se viene indicato 
      l'ultimo argomento e non è 
      <lit>null</lit>, la matrice <by r="k" c="k"/> 
      <argname>V</argname> contiene la versione vincolata della matrice  
      <math>X'X</math><sup>-1</sup>. La matrice di varianza delle stime
      dell'equazione <math>i</math> può essere costruita moltiplicando
      la sottomatrice opportuna di 
      <argname>V</argname> per una stima della varianza dell'errore 
      di quell'equazione.
    </para>
      </description>
    </function>  

    <function name="mshape" section="matshape" output="matrix">
      <fnargs>
    <fnarg type="matrix">X</fnarg>
    <fnarg type="int">r</fnarg>
    <fnarg type="int">c</fnarg>
      </fnargs>
      <description>
    <para>
      Riorganizza gli elementi di <argname>X</argname> in una matrice con 
      <argname>r</argname> righe e <argname>c</argname> colonne. 
      Gli elementi vengono
      letti da <argname>X</argname> e inseriti nel risultato della funzione 
      in ordine di colonna. Se <argname>X</argname> contiene meno di 
      <math>k</math> = <math>rc</math> elementi, questi ultimi vengono 
      ripetuti ciclicamente; in caso contrario, se 
      <argname>X</argname> ha più elementi ne vengono usati solo i 
      primi <math>k</math>.
    </para>
    <para>
      <seelist>
        <fncref targ="cols"/>
        <fncref targ="rows"/> 
        <fncref targ="unvech"/>
        <fncref targ="vec"/> 
        <fncref targ="vech"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="msortby" section="matshape" output="matrix">
      <fnargs>
    <fnarg type="matrix">X</fnarg>
    <fnarg type="int">j</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce una matrice nella quale le righe di <argname>X</argname>
      sono riordinate per valore crescente degli elementi nella
      colonna <argname>j</argname>. Il riordinamento è stabile:
      le righe che contengono lo stesso valore nella colonna 
      <argname>j</argname>
      mantengono l'ordinamento relativo preesistente.
    </para>
      </description>
    </function>

    <function name="muniform" section="matbuild" output="matrix">
      <fnargs>
    <fnarg type="int">r</fnarg>
    <fnarg type="int">c</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce una matrice di <argname>r</argname> righe e
      <argname>c</argname> colonne contenente numeri pseudocasuali
      estratti da una uniforme (0,1). Nota: per generare uno
      scalare pseudocasuale uniforme è consigliabile usare la
      funzione <fncref targ="randgen1"/>.
    </para>
    <para>
      <seelist>
        <fncref targ="mnormal"/>
        <fncref targ="uniform"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="mwrite" section="data-utils" output="int">
      <fnargs>
    <fnarg type="matrix">X</fnarg>
    <fnarg type="string">fname</fnarg>
    <fnarg optional="true" type="bool">export</fnarg>
      </fnargs>
      <description>
    <para>
      Copia la matrice <argname>X</argname> in un file di testo di nome 
      <argname>fname</argname>. Nella prima riga il file contiene 
      due interi separati da un tabulatore corrispondenti ai numeri di 
      riga e di colonna; nelle righe seguenti sono indicati gli elementi
      della matrice in notazione scientifica, separati da tabulatori
      (una riga per ciascuna linea).
    </para>
    <para>
      Se il file <argname>fname</argname> esiste già verrà sovrascritto.
      Il valore restituito è 0 in caso l'esecuzione venga portata a termine
      correttamente; se si verifica un errore, per esempio dovuto al
      fatto che il file non può essere sovrascritto, il valore restituito 
      sarà non nullo.
    </para>
    <para>
      Se viene indicato un valore non nullo per l'argomento 
      <argname>export</argname>, il file di output sarà salvato nella 
      directory <quote>dot</quote> dell'utente, e ad esso per default 
      sarà possibile 
      accedere usando le funzioni che caricano matrici descritte nell'ambito 
      del comando <cmdref targ="foreign"/>. In questo caso 
      è necessario
      indicare come secondo argomento il nome del file privo del percorso.
    </para>
    <para>
      Le matrici memorizzate usando il comando <lit>mwrite</lit> possono 
      essere facilmente lette da altri programmi; v. 
      <guideref targ="chap:matrices"/> per ulteriori dettagli.
    </para>
    <para>
      E' disponibile un'estensione del comportamento base di questa
      funzione: se <argname>fname</argname> ha estensione 
      <quote><lit>.gz</lit></quote>, il file viene salvato usando la 
      compressione gzip.
    </para>
    <para>
      <seelist>
        <fncref targ="mread"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="mxtab" section="stats" output="matrix">
      <fnargs>
    <fnarg type="series-or-vec">x</fnarg>
    <fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce una matrice contenente una tabella a doppia entrata
      dei valori contenuti in <argname>x</argname> (nel senso delle
      righe) e <argname>y</argname> (nel senso delle colonne). I due
      argomenti devono essere dello stesso tipo (entrambe variabili e
      entrambi vettori colonna), e visto l'uso che tipicamente viene
      fatto di questa funzione si assume che contengano solo valori
      interi.
    </para>
    <para>
      <seelist>
        <fncref targ="values"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="nadarwat" section="stats" output="series">
      <fnargs>
    <fnarg type="series">y</fnarg>
    <fnarg type="series">x</fnarg>
    <fnarg type="scalar">h</fnarg>
      </fnargs>
      <description>
    <para>
      Stima nonparametrica della media condizionale di
      <argname>y</argname> dato <argname>x</argname> col metodo di
      Nadaraya&ndash;Watson. Restituisce una variabile contenente la stima
      nonparametrica di
      <math>E(y</math><sub>i</sub><math>|x</math><sub>i</sub><math>)</math>
      per ogni elemento non mancante della variabile
      <argname>x</argname>.
    </para>
    <para context="tex">
      \[
      m(x_i) = \frac{ \sum_{j=1}^{n} y_j \cdot K_h(x_i -
      x_j)} {\sum_{j=1}^{n} K_h(x_i - x_j)}
      \]
      dove la funzione kernel <math>K_h(\cdot)</math> è data da
      \[
      K_h(x) = \exp\left(-\frac{x^2}{2h}\right)
      \]
      per $|x| &lt; \tau$ e 0 altrimenti.
    </para>
    <para context="notex">
      La funzione kernel <math>K</math> è data da <math>K =
      exp(-x</math><sup>2</sup><math> / 2h)</math> per <math>|x|
      &lt; T</math> e 0 altrimenti.
    </para>
    <para context="tex">
      L'argomento <argname>h</argname>, noto come \emph{ampiezza
      di banda}, è un parametro (reale positivo) indicato
      dall'utente. Normalmente, è un numero piccolo: valori grandi
      di $h$ rendono $m(x)$ più liscia; una scelta molto comune è
      $n^{-0.2}$. Per maggiori dettagli, si veda <guideref
      targ="chap:nonparam"/>.
    </para>
    <para context="notex">
      L'argomento <argname>h</argname>, noto come ampiezza di
      banda, è un parametro (reale positivo) indicato
      dall'utente. Normalmente, è un numero piccolo: valori grandi
      di <argname>h</argname> rendono <math>m(x)</math> più
      liscia; una scelta molto comune è
      <math>n</math><sup>-0.2</sup>. Per maggiori dettagli, si veda
      <guideref targ="chap:nonparam"/>.
    </para>
    <para context="tex">
      Lo scalare $\tau$ viene usato per prevenire problemi
      numerici che si verificano quando la funzione kernel è
      calcolata troppo lontano dallo zero e viene detto 
      parametro di taglio.
    </para>
    <para context="notex">
      Lo scalare <math>T</math> viene usato per prevenire problemi
      numerici che si verificano quando la funzione kernel è
      calcolata troppo lontano dallo zero e viene detto 
      parametro di taglio.
    </para>
    <para>
      Quest'ultimo può essere modificato a piacere mediante il comando
      <lit>set nadarwat_trim</lit>; è espresso come multiplo di
      <argname>h</argname>, e il valore di default è 4.
    </para>
    <para>
      L'utente può indicare un valore negativo per l'ampiezza di
      banda: ciò viene interpretato come una sintassi
      comvenzionale per la cosiddetta variante
      <quote>leave-one-out</quote> dello stimatore, ossia una
      variante che non usa la <math>i</math>-esima osservazione
      per calcolare
      <math>m(x</math><sub>i</sub><math>)</math>. Questa variante
      rende il procedimento numericamente più robusto e il suo uso
      è sovente consigliato quando lo stimatore è usato a fini
      inferenziali. Ovviamente, l'ampiezza di banda effettivamente
      usata è il valore assoluto di <argname>h</argname>.
    </para>
      <para context="tex">
        In formule, lo stimatore ``leave-one-out'' è
        \[
        m(x_i) = \frac{ \sum_{j \ne i} y_j \cdot K_h(x_i -
        x_j)} {\sum_{j \ne i} K_h(x_i - x_j)}
        \]
      </para>

      </description>
    </function>

    <function name="nelem" section="data-utils" output="int">
      <fnargs>
    <fnarg type="list">L</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce il numero di elementi nella lista
      <argname>L</argname>.
    </para>
      </description>
    </function>

    <function name="ngetenv" section="strings" output="scalar">
      <fnargs>
    <fnarg type="string">s</fnarg>
      </fnargs>    
      <description>
    <para>
      Se è stata definita una variabile d'ambiente 
      <argname>s</argname> e le è stato assegnato un valore numerico,
      restituisce tale valore; in caso contrario restituisce NA. 
      V anche <fncref targ="getenv"/>.
    </para>
      </description>
    </function>

    <function name="nlines" section="strings" output="scalar">
      <fnargs>
	<fnarg type="string">buf</fnarg>
      </fnargs>    
      <description>
	<para>
	  Ritorna un conteggio delle linee di testo complete (ossia,
	  linee che terminano con un carattere di <quote>a
	  capo</quote>) nel buffer <argname>buf</argname>.
	</para>
    <para>
        Ad esempio:
    </para>
    <code>
        string web_page = readfile("http://gretl.sourceforge.net/")
        scalar number = nlines(web_page)
        print number
    </code>
      </description>
    </function>

    <function name="nobs" section="stats" output="int">
      <fnargs>
    <fnarg type="series">y</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce il numero di osservazioni non mancanti
      per la variabile 
      <argname>y</argname> nella selezione corrente del campione.
    </para>
      </description>
    </function>

    <function name="normal" section="probdist" output="series">
      <fnargs>
    <fnarg type="scalar">&mu;</fnarg>
    <fnarg type="scalar">&sigma;</fnarg>
      </fnargs>
      <description>
    <para>
      Genera una sequenza di numeri pseudo-casuali tratti dalla
      distribuzione normale di media &mu; e deviazione standard
      &sigma;. Se non vengono forniti gli argomenti vengono generate
      realizzazioni tratte dalla distribuzione <math>N</math>(0,1). I
      valori sono prodotti usando il metodo Ziggurat <cite
      key="marsaglia00" p="true">(Marsaglia e Tsang, 2000)</cite>.
    </para>
    <para>
      <seelist>
        <fncref targ="randgen"/>
        <fncref targ="mnormal"/>
        <fncref targ="muniform"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="npv" section="math" output="scalar">
      <fnargs>
    <fnarg type="series-or-vec">x</fnarg>
    <fnarg type="scalar">r</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce il Valore Attuale Netto (VAN) di
      <argname>x</argname>, considerato come una sequenza di
      esborsi (se negativi) e introiti (se positivi), valutati a
      un tasso d'interesse annuo <argname>r</argname>;
      <argname>r</argname> dev'essere espresso in valore non
      percentuale (5<lit>%</lit> = 0.05).  Il primo valore è considerato
      come riferito al periodo <quote>presente</quote> e non viene
      scontato.  Per emulare una funzione che calcola il VAN
      scontando anche il primo valore, inserite uno zero
      all'inizio della sequenza degli input.
    </para>
    <para>
      La funzione può gestire frequenze di osservazione
      annuali, trimestrali, mensili e prive di data (le osservazioni
      prive di data sono considerate annuali).
    </para>
    <para>
      <seelist>
        <fncref targ="irr"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="NRmax" section="numerical" output="scalar">
      <fnargs>
    <fnarg type="vector">b</fnarg>
    <fnarg type="fncall">f</fnarg>
    <fnarg type="fncall" optional="true">g</fnarg>
    <fnarg type="fncall" optional="true">h</fnarg>
      </fnargs>
      <description>
    <para>
      Massimizzazione numerica mediante il metodo di
      Newton&ndash;Raphson. Il vettore <argname>b</argname> deve
      contenere i valori iniziali dei parametri, e l'argomento
      <argname>f</argname> deve specificare una funzione che calcola
      il criterio (scalare) da massimizzare, dati i valori correnti
      dei parametri e altre informazioni rilevanti.  Se l'obiettivo è
      di minimizzare il criterio, la funzione deve restituire il
      criterio cambiato di segno.  Se l'esecuzione viene completata
      con successo, <lit>NRmax</lit> restituisce il valore
      massimizzato del criterio e <argname>b</argname> contiene i
      valori dei parametri corrispondenti al massimo.
    </para>
    <para>
      Gli argomenti opzionali in terza e in quarta posizione
      permettono di specificare rispettivamente le derivate analitiche
      e una matrice Hessiana analitica (negativa). Le funzioni
      indicate come <argname>g</argname> e <argname>h</argname> devono
      assumere come primo argomento una matrice predefinita con le
      stesse dimensioni rispettivamente del gradiente e dell'Hessiana,
      indicati sotto forma di puntatore. Devono inoltre accettare il
      vettore dei parametri come argomento (sotto forma di puntatore o
      altro). Gli altri argomenti sono opzionali. Se si omette uno o
      entrambi gli argomenti opzionali viene utilizzata
      un'approssimazione numerica.
    </para>
    <para>
      Per maggiori dettagli ed esempi si veda il capitolo
      relativo ai metodi numerici in <guideref targ="chap:numerical"/>.
      <seelist>
        <fncref targ="BFGSmax"/>
        <fncref targ="fdjac"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="nullspace" section="linalg" output="matrix">
      <fnargs>
    <fnarg type="matrix">A</fnarg>
      </fnargs>
      <description>
    <para context="notex">
      Calcola lo spazio nullo a destra di <argname>A</argname>
      usando la scomposizione a valori singolari (SVD); il
      risultato è una matrice <math>B</math> tale che il prodotto
      <math>AB</math> è una matrice nulla, tranne quando
      <argname>A</argname> è di rango colonna pieno, caso in cui
      viene restituita una matrice vuota. In caso contrario, se
      <argname>A</argname> è <by r="m" c="n"/>, <math>B</math>
      sarà <math>n</math> per (<math>n</math> &minus;
      <math>r</math>), dove <math>r</math> è il rango di
      <argname>A</argname>.
    </para>
    <para context="tex">
      Calcola lo spazio nullo a destra di <argname>A</argname>,
      usando la scomposizione a valori singolari: il risultato è
      una matrice $B$ tale che $AB=[0]$, tranne quando $A$ è di
      rango colonna pieno, caso in cui viene restituita una
      matrice vuota. In caso contrario, se $A$ è $m \times n$, $B$
      sarà una matrice $n \times (n-r)$, dove $r$ è il rango di
      $A$.
    </para>
    <para>
      <seelist>
        <fncref targ="rank"/>
        <fncref targ="svd"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="obs" section="data-utils" output="series">
      <description>
	<para>
	  Restituisce una serie di interi consecutivi, partendo da 1 in
	  corrispondenza con l'inizio del dataset. Si noti che il
	  risultato è indipendente dal sottocampionamento. Questa
	  funzione è particolarmente utile con dataset di serie
	  storiche. Nota: la funzione <lit>t</lit> è un sinonimo
	  perfetto di <lit>obs</lit>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="obsnum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="obslabel" section="data-utils" output="string">
      <fnargs>
	<fnarg type="int">t</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce l'etichetta per la <argname>t</argname>-esima
	  osservazione, dove <argname>t</argname> è un indice che
	  parte da 1.  La funzione inversa è <fncref targ="obsnum"/>.
	</para>
      </description>
    </function>

    <function name="obsnum" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce un intero corrispondente all'osservazione
      specificata dalla stringa <math>s</math>. Si noti che il
      risultato è invariante al sottocampionamento. Questa
      funzione è particolarmente utile con campioni di serie
      storiche. Ad esempio, il codice
    </para>
    <code>
      open denmark 
      k = obsnum(1980:1)
    </code>
    <para>
      produce <lit>k = 25</lit>, ciò che indica che il primo
      trimestre 1980 è la venticinquesima osservazione nel dataset
      <lit>denmark</lit>.
    </para>
    <para>
      <seelist>
        <fncref targ="obs"/>
        <fncref targ="obslabel"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="ok" section="data-utils" output="seebelow">
      <fnargs>
	<fnarg type="anyfloat-or-list">x</fnarg>
      </fnargs>
      <description>
    <para>
      Se <argname>x</argname> è uno scalare, la funzione
      restituisce 1 se <argname>x</argname> non è <lit>NA</lit>,
      altrimenti 0. Se <argname>x</argname> è una variabile la
      funzione restituisce una serie contenente valore 1 per le
      osservazioni non mancanti e zero altrimenti.  Se
      <argname>x</argname> è una lista il risultato è una
      variabile con zero in corrispondenza delle osservazioni per
      le quali almeno una variabile nella lista ha un valore
      mancante e 1 altrimenti.
    </para>
    <para>
      Se <argname>x</argname> è una matrice il comportamento è
      leggermente diverso, dato che le matrici non possono
      contenere <lit>NA</lit>: la funzione restituisce una matrice
      delle stesse dimensioni di <argname>x</argname>, con
      elementi pari a 1 nelle posizioni corrispondenti a elementi
      di <argname>x</argname> finiti, e 0 di quelli non finiti (o
      infiniti o not-a-number, in conformità con lo standard IEEE
      754).
    </para>
    <para>
      <seelist>
        <fncref targ="missing"/>
        <fncref targ="misszero"/>
        <fncref targ="zeromiss"/>
      </seelist>
      Notare che queste funzioni non possono essere applicate a matrici.
    </para>
      </description>
    </function>

    <function name="onenorm" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Restituisce la norma-1 della matrice <argname>X</argname>;
	  in altre parole, il massimo fra le colonne di
	  <argname>X</argname> della somma dei valori assoluti degli
	  elementi della colonna.
	</para>
	<para context="tex">
	  Restituisce la norma-1 della matrice $r \times c$ 
	  <argname>X</argname>: 
	  \[\| X \|_1 = \max_j \sum_{i=1}^r |X_{ij}| \]
	</para>
	<para>
	  <seelist>
	    <fncref targ="infnorm"/>
	    <fncref targ="rcond"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ones" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce una matrice con <math>r</math> righe e <math>c</math>
	  colonne con elementi tutti pari a 1.
	</para>
	<para>
	  <seelist>
	    <fncref targ="seq"/>
	    <fncref targ="zeros"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="orthdev" section="transforms" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
    <para context="notex">
      La funzione è applicabile solo se il dataset corrente ha
      struttura panel. Calcola le deviazioni ortogonali in avanti
      della variabile <argname>y</argname>.
    </para>
    <para context="tex">
      La funzione è applicabile solo se il dataset corrente ha una
      struttura panel. Calcola le deviazioni ortogonali in avanti
      della variabile <argname>y</argname>; in altre parole, 
      \[ \tilde{y}_{i,t} =
      \sqrt{ \frac{T_i - t + 1}{T_i - t}} \left( y_{i,t} -
      \frac{1}{T_i - t - 1} \sum_{s=t+1}^{T_i} y_{i,s} \right) \]
    </para>
    <para>
      Talvolta questa trasformazione viene utilizzata talvolta al posto delle
      differenze per rimuovere gli effetti individuali da dati panel. Per assicurare
      la compatibilità con le differenze prime, le deviazioni sono memorizzate
      alla data successiva a quella che corrisponde alla loro effettiva collocazione
      temporale (in altre parole, il valore alla data 
      <math>t</math> è la deviazione che in realtà si riferisce alla data 
      <math>t</math> &minus; 1).  In questo modo viene  persa la prima osservazione di 
      ogni serie storica e non l'ultima.
      <seelist>
        <fncref targ="diff"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="pdf" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="char">c</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <examples>
	<example>f1 = pdf(N, -2.5)</example>
	<example>f2 = pdf(X, 3, y)</example>
	<example>f3 = pdf(W, shape, scale, y)</example>
      </examples>
      <description>
    <para>
      Calcola funzioni di densità o di probabilità. Restituisce la
      densità (se continue) o la probabilità (se discrete) in 
      <argname>x</argname> della distribuzione identificata dal
      carattere <argname>c</argname>.  Si veda <fncref targ="cdf"/>
      per dettagli sugli argomenti.  Le distribuzioni supportate
      dalla funzione <lit>pdf</lit> sono la normale,
      <math>t</math> di Student, chi-quadro, <math>F</math>,
      gamma, Weibull, Generalized Error, binomiale and Poisson. Si
      noti che per la binomiale e la Poisson ciò che viene
      calcolato è in effetti la probabilità nel punto specificato.
      Per la <math>t</math> di Student, la chi quadro e la 
      <math>F</math> tanche le varianti non centrali sono ammesse.
    </para>
    <para>
      Per la normale, si veda anche la funzione <fncref
      targ="dnorm"/>.
    </para>
      </description>
    </function>

    <function name="pergm" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg optional="true" type="scalar">bandwidth</fnarg>
      </fnargs>
      <description>
	<para>
	  Se viene fornito solo il primo argomento la funzione calcola 
	  il periodogramma campionario per la variabile o il vettore indicati. 
	  Se viene fornito anche il secondo argomento, la funzione calcola 
	  una stima dello spettro di <argname>x</argname> usando una finestra
	  di ritardi di Bartlett con la banda indicata, fino a un massimo pari alla 
	  metà delle osservazioni (<math>T</math>/2).
	</para>
	<para>
	  Restituisce una matrice con due colonne e <math>T</math>/2 righe:
	  la prima colonna contiene la frequenza, &omega;, da 2&pi;/<math>T</math>
	  a &pi;, ae la seconda la densità spettrale corrispondente.
	</para>
      </description>
    </function>

    <function name="pexpand" section="data-utils" output="series">
      <fnargs>
	<fnarg type="vector">v</fnarg>
      </fnargs>
      <description>
	<para>
	  Questa funzione può essere applicata solo se il dataset
	  corrente ha struttura panel.  Effettua l'operazione inversa
	  di <fncref targ="pshrink"/>. Vale a dire, dato un vettore di
	  lunghezza uguale al numero di individui nel campione panel
	  vigente, restituisce una serie in cui gni valore è ripetuto
	  <math>T</math> volte, dove <math>T</math> è la lunghezza
	  temporale del panel. La serie risultaante è, di conseguenza,
	  invariante nel tempo.
	</para>
      </description>
    </function>    

    <function name="pmax" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para>
	  Questa funzione può essere applicata solo se il dataset corrente
	  ha struttura panel. Restituisce una variabile contenente i massimi
	  della variabile 
	  <argname>y</argname> per ciascuna unità cross-section (ripetuti
	  per tutti i periodi temporali).
	</para>
	<para>
	  Se viene fornito il secondo argomento opzionale le osservazioni
	  per le quali il valore di <argname>mask</argname> è 0 vengono 
	  ignorate.
	</para>
	<para>
	  <seelist> 
	    <fncref targ="pmin"/>
	    <fncref targ="pmean"/>
	    <fncref targ="pnobs"/>
	    <fncref targ="psd"/>
	    <fncref targ="pxsum"/>
	    <fncref targ="pshrink"/>
	    <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pmean" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
    <para context="notex">
      Questa funzione è applicabile solo se il dataset corrente
      ha struttura panel. Calcola la media per ciascuna unità della 
      variabile 
      <argname>y</argname>; in altre parole, la somma delle osservazioni
      valide relative a ciascuna unità divisa per il loro numero.
    </para>
    <para context="tex">
      Questa funzione è applicabile solo se il dataset corrente ha
      struttura panel. Calcola la media per ciascuna unità della 
      variabile 
      <argname>y</argname>; in altre parole, 
      \[ \bar{y}_i = \frac{1}{T_i} \sum_{t=1}^{T_i} y_{i,t}\] 
      dove $T_i$ è il numero di osservazioni valide per l'unità $i$.
    </para>
    <para>
      Se viene indicato il secondo parametro opzionale le
      osservazioni corrispondenti a un valore nullo di <argname>mask</argname>
      sono ignorate.
    </para>
    <para>
      <seelist> 
        <fncref targ="pmax"/>
        <fncref targ="pmin"/>
        <fncref targ="pnobs"/>
        <fncref targ="psd"/>
        <fncref targ="pxsum"/>
        <fncref targ="pshrink"/>
        <fncref targ="psum"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="pmin" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para>
	  Questa funzione è applicabile solo se il dataset corrente ha
	  struttura panel. Restituisce una variabile contenente i minimi della 
	  variabile 
	  <argname>y</argname> per ciascuna unità della cross-section (replicati 
	  per ogni periodo temporale).
	</para>
	<para>
	  Se viene fornito il secondo argomento opzionale le osservazioni 
		corrispondenti a un valore nullo di <argname>mask</argname>
	  sono ignorate.
	</para>	
	<para>
	  <seelist> 
	    <fncref targ="pmax"/>
	    <fncref targ="pmean"/>
	    <fncref targ="pnobs"/>
	    <fncref targ="psd"/>
	    <fncref targ="pshrink"/>
	    <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pnobs" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para>
	  Questa funzione è applicabile solo se il dataset corrente ha
	  struttura panel. Restituisce una variabile contenente il numero
	  di osservazioni valide della variabile <argname>y</argname> per 
	  ciascuna unità della cross-section (replicato per ogni periodo
	  temporale).
	</para>
	<para>
	  Se viene fornito il secondo argomento opzionale le osservazioni 
		corrispondenti a un valore nullo di <argname>mask</argname>
	  sono ignorate.
	</para>
	<para>
	  <seelist> 
	    <fncref targ="pmax"/>
	    <fncref targ="pmin"/>
	    <fncref targ="pmean"/>
	    <fncref targ="psd"/>
	    <fncref targ="pshrink"/>
	    <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="polroots" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="vector">a</fnarg>
      </fnargs>
      <description>
    <para>
      Calcola le radici di un polinomio. Se il polinomio è
      di grado <math>p</math>, il vettore  <argname>a</argname> deve contenere 
      <math>p</math> + 1 coefficienti in ordine crescente, &ie; partendo 
      dalla costante e terminando con il coefficiente di 
      <math>x</math><sup>p</sup>.
    </para>
    <para>
      Se tutte le radici sono reali vengono restituite in un vettore colonna
      di lunghezza <math>p</math>; in caso contrario viene restituita una
      matrice <by r="p" c="2"/> con la parte reale delle radici nella prima colonna
      e la parte immaginaria nella seconda.
    </para>
      </description>
    </function>

    <function name="polyfit" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int">q</fnarg>
      </fnargs>
      <description>
	<para>
	  Interpola con il metodo dei polinomi ortogonali un trend
	  polinomiale di ordine <argname>q</argname> alla variabile <argname>y</argname> 
	  in input. La variabile contiene i valori interpolati.
	</para>
      </description>
    </function>

    <function name="princomp" section="stats" output="matrix">
      <fnargs>
    <fnarg type="matrix">X</fnarg>
    <fnarg type="int">p</fnarg>
    <fnarg optional="true" type="bool">covmat</fnarg>
      </fnargs>
      <description>
    <para>
      Data la matrice <argname>X</argname> di dimensioni <by r="T"
      c="k"/>, contenente <math>T</math> osservazioni su
      <math>k</math> variabili, e un intero positivo <argname>p</argname>
      inferiore o uguale a
      <math>k</math>, questa funzione restituisce una matrice <by
      r="T" c="p"/> <math>P</math>, contenente le prime
      <math>p</math> componenti principali di
      <argname>X</argname>.
    </para>
    <para>
      Il terzo parametro è opzionale e ha l'effetto di una condizione logica:
      se non nullo le componenti principali vengono calcolate
      sulla base della matrice di covarianza delle colonne di <argname>X</argname>
      (il default è usare la matrice di correlazione).
    </para>
    <para context="notex">
      Gli elementi di <math>P</math> sono calcolati come la somma
      da <math>i</math> a <math>k</math> di <math>Z</math><sub>ti</sub>
      per <math>v</math><sub>ji</sub>, dove
      <math>Z</math><sub>ti</sub> è il valore standardizzato della variabile 
      <math>i</math> all'osservazione <math>t</math> e 
      <math>v</math><sub>ji</sub> è l'autovettore <math>j</math> della
      matrice di correlazione (o covarianza) delle <math>X</math><sub>i</sub>, 
      con autovettori ordinati in ordine decrescente degli autovalori
      corrispondenti.
    </para>
    <para context="tex">
      Gli elementi di $P$ sono calcolati come 
      \[ P_{tj} = \sum_{i=1}^{k} Z_{ti} \, v^{(j)}_i \] 
      dove $Z_{ti}$ è il valore standardizzato della variabile 
      $i$ all'osservazione $t$, $Z_{ti} = (X_{ti} -
      \bar{X}_i) / \hat{\sigma}_i$, e $v^{(j)}$ è l'autovettore $j$
      della matrice di correlazione (o covarianza) delle 
      $X_i$, con autovettori ordinati in senso decrescente 
      degli autovalori corrispondenti.
    </para> 
    <para>
      <seelist>
        <fncref targ="eigensym"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="prodc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il prodotto degli elementi di <argname>X</argname>,
	  per colonna.
	  <seelist>
	    <fncref targ="prodr"/>
	    <fncref targ="meanc"/>
	    <fncref targ="sdc"/>
	    <fncref targ="sumc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="prodr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il prodotto degli elementi di <argname>X</argname>,
	  per riga.
	  <seelist>
	    <fncref targ="prodc"/>
	    <fncref targ="meanr"/>
	    <fncref targ="sumr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="psd" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
    <para context="notex">
      Questa funzione è applicabile solo se il dataset corrente ha
      struttura panel. Restituisce una variabile contenente la
      deviazione standard campionaria della variabile <math>y</math>
      per ciascuna unità della cross-section (con valori ripetuti per
      ciascuna data). Il denominatore utilizzato è la numerosità
      campionaria per ciascuna unità meno 1, a meno che il numero di
      osservazioni valide per l'unità in questione sia 1 (nel qual
      caso viene restituito uno zero) o 0 (nel qual caso viene
      <lit>NA</lit>).
    </para>
    <para context="tex">
      Questa funzione è applicabile solo se il dataset corrente ha
      struttura panel. Calcola la deviazione standard campionaria per
      ciascuna unità della cross-section della variabile
      <math>y</math>; in altre parole, \[ \sigma_i =
      \sqrt{\frac{1}{T_i - 1} \sum_{t=1}^{T_i} (y_{i,t} - \bar{y}_i)^2
      } \]. La formula precedente vale per $T_i\ge 2$, dove $T_i$ è il
      numero di osservazioni valide per l'unità $i$; se $T_i = 0$, la
      funzione restituisce <lit>NA</lit>; se $T_i = 1$, la funzione
      restituisce 0.
    </para>
    <para>
      Se viene fornito il secondo argomento opzionale le osservazioni 
        corrispondenti a un valore nullo di <argname>mask</argname>
      sono ignorate.
    </para>
    <para>
      Nota: questa funzione rende possibile controllare se 
      una certa variabile (per esempio <lit>X</lit>) è costante nel tempo usando la condizione
      <lit>max(psd(X)) = 0</lit>.
    </para>
    <para>
      <seelist>
        <fncref targ="pmax"/>
        <fncref targ="pmin"/>
        <fncref targ="pmean"/>
        <fncref targ="pnobs"/>
        <fncref targ="pshrink"/>
        <fncref targ="psum"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="psdroot" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="symmat">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola una variante generalizzata della scomposizione di
	  Cholesky della matrice <argname>A</argname>, che deve essere
	  semidefinita positiva (ma può essere singolare). Se la
	  matrice in input non è quadrata la funzione genera un
	  messaggio d'errore, ma la simmetria viene data per scontata,
	  e non viene verificata; la funzione legge solo il triangolo
	  inferiore di <argname>A</argname>.  Il risultato è una
	  matrice triangolare inferiore <math>L</math> che soddisfa la
	  condizione <equation status="inline" ascii="A = LL'" tex="$A
	  = LL'$"/>. Gli elementi indeterminati della soluzione
	  vengono posti pari a zero.
	</para>
	<para>
	  Nel caso in cui <argname>A</argname> sia definita positiva, v. 
	  <fncref targ="cholesky"/>.
	</para>
      </description>
    </function>

    <function name="pshrink" section="data-utils" output="matrix">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Questa funzione è applicabile solo se il dataset corrente ha
	  struttura panel. Restituisce un vettore colonna contenente
	  la prima osservazione valide della serie
	  <argname>y</argname> per ciascuna unità in cross-section del
	  panel all'interno dell'intervallo campionario corrente. Le
	  unità che non hanno nessuna osservazione valida per la serie
	  in input vengono ignorate.
	</para>
	<para>
	  Questa funzione permette di compattare le variabili
	  create da funzioni come <fncref targ="pmax"/> e
	  <fncref targ="pmean"/>, che replicano per tutti i periodi temporali
	  un valore relativo a ogni unità della cross-section.
	</para>
      </description>
    </function>

    <function name="psum" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Questa funzione è applicabile solo se il dataset corrente ha
	  struttura panel. Restituisce una variabile contenente la somma
	  rispetto al tempo della variabile <argname>y</argname> per ogni unità
	  della cross-section, replicando per tutti i periodi i valori così ottenuti.
	  Nel calcolo delle somme le osservazioni mancanti vengono ignorate.
	</para>
	<para context="tex">
	  Questa funzione è applicabile solo se il dataset corrente ha
	  struttura panel. Calcola la somma rispetto al tempo della
	  variabile <argname>y</argname> per ogni unità della cross-section;
	  in altre parole, 
	  \[ S_i = \sum_{t=1}^{T_i} y_{i,t}\] 
	  dove $T_i$ è il numero di osservazioni valide per l'unità $i$.
	</para>
	<para>
	  Se viene fornito il secondo argomento opzionale le osservazioni 
		corrispondenti a un valore nullo di <argname>mask</argname>
	  sono ignorate.
	</para>
	<para>
	  <seelist> 
	    <fncref targ="pmax"/>
	    <fncref targ="pmean"/>
	    <fncref targ="pmin"/>
	    <fncref targ="pnobs"/>
	    <fncref targ="psd"/>
	    <fncref targ="pxsum"/>
	    <fncref targ="pshrink"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pvalue" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="char">c</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs> 
      <examples>
	<example>p1 = pvalue(z, 2.2)</example>
	<example>p2 = pvalue(X, 3, 5.67)</example>
	<example>p2 = pvalue(F, 3, 30, 5.67)</example>
      </examples>
      <description>
    <para>
      Calcola un <math>P</math>-value. Restituisce 
      <equation status="inline" ascii="P(X > x)" tex="$P(X > x)$"/>,
      dove la distribuzione <math>X</math> è determinata dal carattere 
      <argname>c</argname>. Fra gli argomenti 
      <argname>c</argname> e <argname>x</argname> è necessario indicare 
      zero o più argomenti aggiuntivi per specificare i parametri della 
      distribuzione; v. <fncref targ="cdf"/> per ulteriori dettagli. 
      Le distribuzioni che la funzione <lit>pval</lit> può gestire sono 
      la normale standard, <math>t</math>, chi quadrato, <math>F</math>,
      gamma, binomiale, Poisson, Weibull e Generalized Error.
    </para>
    <para>
      <seelist>
        <fncref targ="critical"/>
        <fncref targ="invcdf"/>
        <fncref targ="urcpval"/>
        <fncref targ="imhof"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="pxnobs" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para>
	  Questa funzione è applicabile solo se il dataset corrente ha
	  struttura panel. Restituisce una variabile contenente il
	  numero di valori validi per <argname>y</argname> rispetto
	  alle unità della cross-section in ciascun periodo,
	  replicando i valori così ottenuti per ciascuna unità.
	</para>
	<para>
	  Se viene fornito il secondo argomento opzionale le osservazioni
	  per le quali il valore di <argname>mask</argname> è 0 vengono 
	  ignorate.
	</para>
	<para>
	  Si noti che questa funzione lavora lungo
	  una dimensione diversa da quella utilizzata dalla funzione 
	  <fncref targ="pnobs"/>.
	</para>
      </description>
    </function>    

    <function name="pxsum" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Questa funzione è applicabile solo se il dataset corrente ha
	  struttura panel. Restituisce una variabile contenente 
	  la somma dei valori di <argname>y</argname> rispetto alle unità della
	  cross-section in ciascun periodo, replicando i valori
	  così ottenuti per ciascuna unità.
	</para>
	<para context="tex">
	  Questa funzione è applicabile solo se il dataset corrente ha
	  struttura panel. Calcola la somma in cross-section della variabile
	  <argname>y</argname> in ciascun periodo; in altre parole, 
	  \[ \tilde{y}_t = \sum_{i=1}^{N} y_{i,t}\] 
	  dove $N$ è il numero di unità in cross-section.
	</para>
	<para>
	  Se viene fornito il secondo argomento opzionale le osservazioni 
		corrispondenti a un valore nullo di <argname>mask</argname>
	  sono ignorate.
	</para>
	<para>
	  Si noti che questa funzione lavora lungo
	  una dimensione diversa da quella utilizzata dalla funzione 
	  <fncref targ="pmean"/>.
	</para>
      </description>
    </function>

    <function name="qform" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">x</fnarg>
	<fnarg type="symmat">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Calcola la forma quadratica <equation status="inline"
	  ascii="Y = xAx'" tex="$Y = x A x'$"/>. L'uso di questa
	  funzione al posto della consueta moltiplicazione matriciale
	  garantisce maggiore velocità e accuratezza nel caso generico
	  in cui <argname>A</argname> sia una qualche matrice
	  simmetrica. Tuttavia, nel caso particolare in cui
	  <argname>A</argname> sia la matrice identità, la semplice
	  espressione <lit>x'x</lit> ha prestazioni molto migliori di
	  <lit>qform(x',I(rows(x))</lit>.
	</para>
	<para context="tex">
	  Calcola la forma quadratica <equation status="inline"
	  ascii="Y = xAx'" tex="$Y = x A x'$"/>. L'uso di questa
	  funzione al posto della consueta moltiplicazione matriciale
	  garantisce maggiore velocità e accuratezza nel caso generico
	  in cui <argname>A</argname> sia una qualche matrice
	  simmetrica. Tuttavia, nel caso particolare <equation
	  status="inline" ascii="A = I" tex="$A = I$"/>, la semplice
	  espressione <lit>x'x</lit> ha prestazioni molto migliori di
	  <lit>qform(x',I(rows(x))</lit>.
	</para>
	<para>
	  Se le dimensioni di <argname>x</argname> e
	  <argname>A</argname> non sono compatibili o se
	  <argname>A</argname> non è simmetrica viene restituito un
	  messaggio d'errore. </para>
      </description>
    </function>

    <function name="qlrpval" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="scalar">X2</fnarg>
	<fnarg type="int">df</fnarg>
	<fnarg type="scalar">p1</fnarg>
	<fnarg type="scalar">p2</fnarg>
      </fnargs>
      <description>
	<para>
	  <math>P</math>-values per la statistica test QLR
	  sup-Wald,usata per la ricerca di un break strutturale ad un
	  punto ignoto (vedi <cmdref targ="qlrtest"/>), secondo <cite
	  key="hansen97">Hansen (1997)</cite>.
	</para>
	<para>
	  Il primo argomento, <argname>X2</argname>, denota la
	  statistica del massimo Wald test (nella forma chi-quadro) e
	  <argname>df</argname> denota i suoi gradi di libertà. Gli
	  argomenti 3 e 4 rappresentano, come numeri fra 0 e 1, il
	  punto iniziale e finale del sottocampione centrale delle
	  osservazioni su cui la successione di test di Wald viene
	  calcolata. Ad esempio, se viene adottato l'usuale approccio
	  di partire dal 15 per cento e fermarsi all'85, si userebbero
	  0.15 per <argname>p1</argname> e 0.85 per
	  <argname>p2</argname>.
	</para>
	<para>
	  <seelist> 
            <fncref targ="pvalue"/>
	    <fncref targ="urcpval"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="qnorm" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce i quantili della normale standardizzata. Se
	  <argname>x</argname> non è fra 0 e 1, restituisce <lit>NA</lit>. 
	  <seelist>
	    <fncref targ="cnorm"/>
	    <fncref targ="dnorm"/>
	  </seelist>
	</para>
      </description>
    </function>  

    <function name="qrdecomp" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;R</fnarg>
      </fnargs>
      <description>
	<para>
	  Calcola la scomposizione QR di una matrice <by r="m" c="n"/>
	  <argname>X</argname>, in altre parole <math>X = QR</math>
	  dove <math>Q</math> è una matrice ortogonale <by r="m"
	  c="n"/> e <math>R</math> è una matrice triangolare superiore
	  <by r="n" c="n"/>. La matrice <math>Q</math> viene
	  restituita direttamente, mentre <math>R</math> può essere
	  recuperata usando il secondo argomento opzionale.
	</para>
	<para>
	  <seelist>
	    <fncref targ="eigengen"/>
	    <fncref targ="eigensym"/>
	    <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="quadtable" section="stats" output="matrix">
      <fnargs>
    <fnarg type="int">n</fnarg>
    <fnarg type="int" optional="true">type</fnarg>
    <fnarg type="scalar" optional="true">a</fnarg>
    <fnarg type="scalar" optional="true">b</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce una matrice <by r="n" c="2"/> da usare per la
      quadratura di Gauss (integrazione numerica). La prima
      colonna contiene i nodi o ascisse, la seconda colonna
      contiene i pesi.
    </para>
    <para>
      Il primo argomento specifica il numero dei punti (righe) da
      calcolare. Il secondo argomento specifica il codice del tipo
      di quadratura da utilizzare: 1 Gauss&ndash;Hermite
      (predefinita); 2 Gauss&ndash;Legendre; 3
      Gauss&ndash;Laguerre. Il significato dei parametri opzionali
      <argname>a</argname> e <argname>b</argname> dipende dal
      <argname>tipo</argname> selezionato, come spiegato sotto.
    </para>
    <para context="notex">
      La quadratura di Gauss è un metodo per l'approssimazione
      numerica di un integrale definito di una qualche funzione di
      interesse. Si rappresenti la funzione come il prodotto
      <math>f(x)W(x)</math>. I diversi tipi di quadratura
      differiscono nella specificazione della componente
      <math>W(x)</math>: nel caso di Hermite questa è uguale a
      exp(&minus;<math>x</math><sup>2</sup>); nel caso di
      Laguerre, è data da exp(&minus;<math>x</math>); infine, nel
      caso di Legendre, si ha semplicemente <math>W(x)</math> = 1.
    </para>
    <para context="tex">
      La quadratura di Gauss è un metodo di approssimazione
      numerica di un integrale definito di una qualche funzione di
      interesse. Si rappresenti la funzione come il prodotto
      $f(x)W(x)$. I diversi tipi di quadratura differiscono nella
      specificazione della componente $W(x)$: nel caso di Hermite
      abbiamo $W(x) = \exp(-x^2)$; nel caso di Laguerre, $W(x) =
      \exp(-x)$; nel caso di Legendre, semplicemente $W(x) = 1$.
    </para>
    <para context="notex">
      Per ciascuna specificazione di <math>W</math>, si può
      calcolare un insieme di nodi, <math>x</math><sub>i</sub>, e
      pesi, <math>w</math><sub>i</sub>, tali che la somma da
      <math>i</math>=1 a <math>n</math> di
      <math>w</math><sub>i</sub><math>f</math>(<math>x</math><sub>i</sub>)
      approssima l'integrale desiderato. Viene usato il metodo di
      <cite key="golub69">Golub and Welsch (1969)</cite>.
    </para>
    <para context="tex">
      Per ciascuna specificazione di $W(x)$, si può calcolare un
      insieme di nodi, $x_i$, e pesi, $w_i$, tali che
      $\sum_{i=1}^n f(x_i) w_i$ approssima l'integrale
      desiderato. È usato il metodo di <cite key="golub69">Golub
      and Welsch (1969)</cite>.
    </para>
    <para context="notex">
      Quando si seleziona il metodo di Gauss&ndash;Legendre, gli
      argomenti opzionali <argname>a</argname> e
      <argname>b</argname> possono essere utilizzati per
      controllare i limiti inferiore e superiore di
      integrazione; i valori predefiniti sono &minus;1 e
      1. (Nella quadratura di Hermite i limiti sono fissati a meno
      e più infinito, mentre in quella di Laguerre sono fissati a
      0 e infinito.)
    </para>
    <para context="tex">
      Quando si seleziona il metodo di Gauss&ndash;Legendre, gli
      argomenti opzionali <argname>a</argname> e
      <argname>b</argname> possono essere utilizzati per
      controllare i limiti, inferiore e superiore, di
      integrazione, i valori predefiniti sono $-1$ e 1. (Nella
      quadratura di Hermite i limiti sono fissati a $-\infty$ e
      $+\infty$, mentre in quella di Laguerre sono fissati a 0 e
      $\infty$.)
    </para>
    <para context="notex">
      Nella quadratura di Hermite <argname>a</argname> e
      <argname>b</argname> svolgono un ruolo differente: possono
      essere utilizzati per sostituire la forma predefinita di
      <math>W</math>(<math>x</math>) con la distribuzione normale
      (strettamente associata) con media <argname>a</argname> e
      deviazione standard <argname>b</argname>. Per esempio,
      fornire valori 0 e 1 per questi parametri ha l'effetto di
      trasformare <math>W</math>(<math>x</math>) nella funzione di
      densità di una normale standard, il che è equivalente a
      moltiplicare i nodi predefiniti per la radice quadrata di 2
      e dividere i pesi per la radice quadrata di &pi;.
    </para>
    <para context="tex">
      Nella quadratura di Hermite <argname>a</argname> e
      <argname>b</argname> svolgono un ruolo differente: possono
      essere utilizzati per sostituire la forma predefinita di
      $W(x)$ con la distribuzione normale (strettamente associata)
      con media <argname>a</argname> e deviazione standard
      <argname>b</argname>. Per esempio, fornire valori 0 e 1 per
      questi parametri ha l'effetto di trasformare $W(x)$ nella
      funzione di densità di una normale standard, il che è
      equivalente a moltiplicare i valori predefiniti $x_i$ per
      $\sqrt{2}$ e dividere i pesi $w_i$ predefiniti per
      $\sqrt{\pi}$.
    </para>
      </description>
    </function>    

    <function name="quantile" section="stats" output="scalar" altout="matrix">
      <fnargs>
	<fnarg type="series-or-mat">y</fnarg>
	<fnarg type="pscalar">p</fnarg>
      </fnargs>
      <description>
	<para>
	  Se <argname>y</argname> è una serie, restituisce il suo
	  <argname>p</argname>-esimo quantile. Ad esempio, se
	  <math>p</math> = 0.5, si avrà la mediana. 
	</para>
	<para>
	  Se l'argomento è invece una matrice, restituisce un vettore riga
	  contenente i <argname>p</argname>-esimi quantili per le
	  colonne di <argname>y</argname>; in pratica, ogni colonna è
	  trattata come se fosse una serie.
	</para>
	<para>
	  Inoltre, se <argname>y</argname> è una matrice, si può usare
	  una forma alternativa del secondo argomento:
	  <argname>p</argname> può essere un vettore. In tal caso, il
	  valore restituito è una matrice <by r="m" c="n"/>, dove
	  <repl>m</repl> è il numero di elementi in
	  <argname>p</argname> e <repl>n</repl> il numero di colonne
	  di <argname>y</argname>.
	</para>
	<para context="tex">
	  Per una serie di lunghezza $n$, il $p$-quantile, $q$, è
	  definito come: \[q = y_{[k]} + [(n+1) \cdot p - k] (y_{[k+1]} -
	  y_{[k]})\] dove $k$ è la parte intera di $(n+1) \cdot p$ e
	  $y_{[i]}$ è l'elemento $i$-esimo della serie ordinata in
	  senso crescente.
	</para>
      </description>
    </function>

    <function name="randgen" section="probdist" output="series">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="scalar-or-series">p1</fnarg>
	<fnarg type="scalar-or-series" conditional="true">p2</fnarg>
	<fnarg type="scalar" conditional="true">p3</fnarg>
      </fnargs>
      <examples>
	<example>series x = randgen(u, 0, 100)</example>
	<example>series t14 = randgen(t, 14)</example>
	<example>series y = randgen(B, 0.6, 30)</example>
	<example>series g = randgen(G, 1, 1)</example>
	<example>series P = randgen(P, mu)</example>
      </examples>
      <description>
    <para>
      Generatore di numeri casuali. L'argomento
      <argname>d</argname> è una stringa (nella maggior parte dei
      casi semplicemente un singolo carattere) che specifica la
      distribuzione da cui i numeri pseudo-casuali sono
      generati. Gli argomenti da <argname>p1</argname> a
      <argname>p3</argname> specificano i parametri della
      distribuzione selezionata. Il numero di tali parametri
      dipende dalla distribuzione. Per le distribuzioni diverse
      dalla beta-binomiale, i parametri <argname>p1</argname> e
      (se applicabile) <argname>p2</argname> devono essere scalari
      o variabili: se sono scalari, la serie generata è identicamente
      distribuita; se al contrario almeno uno dei due parametri in
      ingresso è una serie, per ciascuna osservazione la
      distribuzione è condizionata al valore dei parametri
      corrispondenti. Nel caso della beta-binomiale tutti i
      parametri devono essere scalari.
    </para>
    <para>
      Le specifiche sono fornite sotto: il codice stringa per ogni
      distribuzione è mostrato fra parentesi, seguito
      dall'interpretazione dell'argomento <argname>p1</argname> e,
      ove applicabile, <argname>p2</argname> e
      <argname>p3</argname>.
    </para>
      
    <ilist context="notex">
      <li>
        <para>
          Uniforme (continua) (u o U): minimo, massimo
        </para>
      </li>
      <li>
        <para>
          Uniforme (discreta) (i): minimo, massimo
        </para>
      </li>
      <li>
        <para>
          Normale (z, n, o N): media, deviazione standard
        </para>
      </li>
      <li>
        <para>
          t di Student (t): gradi di libertà
        </para>
      </li>
      <li>
        <para>
          Chi quadro (c, x, o X): gradi di libertà
        </para>
      </li>
      <li>
        <para>
          F di Snedecor (f o F): gradi di libertà (num.), gradi di libertà (den.)
        </para>
      </li>
      <li>
        <para>
          Gamma (g o G): forma, scala
        </para>
      </li>   
      <li>
        <para>
          Binomiale (b o B): probabilità, numero di prove
        </para>
      </li>   
      <li>
        <para>
          Poisson (p o P): media
        </para>
      </li> 
      <li>
        <para>
          Weibull (w o W): forma, scala
        </para>
      </li> 
      <li>
        <para>
          Generalized Error (E): forma
        </para>
      </li>
      <li>
        <para>
          Beta (beta): forma1, forma2
        </para>
      </li>
      <li>
        <para>
          Beta-Binomiale (bb): prove, forma1, forma2
        </para>
      </li>
    </ilist>
    <para context="tex">
      \begin{center}
      \begin{tabular}{lllll}
      \textbf{Distribuzione} &amp; \textsl{d} &amp; \textsl{p1} &amp; \textsl{p2} &amp; \textsl{p3}\\[4pt]
      Uniforme (continua) &amp; \texttt{u} o \texttt{U} &amp; minimo &amp; massimo &amp; --\\
      Uniforme (discreta) &amp; \texttt{i} &amp; minimo &amp; massimo &amp; --\\
      Normale &amp; \texttt{z}, \texttt{n} o \texttt{N} &amp; media &amp; deviazione standard &amp; --\\
      $t$ di Student &amp; \texttt{t} &amp; gradi di libertà &amp; -- &amp; --\\
      Chi quadro &amp; \texttt{c}, \texttt{x} o \texttt{X} &amp; gradi di libertà &amp; -- &amp; --\\
      $F$ di Snedecor &amp; \texttt{f} o \texttt{F} &amp; gradi di libertà (num.) &amp; gradi di libertà (den.) &amp; --\\
      Gamma &amp; \texttt{g} o \texttt{G} &amp; forma &amp; scala &amp; --\\
      Binomiale &amp; \texttt{b} o \texttt{B} &amp; $p$ &amp; $n$  &amp; --\\
      Poisson &amp; \texttt{p} o \texttt{P} &amp; media &amp; --  &amp; --\\
      Weibull &amp; \texttt{w} o \texttt{W} &amp; forma &amp; scala &amp; --\\
      Generalized Error &amp; \texttt{e} o \texttt{E} &amp; forma &amp; -- &amp; --\\
      Beta &amp; \texttt{beta} &amp; forma1 &amp; forma1 &amp; --\\
      Beta-Binomiale &amp; \texttt{bb} &amp; $n$ &amp; forma1 &amp; forma1
      \end{tabular}
      \end{center}
    </para>
    <para>
      <seelist>
        <fncref targ="normal"/>
        <fncref targ="uniform"/> 
        <fncref targ="mrandgen"/>
        <fncref targ="randgen1"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="randgen1" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="char">d</fnarg>
	<fnarg type="scalar">p1</fnarg>
	<fnarg type="scalar" conditional="true">p2</fnarg>
      </fnargs>
      <examples>
	<example>scalar x = randgen1(z, 0, 1)</example>
	<example>scalar g = randgen1(g, 3, 2.5)</example>
      </examples>
      <description>
    <para>
      Funziona come <fncref targ="randgen"/> eccetto per il fatto
      che il valore restituito è uno scalare invece di una variabile.
    </para>
    <para>
      Il primo esempio sopra restituisce un valore da una
      distribuzione normale standard, mentre il secondo
      restituisce un valore generato da una distribuzione Gamma
      con parametro di forma 3 e parametro di scala 2.5.
    </para>
    <para>
      <seelist>
        <fncref targ="mrandgen"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="randint" section="probdist" output="int">
      <fnargs>
	<fnarg type="int">min</fnarg>
	<fnarg type="int">max</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce un numero pseudo-casuale intero nell'intervallo
      chiuso [<argname>min</argname>, <argname>max</argname>].
      <seelist>
      <fncref targ="randgen"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="rank" section="linalg" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce il rango di <argname>X</argname>, calcolato 
      numericamente mediante la scomposizione a valori
      singolari (SVD).
      <seelist> 
        <fncref targ="svd"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="ranking" section="stats" output="asinput">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce una variabile o un vettore con i ranghi di <math>y</math>. Il
      rango di un'osservazione <math>i</math> è pari al numero di
      elementi della variabile minori di <math>y</math><sub>i</sub>
      più metà del numero di elementi della serie uguali a
      <math>y</math><sub>i</sub>. (Intuitivamente, è possibile
      pensare al punteggio negli scacchi, dove per ogni vittoria
      si assegna un punto mentre per ogni patta si assegna mezzo
      punto.) Al numero così calcolato si aggiunge uno, cosicché
      al rango più basso è associato 1 invece di 0.
    </para>
    <para context="tex">
      In termini formali, 
      \[ \mathrm{rank}(y_i) = 1 + \sum_{j \ne i} \left[ 
      I(y_j &lt; y_i) + 0.5 \cdot I(y_j = y_i) \right] \] 
      dove $I$ è la funzione indicatrice.
    </para>
    <para>
      <seelist>
        <fncref targ="sort"/>
        <fncref targ="sortby"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="rcond" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce il reciproco del numero di condizionamento
      di <argname>A</argname> rispetto alla norma-1. In molte circostanze,
      questa grandezza è migliore del determinante come misura di 
      sensibilità di <argname>A</argname> a operazioni numeriche
      come l'inversione.
    </para>
    <para context="notex">
      Il valore è calcolato come il reciproco del prodotto della
      norma-1 di <argname>A</argname> per la norma-1 dell'inversa
      di <argname>A</argname>.
    </para>
    <para context="tex">
      Poiché <math>A</math> è invertibile, è possibile definire 
      \[\kappa(A) = ||A||_1 \cdot ||A^{-1}||_1\] 
      Questa funzione restituisce $\kappa(A)^{-1}$.
    </para>
    <para>
      <seelist>
        <fncref targ="det"/>
        <fncref targ="ldet"/>
        <fncref targ="onenorm"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="readfile" section="strings" output="string">
      <fnargs>
	<fnarg type="string">fname</fnarg>
	<fnarg type="string" optional="true">codeset</fnarg>
      </fnargs>    
      <description>
    <para>
      Se un file di nome <argname>fname</argname> esiste ed è
      leggibile, restituisce una stringa con il contenuto del
      file. In caso contrario restituisce un errore.
    </para>
    <para>
      Nel caso in cui <argname>fname</argname> inizia con
      l'identificatore di un protocollo internet supportato
      (<lit>http://</lit>, <lit>ftp://</lit>,
      <lit>https://</lit>), la funzione richiama libcurl per
      scaricare la risorsa.
    </para>
    <para>
      Se il testo da leggere non ha una codifica UTF-8, gretl
      cerca di ricodificarlo a partire dalla codifica locale, nel
      caso non sia UTF-8, o da ISO-8859-15 in caso contrario. Se
      questo comportamento predefinito non si adatta alle vostre
      esigenze è possibile utilizzare il secondo argomento
      opzionale per specificare la codifica. Per esempio, nel caso
      si desideri leggere un testo nella codifica Microsoft codepage
      1251, diversa dal sistema in uso in locale, è
      possibile fornire come secondo argomento
      <lit>"cp1251"</lit>.
    </para>
    <para>
      Esempi:
    </para>
    <code>
      string web_page = readfile("http://gretl.sourceforge.net/")
      print web_page
        
      string current_settings = readfile("@dotdir/.gretl2rc")
      print current_settings
    </code>
    <para>
      Si vedano anche le funzioni <fncref targ="sscanf"/> e
      <fncref targ="getline"/>.
    </para>
      </description>
    </function>

    <function name="regsub" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg type="string">match</fnarg>
	<fnarg type="string">repl</fnarg>
      </fnargs>  
      <description>
	<para>
	  Restituisce una copia di <argname>s</argname> in cui tutte
	  le occorrenze del tipo <argname>match</argname> sono
	  sostituite con <argname>repl</argname>. Gli argomenti
	  <argname>match</argname> e <argname>repl</argname> sono
	  interpretati come espressioni regolari in stile Perl.
	</para>
	<para>
	  Si veda anche <fncref targ="strsub"/> per semplici
	  sostituzioni di stringhe letterali.
	</para>
      </description>
    </function>

    <function name="remove" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">fname</fnarg>
      </fnargs>    
      <description>
	<para>
	  Se il file <argname>fname</argname> esiste e l'utente ha i
	  permessi di scrittura, lo cancella. Restituisce 0 se il comando
	  è andato a buon fine, non-zero se il file non esiste o non
	  può essere cancellato.
	</para>
      </description>
    </function>

    <function name="replace" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
	<fnarg type="scalar-or-vec">find</fnarg>
	<fnarg type="scalar-or-vec">subst</fnarg>
      </fnargs>    
      <description>
	<para>
	  Sostituisce ogni elemento di <argname>x</argname> uguale
	  all'<math>i</math>-esimo elemento di <argname>find</argname>
	  con il corrispondente elemento di <argname>subst</argname>.
	</para>
	<para>
	  Se <argname>find</argname> è uno scalare, anche
	  <argname>subst</argname> deve essere uno scalare. Se
	  <argname>find</argname> e <argname>subst</argname> sono
	  entrambi vettori, devono avere lo stesso numero di
	  elementi. Se infine <argname>find</argname> è un vettore e
	  <argname>subst</argname> uno scalare, tutte le
	  corrispondenze saranno sostituite con
	  <argname>subst</argname>.
	</para>
	<para>
	  Esempio:
	</para>
	<code>
	  a = {1,2,3;3,4,5}
	  find = {1,3,4}
	  subst = {-1,-8, 0}
	  b = replace(a, find, subst)
	  print a b
	</code>
	<para>
	  genera
	</para>
	<code>
          a (2 x 3)
           
            1   2   3 
            3   4   5 
           
          b (2 x 3)
           
            -1    2   -8 
            -8    0    5 
	</code>
      </description>
    </function>

    <function name="resample" section="stats" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
	<fnarg optional="true" type="int">b</fnarg>
      </fnargs>    
      <description>
    <para>
      Ricampiona da <argname>x</argname> con reintroduzione. Nel
      caso in cui l'argomento sia una variabile, ciascun valore della
      variabile restituita, <math>y</math><sub>t</sub>, è estratto da
      tutti i valori di <math>x</math><sub>t</sub> con uguale
      probabilità. Quando l'argomento è una matrice, ciascuna riga
      della matrice restituita è estratta dalle righe di
      <argname>x</argname> con uguale probabilità.
    </para>
    <para>
      L'argomento opzionale <argname>b</argname>, che deve essere
      un numero intero maggiore o uguale a 2, indica la lunghezza
      del blocco nel ricampionamento a blocchi mobili (moving
      blocks). L'effetto è che l'output generato è il risultato di
      un'estrazione casuale con reintroduzione dall'insieme di
      tutte le possibili sequenze contigue di lunghezza
      <argname>b</argname> nell'input. (Nel caso l'input sia una
      matrice, i blocchi estratti sono sequenze contigue di righe
      della matrice.) Se la lunghezza dei dati non è un multiplo
      della lunghezza del blocco, l'ultimo blocco estratto è
      troncato per adattarlo.
    </para>
      </description>
    </function>

    <function name="round" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Approssima all'intero più vicino. Si noti che, quando
	  <math>x</math> si trova esattamente nel mezzo tra due numeri
	  interi, la funzione restituisce l'intero più distante da
	  zero. Così, per esempio, 2.5 è approssimato a 3, ma
	  <lit>round(-3.5)</lit> restituisce &minus;4. Questa è la
	  convenzione di solito seguita nei fogli di calcolo, anche se
	  altri programmi possono seguire convenzioni diverse.
	  <seelist>
	    <fncref targ="ceil"/>
	    <fncref targ="floor"/>
	    <fncref targ="int"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="rownames" section="matbuild" output="int">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="list-or-string">s</fnarg>
      </fnargs>
      <description>
    <para>
      Attribuisce dei nomi alle righe della matrice
      <argname>M</argname> di dimensioni <by r="m" c="n"/>. 
      Se <argname>s</argname> è una lista, i
      nomi sono copiati da quelli delle variabili; la lista deve
      avere tanti elementi quante sono le righe di
      <argname>M</argname>. Se <argname>s</argname> è una stringa,
      deve contenere un numero appropriato di sub-stringhe
      separate da spazi.  Restituisce 0 se la funzione è andata a
      buon fine, non-zero altrimenti. Si veda anche <fncref
      targ="colnames"/>.
    </para>
    <para>
      Esempio:
    </para>
    <code>
      matrix M = {1,2;2,1;4,1} 
      rownames(M, "Row1 Row2 Row3")
      print M      
    </code>
	  </description>
    </function>

    <function name="rows" section="matshape" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il numero di righe della matrice
	  <argname>X</argname>.
	  <seelist>
	    <fncref targ="cols"/>
	    <fncref targ="mshape"/>
	    <fncref targ="unvech"/> 
	    <fncref targ="vec"/>
	    <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sd" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
      </fnargs>     
      <description>
    <para>
      Se <argname>x</argname> è una variabile, restituisce l'errore
      quadratico medio campionario (scalare) saltando i valori
      mancanti.
    </para>
    <para>
      Se, invece, <argname>x</argname> è una lista, restituisce
      una variabile <math>y</math> tale per cui
      <math>y</math><sub>t</sub> è l'errore quadratico medio delle
      variabili nella lista all'osservazione <math>t</math>, o
      <lit>NA</lit> se ci sono dei valori mancanti <math>t</math>.
    </para>
    <para>
      <seelist> 
        <fncref targ="var"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="sdc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="scalar" optional="true">df</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce le deviazioni standard delle colonne di
      <argname>X</argname>. Se <argname>df</argname> è positivo, è
      utilizzato come divisore nel calcolo delle varianze delle
      colonne, in caso contrario il divisore utilizzato è il
      numero di righe di <argname>X</argname> (in altre parole non viene
      applicata nessuna correzione per i gradi di libertà).
      <seelist>
        <fncref targ="meanc"/>
        <fncref targ="sumc"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="sdiff" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-or-list">y</fnarg>
      </fnargs>   
      <description>
    <para>
      Calcola le differenze stagionali: <equation status="inline"
      ascii="y(t) - y(t-k)" tex="$y_t - y_{t-k}$"/>, dove
      <math>k</math> è la periodicità del dataset corrente (si
      veda <fncref targ="$pd"/>). I valori iniziali sono fissati a
      <lit>NA</lit>.
    </para>
    <para> 
      Quando viene restituita una lista alle singole variabili viene
      automaticamente assegnato un nome secondo il formato
      <lit>sd_</lit><repl>varname</repl>, dove <repl>varname</repl> è
      il nome della variabile originaria. Se necessaril il nome viene
      troncato e può essere modificato in caso di non unicità
      all'interno dell'insieme di nomi costruiti in questo modo.
    </para> 
    <para>
      <seelist> 
        <fncref targ="diff"/>
        <fncref targ="ldiff"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="seasonals" section="data-utils" output="list">
      <fnargs>
	<fnarg optional="true" type="int">baseline</fnarg>
	<fnarg optional="true" type="bool">center</fnarg>
      </fnargs>     
      <description>
	<para>
	  Questa funzione è applicabile solo se il dataset corrente è
	  di tipo temporale ed ha una periodicità maggiore di
	  1. ritorna una lista di variabili dummy per i sottoperiodi,
	  chiamate <lit>S1</lit>, <lit>S2</lit> eccetera.
	</para>
	<para>
	  L'argomento <argname>baseline</argname> (opzionale) serve ad
	  escludere un sottoperiodo. Ad esempio, con
	  <argname>baseline</argname> uguale ad 1 e dati trimestrali
	  la lista risultato conterrà dummy per il 2°, 3° e 4°
	  trimestre.  Se questo argomento è zero o omesso, verrò
	  creata l'intera lista; se non-zero, dev'essere un intero
	  compreso fra 1 e la periodicità dei dati.
	</para>
	<para>
	  L'argomento <argname>center</argname>, se non-zero, fa sì
	  che vengano generate dummy centrate. Per esempio, con dati
	  trimestrali le dummy centrate assumono valori di &minus;0,25
	  e 0,75 anziché 0 e 1.
	</para>
      </description>
    </function>    

    <function name="selifc" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="rvec">b</fnarg>
      </fnargs>   
      <description>
    <para>
      Seleziona da <argname>A</argname> solo le colonne per le
      quali l'elemento corrispondente di <argname>b</argname> è
      non nullo. <argname>b</argname> deve essere un vettore riga
      con lo stesso numero di colonne di <argname>A</argname>.
    </para>
    <para>
      <seelist>
        <fncref targ="selifr"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="selifr" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="cvec">b</fnarg>
      </fnargs>   
      <description>
    <para>
      Seleziona da <argname>A</argname> solo le righe per le quali
      l'elemento corrispondente di <argname>b</argname> è
      non nullo. <argname>b</argname> deve essere un vettore
      colonna con lo stesso numero di righe di
      <argname>A</argname>.
    </para>
    <para>
      <seelist>
        <fncref targ="selifc"/>
        <fncref targ="trimr"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="seq" section="matbuild" output="rvec">
      <fnargs>
	<fnarg type="int">a</fnarg>
	<fnarg type="int">b</fnarg>
	<fnarg optional="true" type="int">k</fnarg>
      </fnargs>   
      <description>
    <para>
      Con due soli argomenti, restituisce un vettore riga di
      interi consecutivi, con <argname>a</argname> come primo
      elemento e <argname>b</argname> come ultimo. Se
      <argname>a</argname> è maggiore di <argname>b</argname>, la
      sequenza sarà decrescente. L'eventuale parte non intera
      viene ignorata per entrambi gli argomenti.
    </para>
    <para>
      In caso sia presente il terzo argomento, la funzione
      restituisce un vettore riga contenente una sequenza di
      interi che inizia con <argname>a</argname> e in
      ciascun passaggio è incrementata
      (o diminuita, nel caso in cui <argname>a</argname> sia
      maggiore di <argname>b</argname>) di <argname>k</argname>. 
      Il valore finale è il più grande elemento
      della sequenza minore o uguale a <argname>b</argname> (o
      mutatis mutandis, nel caso in cui <argname>a</argname> sia
      maggiore di <argname>b</argname>). L'argomento
      <argname>k</argname> deve essere positivo; nel caso non sia
      un intero la parte decimale è ignorata.
    </para>
    <para>
      <seelist>
        <fncref targ="ones"/>
        <fncref targ="zeros"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="setnote" section="data-utils" output="int">
      <fnargs>
	<fnarg type="bundle">b</fnarg>
	<fnarg type="string">key</fnarg>
	<fnarg type="string">note</fnarg>
      </fnargs>   
      <description>
    <para>
      Imposta una nota descrittiva per l'oggetto identificato
      dalla chiave <argname>key</argname> nel bundle
      <argname>b</argname>.  Essa verrà mostrata quando il comando
      <lit>print</lit> viene applicato al bundle. Questa funzione
      restituisce 0 se è andata a buon fine e non nullo in caso
      contrario (ad esempio, se nel bundle <argname>b</argname> non esiste un
      oggetto associato alla chiave <argname>key</argname>).
    </para>
      </description>
    </function>    

    <function name="simann" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="vector">b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="int" optional="true">maxit</fnarg>
      </fnargs>
      <description>
	<para>
	  Implementa il simulated annealing (letteralmente "ricottura
	  simulata", che prende il nome dal processo di ricottura
	  utilizzato per migliorare le caratteristiche delle leghe
	  metalliche), che può essere utile nel migliorare
	  l'inizializzazione nei problemi di ottimizzazione numerica.
	</para>
	<para>
	  Il primo argomento deve contenere il valore iniziale di un
	  vettore di parametri. Il secondo argomento specifica la
	  funzione da chiamare che restituisce il valore (scalare)
	  da massimizzare. Il terzo argomento, opzionale, specifica il
	  massimo numero di iterazioni (il valore predefinito è
	  1024). In caso di successo, <lit>simann</lit> restituisce il
	  valore finale del massimando.
	</para>
	<para>
	  Per maggiori dettagli ed esempi si veda il capitolo sui
	  metodi numerici in <guideref targ="chap:numerical"/>.
	  <seelist>
	    <fncref targ="BFGSmax"/>
	    <fncref targ="NRmax"/>
	  </seelist>
	</para>

      </description>
    </function>

    <function name="sin" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>       
      <description>
    <para>
      Funzione seno di <argname>x</argname>. 
      <seelist>
        <fncref targ="cos"/>
        <fncref targ="tan"/>
        <fncref targ="atan"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="sinh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce il seno iperbolico di <argname>x</argname>.
	</para>
	<para context="tex">
	  \[ \sinh x = \frac{e^x - e^{-x}}{2}  \]
	</para>
	<para>
	  <seelist>
	    <fncref targ="asinh"/>
	    <fncref targ="cosh"/>
	    <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="skewness" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
    <para>
      Restituisce il valore dell'indice di asimmetria per la serie
      <argname>x</argname>, non considerando le osservazioni
      mancanti.
    </para>
      </description>
    </function>

    <function name="sort" section="matshape" output="asinput">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>     
      <description>
    <para>
      Ordina <argname>x</argname> in senso crescente, non
      considerando le osservazioni mancanti nel caso in cui
      <math>x</math> sia una variabile.
      <seelist>
        <fncref targ="dsort"/>
        <fncref targ="values"/>
      </seelist>
      In particolare, per le matrici si veda <fncref targ="msortby"/>.
    </para>
      </description>
    </function>

    <function name="sortby" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y1</fnarg>
	<fnarg type="series">y2</fnarg>
      </fnargs>     
      <description>
    <para>
      Restituisce una variabile contenente gli elementi di
      <argname>y2</argname> ordinati per valore crescente del
      primo argomento, <argname>y1</argname>.
      <seelist>
        <fncref targ="sort"/>
        <fncref targ="ranking"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="sprintf" section="strings" output="string">
      <fnargs>
	<fnarg type="string">formato</fnarg>
	<fnarg type="varargs"/>
      </fnargs>     
      <description>
	<para>
	  Ritorna una stringa contenente la stampa dei valori degli
	  argomenti successivi, indicati dai puntini, sotto il
	  controllo della stringa <argname>formato</argname>. Per
	  maggiori dettagli, si veda l'help del comando <cmdref
	  targ="printf"/>.
	</para>
      </description>
    </function>

    <function name="square" section="transforms" output="list">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg optional="true" type="bool">cross-products</fnarg>
      </fnargs>     
      <description>
	<para>
	  Ritorna una lista contenente le variabili nella lista
	  <argname>L</argname> al quadrato, con nomi basati sul
	  modello <lit>sq_</lit><repl>varname</repl>.  Se il secondo
	  argomento (opzionale) è presente e ha valore non-zero,
	  vengono inclusi anche i prodotti incrociati delle variabili
	  in <argname>L</argname>; i nomi sono vasati sul modello
	  <repl>var1</repl><lit>_</lit><repl>var2</repl>.  I nomi
	  delle serie risultato potrebbero venir troncati se troppo
	  lunghi, e aggiustati per evitare duplicazioni.
	</para>
      </description>
    </function>    

    <function name="sqrt" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>     
      <description>
    <para>
      Radice quadrata di <argname>x</argname>; genera <lit>NA</lit> in
      caso di valori negativi.
    </para>
    <para>
      Si noti che se l'argomento è una matrice l'operazione viene
      effettuata elemento per elemento e dato che le matrici non
      possono contenere <lit>NA</lit>, eventuali valori negativi
      generano un errore. Per la <quote>radice quadrata
      matriciale</quote>, v. <fncref targ="cholesky"/>.
    </para>
      </description>
    </function>

    <function name="sscanf" section="strings" output="int">
      <fnargs>
	<fnarg type="string">src</fnarg>
	<fnarg type="string">format</fnarg>
	<fnarg type="varargs"/>
      </fnargs>  
      <description>
      <para>
        Legge valori da <argname>src</argname> seguendo il formato 
        <argname>format</argname> e assegna questi valori a uno o più degli 
        argomenti seguenti, rappresentati dai punti. Restituisce il numero di valori
        assegnati. Questa funzione rappresenta una versione semplificata della funzione 
        <lit>sscanf</lit> usata nel linguaggio di programmazione C.
      </para>
      <para>
        La <repl>stringa</repl> può essere una stringa vera e propria,
        racchiusa tra virgolette doppie, o il nome di una variabile stringa
        predefinita. <repl>format</repl> è definito in modo simile alla
        stringa di formato del comando <cmdref targ="printf"/> (si veda
        oltre). <repl>args</repl> è una lista separata da virgole
        che contiene i nomi di variabili predefinite cui verranno assegnati 
        i valori letti da <repl>src</repl>. (Per chi conosce
        C: è possibile ma non indispensabile prefissare con <lit>&amp;</lit> i nomi delle
        variabili numeriche).
      </para>
      <para>
        Le regole specificate in <repl>format</repl> vengono usate per
        analizzare <repl>src</repl>. Le specifiche iniziano con un
        carattere <lit>%</lit>, e comprendono
        <lit>%f</lit>, <lit>%g</lit> o <lit>%lf</lit> per i numeri a virgola
        mobile; <lit>%d</lit> per gli interi; <lit>%s</lit> per le stringhe, e
        <lit>%m</lit> per le matrici. È possibile inserire un numero intero
        positivo dopo il carattere percentuale per impostare il numero massimo di
        caratteri da leggere per ogni tipo di specifica (o il numero massimo di
        righe nel caso di conversione in matrici). In alternativa è possibile
        inserire un carattere <lit>*</lit> dopo il percentuale per sopprimere la
        conversione di un certo numero di caratteri della stringa (e saltando
        così eventuali caratteri che in caso contrario verrebbero convertiti
        per un certo tipo). Ad esempio,
        <lit>%3d</lit> converte i 3 caratteri successivi di <repl>src</repl>
        in un numero intero, se possibile; <lit>%*g</lit> salta tutti i caratteri
        in <repl>src</repl> che potrebbero essere convertiti in un numero
        a virgola mobile.
      </para>
      <para>
	La conversione in matrici funziona nel modo seguente: viene letta ogni
        riga dell'input e vengono contati i campi numerici (separati da spazi o
        tabulatori). In questo modo viene definito il numero di colonne della matrice.
        Vengono quindi lette tutte le righe seguenti che contengono lo stesso
        numero di colonne numeriche, ma è comunque possibile limitare il numero
        massimo di righe da leggere procedendo come descritto sopra.
      </para>
      <para>
        Oltre alla conversione di <lit>%s</lit> per le stringhe, è disponibile
        anche una versione semplificata del formato C
        <lit>%</lit><repl>N</repl><lit>[</lit><repl>chars</repl><lit>]</lit>.
        In questo formato, <repl>N</repl> è il numero massimo di caratteri da
        leggere, e <repl>chars</repl> è un insieme di caratteri accettabili,
        racchiusi tra parentesi quadre; la lettura si ferma se si raggiunge il
        limite di <repl>N</repl> o se si incontra un carattere non compreso
        nell'insieme ammissibile. La funzione dell'insieme
        <repl>chars</repl> può essere invertita specificando un accento
        circonflesso <lit>^</lit> come primo carattere dell'insieme; in questo
        caso, la lettura si ferma se si incontra un carattere dell'insieme
        specificato. Al contrario del C, il carattere trattino non ha alcuna
        funzione speciale in questo contesto.
      </para>
      <para>
	Se la stringa non corrisponde esattamente al formato specificato, il
        numero di conversioni effettuate può risultare diverso dal numero di
        argomenti indicati. Per gretl questo non è necessariamente un errore,
        tuttavia può essere utile controllare il numero di conversioni 
        effettuate, pari al valore restituito dalla funzione.
      </para>
      <para>
	Ecco alcuni esempi:
      </para>
	<code>
	  scalar x
	  scalar y
	  sscanf("123456", "%3d%3d", x, y)

	  sprintf S, "1 2 3 4\n5 6 7 8"
	  S
	  matrix m
	  sscanf(S, "%m", m)
	  print m
	</code>
      </description>
    </function>

    <function name="sst" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>  
      <description>
    <para>
      Restituisce la somma dei quadrati degli scarti dalla media per le
      osservazioni valide nella variabile <argname>y</argname>.
      <seelist> 
        <fncref targ="var"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="stringify" section="strings" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="strings">S</fnarg>
      </fnargs>  
      <description>
	<para>
	  Serve a definire valori di stringa per la serie
	  <argname>y</argname>. Affinché la cosa funzioni, ci sono due
	  condizioni: la serie risultante deve contenere solo interi
	  maggiori o uguali a 1, e l'array <argname>S</argname> deve
	  contenere almeno <math>n</math> elementi, dove
	  <math>n</math> è il massimo valore in <argname>y</argname>.
	  In più, ogni elemento di <argname>S</argname> deve contenere
	  caratteri validi secondo la codifica UTF-8.
	  <seelist> 
            <fncref targ="strvals"/>
	  </seelist>	  
	</para>
	<para>
	  Ritorna 0 se l'operazione ha avuto successo, o un codice di errore
	  positivo.
	</para>
      </description>
    </function>

    <function name="strlen" section="strings" output="int">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>  
      <description>
    <para>
      Restituisce il numero di caratteri nella stringa
      <argname>s</argname>. Si note che questo può non coincidere
      col numero di byte se sono presenti
      caratteri al di fuori del campo ASCII stampabile (ad
      esempio, lettere accentate).
    </para>
    <para>
        Esempio:
    </para>
    <code>
        string s = "regression"
        scalar number = strlen(s)
        print number
    </code>

      </description>
    </function>

    <function name="strncmp" section="strings" output="int">
      <fnargs>
	<fnarg type="string">s1</fnarg>
	<fnarg type="string">s2</fnarg>
	<fnarg optional="true" type="scalar">n</fnarg>
      </fnargs>  
      <description>
    <para>
      Confronta le due stringhe fornite come argomenti e restituisce
      un intero minore, uguale, o maggiore di zero se
      <argname>s1</argname> risulta rispettivamente essere
      minore, combaciare, o essere maggiore di
      <argname>s2</argname>, fino ai primi <argname>n</argname>
      caratteri.  Se <argname>n</argname> è omesso, il confronto 
      procede fin dove possibile.
    </para>
    <para> 
      Si noti che per verificare l'uguaglianza di due stringhe 
      non è necessaria alcuna funzione, come in <lit>if (s1
      == s2) ...</lit>
    </para>
      </description>
    </function>
    <function name="strsplit" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg type="int">i</fnarg>
      </fnargs>  
      <description>
    <para>
      Restituisce l'elemento <argname>i</argname>-esimo della stringa
      <argname>s</argname> separato da spazi. L'indice <argname>i</argname> è a base
      1 e la funzione genera un errore se <argname>i</argname> è
      minore di 1. Nel caso in cui <argname>s</argname> non
      contenga spazi e <argname>i</argname> sia uguale ad 1, la
      funzione restituisce una copia dell'intera stringa in
      ingresso; in caso contrario, se <argname>i</argname> è maggiore del 
      numero di elementi separati da spazio la funzione
      restituisce una stringa vuota.
    </para>
    <para>
        Esempi:
    </para>
    <code>
        string basket = "banana apple jackfruit orange"
        
        strings fruits = strsplit(basket)
        eval fruits[1]
        eval fruits[2]
        eval fruits[3]
        eval fruits[4]
        
        string favorite = strsplit(basket, 3)
        eval favorite
    </code>
      </description>
    </function>

    <function name="strstr" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s1</fnarg>
	<fnarg type="string">s2</fnarg>
      </fnargs>  
      <description>
    <para>
      Cerca all'interno della stringa <argname>s1</argname> un'occorrenza
      della stringa <argname>s2</argname>.  Nel caso venga trovata
      una corrispondenza la funzione restituisce una copia della
      porzione di <argname>s1</argname> che inizia con
      <argname>s2</argname>; in caso contrario, la funzione
      restituisce una stringa vuota.
    </para>
    <para>
      Esempi:
    </para>
    <code>
        string s1 = "Gretl is an econometrics package"
        string s2 = strstr(s1, "an")
        print s2
    </code>
      </description>
    </function>

    <function name="strstrip" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>  
      <description>
	<para>
	  Restituisce una copia dell'argomento <argname>s</argname> da
	  cui sono stati rimossi gli spazi bianchi iniziali e finali.
	</para>
	<para>
          Esempio:
	</para>
	<code>
          string s1 = "    A lot of white space.  "
          string s2 = strstrip(s1)
          print s1 s2
	</code>

      </description>
    </function>

    <function name="strsub" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg type="string">find</fnarg>
	<fnarg type="string">subst</fnarg>
      </fnargs>  
      <description>
    <para>
      Restituisce una copia di <argname>s</argname> in cui tutte
      le occorrenze di <argname>find</argname> sono sostituite con
      <argname>subst</argname>. V. anche <fncref targ="regsub"/> per 
      una funzione più complessa che permette di sostituire stringhe sulla
      base di espressioni regolari.
    </para>
    <para>
        Esempio:
    </para>
    <code>
        string s1 =  "Ciao, Gretl!"
        string s2 = strsub(s1, "Gretl", "Hansl")
        print s2
    </code>
      </description>
    </function>

    <function name="strvals" section="strings" output="strings">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>  
      <description>
	<para>
	  Se la serie <argname>y</argname> contiene stringhe,
	  restituisce un array contenente tutti i suoi valori
	  distinti, ordinati per il valore numerico associato,
	  partendo da 1. Se invece <argname>y</argname> non contiene
	  stringhe, viene restituito un array vuoto.
	  <seelist> 
            <fncref targ="stringify"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="substr" section="strings" output="string">
      <fnargs>
    <fnarg type="string">s</fnarg>
    <fnarg type="int">start</fnarg>
    <fnarg type="int">end</fnarg>
      </fnargs>  
      <description>
    <para>
      Restituisce la sottostringa di <argname>s</argname> dal
      carattere <argname>start</argname> al carattere
      <argname>end</argname> compresi. L'indicizzazione è a base
      1.
    </para>
	<para>
          Esempi:
	</para>
	<code>
          string s1 = "Ciao, Gretl!"
          string s2 = substr(s1, 7, 11)
          print s2
        
          string s3 = substr("Ciao, Gretl!", 7, 11)
          print s3
	</code>
      </description>
    </function>

    <function name="sum" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="smlist">x</fnarg>
      </fnargs>      
      <description>
    <para>
      Se <argname>x</argname> è una variabile restituisce la somma
      (scalare) delle osservazioni non mancanti in
      <argname>x</argname>. Si veda anche <fncref targ="sumall"/>.
    </para>
    <para>
      Se <argname>x</argname> è una matrice restituisce la somma
      degli elementi della matrice.
    </para> 
    <para>
      Se <argname>x</argname> è una lista, restituisce una variabile 
      <math>y</math> tale che <math>y</math><sub>t</sub> è la
      somma dei valori delle variabili nella lista
      all'osservazione <math>t</math>, o <lit>NA</lit> se ci sono
      valori mancanti all'osservazione <math>t</math>.
    </para>
      </description>
    </function>

    <function name="sumall" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>      
      <description>
	<para>
	  Restituisce la somma delle osservazioni di
	  <argname>x</argname> nel campione corrente, o <lit>NA</lit>
	  se ci sono valori mancanti.
	</para>
      </description>
    </function>

    <function name="sumc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>     
      <description>
	<para>
	  Restituisce le somme per colonna di <argname>X</argname>.
	  <seelist>
	    <fncref targ="meanc"/>
	    <fncref targ="sumr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sumr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>  
      <description>
	<para>
	  Restituisce le somme per riga di <argname>X</argname>.
	  <seelist> 
	    <fncref targ="meanr"/>
	    <fncref targ="sumc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="svd" section="linalg" output="rvec">
      <fnargs>
    <fnarg type="matrix">X</fnarg>
    <fnarg type="matrixref" optional="true">&amp;U</fnarg>
    <fnarg type="matrixref" optional="true">&amp;V</fnarg>
      </fnargs>
      <description>
    <para context="notex">
      Esegue la scomposizione a valori singolari (SVD) della
      matrice <argname>X</argname>.
    </para>
    <para context="tex">
      Esegue la scomposizione a valori singolari (SVD) della
      matrice $r \times c$ $X$:
      \[ X = U \left[
      \begin{array}{cccc} 
      \sigma_1 \\ 
      &amp; \sigma_2 \\ 
      &amp; &amp; \ddots \\ 
      &amp; &amp; &amp; \sigma_n ,
      \end{array}
      \right] V \] 
      dove $n = \min(r,c)$. $U$ è $r \times n$ e $V$ è $n \times c$, 
      con $U'U = I$ e $VV' = I$.
    </para>
    <para>
      I valori singolari sono restituiti in un vettore riga.  I
      vettori singolari sinistri e/o destri <math>U</math> e
      <math>V</math> possono essere ottenuti fornendo valori
      non nulli per, rispettivamente, gli argomenti 2 e 3. Per una
      matrice <lit>A</lit>, il codice
    </para>
    <code>
      s = svd(A, &amp;U, &amp;V) 
      B = (U .* s) * V
    </code>
    <para>
      dovrebbe generare <lit>B</lit> identica ad <lit>A</lit> 
      (precisione numerica a parte).
    </para>
    <para>
      <seelist>
        <fncref targ="eigengen"/>
        <fncref targ="eigensym"/>
        <fncref targ="qrdecomp"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="tan" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
    <para>
      Funzione tangente di <argname>x</argname>.
      <seelist>
        <fncref targ="atan"/>
        <fncref targ="cos"/>
        <fncref targ="sin"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="tanh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Restituisce la tangente iperbolica di <argname>x</argname>. 
	</para>
	<para context="tex">
	  \[ \tanh x = \frac{e^{2x} - 1}{e^{2x} + 1}  \]
	</para>
	<para>
	  <seelist>
	    <fncref targ="atanh"/>
	    <fncref targ="cosh"/>
	    <fncref targ="sinh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="toepsolv" section="linalg" output="cvec">
      <fnargs>
    <fnarg type="vector">c</fnarg>
    <fnarg type="vector">r</fnarg>
    <fnarg type="vector">b</fnarg>
      </fnargs>
      <description>
    <para>
      Risolve un sistema di Toeplitz di equazioni lineari, cioè
      <math>Tx = b</math> dove <math>T</math> è una matrice
      quadrata il cui elemento <math>T</math><sub>i,j</sub> è
      uguale a <math>c</math><sub>i-j</sub> per <equation
      status="inline" ascii="i&gt;=j" tex="$i\ge j$"/> e a
      <math>r</math><sub>j-i</sub> per <equation status="inline"
      ascii="i&lt;=j" tex="$i\le j$"/>. Si noti che i primi
      elementi di <math>c</math> e <math>r</math> devono essere
      uguali; in caso contrario la funzione restituisce un
      errore. In caso di successo, la funzione restituisce il
      vettore <math>x</math>.
    </para>
    <para>
      L'algoritmo usato sfrutta la speciale struttura della
      matrice <math>T</math>, che lo rende molto più efficiente di
      altri algoritmi meno specifici, specialmente per sistemi di
      grandi dimensioni. Attenzione: in certi casi, la funzione
      può restituire un errore di singolarità anche se la matrice
      <math>T</math> non è effettivamente singolare; questo
      problema tuttavia non si presenta quando <math>T</math> è
      definita positiva.
    </para>
      </description>
    </function>

    <function name="tolower" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>    
      <description>
	<para>
	  Restituisce una copia di <argname>s</argname> in cui ogni
	  lettera maiuscola è convertita in minuscola.
	</para>
	<para>
          Esempi:
	</para>
	<code>
          string s1 = "Ciao, Gretl!"
          string s2 = tolower(s1)
          print s2
          
          string s3 = tolower("Ciao, Gretl!")
          print s3
	</code>
      </description>
    </function>

    <function name="toupper" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>    
      <description>
	<para>
	  Restituisce una copia di <argname>s</argname> in cui ogni
	  lettera minuscola è convertita in maiuscola.
	</para>
	<para>
          Esempi:
	</para>
	<code>
          string s1 = "Ciao, Gretl!"
          string s2 = toupper(s1)
          print s2
          
          string s3 = toupper("Ciao, Gretl!")
          print s3
	</code>
      </description>
    </function>

    <function name="tr" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>    
      <description>
	<para>
	  Restituisce la traccia della matrice <argname>A</argname>,
	  ovvero la somma degli elementi lungo la diagonale.
	  <seelist> 
	    <fncref targ="diag"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="transp" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>      
      <description>
    <para>
      Trasposizione della matrice <argname>X</argname>. Si noti che per 
      ottenere la trasposta di una matrice nella maggior parte dei casi è
      possibile utilizzare l'operatore apice: <lit>X'</lit>.
    </para>
      </description>
    </function>

    <function name="trimr" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">ttop</fnarg>
	<fnarg type="int">tbot</fnarg>
      </fnargs>   
      <description>
	<para>
	  Restituisce una matrice che è una copia di
	  <argname>X</argname> con <argname>ttop</argname> righe
	  eliminate partendo dall'alto e <argname>tbot</argname> righe
	  eliminate partendo dal basso. Gli ultimi due argomenti
	  devono essere non-negativi e la somma dei due deve essere
	  minore del numero totale di righe di <argname>X</argname>.
	</para>
	<para>
	  <seelist>
	    <fncref targ="selifr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="typestr" section="data-utils" output="string">
      <fnargs>
	<fnarg type="int">typecode</fnarg>
      </fnargs>      
      <description>
	<para>
	  Restituisce il nome del tipo di dati di gretl corrispondente
	  a <argname>typecode</argname>. È utilizzata insieme alla
	  funzione <fncref targ="inbundle"/>. Il valore restituito è:
	  <quote>scalar</quote>, <quote>series</quote>,
	  <quote>matrix</quote>, <quote>string</quote>,
	  <quote>bundle</quote> o <quote>null</quote>.
	</para>
      </description>
    </function>

    <function name="uniform" section="probdist" output="series">
      <fnargs>
	<fnarg type="scalar">a</fnarg>
	<fnarg type="scalar">b</fnarg>
      </fnargs>     
      <description>
    <para>
      Genera una serie di numeri pseudo-casuali uniformi
      nell'intervallo (<argname>a</argname>,
      <argname>b</argname>), oppure, in assenza di argomenti,
      nell'intervallo (0,1). L'algoritmo usato è il Mersenne
      Twister sviluppato da <cite key="saito_matsumoto08">Saito and
      Matsumoto (2008)</cite>.
    </para>
    <para>
      <seelist>
        <fncref targ="randgen"/>
        <fncref targ="normal"/>
        <fncref targ="mnormal"/>
        <fncref targ="muniform"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="uniq" section="stats" output="cvec">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>      
      <description>
	<para>
	  Restituisce un vettore che contiene gli elementi distinti di
	  <argname>x</argname>, non ordinati ma nell'ordine in cui
	  compaiono. Si veda <fncref targ="values"/> per una variante
	  che ordina gli elementi.
	</para>
      </description>
    </function>

    <function name="unvech" section="matbuild" output="smatrix">
      <fnargs>
	<fnarg type="vector">v</fnarg>
      </fnargs>      
      <description>
    <para>
      Restituisce una matrice simmetrica <by r="n" c="n"/>
      ottenuta riordinando gli elementi di <math>v</math>. Il
      numero di elementi in <math>v</math> deve essere un intero
      triangolare, ossia un numero <math>k</math> che può essere
      scritto come <equation status="inline" ascii="k = n(n+1)/2"
      tex="$k = n(n+1)/2$"/>, con <math>n</math> intero. Questa
      funzione è l'inversa della funzione <fncref targ="vech"/>.
    </para>
    <para>
      <seelist>
        <fncref targ="mshape"/>
        <fncref targ="vech"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="upper" section="matbuild" output="smatrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>  
      <description>
	<para context="notex">
	  Restituisce una matrice triangolare superiore <by r="n"
	  c="n"/>: gli elementi sulla e sopra la diagonale sono uguali
	  ai corrispondenti elementi di <argname>A</argname>; i
	  restanti elementi sono zero.
	</para>
	<para context="tex">
	  Restituisce una matrice triangolare superiore $n\times n$
	  <math>B</math> per cui $B_{ij} = A_{ij}$ se $i \le j$ e 0
	  altrimenti.
	</para>
	<para>
	  <seelist>
	    <fncref targ="lower"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="urcpval" section="probdist" output="scalar">
      <fnargs>
    <fnarg type="scalar">tau</fnarg>
    <fnarg type="int">n</fnarg>
    <fnarg type="int">niv</fnarg>
    <fnarg type="int">itv</fnarg>
      </fnargs>
      <description>
    <para>
      <math>P</math>-value della statistica test per il test di radici 
      unitarie di Dickey&ndash;Fuller e del test di cointegrazione di
      Engle&ndash;Granger, calcolato usando il metodo proposto da 
      <cite key="mackinnon96">James MacKinnon (1996)</cite>.
    </para>
    <para>
      Gli argomenti sono i seguenti: <argname>tau</argname> indica
      la statistica test; <argname>n</argname> è il numero di
      osservazioni (o 0 per il risultato asintotico);
      <argname>niv</argname> è il numero di variabili
      potenzialmente cointegrate nel test di cointegrazione (o 1
      per il test univariato di radici unitarie);
      <argname>itv</argname> è il codice di specificazione del
      modello: 1 per il modello senza costante, 2 per il modello
      con costante inclusa, 3 per il modello con costante e trend
      lineare, 4 per il modello con costante e trend quadratico.
    </para>
    <para>
      Si noti che se il test è <quote>aumentato</quote> con i
      ritardi della variabile dipendente, si deve fornire un
      valore 0 all'argomento <argname>n</argname> per ottenere il
      risultato asintotico.
    </para>
    <para>
      <seelist> 
        <fncref targ="pvalue"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="values" section="stats" output="cvec">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>      
      <description>
    <para>
      Restituisce un vettore contenente gli elementi distinti di
      <argname>x</argname> ordinati in senso crescente. Se si desidera
      troncare all'intero i valori prima di applicare questa funzione è 
      possibile usare l'espressione <lit>values(int(x))</lit>.
    </para>
    <para>
      <seelist>
        <fncref targ="uniq"/>
        <fncref targ="dsort"/>
        <fncref targ="sort"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="var" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
      </fnargs>     
      <description>
    <para>
      Se <argname>x</argname> è una variabile, restituisce la sua 
      varianza campionaria (uno scalare), saltando i valori mancanti.
    </para>
    <para>
      Se <argname>x</argname> è una lista, restituisce una variabile 
      <math>y</math> tale che <math>y</math><sub>t</sub> è la
      varianza campionaria dei valori delle variabili nella lista
      all'osservazione <math>t</math>, o <lit>NA</lit> se ci sono
      valori mancanti a <math>t</math>.
    </para>
    <para>
      In ogni caso, la somma delle deviazioni al quadrato dalla
      media è divisa per (<math>n</math> &minus; 1) se
      <math>n</math> &gt; 1. In caso contrario, la varianza
      restituita è nulla se <math>n</math> = 1, o <lit>NA</lit> se
      <math>n</math> = 0.
    </para>
    <para>
      <seelist>
        <fncref targ="sd"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="varname" section="strings" output="string">
      <fnargs>
	<fnarg type="int-or-list">v</fnarg>
      </fnargs>     
      <description>
    <para>
      Se l'argomento è uno scalare restituisce il nome della
      variabile con numero ID <argname>v</argname> o genera un
      errore nel caso in cui una tale variabile non esista.
    </para>
    <para>
      Se l'argomento è una lista restituisce una stringa
      contenente i nomi delle variabili nella lista, separati da
      virgole. Se la lista fornita è vuota, la stringa
      restituita sarà vuota.
    </para>
    <para>
      Esempio:
    </para>
    <code>
      open broiler.gdt
      string s = varname(7)
      print s
    </code>
      </description>
    </function>

    <function name="varnames" section="strings" output="strings">
      <fnargs>
	<fnarg type="list">L</fnarg>
      </fnargs>     
      <description>
	<para>
	  Restituisce un array di stringhe contenente i nomi delle
	  variabili nella lista <argname>L</argname>. Se quest'ultima
	  è vuota, lo sarà anche l'array risultato.
	</para>
    <para>
        Esempio:
    </para>
    <code>
        open keane.gdt
        list L = year wage status
        strings S = varnames(L)
        eval S[1]
        eval S[2]
        eval S[3]
    </code>
      </description>
    </function>

    <function name="varnum" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">varname</fnarg>
      </fnargs>     
      <description>
    <para>
      Restituisce il numero ID della variabile  
      <argname>varname</argname>, o NA se tale variabile non esiste.
    </para>
      </description>
    </function>

    <function name="varsimul" section="linalg" output="matrix">
      <fnargs>
    <fnarg type="matrix">A</fnarg>
    <fnarg type="matrix">U</fnarg>
    <fnarg type="matrix">y0</fnarg>
      </fnargs>
      <description>
    <para>
      Simula un VAR di ordine <math>p</math> con 
      <math>n</math> variabili, cioè 
      <equation status="inline"
      ascii="y(t) = A1 y(t-1) + ... + Ap y(t-p) + u(t)." 
      tex="$y_t = \sum_{i=1}^p A_i y_{t-i} + u_t$."/>
      La matrice dei coefficienti <argname>A</argname> è formata
      incolonnando orizzontalmente le matrici
      <math>A</math><sub>i</sub>. Si tratta di una matrice <by
      r="n" c="np"/>, con una riga per ogni equazione. Ciò corrisponde
      alle prime <math>n</math> righe della matrice
      <lit>$compan</lit> fornita dai comandi <lit>var</lit> e
      <lit>vecm</lit> di gretl.
    </para>
    <para>
      I vettori <math>u_t</math> sono contenuti (sotto forma di righe)
      nella matrice <argname>U</argname> (<by r="T" c="n"/>). I
      valori iniziali sono in <argname>y0</argname> (<by r="p"
      c="n"/>).
    </para>
    <para>
      Se il VAR contiene termini deterministici e/o regressori
      esogeni, essi possono essere gestiti racchiudendoli nella
      matrice <argname>U</argname>: ciascuna riga di
      <argname>U</argname> diventa allora
      <equation status="inline"
      ascii="u(t) = B' x(t) + e(t)." 
      tex="$u_t = B' x_t + e_t$."/>
    </para>
    <para>
      La matrice in uscita ha<math>T</math> + <math>p</math> righe
      e <math>n</math> colonne; contiene i <math>p</math> valori
      iniziali delle variabili endogene più i <math>T</math>
      valori simulati.
    </para>
    <para>
      <seelist> 
        <fncref targ="$compan"/>
        <cmdref targ="var"/>
        <cmdref targ="vecm"/>
      </seelist>
    </para>

      </description>
    </function>

    <function name="vec" section="matbuild" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>     
      <description>
	<para>
	  Restituisce le colonne di <argname>X</argname> una sotto
	  l'altra in un vettore colonna.
	  <seelist>
	    <fncref targ="mshape"/>
	    <fncref targ="unvech"/>
	    <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="vech" section="matbuild" output="cvec">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>    
      <description>
	<para>
	  Restituisce, sotto forma di vettore colonna, gli elementi di
	  <argname>A</argname> sulla diagonale e al di sopra di
	  essa. L'uso tipico di questa funzione è con matrici
	  simmetriche, nel qual caso la sua funzione inversa è <fncref
	  targ="unvech"/>.
	  <seelist> 
	    <fncref targ="vec"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="weekday" section="calendar" output="int">
      <fnargs>
	<fnarg type="scalar-or-series">anno</fnarg>
	<fnarg type="scalar-or-series">mese</fnarg>
	<fnarg type="scalar-or-series">giorno</fnarg>
      </fnargs>    
      <description>
	<para>
	  Fornisce il giorno della settimana (Domenica = 0, Lunedì =
	  1, ecc.) corrispondente alla data specificata dai tre
	  argomenti, o <lit>NA</lit> se la data non è valida. Si noti
	  che i tre argomenti devono essere dello stesso tipo: o
	  scalari, oppure serie.
	</para>
      </description>
    </function>

    <function name="wmean" section="stats" output="series">
      <fnargs>
	<fnarg type="list">Y</fnarg>
	<fnarg type="list">W</fnarg>
      </fnargs>    
      <description>
    <para>
      Restituisce una variabile <math>y</math> tale che
      <math>y</math><sub>t</sub> è la media ponderata dei valori
      delle variabili nella lista <argname>Y</argname>
      all'osservazione <math>t</math>; i rispettivi pesi devono
      essere contenuti nella lista <argname>W</argname> e 
      possono quindi cambiare nel tempo. Le due liste
      <argname>Y</argname> e <argname>W</argname> devono avere lo
      stesso numero di elementi ed i pesi devono essere
      non-negativi.
    </para>
    <para>
      <seelist> 
        <fncref targ="wsd"/>
        <fncref targ="wvar"/>
      </seelist>
    </para> 
      </description>
    </function>

    <function name="wsd" section="stats" output="series">
      <fnargs>
	<fnarg type="list">Y</fnarg>
	<fnarg type="list">W</fnarg>
      </fnargs>    
      <description>
    <para>
      Restituisce una variabile <math>y</math> tale che
      <math>y</math><sub>t</sub> è l'errore quadratico medio
      ponderato dei valori delle variabili nella lista
      <argname>Y</argname> all'osservazione <math>t</math>; i
      rispettivi pesi devono essere contenuti nella lista
      <argname>W</argname>, e possono quindi cambiare nel
      tempo. Le due liste <argname>Y</argname> e
      <argname>W</argname> devono avere lo stesso numero di
      elementi ed i pesi devono essere non-negativi.
    </para>
    <para>
      <seelist> 
        <fncref targ="wmean"/>
        <fncref targ="wvar"/>
      </seelist>
    </para> 
      </description>
    </function>

    <function name="wvar" section="stats" output="series">
      <fnargs>
	<fnarg type="list">X</fnarg>
	<fnarg type="list">W</fnarg>
      </fnargs>    
      <description>
    <para>
      Restituisce una variabile <math>y</math> tale che
      <math>y</math><sub>t</sub> è la varianza campionaria
      ponderata dei valori delle variabili nella lista
      <argname>Y</argname> all'osservazione <math>t</math>; i
      rispettivi pesi devono essere contenuti nella lista
      <argname>W</argname>, e possono quindi cambiare nel
      tempo. Le due liste <argname>Y</argname> e
      <argname>W</argname> devono avere lo stesso numero di
      elementi ed i pesi devono essere non-negativi.
    </para>
    <para context="tex">
      La varianza ponderata è calcolata come 
      \[ 
      s^2_w = \frac{n'}{n'-1} \, 
      \frac{\sum_{i=1}^n w_i(x_i - \bar{x}_w)^2}{\sum_{i=1}^n w_i} 
      \] 
      dove $n'$ è il numero di pesi non nulli e $\bar{x}_w$ è la
      media ponderata.
    </para>
    <para>
      <seelist> 
        <fncref targ="wmean"/>
        <fncref targ="wsd"/>
      </seelist>
    </para> 
      </description>
    </function>

    <function name="xmax" section="math" output="scalar">
      <fnargs>
	<fnarg type="scalar">x</fnarg>
	<fnarg type="scalar">y</fnarg>
      </fnargs>     
      <description>
	<para>
	  Fornisce il maggiore fra <argname>x</argname> e
	  <argname>y</argname>, o <lit>NA</lit> se uno dei due valori 
	  è mancante.  
	</para>
	<para>
	  <seelist> 
	    <fncref targ="xmin"/>
	    <fncref targ="max"/>
	    <fncref targ="min"/>
	  </seelist>
	</para> 
      </description>
    </function>

    <function name="xmin" section="math" output="scalar">
      <fnargs>
	<fnarg type="scalar">x</fnarg>
	<fnarg type="scalar">y</fnarg>
      </fnargs>     
      <description>
	<para>
	  Fornisce il minore fra <argname>x</argname> e
	  <argname>y</argname>, o <lit>NA</lit> se uno dei due valori
      è mancante.
	</para>
	<para>
	  <seelist> 
	    <fncref targ="xmax"/>
	    <fncref targ="max"/>
	    <fncref targ="min"/>
	  </seelist>
	</para> 
      </description>
    </function>

    <function name="zeromiss" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-series">x</fnarg>
      </fnargs>     
      <description>
    <para>
      Converte gli zeri in <lit>NA</lit>s. Se <argname>x</argname>
      è una variabile la conversione viene fatta elemento per
      elemento.
      <seelist>
        <fncref targ="missing"/>
        <fncref targ="misszero"/>
        <fncref targ="ok"/>
      </seelist>
    </para>
      </description>
    </function>

    <function name="zeros" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg type="int">c</fnarg>
      </fnargs> 
      <description>
    <para>
      Genera una matrice di zero con <math>r</math> righe e 
      <math>c</math> colonne. 
      <seelist> 
        <fncref targ="ones"/>
        <fncref targ="seq"/>
      </seelist>
    </para>
      </description>
    </function>

  </funclist>
</funcref>
