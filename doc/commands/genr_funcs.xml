<?xml version="1.0"?>
<!DOCTYPE funcref SYSTEM "genr_funcs.dtd">

<funcref language="english">

  <funclist name="Accessors" ref="accessors">

    <function name="$ahat" section="access" output="series">
      <description>
	<para>
	  Must follow the estimation of a fixed-effect panel data model.
	  Returns a series containing the estimates of the individual fixed
	  effects (per-unit intercepts).
	</para>
      </description>
    </function>

    <function name="$aic" section="access" output="scalar">
      <description>
	<para>
	  Returns the Akaike Information Criterion for the last estimated
	  model, if available. See <guideref targ="chap:criteria"/> for
	  details of the calculation.
	</para>
      </description>
    </function>

    <function name="$bic" section="access" output="scalar">
      <description>
	<para>
	  Returns Schwarz's Bayesian Information Criterion for the
	  last estimated model, if available. See <guideref
	  targ="chap:criteria"/> for details of the calculation.
	</para>
      </description>
    </function>

    <function name="$chisq" section="access" output="scalar">
      <description>
	<para>
	  Returns the overall chi-square statistic from the last estimated
	  model, if available.
	</para>
      </description>
    </function>

    <function name="$coeff" section="access" output="matrix" altout="scalar">
      <fnargs>
	<fnarg optional="true" type="coeffname">s</fnarg>
      </fnargs>
      <description>
	<para>
	  With no arguments, <lit>$coeff</lit> returns a column vector
	  containing the estimated coefficients for the last model. With
	  the optional string argument it returns a scalar, namely the
	  estimated parameter named <argname>s</argname>.
	  <seelist>
            <fncref targ="$stderr"/>
            <fncref targ="$vcv"/>
	  </seelist>
	</para>
	<para>
	  Example:
	</para>
	<code>
	  open bjg
	  arima 0 1 1 ; 0 1 1 ; lg 
	  b = $coeff               # gets a vector
	  macoef = $coeff(theta_1) # gets a scalar
	</code>
	<para>
	  If the <quote>model</quote> in question is actually a system,
	  the result depends on the characteristics of the system: for
	  VARs and VECMs the value returned is a matrix with one column
	  per equation, otherwise it is a column vector containing the
	  coefficients from the first equation followed by those from the
	  second equation, and so on.
	</para>
      </description>
    </function>

    <function name="$command" section="access" output="string">
      <description>
	<para>
	  Must follow the estimation of a model; returns the command
	  word, for example <lit>ols</lit> or <lit>probit</lit>.
	</para>
      </description>
    </function>

    <function name="$compan" section="access" output="matrix">
      <description>
	<para>
	  Must follow the estimation of a VAR or a VECM; returns the
	  companion matrix.
	</para>
      </description>
    </function>

    <function name="$datatype" section="access" output="scalar">
      <description>
	<para>
	  Returns an integer value representing the sort of dataset that
	  is currently loaded: 0 = no data; 1 = cross-sectional (undated)
	  data; 2 = time-series data; 3 = panel data.
	</para>
      </description>
    </function>

    <function name="$depvar" section="access" output="string">
      <description>
	<para>
	  Must follow the estimation of a single-equation model;
	  returns the name of the dependent variable.
	</para>
      </description>
    </function>

    <function name="$df" section="access" output="scalar">
      <description>
	<para>
	  Returns the degrees of freedom of the last estimated
	  model. If the last model was in fact a system of equations,
	  the value returned is the degrees of freedom per equation;
	  if this differs across the equations then the value given is
	  the number of observations minus the mean number of
	  coefficients per equation (rounded up to the nearest
	  integer).
	</para>
      </description>
    </function>

    <function name="$diagpval" section="access" output="scalar">
      <description>
	<para>
	  Must follow estimation of a system of equations. Returns the
	  <math>P</math>-value associated with the <fncref
	  targ="$diagtest"/> statistic.
	</para>
      </description>
    </function>     

    <function name="$diagtest" section="access" output="scalar">
      <description>
	<para>
	  Must follow estimation of a system of equations. Returns the
	  test statistic for the null hypothesis that the
	  cross-equation covariance matrix is diagonal. This is the
	  Breusch&ndash;Pagan test except when the estimator is
	  (unrestricted) iterated SUR, in which case it is a Likelihood
	  Ratio test. See <guideref targ="chap:system"/> for
	  details; see also <fncref targ="$diagpval"/>.
	</para>
      </description>
    </function>    

    <function name="$dwpval" section="access" output="scalar">
      <description>
	<para>
	  Returns the p-value for the Durbin&ndash;Watson statistic
	  for the model last estimated (if available), computed using
	  the Imhof procedure.
	</para>
	<para>
	  Due to the limited precision of computer arithmetic, the
	  Imhof integral can go negative when the Durbin&ndash;Watson
	  statistic is close to its lower bound. In that case the
	  accessor returns <lit>NA</lit>. Since any other failure mode
	  results in an error being flagged it is probably safe to
	  assume that an NA value means the true p-value is
	  <quote>very small</quote>, although we are unable to
	  quantify it.
	</para>
      </description>
    </function>

    <function name="$ec" section="access" output="matrix">
      <description>
	<para>
	  Must follow the estimation of a VECM; returns a matrix containing
	  the error correction terms.  The number of rows equals the number 
	  of observations used and the number of columns equals the
	  cointegration rank of the system.
	</para>
      </description>
    </function>

    <function name="$error" section="access" output="scalar">
      <description>
	<para>
	  Returns the program's internal error code, which will be
	  non-zero in case an error has occurred but has been trapped
	  using <cmdref targ="catch"/>. Note that using this accessor
	  causes the internal error code to be reset to zero. If you
	  want to get the error message associated with a given
	  <lit>$error</lit> you need to store the value in a temporary
	  variable, as in
	</para>
	<code>
	  err = $error
	  if (err)
	      printf "Got error %d (%s)\n", err, errmsg(err);
	  endif
	</code>
	<para>
	  <seelist>
            <cmdref targ="catch"/>
            <fncref targ="errmsg"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$ess" section="access" output="scalar">
      <description>
	<para>
	  Returns the error sum of squares of the last estimated model,
	  if available.
	</para>
      </description>
    </function>

    <function name="$evals" section="access" output="matrix">
      <description>
	<para>
	  Must follow the estimation of a VECM; returns a vector
	  containing the eigenvalues that are used in computing
	  the trace test for cointegration.
	</para>
      </description>
    </function>

    <function name="$fcast" section="access" output="matrix">
      <description>
	<para>
	  Must follow the <cmdref targ="fcast"/> forecasting command;
	  returns the forecast values as a matrix. If the model on
	  which the forecast was based is a system of equations the
	  returned matrix will have one column per equation, otherwise
	  it is a column vector. 
	</para>
      </description>
    </function>

    <function name="$fcerr" section="access" output="matrix">
      <description>
	<para>
	  Must follow the <cmdref targ="fcast"/> forecasting command;
	  returns the standard errors of the forecasts, if available, as a
	  matrix. If the model on which the forecast was based is a system
	  of equations the returned matrix will have one column per
	  equation, otherwise it is a column vector.
	</para>
      </description>
    </function>

    <function name="$fevd" section="access" output="matrix">
      <description>
	<para>
	  Must follow estimation of a VAR. Returns a matrix containing
	  the forecast error variance decomposition (FEVD). This
	  matrix has <math>h</math> rows where <math>h</math> is the
	  forecast horizon, which can be chosen using <lit>set
	  horizon</lit> or otherwise is set automatically based on the
	  frequency of the data.
	</para>
	<para>
	  For a VAR with <math>p</math> variables, the matrix has
	  <math>p</math><sup>2</sup> columns: the first <math>p</math>
	  columns contain the FEVD for the first variable in the VAR;
	  the second <math>p</math> columns the FEVD for the second
	  variable; and so on.  The (decimal) fraction of the forecast
	  error for variable <math>i</math> attributable to innovation
	  in variable <math>j</math> is therefore found in column
	  (<math>i</math> &minus; 1)<math>p</math> + <math>j</math>.
	</para>
      </description>
    </function>

    <function name="$Fstat" section="access" output="scalar">
      <description>
	<para>
	  Returns the overall F-statistic from the last estimated model,
	  if available.
	</para>
      </description>
    </function>

    <function name="$gmmcrit" section="access" output="scalar">
      <description>
	<para>
	  Must follow a <lit>gmm</lit> block. Returns the value of the
	  GMM objective function at its minimum.
	</para>
      </description>
    </function>

    <function name="$h" section="access" output="series">
      <description>
	<para>
	  Must follow a <lit>garch</lit> command. Returns the estimated
	  conditional variance series.
	</para>
      </description>
    </function>

    <function name="$hausman" section="access" output="rvec">
      <description>
	<para>
	  Must follow estimation of a model via either <lit>tsls</lit> or
	  <lit>panel</lit> with the random effects option. Returns a <by
          r="1" c="3"/> vector containing the value of the
	  Hausman test statistic, the corresponding degrees of freedom and
	  the p-value for the test, in that order.
	</para>
     </description>
    </function>

    <function name="$hqc" section="access" output="scalar">
      <description>
	<para>
	  Returns the Hannan-Quinn Information Criterion for the last
	  estimated model, if available.  See <guideref
	  targ="chap:criteria"/> for details of the calculation.
	</para>
      </description>
    </function>

    <function name="$huge" section="access" output="scalar">
      <description>
	<para>
	  Returns a very large positive number. By default this is 1.0E100,
	  but the value can be changed using the <cmdref targ="set"/> command.
	</para>
      </description>
    </function>

    <function name="$jalpha" section="access" output="matrix">
      <description>
	<para>
	  Must follow the estimation of a VECM, and returns the loadings
	  matrix. It has as many rows as variables in the VECM and as many
	  columns as the cointegration rank.
	</para>
      </description>
    </function>

    <function name="$jbeta" section="access" output="matrix">
      <description>
	<para>
	  Must follow the estimation of a VECM, and returns the
	  cointegration matrix. It has as many rows as variables in the
	  VECM (plus the number of exogenous variables that are restricted
	  to the cointegration space, if any), and as many columns as the
	  cointegration rank.
	</para>
      </description>
    </function>

    <function name="$jvbeta" section="access" output="smatrix">
      <description>
	<para>
	  Must follow the estimation of a VECM, and returns the estimated
	  covariance matrix for the elements of the cointegration vectors.
	</para>
	<para>
	  In the case of unrestricted estimation, this matrix has a number of
	  rows equal to the unrestricted elements of the cointegration space
	  after the Phillips normalization. If, however, a restricted system
	  is estimated via the <lit>restrict</lit> command with the
	  <lit>--full</lit> option, a singular matrix with <math>(n+m)r</math>
	  rows will be returned (<math>n</math> being the number of endogenous
	  variables, <math>m</math> the number of exogenous variables that are
	  restricted to the cointegration space, and <math>r</math> the
	  cointegration rank).
	</para>
	<para>
	  Example: the code
	</para>
	<code>
	  open denmark.gdt
	  vecm 2 1 LRM LRY IBO IDE --rc --seasonals -q
	  s0 = $jvbeta

	  restrict --full
	    b[1,1] = 1
	    b[1,2] = -1
	    b[1,3] + b[1,4] = 0
	  end restrict
	  s1 = $jvbeta

	  print s0
	  print s1
	</code>
	<para>
	  produces the following output.
	</para>
	<code>
	  s0 (4 x 4)

          0.019751     0.029816  -0.00044837     -0.12227 
          0.029816      0.31005     -0.45823     -0.18526 
	  -0.00044837     -0.45823       1.2169    -0.035437 
          -0.12227     -0.18526    -0.035437      0.76062 

	  s1 (5 x 5)

	  0.0000       0.0000       0.0000       0.0000       0.0000 
	  0.0000       0.0000       0.0000       0.0000       0.0000 
	  0.0000       0.0000      0.27398     -0.27398    -0.019059 
	  0.0000       0.0000     -0.27398      0.27398     0.019059 
	  0.0000       0.0000    -0.019059     0.019059    0.0014180 
	</code>
      </description>
    </function>

    <function name="$lang" section="access" output="string">
      <description>
	<para>
	  Returns a string representing the national language in force
	  currently, if this can be determined. The string is composed
	  of a two-letter ISO 639-1 language code (for example,
	  <lit>en</lit> for English, <lit>jp</lit> for Japanese,
	  <lit>el</lit> for Greek) followed by an underscore plus a
	  two-letter ISO 3166-1 country code.  Thus for example
	  Portuguese in Portugal gives <lit>pt_PT</lit> while
	  Portuguese in Brazil gives <lit>pt_BR</lit>.
	</para>
	<para>
	  If the national language cannot be determined, the string
	  <quote><lit>unknown</lit></quote> is returned.
	</para>
      </description>
    </function>    

    <function name="$llt" section="access" output="series">
      <description>
	<para>
	  For selected models estimated via Maximum Likelihood,
	  returns the series of per-observation log-likelihood
	  values. At present this is supported only for binary logit
	  and probit, tobit and heckit.
	</para>
      </description>
    </function>

    <function name="$lnl" section="access" output="scalar">
      <description>
	<para>
	  Returns the log-likelihood for the last estimated model (where
	  applicable).
	</para>
      </description>
    </function>

    <function name="$macheps" section="access" output="scalar">
      <description>
	<para>
	  Returns the value of <quote>machine epsilon</quote>, which
	  gives an upper bound on the relative error due to rounding
	  in double-precision floating point arithmetic.
	</para>
      </description>
    </function>

    <function name="$mnlprobs" section="access" output="matrix">
      <description>
	<para>
	  Following estimation of a multinomial logit model (only),
	  retrieves a matrix holding the estimated probabilities
	  of each possible outcome at each observation in the model's
	  sample range. Each row represents an observation and
	  each column an outcome. 
	</para>
      </description>
    </function>

    <function name="$ncoeff" section="access" output="int">
      <description>
	<para>
	  Returns the total number of coefficients estimated in the last
	  model.
	</para>
      </description>
    </function>

    <function name="$nobs" section="access" targ="dnobs" output="int">
      <description>
	<para>
	  Returns the number of observations in the currently selected
	  sample.
	</para>
      </description>
    </function>

    <function name="$nvars" section="access" output="int">
      <description>
	<para>
	  Returns the number of variables in the dataset (including the
	  constant).
	</para>
      </description>
    </function>

    <function name="$obsdate" section="access" output="series">
      <description>
	<para>
	  Applicable when the current dataset is time-series with
	  annual, quarterly, monthly or decennial frequency, or is
	  dated daily or weekly, or when the dataset is a panel with
	  time-series information set appropriately (see the <cmdref
	  targ="setobs"/> command).  The returned series holds 8-digit
	  numbers on the pattern <lit>YYYYMMDD</lit> (ISO 8601
	  <quote>basic</quote> date format), which correspond to the
	  day of the observation, or the first day of the observation
	  period in case of a time-series frequency less than daily.
	</para>
	<para>
	  Such a series can be helpful when using the <cmdref
	  targ="join"/> command.
	</para>
      </description>
    </function>

    <function name="$obsmajor" section="access" output="series">
      <description>
	<para>
	  Applicable when the observations in the current dataset have
	  a major:minor structure, as in quarterly time series
	  (year:quarter), monthly time series (year:month), hourly
	  data (day:hour) and panel data (individual:period).  Returns
	  a series holding the major or low-frequency component of
	  each observation (for example, the year).
	</para>
	<para>
	  <seelist>
            <fncref targ="$obsminor"/>
            <fncref targ="$obsmicro"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$obsmicro" section="access" output="series">
      <description>
	<para>
	  Applicable when the observations in the current dataset have
	  a major:minor:micro structure, as in dated daily time series
	  (year:month:day).  Returns a series holding the micro or
	  highest-frequency component of each observation (for
	  example, the day).
	</para>
	<para>
	  <seelist>
            <fncref targ="$obsmajor"/>
            <fncref targ="$obsminor"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$obsminor" section="access" output="series">
      <description>
	<para>
	  Applicable when the observations in the current dataset have
	  a major:minor structure, as in quarterly time series
	  (year:quarter), monthly time series (year:month), hourly
	  data (day:hour) and panel data (individual:period).  Returns
	  a series holding the minor or high-frequency component of
	  each observation (for example, the month).
	</para>
	<para>
	  In the case of dated daily data, <lit>$obsminor</lit> gets
	  the month of each observation.
	</para>
	<para>
	  <seelist>
            <fncref targ="$obsmajor"/>
            <fncref targ="$obsmicro"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$pd" section="access" output="int">
      <description>
	<para>
	  Returns the frequency or periodicity of the data (e.g. 4 for
	  quarterly data).  In the case of panel data the value returned
	  is the time-series length.
	</para>
      </description>
    </function>

    <function name="$pi" section="access" output="scalar">
      <description>
	<para>
	  Returns the value of &pi; in double precision.
	</para>
      </description>
    </function>

    <function name="$pvalue" section="access" targ="dpvalue" output="scalar-or-matrix">
      <description>
	<para>
	  Returns the p-value of the test statistic that was generated
	  by the last explicit hypothesis-testing command, if any (for
	  example, <lit>chow</lit>).  See <guideref targ="chap:genr"/>
	  for details.
	</para>
	<para>
	  In most cases the return value is a scalar but sometimes it
	  is a matrix (for example, the trace and lambda-max p-values
	  from the Johansen cointegration test); in that case the
	  values in the matrix are laid out in the same pattern as the
	  printed results.
	</para>
	<para>
	  <seelist>
            <fncref targ="$test"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$qlrbreak" section="access" output="scalar">
      <description>
	<para>
	  Must follow an invocation of the <cmdref targ="qlrtest"/>
	  command (the QLR test for a structural break at an unknown
	  point). The value returned is the 1-based index of the
	  observation at which the test statistic is maximized.
	</para>
      </description>
    </function>    

    <function name="$rho" section="access" output="scalar">
      <fnargs>
	<fnarg optional="true" type="scalar">n</fnarg>
      </fnargs>
      <description>
	<para>
	  Without arguments, returns the first-order autoregressive
	  coefficient for the residuals of the last model. After
	  estimating a model via the <lit>ar</lit> command, the syntax
	  <lit>$rho(n)</lit> returns the corresponding estimate of
	  &rgr;(<math>n</math>).
	</para>
      </description>
    </function>

    <function name="$rsq" section="access" output="scalar">
      <description>
	<para>
	  Returns the unadjusted <math>R</math><sup>2</sup> from the
	  last estimated model, if available.
	</para>
      </description>
    </function>

    <function name="$sample" section="access" output="series">
      <description>
	<para>
	  Must follow estimation of a single-equation model.  Returns a dummy
	  series with value 1 for observations used in estimation, 0 for
	  observations within the currently defined sample range but not used
	  (presumably because of missing values), and NA for observations
	  outside of the current range.
	</para>
	<para>
	  If you wish to compute statistics based on the sample that was
	  used for a given model, you can do, for example: 
	</para>
	<code>
	  ols y 0 xlist
	  genr sdum = $sample
	  smpl sdum --dummy
	</code>
      </description>
    </function>

    <function name="$sargan" section="access" output="rvec">
      <description>
	<para>
	  Must follow a <lit>tsls</lit> command. Returns a <by r="1"
	  c="3"/> vector, containing the value of the Sargan
	  over-identification test statistic, the corresponding
	  degrees of freedom and p-value, in that order. If the model is
	  exactly identified, the statistic is unavailable, and trying to
	  access it provokes an error.
	</para>
      </description>
    </function>

    <function name="$sigma" section="access" output="scalar-or-matrix">
      <description>
	<para>
	  Requires that a model has been estimated.  If the last model was
	  a single equation, returns the (scalar) Standard Error of the
	  Regression (or in other words, the standard deviation of the
	  residuals, with an appropriate degrees of freedom correction).
	  If the last model was a system of equations, returns the
	  cross-equation covariance matrix of the residuals.
	</para>
      </description>
    </function>

    <function name="$stderr" section="access" output="matrix" altout="scalar">
      <fnargs>
	<fnarg optional="true" type="coeffname">s</fnarg>
      </fnargs>
      <description>
	<para>
	  With no arguments, <lit>$stderr</lit> returns a column vector
	  containing the standard error of the coefficients for the last
	  model.  With the optional string argument it returns a scalar,
	  namely the standard error of the parameter named
	  <argname>s</argname>.
	</para>
	<para>
	  If the <quote>model</quote> in question is actually a system,
	  the result depends on the characteristics of the system: for
	  VARs and VECMs the value returned is a matrix with one column
	  per equation, otherwise it is a column vector containing the
	  coefficients from the first equation followed by those from the
	  second equation, and so on.
	</para>
	<para>
	  <seelist>
            <fncref targ="$coeff"/> 
            <fncref targ="$vcv"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$stopwatch" section="access" output="scalar">
      <description>
	<para>
	  Must be preceded by <lit>set stopwatch</lit>, which activates the
	  measurement of CPU time.  The first use of this accessor yields the
	  seconds of CPU time that have elapsed since the <lit>set
          stopwatch</lit> command.  At each access the clock is reset, so
	  subsequent uses of <lit>$stopwatch</lit> yield the seconds of CPU
	  time since the previous access.
	</para>
      </description>
    </function>

    <function name="$sysA" section="access" output="matrix">
      <description>
	<para>
	  Must follow estimation of a simultaneous equations system.
	  Returns the matrix of coefficients on the lagged endogenous
	  variables, if any, in the structural form of the system.  See
	  the <cmdref targ="system"/> command.
	</para>
      </description>
    </function>

    <function name="$sysB" section="access" output="matrix">
      <description>
	<para>
	  Must follow estimation of a simultaneous equations system.
	  Returns the matrix of coefficients on the exogenous variables in
	  the structural form of the system.  See the <cmdref
	  targ="system"/> command.
	</para>
      </description>
    </function>

    <function name="$sysGamma" section="access" output="matrix">
      <description>
	<para>
	  Must follow estimation of a simultaneous equations system.
	  Returns the matrix of coefficients on the contemporaneous
	  endogenous variables in the structural form of the system.
	  See the <cmdref targ="system"/> command.
	</para>
      </description>
    </function>

    <function name="$sysinfo" section="access" output="bundle">
      <description>
	<para>
	  Returns a bundle containing information on the capabilities
	  of the gretl build and the system on which gretl is
	  running. The members of the bundle are as follows:
	</para>
	<ilist>
	  <li>
            <para>
              <lit>mpi</lit>: integer, equals 1 if the system supports
              MPI (Message Passing Interface), otherwise 0.
            </para>
	  </li>
	  <li>
            <para>
              <lit>omp</lit>: integer, equals 1 if gretl is built with
              support for Open MP, otherwise 0.
            </para>
	  </li>
	  <li>
            <para>
              <lit>nproc</lit>: integer, the number of processors
              available.
            </para>
	  </li>
	  <li>
            <para>
              <lit>mpimax</lit>: integer, the maximum number of MPI
              processes that can be run in parallel. This is zero if
              MPI is not supported, otherwise it equals the local
              <lit>nproc</lit> value unless an MPI hosts file has been
              specified, in which case it is the sum of the number of
              processors or <quote>slots</quote> across all the
              machines referenced in that file.
            </para>
	  </li>
	  <li>
            <para>
              <lit>wordlen</lit>: integer, either 32 or 64 for
              32- and 64-bit systems respectively.
            </para>
	  </li>
	  <li>
            <para>
              <lit>os</lit>: string representing the operating system,
              either <lit>linux</lit>, <lit>osx</lit>,
              <lit>windows</lit> or <lit>other</lit>.
            </para>
	  </li>
	  <li>
            <para>
              <lit>hostname</lit>: the name of the host machine on
              which the current gretl process is running (with a
              fallback of <lit>localhost</lit> in case the name
              cannot be determined).
            </para>
	  </li>   
	</ilist>
	<para>
	  Note that individual elements in the bundle can be accessed
	  using <quote>dot</quote> notation without any need to copy the
	  whole bundle under a user-specified name. For example,
	</para>
	<code>
	  if $sysinfo.os == "linux"
	      # do something linux-specific
	  endif
	</code>
      </description>
    </function>

    <function name="$T" section="access" output="int">
      <description>
	<para>
	  Returns the number of observations used in estimating the
	  last model.
	</para>
      </description>
    </function>

    <function name="$t1" section="access" output="int">
      <description>
	<para>
	  Returns the 1-based index of the first observation in the currently
	  selected sample.
	</para>
      </description>
    </function>

    <function name="$t2" section="access" output="int">
      <description>
	<para>
	  Returns the 1-based index of the last observation in the currently
	  selected sample.
	</para>
      </description>
    </function>

    <function name="$test" section="access" output="scalar-or-matrix">
      <description>
	<para>
	  Returns the value of the test statistic that was generated
	  by the last explicit hypothesis-testing command, if any
	  (&eg; <lit>chow</lit>). See <guideref targ="chap:genr"/> for
	  details.
	</para>
	<para>
	  In most cases the return value is a scalar but sometimes it
	  is a matrix (for example, the trace and lambda-max
	  statistics from the Johansen cointegration test); in that
	  case the values in the matrix are laid out in the same
	  pattern as the printed results.
	</para>
	<para>
	  <seelist>
            <fncref label="\$pvalue" targ="dpvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="$trsq" section="access" output="scalar">
      <description>
	<para>
	  Returns <math>TR</math><sup>2</sup> (sample size times
	  R-squared) from the last model, if available.
	</para>
      </description>
    </function>

    <function name="$uhat" section="access" output="series">
      <description>
	<para>
	  Returns the residuals from the last model. This may have
	  different meanings for different estimators. For example, after
	  an ARMA estimation <lit>$uhat</lit> will contain the
	  one-step-ahead forecast error; after a probit model, it will
	  contain the generalized residuals.
	</para>
	<para>
	  If the <quote>model</quote> in question is actually a system (a
	  VAR or VECM, or system of simultaneous equations),
	  <lit>$uhat</lit> with no parameters retrieves the matrix of
	  residuals, one column per equation.
	</para>
      </description>
    </function>

    <function name="$unit" section="access" output="series">
      <description>
	<para>
	  Valid for panel datasets only.  Returns a series with
	  value 1 for all observations on the first unit or group,
	  2 for observations on the second unit, and so on.
	</para>
      </description>
    </function>

    <function name="$vcv" section="access" output="matrix" altout="scalar">
      <fnargs>
	<fnarg optional="true" type="coeffname">s1</fnarg>
	<fnarg optional="true" type="coeffname">s2</fnarg>
      </fnargs>
      <description>
	<para>
	  With no arguments, <lit>$vcv</lit> returns a square matrix
	  containing the estimated covariance matrix for the coefficients of
	  the last model.  If the last model was a single equation, then you
	  may supply the names of two parameters in parentheses to retrieve
	  the estimated covariance between the parameters named
	  <argname>s1</argname> and <argname>s2</argname>.
	  <seelist>
            <fncref targ="$coeff"/> 
            <fncref targ="$stderr"/>
	  </seelist>      
	</para>
	<para>
	  This accessor is not available for VARs or VECMs; for models of that
	  sort see <fncref targ="$sigma"/> and <fncref targ="$xtxinv"/>.
	</para>
      </description>
    </function>

    <function name="$vecGamma" section="access" output="matrix">
      <description>
	<para>
	  Must follow the estimation of a VECM; returns a matrix in
	  which the Gamma matrices (coefficients on the lagged differences
	  of the cointegrated variables) are stacked side by side.
	  Each row represents an equation; for a VECM of lag order
	  <math>p</math> there are <math>p</math> &minus; 1 sub-matrices.
	</para>
      </description>
    </function>    

    <function name="$version" section="access" output="scalar">
      <description>
	<para>
	  Returns an integer value that codes for the program
	  version. The current gretl version string takes the form of
	  a 4-digit year followed by a letter from a to j representing
	  the sequence of releases within the year (for example,
	  2015d).  The return value from this accessor is formed as 10
	  times the year plus the zero-based lexical order of the
	  letter, so 2015d translates to 20153.
	</para>
	<para>
	  Prior to gretl 2015d, version identifiers took the form
	  x.y.z (three integers separated by dots), and in that case
	  the accessor value was calculated as <lit>10000*x + 100*y +
	  z</lit>, so that for example 1.10.2 (the last release under
	  the old scheme) translates as 11002. Numerical order of
	  <lit>$version</lit> values is therefore preserved across the
	  change in versioning scheme.
	</para>
      </description>
    </function>

    <function name="$vma" section="access" output="matrix">
      <description>
	<para>
	  Must follow the estimation of a VAR or a VECM; returns a
	  matrix containing the VMA representation up to the order
	  specified via the <lit>set horizon</lit> command. See
	  <guideref targ="chap:var"/> for details.
	</para>
      </description>
    </function>

    <function name="$windows" section="access" output="int">
      <description>
	<para>
	  Returns 1 if gretl is running on MS Windows, otherwise 0. By
	  conditioning on the value of this variable you can write shell
	  calls that are portable across different operating systems.
	</para>
	<para>
	  Also see the <cmdref targ="shell"/> command.
	</para>
      </description>
    </function>

    <function name="$xlist" section="access" output="list">
      <description>
	<para>
	  If the last model was a single equation, returns the list of
	  regressors. If the last model was a system of equations,
	  returns the <quote>global</quote> list of exogenous and
	  predetermined variables (in the same order in which they
	  appear in <fncref targ="$sysB"/>). If the last model was a
	  VAR, returns the list of exogenous regressors, if any.
	</para>
      </description>
    </function>

    <function name="$xtxinv" section="access" output="matrix">
      <description>
	<para>
	  Following estimation of a VAR or VECM (only), returns
	  <math>X'X</math><sup>-1</sup>, where <math>X</math> is the common
	  matrix of regressors used in each of the equations.  This accessor
	  is not available for a VECM estimated with a restriction imposed on
	  &agr;, the <quote>loadings</quote> matrix.
	</para>
      </description>
    </function>

    <function name="$yhat" section="access" output="series">
      <description>
	<para>
	  Returns the fitted values from the last regression.
	</para>
      </description>
    </function>

    <function name="$ylist" section="access" output="list">
      <description>
	<para>
	  If the last model estimated was a VAR, VECM or simultaneous
	  system, returns the associated list of endogenous variables.
	  If the last model was a single equation, this accessor gives
	  a list with a single element, the dependent variable. In the
	  special case of the biprobit model the list contains two
	  elements. 
	</para>
      </description>
    </function>

  </funclist>

  <funclist name="Functions proper" ref="functions">

    <function name="abs" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the absolute value of <argname>x</argname>.
	</para>
      </description>
    </function>

    <function name="acos" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the arc cosine of <argname>x</argname>, that is, the value
	  whose cosine is <argname>x</argname>.  The result is in radians; the
	  input should be in the range &minus;1 to 1.
	</para>
      </description>
    </function>

    <function name="acosh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the inverse hyperbolic cosine of <argname>x</argname>
	  (positive solution). <argname>x</argname> should be greater than 1;
	  otherwise, NA is returned.
	  <seelist>
            <fncref targ="cosh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="aggregate" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
	<fnarg type="series-or-list">byvar</fnarg>
	<fnarg type="string">funcname</fnarg>   
      </fnargs>
      <description>
	<para>
	  In the simplest version, both <argname>x</argname> and
	  <argname>byvar</argname> are individual series. In that case
	  this function returns a matrix with three columns: the first
	  holds the distinct values of <argname>byvar</argname>,
	  sorted in ascending order; the second holds the count of
	  observations at which <argname>byvar</argname> takes on each
	  of these values; and the third holds the values of the
	  statistic specified by <argname>funcname</argname>
	  calculated on series <argname>x</argname>, using only those
	  observations at which <argname>byvar</argname> takes on the
	  value given in the first column.
	</para>
	<para>
	  More generally, if <argname>byvar</argname> is a list with
	  <math>n</math> members then the left-hand <math>n</math>
	  columns hold the combinations of the distinct values of each
	  of the <math>n</math> series and the count column holds the
	  number of observations at which each combination is
	  realized.  If <argname>x</argname> is a list with
	  <math>m</math> members then the rightmost <math>m</math>
	  columns hold the values of the specified statistic for each
	  of the <argname>x</argname> variables, again calculated on
	  the sub-sample indicated in the first column(s).
	</para>
	<para>
	  The following values of <argname>funcname</argname> are
	  supported <quote>natively</quote>: <fncref targ="sum"/>,
	  <fncref targ="sumall"/>, <fncref targ="mean"/>, <fncref
	  targ="sd"/>, <fncref targ="var"/>, <fncref targ="sst"/>,
	  <fncref targ="skewness"/>, <fncref targ="kurtosis"/>,
	  <fncref targ="min"/>, <fncref targ="max"/>, <fncref
	  targ="median"/>, <fncref targ="nobs"/> and <fncref
	  targ="gini"/>. Each of these functions takes a series
	  argument and returns a scalar value, and in that sense can
	  be said to <quote>aggregate</quote> the series in some way.
	  You may give the name of a user-defined function as the
	  aggregator; like the built-ins, such a function must
	  take a single series argument and return a scalar value.
	</para>
	<para>
	  Note that although a count of cases is provided
	  automatically the <lit>nobs</lit> function is not redundant
	  as an aggregator, since it gives the number of valid
	  (non-missing) observations on <argname>x</argname> at
	  each <argname>byvar</argname> combination.
	</para>
	<para>
	  For a simple example, suppose that <lit>region</lit>
	  represents a coding of geographical region using integer
	  values 1 to <math>n</math>, and <lit>income</lit> represents
	  household income. Then the following would produce an <by
	  r="n" c="3"/> matrix holding the region codes, the count of
	  observations in each region, and mean household income for
	  each of the regions:
	</para>
	<code>
	  matrix m = aggregate(income, region, mean)
	</code>
	<para>
	  For an example using lists, let <lit>gender</lit> be a
	  male/female dummy variable, let <lit>race</lit> be a
	  categorical variable with three values, and consider
	  the following:
	</para>
	<code>
	  list BY = gender race
	  list X = income age
	  matrix m = aggregate(X, BY, sd)
	</code> 
	<para>
	  The <lit>aggregate</lit> call here will produce a <by r="6"
	  c="5"/> matrix. The first two columns hold the 6 distinct
	  combinations of gender and race values; the middle column
	  holds the count for each of these combinations; and the
	  rightmost two columns contain the sample standard deviations
	  of <lit>income</lit> and <lit>age</lit>.
	</para>
	<para>
	  Note that if <argname>byvar</argname> is a list, some
	  combinations of the <argname>byvar</argname> values may not
	  be present in the data (giving a count of zero). In that
	  case the value of the statistics for <argname>x</argname>
	  are recorded as <lit>NaN</lit> (not a number).  If you want
	  to ignore such cases you can use the <fncref targ="selifr"/>
	  function to select only those rows that have a non-zero
	  count. The column to test is one place to the right of the
	  number of <argname>byvar</argname> variables, so we can do:
	</para>
	<code>
	  matrix m = aggregate(X, BY, sd)
	  scalar c = nelem(BY)
	  m = selifr(m, m[,c+1])
	</code>
      </description>
    </function>

    <function name="argname" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  For <argname>s</argname> the name of a parameter to a 
	  user-defined function, returns the name of the corresponding
	  argument, or an empty string if the argument was anonymous.
	</para>
      </description>
    </function>

    <function name="array" section="data-utils" output="seebelow">
      <fnargs>
	<fnarg type="int">n</fnarg>
      </fnargs>
      <description>
	<para>
	  The basic <quote>constructor</quote> function for a new
	  array variable. In using this function you must specify a
	  type (in plural form) for the array: <lit>strings</lit>,
	  <lit>matrices</lit>, <lit>bundles</lit> or <lit>lists</lit>.
	  The return value is an array of the specified type with
	  <argname>n</argname> elements, each of which is initialized
	  as <quote>empty</quote> (&eg; zero-length string, null
	  matrix). Examples of usage:
	</para>
	<code>
	  strings S = array(5)
	  matrices M = array(3)
	</code>
	<para>
	  See also <fncref targ="defarray"/>.
	</para>
      </description>
    </function>    

    <function name="asin" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the arc sine of <argname>x</argname>, that is, the value
	  whose sine is <argname>x</argname>.  The result is in radians; the
	  input should be in the range &minus;1 to 1.
	</para>
      </description>
    </function>

    <function name="asinh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the inverse hyperbolic sine of <argname>x</argname>.
	  <seelist>
            <fncref targ="sinh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="atan" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the arc tangent of <argname>x</argname>, that is, the value
	  whose tangent is <argname>x</argname>.  The result is in radians.
	</para>
      </description>
    </function>

    <function name="atanh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the inverse hyperbolic tangent of <argname>x</argname>.
	  <seelist>
            <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="atof" section="strings" output="scalar">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Closely related to the C library function of the same name.
	  Returns the result of converting the string
	  <argname>s</argname> (or the leading portion thereof, after
	  discarding any initial white space) to a floating-point
	  number.  Unlike C's <lit>atof</lit>, however, the decimal
	  character is always assumed (for reasons of portability) to
	  be <quote><lit>.</lit></quote>. Any characters that follow
	  the portion of <argname>s</argname> that converts to a
	  floating-point number under this assumption are ignored.
	</para>
	<para>
	  If none of <argname>s</argname> (following any discarded
	  white space) is convertible under the stated assumption,
	  <lit>NA</lit> is returned.
	</para>
	<code>
	  # examples
	  x = atof("1.234") # gives x = 1.234 
	  x = atof("1,234") # gives x = 1
	  x = atof("1.2y")  # gives x = 1.2
	  x = atof("y")     # gives x = NA
	  x = atof(",234")  # gives x = NA
	</code> 
	<para>
	  See also <fncref targ="sscanf"/> for more flexible string to
	  numeric conversion.
	</para>
      </description>
    </function>

    <function name="bessel" section="math" output="asinput">
      <fnargs>
	<fnarg type="char">type</fnarg>
	<fnarg type="scalar">v</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes one of the Bessel function variants for order
	  <argname>v</argname> and argument <argname>x</argname>.  The return
	  value is of the same type as <argname>x</argname>. The specific
	  function is selected by the first argument, which must be
	  <lit>J</lit>, <lit>Y</lit>, <lit>I</lit>, or <lit>K</lit>.  A good
	  discussion of the Bessel functions can be found on Wikipedia; here
	  we give a brief account.
	</para>
	<para>
	  case <lit>J</lit>: Bessel function of the first kind.  Resembles a
	  damped sine wave.  Defined for real <argname>v</argname> and
	  <argname>x</argname>, but if <argname>x</argname> is negative
	  then <argname>v</argname> must be an integer.
	</para>
	<para>
	  case <lit>Y</lit>: Bessel function of the second kind.  Defined
	  for real <argname>v</argname> and <argname>x</argname> but has
	  a singularity at <argname>x</argname> = 0.
	</para>
	<para>
	  case <lit>I</lit>: Modified Bessel function of the first kind.
	  An exponentially growing function.  Acceptable arguments are
	  as for case <lit>J</lit>.
	</para>
	<para>
	  case <lit>K</lit>: Modified Bessel function of the second kind.  An
	  exponentially decaying function.  Diverges at <argname>x</argname> =
	  0 and is not defined for negative <argname>x</argname>.  Symmetric
	  around <argname>v</argname> = 0.
	</para>
      </description>
    </function>

    <function name="BFGSmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="fncall" optional="true">g</fnarg>
      </fnargs>
      <description>
	<para>
	  Numerical maximization via the method of Broyden, Fletcher,
	  Goldfarb and Shanno. On input the vector
	  <argname>b</argname> should hold the initial values of a set
	  of parameters, and the argument <argname>f</argname> should
	  specify a call to a function that calculates the (scalar)
	  criterion to be maximized, given the current parameter
	  values and any other relevant data. If the object is in fact
	  minimization, this function should return the negative of
	  the criterion.  On successful completion, <lit>BFGSmax</lit>
	  returns the maximized value of the criterion, and
	  <argname>b</argname> holds the parameter values which
	  produce the maximum.
	</para>
	<para>
	  The optional third argument provides a means of supplying
	  analytical derivatives (otherwise the gradient is computed
	  numerically).  The gradient function call
	  <argname>g</argname> must have as its first argument a
	  pre-defined matrix that is of the correct size to contain
	  the gradient, given in pointer form. It also must take the
	  parameter vector as an argument (in pointer form or
	  otherwise).  Other arguments are optional.
	</para>
	<para>
	  For more details and examples see the chapter on numerical
	  methods in <guideref targ="chap:numerical"/>.
	  <seelist>
	    <fncref targ="BFGScmax"/>
            <fncref targ="NRmax"/>
            <fncref targ="fdjac"/>
            <fncref targ="simann"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="BFGScmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="matrix">bounds</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="fncall" optional="true">g</fnarg>
      </fnargs>
      <description>
	<para>
	  Constrained numerical maximization using L-BFGS-B (limited
	  memory BFGS, see <cite key="byrd-etal95">Byrd, Lu, Nocedal
	  and Zhu, 1995</cite>).  On input the vector
	  <argname>b</argname> should hold the initial values of a set
	  of parameters, <argname>bounds</argname> should hold bounds
	  on the parameter values (see below), and
	  <argname>f</argname> should specify a call to a function
	  that calculates the (scalar) criterion to be maximized,
	  given the current parameter values and any other relevant
	  data. If the object is in fact minimization, this function
	  should return the negative of the criterion.  On successful
	  completion, <lit>BFGScmax</lit> returns the maximized value
	  of the criterion, subject to the constraints in
	  <argname>bounds</argname>, and <argname>b</argname> holds
	  the parameter values which produce the maximum.
	</para>
	<para>
	  The <argname>bounds</argname> matrix must have 3 columns and
	  as many rows are there are constrained elements in the
	  parameter vector. The first element on a given row is the
	  (1-based) index of the constrained parameter; the second and
	  third are the lower and upper bounds, respectively. The
	  values <lit>-$huge</lit> and <lit>$huge</lit> should be used
	  to indicate that the parameter is unconstrained downward or
	  upward, respectively. For example, the following is the way
	  to specify that the second element of the parameter vector
	  must be non-negative:
	</para>
	<code>
	  matrix bounds = {2, 0, $huge}
	</code>
	<para>
	  The optional third argument provides a means of supplying
	  analytical derivatives (otherwise the gradient is computed
	  numerically).  The gradient function call
	  <argname>g</argname> must have as its first argument a
	  pre-defined matrix that is of the correct size to contain
	  the gradient, given in pointer form. It also must take the
	  parameter vector as an argument (in pointer form or
	  otherwise).  Other arguments are optional.
	</para>
	<para>
	  For more details and examples see the chapter on numerical
	  methods in <guideref targ="chap:numerical"/>.
	  <seelist>
	    <fncref targ="BFGSmax"/>
            <fncref targ="NRmax"/>
            <fncref targ="fdjac"/>
            <fncref targ="simann"/>
	  </seelist>
	</para>
      </description>
    </function>    

    <function name="bkfilt" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int" optional="true">f1</fnarg>
	<fnarg type="int" optional="true">f2</fnarg>
	<fnarg type="int" optional="true">k</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the result from application of the Baxter&ndash;King
	  bandpass filter to the series <argname>y</argname>.  The
	  optional parameters <argname>f1</argname> and
	  <argname>f2</argname> represent, respectively, the lower and
	  upper bounds of the range of frequencies to extract, while
	  <argname>k</argname> is the approximation order to be
	  used.
	</para>
	<para>
	  If these arguments are not supplied then the default values
	  depend on the periodicity of the dataset. For yearly data
	  the defaults for <argname>f1</argname>,
	  <argname>f2</argname> and <argname>k</argname> are 2, 8 and
	  3, respectively; for quarterly data, 6, 32 and 12; for
	  monthly data, 18, 96 and 36. These values are chosen to
	  match the most common choice among practitioners, that is to
	  use this filter for extracting the <quote>business
	  cycle</quote> frequency component; this, in turn, is
	  commonly defined as being between 18 months and 8 years. The
	  filter, per default choice, spans 3 years of data.
	</para>
	<para>
	  If <argname>f2</argname> is greater than or equal to the
	  number of available observations, then the
	  <quote>low-pass</quote> version of the filter will be run
	  and the resulting series should be taken as an estimate of
	  the trend component, rather than the cycle.
	  <seelist>
            <fncref targ="bwfilt"/>
            <fncref targ="hpfilt"/>
	  </seelist>
	</para>
      </description>
    </function>
    
    <function name="boxcox" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="scalar">d</fnarg>
      </fnargs>    
      <description>
	<para>
	  Returns the Box&ndash;Cox transformation with parameter
	  <argname>d</argname> for the positive series <argname>y</argname>.
	</para>   
	<para context="tex">
	  \[ y_t^{(d)} = \left\{ \begin{array}{ll} \frac{y_t^d - 1}{d} &amp;
	  {\rm if}\quad d\neq 0 \\ \log (y_t) &amp; {\rm if}\quad d=0
	  \end{array} \right. \]
	</para>
	<para context="notex">
	  The transformed series is (<math>y</math><sup>d</sup> -
	  1)/<math>d</math> for <math>d</math> not equal to zero, or
	  log(<math>y</math>) for <math>d</math> = 0.
	</para>
      </description>
    </function>

    <function name="bread" section="data-utils" output="bundle">
      <fnargs>
	<fnarg type="string">fname</fnarg>
	<fnarg optional="true" type="bool">import</fnarg>
      </fnargs>
      <description>
	<para>
	  Reads a bundle from a text file. The string
	  <argname>fname</argname> must contain the name of the file
	  from which the bundle is to be read. If this name has the
	  suffix <quote><lit>.gz</lit></quote> it is assumed that gzip
	  compression has been applied in writing the file.
	</para>
	<para>
	  The file in question should be an appropriately defined XML
	  file: it should contain a <lit>gretl-bundle</lit> element, which
	  is used to store zero or more <lit>bundled-item</lit>
	  elements. For example,
	</para>
	<code>
	  &lt;?xml version="1.0" encoding="UTF-8"?&gt;
	  &lt;gretl-bundle name="temp"&gt;
          &lt;bundled-item key="s" type="string"&gt;moo&lt;/bundled-item&gt;
          &lt;bundled-item key="x" type="scalar"&gt;3&lt;/bundled-item&gt;
	  &lt;/gretl-bundle&gt;
	</code>
	<para>
	  As you may expect, such files are generated automatically by the
	  companion function <fncref targ="bwrite"/>.
	</para>
	<para>
	  If the file name does not contain a full path specification,
	  it will be looked for in several <quote>likely</quote>
	  locations, beginning with the currently set <cmdref
	  targ="workdir"/>. However, if a non-zero value is given for
	  the optional <argname>import</argname> argument, the input
	  file is looked for in the user's <quote>dot</quote>
	  directory. In this case the <argname>fname</argname>
	  argument should be a plain filename, without any path
	  component.
	</para>
	<para>
	  Should an error occur (such as the file being badly formatted or
	  inaccessible), an error is returned via the <fncref
	  targ="$error"/> accessor.
	</para>
	<para>
	  <seelist>
            <fncref targ="mread"/>
            <fncref targ="bwrite"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="bwfilt" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int">n</fnarg>
	<fnarg type="scalar">omega</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the result from application of a low-pass
	  Butterworth filter with order <argname>n</argname> and
	  frequency cutoff <argname>omega</argname> to the series
	  <argname>y</argname>. The cutoff is expressed in degrees and
	  must be greater than 0 and less than 180. Smaller cutoff
	  values restrict the pass-band to lower frequencies and hence
	  produce a smoother trend. Higher values of
	  <argname>n</argname> produce a sharper cutoff, at the cost
	  of possible numerical instability. 
	</para>
	<para>
	  Inspecting the periodogram of the target series is a
	  useful preliminary when you wish to apply this function.
	  See <guideref targ="chap:tsfilter"/> for details.
	  <seelist>
            <fncref targ="bkfilt"/>
            <fncref targ="hpfilt"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="bwrite" section="data-utils" output="int">
      <fnargs>
	<fnarg type="bundle">B</fnarg>
	<fnarg type="string">fname</fnarg>
	<fnarg optional="true" type="bool">export</fnarg>
      </fnargs>
      <description>
	<para>
	  Writes the bundle <argname>B</argname> to an XML file named
	  <argname>fname</argname>. For a summary description of its
	  format, see <fncref targ="bread"/>. If file
	  <argname>fname</argname> already exists, it will be
	  overwritten. The return value is 0 on successful completion; if
	  an error occurs, such as the file being unwritable, the return
	  value will be non-zero.
	</para>
	<para>
	  The output file will be written in the currently set <cmdref
	  targ="workdir"/>, unless the <repl>filename</repl> string
	  contains a full path specification. However, if a non-zero
	  value is given for the <argname>export</argname> argument,
	  the output file will be written into the user's
	  <quote>dot</quote> directory. In this case a plain filename,
	  without any path component, should be given for the second
	  argument.
	</para>
	<para>
	  <seelist>
            <fncref targ="bread"/>
            <fncref targ="mwrite"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cdemean" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Centers the columns of matrix <argname>X</argname> around their
	  means.
	</para>
      </description>
    </function>

    <function name="cdf" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <examples>
	<example>p1 = cdf(N, -2.5)</example>
	<example>p2 = cdf(X, 3, 5.67)</example>
	<example>p3 = cdf(D, 0.25, -1, 1)</example>
      </examples>
      <description>
	<para>
	  Cumulative distribution function calculator. Returns
	  <equation status="inline" ascii="P(X &le; x)" tex="$P(X \le
	  x)$"/>, where the distribution of <math>X</math> is
	  determined by the string <argname>d</argname>. Between
	  the arguments <argname>d</argname> and <argname>x</argname>,
	  zero or more additional scalar arguments are required to
	  specify the parameters of the distribution, as follows (but
	  note that the normal distribution has its own convenience
	  function, <fncref targ="cnorm"/>).
	</para>
	<ilist context="notex">
	  <li>
            <para>
              Standard normal (c = z, n, or N): no extra arguments
            </para>
	  </li>
	  <li>
            <para>
              Bivariate normal (D): correlation coefficient
            </para>
	  </li>
	  <li>
            <para>
              Student's t (t): degrees of freedom
            </para>
	  </li>
	  <li>
            <para>
              Chi square (c, x, or X): degrees of freedom
            </para>
	  </li>
	  <li>
            <para>
              Snedecor's F (f or F): df (num.); df (den.)
            </para>
	  </li>
	  <li>
            <para>
              Gamma (g or G): shape; scale
            </para>
	  </li>   
	  <li>
            <para>
              Binomial (b or B): probability; number of trials
            </para>
	  </li>   
	  <li>
            <para>
              Poisson (p or P): Mean
            </para>
	  </li> 
	  <li>
            <para>
              Weibull (w or W): shape; scale
            </para>
	  </li> 
	  <li>
            <para>
              Generalized Error (E): shape
            </para>
	  </li>
	  <li>
	    <para>
	      Non-central chi square (ncX): df, non-centrality parameter
	    </para>
	  </li>
	  <li>
	    <para>
	      Non-central F (ncF): df (num.), df (den.),
	      non-centrality parameter
	    </para>
	  </li>
	  <li>
	    <para>
	      Non-central t (nct): df, non-centrality parameter
	    </para>
	  </li>	  
	</ilist>
	<para context="tex">
	  \begin{center} 
	  \begin{tabular}{lllll} 
	  \textit{Distribution} &amp; \textsl{d} &amp;
	  \textit{Arg} 2 &amp; \textit{Arg} 3 &amp; \textit{Arg} 4 \\[4pt] 
	  Standard normal &amp; \texttt{z}, \texttt{n} or \texttt{N} &amp; 
	  -- &amp; -- &amp; --\\ 
	  Bivariate normal &amp; \texttt{D} &amp; 
	  $\rho$ &amp; -- &amp; --\\ 
	  Student's $t$ (central) &amp; \texttt{t} &amp;  
	  df &amp; -- &amp; --\\ 
	  Chi square &amp; \texttt{c}, \texttt{x} or \texttt{X} &amp; 
	  df &amp; -- &amp; --\\ 
	  Snedecor's $F$ &amp; \texttt{f} or \texttt{F} &amp;
	  df (num.) &amp; df (den.) &amp; --\\ 
	  Gamma &amp; \texttt{g} or \texttt{G} &amp;
	  shape &amp; scale &amp; --\\ 
	  Binomial &amp; \texttt{b} or \texttt{B} &amp;
	  probability &amp; trials &amp; --\\ 
	  Poisson &amp; \texttt{p} or \texttt{P} &amp; 
	  mean &amp; -- &amp; --\\
	  Weibull &amp; \texttt{w} or \texttt{W} &amp; 
	  shape &amp; scale &amp; --\\
	  Generalized Error &amp; \texttt{E} &amp; 
	  shape &amp; -- &amp; --\\
	  Non-central $\chi^2$ &amp; \texttt{ncX} &amp; 
	  df &amp; non-centrality &amp; -- \\
	  Non-central $F$ &amp; \texttt{ncF} &amp; 
	  df (num.) &amp; df (den.) &amp; non-centrality \\
	  Non-central $t$ &amp; \texttt{nct} &amp; 
	  df &amp; non-centrality &amp; -- \\
	  \end{tabular}
	  \end{center}
	</para>
	<para>
	  Note that most cases have aliases to help memorizing the codes.
	  The bivariate normal case is special: the syntax is <lit>x =
          cdf(D, rho, z1, z2)</lit> where <lit>rho</lit> is the
	  correlation between the variables <lit>z1</lit> and
	  <lit>z2</lit>.
	</para>
	<para context="tex">
	  The parametrization \app{gretl} uses for the Gamma random variate
	  implies that its density function can be written as
	  \[
	  f(x; k, \theta) = \frac{x^{k-1}}{\theta^k} \frac{e^{-x/\theta}}{\Gamma(k)}
	  \]
	  where $k>0$ is the shape parameter and $\theta>0$ is the scale
	  parameter.
	</para>
	<para>
	  <seelist>
            <fncref targ="pdf"/>
            <fncref targ="critical"/>
            <fncref targ="invcdf"/>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cdiv" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">Y</fnarg>
      </fnargs>
      <description>
	<para>
	  Complex division. The two arguments must have the same number of
	  rows, <math>n</math>, and either one or two columns.  The first
	  column contains the real part and the second (if present) the
	  imaginary part.  The return value is an <by r="n" c="2"/>
	  matrix or, if the result has no imaginary part, an
	  <math>n</math>-vector.
	  <seelist>
            <fncref targ="cmult"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ceil" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Ceiling function: returns the smallest integer greater than or
	  equal to <argname>x</argname>. 
	  <seelist> 
            <fncref targ="floor"/>
            <fncref targ="int"/>
	  </seelist>
	</para>
      </description>
    </function>  

    <function name="cholesky" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="pdmat">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Peforms a Cholesky decomposition of the matrix
	  <argname>A</argname>, which is assumed to be symmetric and
	  positive definite. The result is a lower-triangular matrix
	  <math>L</math> which satisfies <equation status="inline"
	  ascii="A = LL'"  tex="$A = LL'$"/>. The function will fail if
	  <argname>A</argname> is not symmetric or not positive definite.
	  <seelist> 
            <fncref targ="psdroot"/>
	  </seelist>
	</para> 
      </description>
    </function>

    <function name="chowlin" section="transforms" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="int">xfac</fnarg>
	<fnarg type="matrix" optional="true">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Expands the input data, <argname>Y</argname>, to a higher
	  frequency, using the interpolation method of <cite
	  key="chowlin71">Chow and Lin (1971)</cite>. It is
	  assumed that the columns of <argname>Y</argname>
	  represent data series; the returned matrix has as many columns
	  as <argname>Y</argname> and <argname>xfac</argname> times
	  as many rows.
	</para>
	<para>
	  The second argument represents the expansion factor: it should
	  be 3 for expansion from quarterly to monthly or 4 for expansion
	  from annual to quarterly, these being the only supported
	  factors. The optional third argument may be used to provide a
	  matrix of covariates at the higher (target) frequency.
	</para>
	<para>
	  The regressors used by default are a constant and quadratic
	  trend. If <argname>X</argname> is provided, its columns are
	  used as additional regressors; it is an error if the number of
	  rows in <argname>X</argname> does not equal
	  <argname>xfac</argname> times the number of rows in
	  <argname>Y</argname>.
	</para>
      </description>
    </function>

    <function name="cmult" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">Y</fnarg>
      </fnargs>
      <description>
	<para>
	  Complex multiplication. The two arguments must have the same
	  number of rows, <math>n</math>, and either one or two columns.
	  The first column contains the real part and the second (if
	  present) the imaginary part.  The return value is an
	  <by r="n" c="2"/> matrix, or, if the result has no imaginary
	  part, an <math>n</math>-vector. 
	  <seelist>
            <fncref targ="cdiv"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cnorm" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the cumulative distribution function for a standard
	  normal. 
	  <seelist>
            <fncref targ="dnorm"/>
            <fncref targ="qnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="colname" section="strings" output="string">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="int">col</fnarg>
      </fnargs>
      <description>
	<para>
	  Retrieves the name for column <argname>col</argname> of
	  matrix <argname>M</argname>. If <argname>M</argname> has
	  no column names attached the value returned is an empty
	  string; if <argname>col</argname> is out of bounds for
	  the given matrix an error is flagged. See also
	  <fncref targ="colnames"/>.
	</para>
	<para>
	  Example:
	</para>
	<code>
	  matrix A = { 11, 23, 13 ; 54, 15, 46 }
	  colnames(A, "Col_A Col_B Col_C")
	  string name = colname(A, 3)
	  print name
	</code>
      </description>
    </function>

    <function name="colnames" section="matbuild" output="scalar">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="strings-or-list">S</fnarg>
      </fnargs>
      <description>
	<para>
	  Attaches names to the columns of the <by r="T" c="k"/>
	  matrix <argname>M</argname>. If <argname>S</argname> is a
	  named list, the names are taken from the names of the listed
	  series; the list must have <math>k</math> members. If
	  <argname>S</argname> is an array of strings, it should
	  contain <math>k</math> elements. For backward
	  caompatibility, a single string may also be given as the
	  second argument; in that case it should contain
	  <math>k</math> space-separated substrings.
	</para>
	<para>
	  The return value is 0 on successful completion, non-zero on
	  error. See also <fncref targ="rownames"/>.
	</para>
	<para>
	  Example:
	</para>
	<code>
	  matrix M = {1, 2; 2, 1; 4, 1}
	  strings S = array(2)
	  S[1] = "Col1"
	  S[2] = "Col2"
	  colnames(M, S)
	  print M
	</code>
      </description>
    </function>

    <function name="cols" section="matshape" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the number of columns of <argname>X</argname>. 
	  <seelist> 
            <fncref targ="mshape"/>
            <fncref targ="rows"/>
            <fncref targ="unvech"/>
            <fncref targ="vec"/> 
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="corr" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y1</fnarg>
	<fnarg type="series-or-vec">y2</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes the correlation coefficient between <argname>y1</argname>
	  and <argname>y2</argname>. The arguments should be either 
	  two series, or two vectors of the same length.
	  <seelist> 
            <fncref targ="cov"/>
            <fncref targ="mcov"/>
            <fncref targ="mcorr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="corrgm" section="stats" output="matrix">
      <fnargs>
	<fnarg type="smlist">x</fnarg>
	<fnarg type="int">p</fnarg>
	<fnarg optional="true" type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  If only the first two arguments are given, computes the correlogram
	  for <argname>x</argname> for lags 1 to <argname>p</argname>.  Let
	  <math>k</math> represent the number of elements in
	  <argname>x</argname> (1 if <argname>x</argname> is a series, the
	  number of columns if <argname>x</argname> is a matrix, or the number
	  of list-members is <argname>x</argname> is a list).  The return
	  value is a matrix with <argname>p</argname> rows and 2<math>k</math>
	  columns, the first <math>k</math> columns holding the respective
	  autocorrelations and the remainder the respective partial
	  autocorrelations.
	</para>
	<para>
	  If a third argument is given, this function computes the
	  cross-correlogram for each of the <math>k</math> elements in
	  <argname>x</argname> and <argname>y</argname>, from lead
	  <argname>p</argname> to lag <argname>p</argname>. The returned
	  matrix has 2<math>p</math> + 1 rows and <math>k</math> columns.
          If <argname>x</argname> is series or list and <argname>y</argname>
          is a vector, the vector must have just as many rows as there
          are observations in the current sample range.
	</para>
      </description>
    </function>

    <function name="cos" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the cosine of <argname>x</argname>.
	</para>
      </description>
    </function>

    <function name="cosh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the hyperbolic cosine of <argname>x</argname>.
	</para>
	<para context="tex">
	  \[ \cosh x = \frac{e^x + e^{-x}}{2}  \]
	</para>
	<para>
	  <seelist>
            <fncref targ="acosh"/>
            <fncref targ="sinh"/>
            <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="cov" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y1</fnarg>
	<fnarg type="series-or-vec">y2</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the covariance between <argname>y1</argname> and
	  <argname>y2</argname>. The arguments should be either 
	  two series, or two vectors of the same length.
	  <seelist> 
            <fncref targ="corr"/> 
            <fncref targ="mcov"/>
            <fncref targ="mcorr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="critical" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="char">c</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">p</fnarg>
      </fnargs>
      <examples>
	<example>c1 = critical(t, 20, 0.025)</example>
	<example>c2 = critical(F, 4, 48, 0.05)</example>
      </examples>
      <description>
	<para>
	  Critical value calculator. Returns <math>x</math> such that
	  <equation status="inline" ascii="P(X &gt; x) = p"  
		    tex="$P(X &gt; x) = p$"/>, where the distribution <math>X</math> is
	  determined by the character <argname>c</argname>. Between the
	  arguments <argname>c</argname> and <argname>p</argname>, zero or
	  more additional scalar arguments are required to specify the
	  parameters of the distribution, as follows.
	</para>
	<ilist context="notex">
	  <li>
            <para>
              Standard normal (c = z, n, or N): no extra arguments
            </para>
	  </li>
	  <li>
            <para>
              Student's t (t): degrees of freedom
            </para>
	  </li>
	  <li>
            <para>
              Chi square (c, x, or X): degrees of freedom
            </para>
	  </li>
	  <li>
            <para>
              Snedecor's F (f or F): df (num.); df (den.)
            </para>
	  </li>
	  <li>
            <para>
              Binomial (b or B): probability; trials
            </para>
	  </li>
	  <li>
            <para>
              Poisson (p or P): mean
            </para>
	  </li>
	</ilist>
	<para context="tex">
	  \begin{center} 
	  \begin{tabular}{llll} 
	  \textit{Distribution} &amp; \textsl{c} &amp;
	  \textit{Arg} 2 &amp; \textit{Arg} 3 \\[4pt]
	  Standard normal &amp; \texttt{z}, \texttt{n} or \texttt{N} &amp;
	  -- &amp; -- \\ 
	  Student's $t$ (central) &amp; \texttt{t} &amp; 
	  degrees of freedom &amp; -- \\ 
	  Chi square &amp; \texttt{c}, \texttt{x} or \texttt{X} &amp; 
	  degrees of freedom &amp; -- \\
	  Snedecor's $F$ &amp; \texttt{f} or \texttt{F} &amp; 
	  df (num.) &amp; df (den.) \\ 
	  Binomial &amp; \texttt{b} or \texttt{B} &amp; 
	  $p$ &amp; $n$ \\ 
	  Poisson &amp; \texttt{p} or \texttt{P} &amp; 
	  $\lambda$ &amp; -- \\ 
	  \end{tabular}
	  \end{center}
	</para>
	<para>
	  <seelist>
            <fncref targ="cdf"/>
            <fncref targ="invcdf"/>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>  

    <function name="cum" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Cumulates <argname>x</argname> (that is, creates a running
	  sum). When <argname>x</argname> is a series, produces a
	  series <math>y</math> each of whose elements is the sum of
	  the values of <argname>x</argname> to date; the starting
	  point of the summation is the first non-missing observation
	  in the currently selected sample. When <argname>x</argname>
	  is a matrix, its elements are cumulated by columns.
	</para>
	<para context="tex">
	  Cumulates <argname>x</argname>. When <math>x</math> is a series,
	  produces a series $y_t = \sum_{s=m}^t x_s$; the starting point of
	  the summation, <math>m</math>, is the first non-missing observation
	  of the currently selected sample.  If any missing values are
	  encountered in <math>x</math>, subsequent values of <math>y</math>
	  will be set to missing. When <argname>x</argname> is a matrix, its
	  elements are cumulated by columns.
	</para>
	<para>
	  <seelist>
            <fncref targ="diff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="curl" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="bundleref">&amp;b</fnarg>
      </fnargs>
      <description>
	<para>
	  Provides a somewhat flexible means of obtaining a text
	  buffer containing data from an internet server, using
	  libcurl. On input the bundle <argname>b</argname> must
	  contain a string named <lit>URL</lit> which gives the full
	  address of the resource on the target host. Other optional
	  elements are as follows.
	</para>
	<ilist>
	  <li>
	    <para> 
	      <quote><lit>header</lit></quote>: a string specifying
	      an HTTP header to be sent to the host.
	    </para>
	  </li>
	  <li>
	    <para> 
	      <quote><lit>postdata</lit></quote>: a string holding
	      data to be sent to the host.
	    </para>
	  </li>
	</ilist>
	<para>
	  The <lit>header</lit> and <lit>postdata</lit> fields are
	  intended for use with an HTTP <lit>POST</lit> request; if
	  <lit>postdata</lit> is present the <lit>POST</lit> method is
	  implicit, otherwise the <lit>GET</lit> method is
	  implicit. (But note that for straightforward <lit>GET</lit>
	  requests <fncref targ="readfile"/> offers a simpler
	  interface.)
	</para>
	<para>
	  One other optional bundle element is recognized: if a scalar
	  named <lit>include</lit> is present and has a non-zero value,
	  this is taken as a request to include the header received
	  from the host with the output body.
	</para>
	<para>
	  On completion of the request, the text received from the
	  server is added to the bundle under the key
	  <quote><lit>output</lit></quote>.
	</para>
	<para>
	  If an error occurs in formulating the request (for example
	  there's no <lit>URL</lit> on input) the function fails,
	  otherwise it returns 0 if the request succeeds or non-zero if
	  it fails, in which case the error message from the curl
	  library is added to the bundle under the key
	  <quote><lit>errmsg</lit></quote>.  Note, however, that
	  <quote>success</quote> in this sense does not necessarily
	  mean you got the data you wanted; all it means is that some
	  response was received from the server. You must check the
	  content of the output buffer (which may in fact be a message
	  such as <quote>Page not found</quote>).
	</para>
	<para>
	  Here is an example of use: downloading some data from the
	  US Bureau of Labor Statistics site, which requires sending
	  a JSON query. Note the use of <cmdref targ="sprintf"/> to
	  embed double-quotes in the <lit>POST</lit> data.
	</para>
	<code>
	  bundle req
	  req.URL = "http://api.bls.gov/publicAPI/v1/timeseries/data/"
	  req.include = 1
	  req.header = "Content-Type: application/json"
	  string s = sprintf("{\"seriesid\":[\"LEU0254555900\"]}")
	  req.postdata = s
	  err = curl(&amp;req)
	  if err == 0
	      s = req.output
	      string line
	      loop while getline(s, line) --quiet
	          printf "%s\n", line
	      endloop
	  endif
	</code>
	<para>
	  See also the <fncref targ="jsonget"/> function for means of
	  processing JSON data received.
	</para>
      </description>
    </function>

    <function name="defarray" section="data-utils" output="seebelow">
      <fnargs>
	<fnarg type="varargs"/>
      </fnargs>
      <description>
	<para>
	  Enables the definition of an array variable <emphasis>in
	  extenso</emphasis>, by providing one or more elements.  In
	  using this function you must specify a type (in plural form)
	  for the array: <lit>strings</lit>, <lit>matrices</lit>,
	  <lit>bundles</lit> or <lit>lists</lit>. Each of the
	  arguments must evaluate to an object of the specified
	  type. On successful completion, the return value is an array
	  of <math>n</math> elements, where <math>n</math> is the
	  number of arguments.
	</para>
	<code>
	  strings S = defarray("foo", "bar", "baz")
	  matrices M = defarray(I(3), X'X, A*B, P[1:])
	</code>
	<para>
	  See also <fncref targ="array"/>.
	</para>
      </description>
    </function>        

    <function name="deseas" section="filters" output="series">
      <fnargs>
	<fnarg type="series">x</fnarg>
	<fnarg optional="true" type="char">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Depends on having TRAMO/SEATS or X-12-ARIMA installed. Returns a
	  deseasonalized (seasonally adjusted) version of the input series
	  <argname>x</argname>, which must be a quarterly or monthly time
	  series.  To use X-12-ARIMA give <lit>X</lit> as the second argument;
	  to use TRAMO give <lit>T</lit>.  If the second argument is omitted
	  then X-12-ARIMA is used.
	</para>
	<para>
	  Note that if the input series has no detectable seasonal
	  component this function will fail.  Also note that both
	  TRAMO/SEATS and X-12-ARIMA offer numerous options;
	  <lit>deseas</lit> calls them with all options at their default
	  settings. For both programs, the seasonal factors are calculated
	  on the basis of an automatically selected ARIMA model. One
	  difference between the programs which can sometimes make a
	  substantial difference to the results is that by default TRAMO
	  performs a prior adjustment for outliers while X-12-ARIMA does
	  not.
	</para>
      </description>
    </function>

    <function name="det" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the determinant of <argname>A</argname>, computed via the
	  LU factorization.
	  <seelist> 
            <fncref targ="ldet"/>
            <fncref targ="rcond"/>
	  </seelist>
	</para>
      </description>
    </function>  

    <function name="diag" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the principal diagonal of <argname>X</argname> in a
	  column vector. Note: if <argname>X</argname> is an
	  <by r="m" c="n"/> matrix, the number of elements
	  of the output vector is min(<math>m</math>, <math>n</math>).
	  <seelist>
            <fncref targ="tr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="diagcat" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix">B</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the direct sum of <argname>A</argname> and
	  <argname>B</argname>, that is a matrix holding
	  <argname>A</argname> in its north-west corner and
	  <argname>B</argname> in its south-east corner. If both
	  <argname>A</argname> and <argname>B</argname> are square,
	  the resulting matrix is block-diagonal.
	</para>
      </description>
    </function>

    <function name="diff" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="smlist">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes first differences.  If <argname>y</argname> is a series, or
	  a list of series, starting values are set to <lit>NA</lit>.  If
	  <argname>y</argname> is a matrix, differencing is done by columns
	  and starting values are set to 0. 
	</para>
	<para> 
	  When a list is returned, the individual variables are
	  automatically named according to the template
	  <lit>d_</lit>
	  <repl>varname</repl> where <repl>varname</repl> is the
	  name of the original series.  The name is truncated if necessary,
	  and may be adjusted in case of non-uniqueness in the set of names
	  thus constructed.
	</para> 
	<para>
	  <seelist>
            <fncref targ="cum"/>
            <fncref targ="ldiff"/>
            <fncref targ="sdiff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="digamma" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>    
      <description>
	<para context="notex">
	  Returns the digamma (or Psi) function of
	  <argname>x</argname>, that is the derivative of the log of
	  the Gamma function.
	</para>
	<para context="tex">
	  Returns the digamma (or Psi) function of $x$, that is 
	  $\frac{\mathrm{d} \Gamma(x)}{\mathrm{d} x}$.
	</para>
      </description>
    </function>

    <function name="dnorm" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the density of the standard normal distribution at
	  <argname>x</argname>.  To get the density for a non-standard
	  normal distribution at <math>x</math>, pass the
	  <math>z</math>-score of <math>x</math> to the <lit>dnorm</lit>
	  function and multiply the result by the Jacobian of the
	  <math>z</math> transformation, namely 1 over &sigma;, as
	  illustrated below:
	</para>
	<code>
	  mu = 100
	  sigma = 5
	  x = 109
	  fx = (1/sigma) * dnorm((x-mu)/sigma)
	</code>
	<para>
	  <seelist>
            <fncref targ="cnorm"/>
            <fncref targ="qnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="dropcoll" section="transforms" output="list">
      <fnargs>
	<fnarg type="list">X</fnarg>
	<fnarg optional="true" type="scalar">epsilon</fnarg>
      </fnargs>     
      <description>
	<para>
	  Returns a list with the same elements as
	  <argname>X</argname>, but for the collinear
	  series. Therefore, if all the series in <argname>X</argname>
	  are linearly independent, the output list is just a copy of
	  <argname>X</argname>.
	</para>
	<para>
	  The algorithm uses the QR decomposition (Householder
	  transformation), so it is subject to finite precision
	  error. In order to gauge the sensitivity of the algorithm, a
	  second optional parameter <argname>epsilon</argname> may be
	  specified to make the collinearity test more or less strict,
	  as desired. The default value for <argname>epsilon</argname>
	  is 1.0e-8. Setting <argname>epsilon</argname> to a larger
	  value increases the probability of a series to be dropped.
	</para>
	<para>
	  Example:
	</para>
	<code>
	  nulldata 20
	  set seed 9876
	  series foo = normal()
	  series bar = normal()
	  series foobar = foo + bar
	  list X = foo bar foobar
	  list Y = dropcoll(X)
	  list print X
	  list print Y
	  # set epsilon to a ridiculously small value
	  list Y = dropcoll(X, 1.0e-30)
	  list print Y
	</code>
	<para>
	  produces
	</para>
	<code>
	  ? list print X
	  foo bar foobar 
	  ? list print Y
	  foo bar 
	  ? list Y = dropcoll(X, 1.0e-30)
	  Replaced list Y
	  ? list print Y
	  foo bar foobar 
	</code>
      </description>
    </function>    

    <function name="dsort" section="matshape" output="asinput">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Sorts <argname>x</argname> in descending order, skipping
	  observations with missing values when <argname>x</argname> is a
	  series. 
	  <seelist> 
            <fncref targ="sort"/>
            <fncref targ="values"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="dummify" section="transforms" output="list">
      <fnargs>
	<fnarg type="series">x</fnarg>
	<fnarg optional="true" type="scalar">omitval</fnarg>
      </fnargs>
      <description>
	<para>
	  The argument <argname>x</argname> should be a discrete
	  series. This function creates a set of dummy variables
	  coding for the distinct values in the series.  By default
	  the smallest value is taken as the omitted category and is
	  not explicitly represented.
	</para>
	<para>
	  The optional second argument represents the value of
	  <argname>x</argname> which should be treated as the omitted
	  category. The effect when a single argument is given is
	  equivalent to <lit>dummify(x, min(x))</lit>.  To produce a
	  full set of dummies, with no omitted category, use
	  <lit>dummify(x, NA)</lit>.
	</para>
	<para> 
	  The generated variables are automatically named according to
	  the template
	  <lit>D</lit><repl>varname</repl><lit>_</lit><repl>i</repl>
	  where <repl>varname</repl> is the name of the original
	  series and <repl>i</repl> is a 1-based index.  The original
	  portion of the name is truncated if necessary, and may be
	  adjusted in case of non-uniqueness in the set of names thus
	  constructed.
	</para>
      </description>
    </function>

    <function name="easterday" section="calendar" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Given the year in argument <argname>x</argname>, returns the
	  date of Easter in the Gregorian calendar as <math> month +
	  day/100</math>. Note that April the 10th, is, under this
	  convention, 4.1; hence, 4.2 is April the 20th, not April the
	  2nd (which would be 4.02).
	</para>
	<code>
	  scalar e = easterday(2014)
	  scalar m = floor(e)
	  scalar d = 100*(e-m)
	</code>
      </description>
    </function>

    <function name="eigengen" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes the eigenvalues, and optionally the right eigenvectors, of
	  the <by r="n" c="n"/> matrix <argname>A</argname>.  If all the
	  eigenvalues are real an <by r="n" c="1"/> matrix is returned;
	  otherwise the result is an <by r="n" c="2"/> matrix, the first
	  column holding the real components and the second column the
	  imaginary components. The eigenvalues are not guaranteed to
	  be sorted in any particular order.
	</para>
	<para>
	  The second argument must be either the name of an existing
	  matrix preceded by <lit>&amp;</lit> (to indicate the
	  <quote>address</quote> of the matrix in question), in which case
	  an auxiliary result is written to that matrix, or the keyword
	  <lit>null</lit>, in which case the auxiliary result is not
	  produced.
	</para>
	<para>
	  If a non-null second argument is given, the specified matrix
	  will be over-written with the auxiliary result.  (It is not
	  required that the existing matrix be of the right dimensions to
	  receive the result.) It will be organized as follows:
	</para>
	<ilist>
	  <li>
            <para>
              If the <math>i</math>-th eigenvalue is real, the
              <math>i</math>-th column of <math>U</math> will contain the
              corresponding eigenvector;
            </para>
	  </li>
	  <li>
            <para>
              If the <math>i</math>-th eigenvalue is complex, the
              <math>i</math>-th column of <argname>U</argname> will
              contain the real part of the corresponding eigenvector and
              the next column the imaginary part. The eigenvector for the
              conjugate eigenvalue is the conjugate of the eigenvector.
            </para>
	  </li>
	</ilist>
	<para>
	  In other words, the eigenvectors are stored in the same order as
	  the eigenvalues, but the real eigenvectors occupy one column,
	  whereas complex eigenvectors take two (the real part comes
	  first); the total number of columns is still <math>n</math>,
	  because the conjugate eigenvector is skipped.
	</para>
	<para>
	  <seelist>
            <fncref targ="eigensym"/>
            <fncref targ="eigsolve"/>
            <fncref targ="qrdecomp"/>
            <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="eigensym" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="symmat">A</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Works just as <fncref targ="eigengen"/>, but the argument
	  <argname>A</argname> must be symmetric (in which case the
	  calculations can be reduced). Unlike <fncref
	  targ="eigengen"/>, eigenvalues are returned in ascending
	  order.
	</para>
	<para>
	  Note: if you're interested in the eigen-decomposition of a
	  matrix of the form <math>X'X</math>, where <math>X</math> is
	  a large matrix, it is preferable to compute it via the prime
	  operator <lit>X'X</lit> rather than using the more general
	  syntax <lit>X'*X</lit>. The former expression uses a
	  specialized algorithm which has the double advantage of
	  being more efficient computationally and of ensuring that
	  the result will be free by construction of machine precision
	  artifacts that may render it numerically non-symmetric.
	</para>
      </description>
    </function>

    <function name="eigsolve" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="symmat">A</fnarg>
	<fnarg type="symmat">B</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Solves the generalized eigenvalue problem |<math>A</math>
	  &minus; &lgr;<math>B</math>| = 0, where both <math>A</math>
	  and <math>B</math> are symmetric and <math>B</math> is
	  positive definite. The eigenvalues are returned directly,
	  arranged in ascending order. If the optional third argument
	  is given it should be the name of an existing matrix
	  preceded by <lit>&amp;</lit>; in that case the generalized
	  eigenvectors are written to the named matrix.
	</para>
      </description>
    </function>

    <function name="epochday" section="calendar" output="scalar-or-series">
      <fnargs>
	<fnarg type="scalar-or-series">year</fnarg>
	<fnarg type="scalar-or-series">month</fnarg>
	<fnarg type="scalar-or-series">day</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the number of the day in the current epoch specified
	  by year, month and day. The epoch day equals 1 for the first
	  of January in the year 1 AD; it stood at 733786 on
	  2010-01-01. If any of the arguments are given as series the
	  value returned is a series, otherwise it is a scalar.
	</para>
	<para>
	  For the inverse function, see <fncref targ="isodate"/>.
	</para>
      </description>
    </function>

    <function name="errmsg" section="strings" output="string">
      <fnargs>
	<fnarg type="int">errno</fnarg>
      </fnargs>
      <description>
	<para>
	  Retrieves the gretl error message associated with
	  <argname>errno</argname>. See also <fncref
	  targ="$error"/>.
	</para>
      </description>
    </function>

    <function name="exists" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">name</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns 1 if <argname>name</argname> is the identifier for a
	  currently defined object, be it a scalar, a series, a matrix,
	  list, string, bundle or array; otherwise returns 0.
	</para>
      </description>
    </function>    

    <function name="exp" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns <math>e</math><sup>x</sup>. Note that in case of
	  matrices the function acts element by element. For the
	  matrix exponential function, see <fncref targ="mexp"/>.
	</para>
      </description>
    </function>

    <function name="fcstats" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="series-or-vec">f</fnarg>
      </fnargs>
      <description>
	<para>
	  Produces a column vector holding several statistics which may be
	  used for evaluating the series <argname>f</argname> as a
	  forecast of the series <argname>y</argname> over the current
	  sample range. Two vectors of the same length may be given in
	  place of two series arguments.
	</para>
	<para>
	  The layout of the returned vector is as follows:
	</para>
	<code>
	  1  Mean Error (ME)
	  2  Mean Squared Error (MSE)
	  3  Mean Absolute Error (MAE)
	  4  Mean Percentage Error (MPE)
	  5  Mean Absolute Percentage Error (MAPE)
	  6  Theil's U 
	  7  Bias proportion, UM
	  8  Regression proportion, UR
	  9  Disturbance proportion, UD
	</code>
	<para>
	  For details on the calculation of these statistics, and the
	  interpretation of the <math>U</math> values, please see 
	  <guideref targ="chap:forecast"/>.
	</para>
      </description>
    </function>

    <function name="fdjac" section="numerical" output="matrix">
      <fnargs>
	<fnarg type="cvec">b</fnarg>
	<fnarg type="fncall">fcall</fnarg>
      </fnargs> 
      <description>
	<para>
	  Calculates a numerical approximation to the Jacobian
	  associated with the <math>n</math>-vector
	  <argname>b</argname> and the transformation function
	  specified by the argument <argname>fcall</argname>.  The
	  function call should take <argname>b</argname> as its first
	  argument (either straight or in pointer form), followed by
	  any additional arguments that may be needed, and it should
	  return an <by r="m" c="1"/> matrix. On successful completion
	  <lit>fdjac</lit> returns an <by r="m" c="n"/> matrix holding
	  the Jacobian. Example:
	</para>
	<code>
	  matrix J = fdjac(theta, myfunc(&amp;theta, X))
	</code>
	<para>
	  The function can use three different methods: simple
	  forward-difference, bilateral difference or 4-nodes
	  Richardson extrapolation. Respectively:
	</para>
	<para context="tex">
	  \[ J_0 = \frac{f(x + h) - f(x)}{h} \]
	</para>
	<para context="tex">
	  \[ J_1 = \frac{f(x + h) - f(x - h)}{2h} \]
	</para>
	<para context="tex">
	  \[ J_2 = \frac{8(f(x+h) - f(x-h)) - (f(x+2h) - f(x-2h))}{12h} \]
	</para>
	<para context="notex">
	  <math>J</math><sub>0</sub> = <math>(f(x+h) - f(x))/h</math>
	</para>
	<para context="notex">
	  <math>J</math><sub>1</sub> = <math>(f(x+h) - f(x-h))/2h</math>
	</para>
	<para context="notex">
	  <math>J</math><sub>2</sub>  = <math>[8(f(x+h) - f(x-h)) -
	  (f(x+2h) - f(x-2h))] /12h</math>
	</para>
	<para>
	  The three alternatives above provide, generally, a trade-off
	  between accuracy and speed. You can choose among methods by
	  using the <cmdref targ="set"/> command and specify the value
	  0, 1 or 2 for the <lit>fdjac_quality</lit> variable.
	</para>
	<para>
	  For more details and examples see the chapter on numerical
	  methods in <guideref targ="chap:numerical"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="BFGSmax"/>
            <cmdref targ="set"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="fft" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Discrete real Fourier transform. If the input matrix
	  <argname>X</argname> has <math>n</math> columns, the output has
	  2<math>n</math> columns, where the real parts are stored in the
	  odd columns and the complex parts in the even ones.
	</para>
	<para>
	  Should it be necessary to compute the Fourier transform on several
	  vectors with the same number of elements, it is numerically more
	  efficient to group them into a matrix rather than invoking
	  <lit>fft</lit> for each vector separately.  
	  <seelist>
            <fncref targ="ffti"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ffti" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Inverse discrete real Fourier transform. It is assumed that
	  <argname>X</argname> contains <math>n</math> complex column
	  vectors, with the real part in the odd columns and the imaginary
	  part in the even ones, so the total number of columns should be
	  2<math>n</math>. A matrix with <math>n</math> columns is
	  returned.
	</para>
	<para>
	  Should it be necessary to compute the inverse Fourier transform on
	  several vectors with the same number of elements, it is
	  numerically more efficient to group them into a matrix rather
	  than invoking <lit>ffti</lit> for each vector separately.
	  <seelist>
            <fncref targ="fft"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="filter" section="filters" output="series">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
	<fnarg optional="true" type="scalar-or-vec">a</fnarg>
	<fnarg optional="true" type="scalar-or-vec">b</fnarg>
	<fnarg optional="true" type="scalar">y0</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes an ARMA-like filtering of the argument
	  <argname>x</argname>. The transformation can be written as
	</para>
	<para context="tex">
	  \[ y_t = \sum_{i=0}^q a_i x_{t-i} + \sum_{i=1}^p b_i y_{t-i} \]
	</para>
	<para context="notex">
	  <math>y</math><sub>t</sub> = 
	  <math>a</math><sub>0</sub> <math>x</math><sub>t</sub> +
	  <math>a</math><sub>1</sub> <math>x</math><sub>t-1</sub> +
	  ...
	  <math>a</math><sub>q</sub> <math>x</math><sub>t-q</sub> +
	  <math>b</math><sub>1</sub> <math>y</math><sub>t-1</sub> +
	  ...
	  <math>b</math><sub>p</sub><math>y</math><sub>t-p</sub>
	</para>
	<para>
	  If argument <argname>x</argname> is a series, the result
	  will be itself a series. Otherwise, if <argname>x</argname>
	  is a matrix with <math>T</math> rows and <math>k</math>
	  columns, the result will be a matrix of the same size, in
	  which the filtering is performed column by column.
	</para>
	<para>
	  The two arguments <argname>a</argname> and
	  <argname>b</argname> are optional. They may be scalars,
	  vectors or the keyword <lit>null</lit>.
	</para>
	<para>
	  If <argname>a</argname> is a scalar, this is used as
	  <math>a</math><sub>0</sub> and implies <math>q=0</math>; if
	  it is a vector of <math>q+1</math> elements, they contain
	  the coefficients from <math>a</math><sub>0</sub> to
	  <math>a</math><sub>q</sub>. If <argname>a</argname> is
	  <lit>null</lit> or omitted, this is equivalent to setting
	  <math>a</math><sub>0</sub> <math>=1</math> and
	  <math>q=0</math>.
	</para>
	<para>
	  If <argname>b</argname> is a scalar, this is used as
	  <math>b</math><sub>1</sub> and implies <math>p=1</math>; if
	  it is a vector of <math>p</math> elements, they contain the
	  coefficients from <math>b</math><sub>1</sub> to
	  <math>b</math><sub>p</sub>. If <argname>b</argname> is
	  <lit>null</lit> or omitted, this is equivalent to setting
	  <math>B(L)=1</math>.
	</para>
	<para>
	  The optional scalar argument <argname>y0</argname> is taken
	  to represent all values of <math>y</math> prior to the
	  beginning of sample (used only when <math>p>0</math>). If
	  omitted, it is understood to be 0.  Pre-sample values of
	  <argname>x</argname> are always assumed zero.
	</para>
	<para>
	  <seelist> 
            <fncref targ="bkfilt"/>
            <fncref targ="bwfilt"/>
            <fncref targ="fracdiff"/>
            <fncref targ="hpfilt"/>
            <fncref targ="movavg"/>
            <fncref targ="varsimul"/>
	  </seelist>
	</para>
	<para>
	  Example:
	</para>
	<code>
	  nulldata 5
	  y = filter(index, 0.5, -0.9, 1)
	  print index y --byobs
	  x = seq(1,5)' ~ (1 | zeros(4,1))
	  w = filter(x, 0.5, -0.9, 1)
	  print x w
	</code>
	<para>
	  produces
	</para>
	<code>
          index            y   
          
          1            1     -0.40000   
          2            2      1.36000   
          3            3      0.27600   
          4            4      1.75160   
          5            5      0.92356   

          x (5 x 2)
          
          1   1 
          2   0 
          3   0 
          4   0 
          5   0 
          
          w (5 x 2)
          
          -0.40000     -0.40000 
          1.3600      0.36000 
          0.27600     -0.32400 
          1.7516      0.29160 
          0.92356     -0.26244 
	</code>
      </description>
    </function>

    <function name="firstobs" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the 1-based index of the first non-missing
	  observation for the series <argname>y</argname>. Note that
	  if some form of subsampling is in effect, the value returned
	  may be smaller than the dollar variable <fncref
	  targ="$t1"/>.
	  <seelist> 
            <fncref targ="lastobs"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="fixname" section="strings" output="string">
      <fnargs>
	<fnarg type="string">rawname</fnarg>
      </fnargs>
      <description>
	<para>
	  Intended for use in connection with the <cmdref
	  targ="join"/> command.  Returns the result of converting
	  <argname>rawname</argname> to a valid gretl identifier,
	  which must start with a letter, contain nothing but (ASCII)
	  letters, digits and the underscore character, and must not
	  exceed 31 characters. The rules used in conversion are:
	</para>
	<para>
	  1. Skip any leading non-letters.
	</para>
	<para>
	  2. Until the 31-character limit is reached or the input is
	  exhausted: transcribe <quote>legal</quote> characters; skip
	  <quote>illegal</quote> characters apart from spaces; and
	  replace one or more consecutive spaces with an underscore,
	  unless the previous character transcribed is an underscore in
	  which case space is skipped.
	</para>
      </description>
    </function>

    <function name="floor" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">y</fnarg>
      </fnargs>    
      <description>
	<para>
	  Returns the greatest integer less than or equal to
	  <argname>x</argname>. Note: <fncref targ="int"/> and
	  <lit>floor</lit> differ in their effect for negative
	  arguments: <lit>int(-3.5)</lit> gives &minus;3, while
	  <lit>floor(-3.5)</lit> gives &minus;4.
	</para>
      </description>
    </function>

    <function name="fracdiff" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="scalar">d</fnarg>
      </fnargs>    
      <description>
	<para context="notex">
	  Returns the fractional difference of order <argname>d</argname>
	  for the series <argname>y</argname>.
	</para>   
	<para context="tex">
          \[
          \Delta^d y_t = y_t - \sum_{i=1}^{\infty} \psi_i y_{t-i}
          \]
	  where
          \[\psi_i = \frac{\Gamma(i-d)}{\Gamma(-d) \Gamma(i+1)}\]
	</para>
	<para>
	  Note that in theory fractional differentiation is an
	  infinitely long filter. In practice, presample values of
	  <math>y</math><sub>t</sub> are assumed to be zero.
	</para>
	<para>
	  A negative value of <argname>d</argname> can be given, in
	  which case fractional integration is performed.
	</para>	
      </description>
    </function>

    <function name="gammafun" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>    
      <description>
	<para>
	  Returns the gamma function of <argname>x</argname>. 
	</para>
      </description>
    </function>

    <function name="genseries" section="data-utils" output="scalar">
      <fnargs>
	<fnarg type="string">varname</fnarg>
	<fnarg type="series">rhs</fnarg>
      </fnargs>    
      <description>
	<para>
	  Provides the script writer with a convenient means of
	  generating series whose names are not known in advance,
	  and/or creating a series and appending it to a list in a
	  single operation.
	</para>
	<para>
	  The first argument gives the name of the series to create
	  (or modify); this can be a string literal, a string
	  variable, or an expression that evaluates to a string.  The
	  second argument, <argname>rhs</argname> (<quote>right-hand
	  side</quote>), defines the source series: this can be the
	  name of an existing series or an expression that evaluates
	  to a series, as would appear to the right of the equals sign
	  when defining a series in the usual way.
	</para>
	<para>
	  The return value from this function is the ID number of the
	  series in the dataset, a value suitable for inclusion in a
	  list (or &minus;1 on failure).
	</para>
	<para>
	  For example, suppose you want to add <math>n</math> random
	  normal series to the dataset and put them all into a named
	  list. The following will do the job:
	</para>
	<code>
	  list Normals = null
	  loop i=1..n --quiet
	      Normals += genseries(sprintf("norm%d", i), normal())
	  endloop
	</code>
	<para>
	  On completion <lit>Normals</lit> will contain the series
	  <lit>norm1</lit>, <lit>norm2</lit> and so on.
	</para>
      </description>
    </function>

    <function name="getenv" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>    
      <description>
	<para>
	  If an environment variable by the name of
	  <argname>s</argname> is defined, returns the string value of
	  that variable, otherwise returns an empty string.
	  See also <fncref targ="ngetenv"/>.
	</para>
      </description>
    </function>

    <function name="getline" section="strings" output="scalar">
      <fnargs>
	<fnarg type="string">source</fnarg>
	<fnarg type="string">target</fnarg>
      </fnargs>    
      <description>
	<para>
	  This function is used to read successive lines from
	  <argname>source</argname>, which should be a named string
	  variable. On each call a line from the source is written to
	  <argname>target</argname> (which must also be a named string
	  variable), with the newline character stripped off. The
	  valued returned is 1 if there was anything to be read
	  (including blank lines), 0 if the source has been exhausted.
	</para>
	<para>
	  Here is an example in which the content of a text file is
	  broken into lines:
	</para>
	<code>
	  string s = readfile("data.txt")
	  string line
	  scalar i = 1
	  loop while getline(s, line)
	      printf "line %d = '%s'\n", i++, line
	  endloop
	</code>
	<para>
	  In this example we can be sure that the source is exhausted
	  when the loop terminates. If the source might not be
	  exhausted you should follow your regular call(s) to
	  <lit>getline</lit> with a <quote>clean up</quote> call, in which
	  <argname>target</argname> is replaced by <lit>null</lit> (or
	  omitted altogether) as in
	</para>
	<code>
	  getline(s, line) # get a single line
	  getline(s, null) # clean up
	</code>
	<para>
	  Note that although the reading position advances at each call
	  to <lit>getline</lit>, <argname>source</argname> is not modified
	  by this function, only <argname>target</argname>.
	</para>
      </description>
    </function>

    <function name="ghk" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">C</fnarg>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix">B</fnarg>
	<fnarg type="matrix">U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;dP</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes the GHK (Geweke, Hajivassiliou, Keane) approximation to the
	  multivariate normal distribution function; see for example <cite
	  key="geweke91">Geweke (1991)</cite>. The value returned is an <by
	  r="n" c="1"/> vector of probabilities.
	</para>
	<para>
	  The argument <argname>C</argname> (<by r="m" c="m"/>) should give
	  the Cholesky factor (lower triangular) of the covariance
	  matrix of <math>m</math> normal variates.  The arguments
	  <argname>A</argname> and <argname>B</argname> should both be <by
	  r="n" c="m"/>, giving respectively the lower and upper bounds
	  applying to the variates at each of <math>n</math>
	  observations. Where variates are unbounded, this should be indicated
	  using the built-in constant <fncref targ="$huge"/> or its negative.
	</para>
	<para>
	  The matrix <argname>U</argname> should be <by r="m" c="r"/>, with
	  <math>r</math> the number of pseudo-random draws from the uniform
	  distribution; suitable functions for creating <argname>U</argname>
	  are <fncref targ="muniform"/> and <fncref targ="halton"/>.
	</para>
	<para>
	  We illustrate below with a relatively simple case where the
	  multivariate probabilities can be calculated
	  analytically. The series <lit>P</lit> and <lit>Q</lit>
	  should be numerically very similar to one another,
	  <lit>P</lit> being the <quote>true</quote> probability and
	  <lit>Q</lit> its GHK approximation:
	</para>
	<code>
	  nulldata 20
	  series inf1 = -2*uniform()
	  series sup1 = 2*uniform()
	  series inf2 = -2*uniform()
	  series sup2 = 2*uniform()

	  scalar rho = 0.25
	  matrix V = {1, rho; rho, 1}

	  series P = cdf(D, rho, inf1, inf2) - cdf(D, rho, sup1, inf2) \
	  - cdf(D, rho, inf1, sup2) + cdf(D, rho, sup1, sup2)

	  C = cholesky(V)
	  U = halton(2, 100)

	  series Q = ghk(C, {inf1, inf2}, {sup1, sup2}, U)
	</code>
	<para>
	  The optional <argname>dP</argname> argument can be used to
	  retrieve the <by r="n" c="k"/> matrix of derivatives of the
	  probabilities, where <math>k</math> equals 2<math>m</math> +
	  <math>m</math>(<math>m</math> + 1)/2. The first
	  <math>m</math> columns hold the derivatives with respect to
	  the lower bounds, the next <math>m</math> those with respect
	  to the upper bounds, and the remainder the derivatives with
	  respect to the unique elements of the <math>C</math> matrix
	  in <quote>vech</quote> order.
	</para>
      </description>
    </function>

    <function name="gini" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>    
      <description>
	<para>
	  Returns Gini's inequality index for the series
	  <argname>y</argname>.
	</para>
      </description>
    </function>

    <function name="ginv" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
      </fnargs>    
      <description>
	<para>
	  Returns <math>A</math><sup>+</sup>, the Moore&ndash;Penrose
	  or generalized inverse of <argname>A</argname>, computed via
	  the singular value decomposition.
	</para>
	<para context="notex">
	  This matrix has the properties <math>A</math>
	  <math>A</math><sup>+</sup> <math>A</math> = <math>A</math>
	  and <math>A</math><sup>+</sup> <math>A</math>
	  <math>A</math><sup>+</sup> = <math>A</math><sup>+</sup>.
	  Moreover, the products <math>A</math>
	  <math>A</math><sup>+</sup> and <math>A</math><sup>+</sup>
	  <math>A</math> are symmetric by construction.
	</para>
	<para context="tex">
	  This matrix has the properties
	  \begin{eqnarray*}
	  A A^+ A &amp; = &amp; A \\
	  A^+ A A^+ &amp; = &amp; A^+ 
	  \end{eqnarray*}
	  Moreover, the products $A^+ A$ and $A A^+$ are
	  symmetric by construction.
	</para>
	<para>
	  <seelist>
            <fncref targ="inv"/>
            <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="halton" section="stats" output="matrix">
      <fnargs>
	<fnarg type="int">m</fnarg>
	<fnarg type="int">r</fnarg>
	<fnarg optional="true" type="int">offset</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns an <by r="m" c="r"/> matrix containing
	  <math>m</math> Halton sequences of length <math>r</math>;
	  <math>m</math> is limited to a maximum of 40. The sequences
	  are contructed using the first <math>m</math> primes. By
	  default the first 10 elements of each sequence are
	  discarded, but this figure can be adjusted via the optional
	  <argname>offset</argname> argument, which should be a
	  non-negative integer. See <cite key="halton64">Halton and
	  Smith (1964)</cite>.
	</para>
      </description>
    </function>

    <function name="hdprod" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">Y</fnarg>
      </fnargs>
      <description>
	<para>
	  Horizontal direct product. The two arguments must have the
	  same number of rows, <math>r</math>. The return value is a
	  matrix with <math>r</math> rows, in which the
	  <math>i</math>-th row is the Kronecker product of the
	  corresponding rows of <argname>X</argname> and
	  <argname>Y</argname>.
	</para>
	<para context="tex">
	  In other words, if $X$ is an $r \times k$ matrix, $Y$ is an
	  $r \times m$ matrix and $Z$ is the result matrix of the
	  horizontal direct product of $X$ times $Y$, then $Z$ will
	  have $r$ rows and $k\cdot m$ columns; moreover, 
	  \[ 
	  Z_{in} = X_{ij} Y_{il} 
	  \]
	  where $n = (j-1) m + l$.
	</para>
	<para>
	  This operation is called <quote>horizontal direct
	  product</quote> in conformity to its implementation in the
	  GAUSS programming language. Its equivalent in standard
	  matrix algebra would be called the row-wise Khatri-Rao
	  product.
	</para>
	<para>
	  Example: the code
	</para>
	<code>
	  A = {1,2,3; 4,5,6}
	  B = {0,1; -1,1}
	  C = hdprod(A, B)
	</code>
	<para>
	  produces the following matrix:
	</para>
	<code>
          0    1    0    2    0    3 
         -4    4   -5    5   -6    6 
	</code>
      </description>
    </function>

    <function name="hflags" section="transforms" output="list">
      <fnargs>
	<fnarg type="int">minlag</fnarg>
	<fnarg type="int">maxlag</fnarg>
	<fnarg type="list">hfvars</fnarg>
      </fnargs>
      <description>
	<para>
	  Given a MIDAS list, <repl>hfvars</repl>, produces a list
	  holding high-frequency lags <repl>minlag</repl> to
	  <repl>maxlag</repl>. Use positive values for actual lags,
	  negative for leads. For example, if <repl>minlag</repl> is
	  &minus;3 and <repl>maxlag</repl> is 5 than the returned list
	  will hold 9 series: 3 leads, the contemporary value, and 5
	  lags.
	</para>
	<para>
	  Note that high-frequency lag 0 corresponds to the first
	  high frequency period within a low frequency period, for
	  example the first month of a quarter or the first day of
	  a month.
	</para>
      </description>
    </function>    

    <function name="hpfilt" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="scalar" optional="true">lambda</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the cycle component from application of the
	  Hodrick&ndash;Prescott filter to series <argname>y</argname>. If the
	  smoothing parameter, <argname>lambda</argname>, is not supplied then
	  a data-based default is used, namely 100 times the square of the
	  periodicity (100 for annual data, 1600 for quarterly data, and so
	  on).  
	  <seelist> 
            <fncref targ="bkfilt"/>
            <fncref targ="bwfilt"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="I" section="matbuild" output="smatrix">
      <fnargs>
	<fnarg type="int">n</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns an identity matrix with <argname>n</argname> rows and
	  columns.
	</para>
      </description>
    </function>

    <function name="imaxc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the row indices of the maxima of the columns of
	  <argname>X</argname>. 
	</para>
	<para>
	  <seelist> 
            <fncref targ="imaxr"/> 
            <fncref targ="iminc"/>
            <fncref targ="maxc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="imaxr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>    
      <description>
	<para>
	  Returns the column indices of the maxima of the rows of
	  <argname>X</argname>. 
	</para>
	<para>
	  <seelist> 
            <fncref targ="imaxc"/>
            <fncref targ="iminr"/>
            <fncref targ="maxr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="imhof" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="scalar">x</fnarg>
      </fnargs>    
      <description>
	<para context="notex">
	  Computes Prob(<math>u'Au</math> &lt; <math>x</math>) for a quadratic
	  form in standard normal variates, <math>u</math>, using the procedure
	  developed by <cite key="imhof61">Imhof (1961)</cite>.
	</para>
	<para context="tex">
	  Computes ${\rm Prob}(u'Au &lt; x)$ for a quadratic form in standard
	  normal variates, $u$, using the procedure developed by
	  <cite key="imhof61">Imhof (1961)</cite>.
	</para>
	<para>
	  If the first argument, <argname>M</argname>, is a square matrix it
	  is taken to specify <math>A</math>, otherwise if it's a column
	  vector it is taken to be the precomputed eigenvalues of
	  <math>A</math>, otherwise an error is flagged.
	</para>
	<para>
	  <seelist>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="iminc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>    
      <description>
	<para>
	  Returns the row indices of the minima of the columns of
	  <math>X</math>. 
	</para>
	<para>
	  <seelist>
            <fncref targ="iminr"/>
            <fncref targ="imaxc"/>
            <fncref targ="minc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="iminr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>    
      <description>
	<para>
	  Returns the column indices of the mimima of the rows of
	  <math>X</math>. 
	</para>
	<para>
	  <seelist>
            <fncref targ="iminc"/> 
            <fncref targ="imaxr"/>
            <fncref targ="minr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="inbundle" section="data-utils" output="int">
      <fnargs>
	<fnarg type="bundle">b</fnarg>
	<fnarg type="string">key</fnarg>
      </fnargs>    
      <description>
	<para>
	  Checks whether bundle <argname>b</argname> contains a
	  data-item with name <argname>key</argname>. The value
	  returned is an integer code for the type of the item: 0 for
	  no match, 1 for scalar, 2 for series, 3 for matrix, 4 for
	  string, 5 for bundle and 6 for array. The function <fncref
	  targ="typestr"/> may be used to get the string corresponding
	  to this code.
	</para>   
      </description>
    </function>   

    <function name="infnorm" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>    
      <description>
	<para context="notex">
	  Returns the infinity-norm of <argname>X</argname>, that is,
	  the maximum across the rows of <argname>X</argname> of
	  the sum of absolute values of the row elements.
	</para>
	<para context="tex">
	  Returns the $\infty$-norm of the $r\times c$ matrix
	  <argname>X</argname>, namely, 
          \[\| X \|_{\infty} = \max_i \sum_{j=1}^c |X_{ij}|\]
	</para>
	<para>
	  <seelist>
            <fncref targ="onenorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="inlist" section="data-utils" output="int">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg type="series">y</fnarg>
      </fnargs>    
      <description>
	<para>
	  Returns the (1-based) position of <argname>y</argname> in
	  list <argname>L</argname>, or 0 if <argname>y</argname>
	  is not present in <argname>L</argname>. The second
	  argument may be given as the name of a series or
	  alternatively as an integer ID number.
	</para>
      </description>
    </function>

    <function name="int" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>  
      <description>
	<para>
	  Returns the integer part of <argname>x</argname>, truncating the
	  fractional part. Note: <lit>int</lit> and <fncref targ="floor"/>
	  differ in their effect for
	  negative arguments: <lit>int(-3.5)</lit> gives &minus;3, while
	  <lit>floor(-3.5)</lit> gives &minus;4. 
	  <seelist> 
            <fncref targ="ceil"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="inv" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>  
      <description>
	<para>
	  Returns the inverse of <argname>A</argname>. If
	  <argname>A</argname> is singular or not square, an error message
	  is produced and nothing is returned. Note that gretl checks
	  automatically the structure of <argname>A</argname> and uses the
	  most efficient numerical procedure to perform the inversion.
	</para>
	<para>
	  The matrix types gretl checks for are: identity; diagonal;
	  symmetric and positive definite; symmetric but not positive
	  definite; and triangular.
	</para>
	<para>
	  Note: it makes sense to use this function only if you plan
	  to use the inverse of <argname>A</argname> more than
	  once. If you just need to compute an expression of the form
	  <math>A</math><sup>-1</sup><math>B</math>, you'll be much
	  better off using the <quote>division</quote> operators
	  <lit>\</lit> and <lit>/</lit>. See <guideref
	  targ="chap:matrices"/> for details.
	</para>
	<para>
	  <seelist>
            <fncref targ="ginv"/>
            <fncref targ="invpd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="invcdf" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">p</fnarg>
      </fnargs>
      <description>
	<para>
	  Inverse cumulative distribution function calculator. Returns
	  <math>x</math> such that
	  <equation status="inline" ascii="P(X &le; x) = p"  
		    tex="$P(X \le x) = p$"/>, where the distribution
	  of <math>X</math> is determined by the string
	  <argname>d</argname>. Between the arguments
	  <argname>d</argname> and <argname>p</argname>, zero or
	  more additional scalar arguments are required to specify the
	  parameters of the distribution, as follows.
	</para>
	<ilist context="notex">
	  <li>
            <para>
              Standard normal (c = z, n, or N): no extra arguments
            </para>
	  </li>
	  <li>
            <para>
              Gamma (g or G): shape; scale
            </para>
	  </li>
	  <li>
            <para>
              Student's t (t): degrees of freedom
            </para>
	  </li>
	  <li>
            <para>
              Chi square (c, x, or X): degrees of freedom
            </para>
	  </li>
	  <li>
            <para>
              Snedecor's F (f or F): df (num.); df (den.)
            </para>
	  </li>
	  <li>
            <para>
              Binomial (b or B): probability; trials
            </para>
	  </li>
	  <li>
            <para>
              Poisson (p or P): mean
            </para>
	  </li>
	  <li>
            <para>
              Standardized GED (E): shape
            </para>
	  </li>
	  <li>
	    <para>
	      Non-central chi square (ncX): df, non-centrality parameter
	    </para>
	  </li>
	  <li>
	    <para>
	      Non-central F (ncF): df (num.), df (den.),
	      non-centrality parameter
	    </para>
	  </li>
	  <li>
	    <para>
	      Non-central t (nct): df, non-centrality parameter
	    </para>
	  </li>	  
	</ilist>
	<para context="tex">
	  \begin{center} 
	  \begin{tabular}{lllll} 
	  \textit{Distribution} &amp; \textsl{d} &amp;
	  \textit{Arg} 2 &amp; \textit{Arg} 3 &amp; \textit{Arg} 4 \\[4pt] 
	  Standard normal &amp; \texttt{z}, \texttt{n} or \texttt{N} &amp;
	  -- &amp; --  &amp; -- \\ 
	  Gamma &amp; \texttt{g} or \texttt{G} &amp;
	  shape &amp; scale  &amp; -- \\ 
	  Student's $t$ (central) &amp; \texttt{t} &amp; 
	  degrees of freedom &amp; --  &amp; -- \\ 
	  Chi square &amp; \texttt{c}, \texttt{x} or \texttt{X} &amp; 
	  degrees of freedom &amp; --  &amp; -- \\
	  Snedecor's $F$ &amp; \texttt{f} or \texttt{F} &amp; 
	  df (num.) &amp; df (den.)  &amp; -- \\ 
	  Binomial &amp; \texttt{b} or \texttt{B} &amp; 
	  $p$ &amp; $n$  &amp; -- \\
	  Poisson &amp; \texttt{p} or \texttt{P} &amp;
          $\lambda$ &amp; --  &amp; -- \\ 
	  Standardized GED &amp; \texttt{E} &amp; shape &amp; --
	  &amp; -- \\
	  Non-central $\chi^2$ &amp; \texttt{ncX} &amp; 
	  df &amp; non-centrality &amp; -- \\
	  Non-central $F$ &amp; \texttt{ncF} &amp; 
	  df (num.) &amp; df (den.) &amp; non-centrality \\
	  Non-central $t$ &amp; \texttt{nct} &amp; 
	  df &amp; non-centrality &amp; -- \\
	  \end{tabular}
	  \end{center}
	</para>
	<para>
	  <seelist>
            <fncref targ="cdf"/>
            <fncref targ="critical"/>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="invmills" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>  
      <description>
	<para>
	  Returns the inverse Mills ratio at <argname>x</argname>, that is
	  the ratio between the standard normal density and the complement
	  to the standard normal distribution function, both evaluated at
	  <argname>x</argname>. 
	</para>
	<para>
	  This function uses a dedicated algorithm which yields greater
	  accuracy compared to calculation using <fncref targ="dnorm"/>
	  and <fncref targ="cnorm"/>, but the difference between the two
	  methods is appreciable only for very large negative values of
	  <argname>x</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="cdf"/>
            <fncref targ="cnorm"/>
            <fncref targ="dnorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="invpd" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="pdmat">A</fnarg>
      </fnargs>  
      <description>
	<para>
	  Returns the inverse of the symmetric, positive definite matrix
	  <argname>A</argname>.   This function is slightly faster than
	  <fncref targ="inv"/> for large matrices, since no check for
	  symmetry is performed; for that reason it should be used with
	  care.
	</para>
	<para>
	  Note: if you're interested in the inversion of a matrix of
	  the form <math>X'X</math>, where <math>X</math> is a large
	  matrix, it is preferable to compute it via the prime
	  operator <lit>X'X</lit> rather than using the more general
	  syntax <lit>X'*X</lit>. The former expression uses a
	  specialized algorithm which has the double advantage of
	  being more efficient computationally and of ensuring that
	  the result will be free by construction of machine precision
	  artifacts that may render it numerically non-symmetric.
	</para>
      </description>
    </function>

    <function name="irf" section="stats" output="matrix">
      <fnargs>
	<fnarg type="int">target</fnarg>
	<fnarg type="int">shock</fnarg>
	<fnarg type="pscalar" optional="true">alpha</fnarg>
      </fnargs>  
      <description>
	<para>
	  This function is available only when the last model
	  estimated was a VAR or VECM. It returns a matrix containing
	  the estimated response of the <argname>target</argname>
	  variable to an impulse of one standard deviation in the
	  <argname>shock</argname> variable. These variables are
	  identified by their position in the VAR specification: for
	  example, if <argname>target</argname> and
	  <argname>shock</argname> are given as 1 and 3 respectively,
	  the returned matrix gives the response of the first variable
	  in the VAR for a shock to the third variable.
	</para>
	<para>
	  If the optional <argname>alpha</argname> argument is given,
	  the returned matrix has three columns: the point estimate of
	  the responses, followed by the lower and upper limits of a 1
	  &minus; &agr; confidence interval obtained via
	  bootstrapping.  (So <argname>alpha</argname> = 0.1
	  corresponds to 90 percent confidence.) If
	  <argname>alpha</argname> is omitted or set to zero, only the
	  point estimate is provided.
	</para>
	<para>
	  The number of periods (rows) over which the response is
	  traced is determined automatically based on the frequency
	  of the data, but this can be overridden via the <cmdref
	  targ="set"/> command, as in <lit>set horizon 10</lit>.
	</para>
      </description>
    </function>

    <function name="irr" section="math" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>  
      <description>
	<para>
	  Returns the Internal Rate of Return for <argname>x</argname>,
	  considered as a sequence of payments (negative) and receipts
	  (positive).
	  <seelist>
            <fncref targ="npv"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="isconst" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="int" optional="true">panel-code</fnarg>
      </fnargs>
      <description>
	<para>
	  Without the optional second argument, returns 1 if
	  <argname>y</argname> has a constant value over the current
	  sample range (or over its entire length if
	  <argname>y</argname> is a vector), otherwise 0.
	</para>
	<para>
	  The second argument is accepted only if the current dataset
	  is a panel and <argname>y</argname> is a series.  In that
	  case a <argname>panel-code</argname> value of 0 calls for a
	  check for time-invariance, while a value of 1 means check
	  for cross-sectional invariance (that is, in each time period
	  the value of <argname>y</argname> is the same for all
	  groups).
	</para>
	<para>
	  If <argname>y</argname> is a series, missing values are
	  ignored in checking for constancy.
	</para>
      </description>
    </function>

    <function name="isdiscrete" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">name</fnarg>
      </fnargs>
      <description>
	<para>
	  If <argname>name</argname> is the identifier for a currently
	  defined series, returns 1 if the series is marked as
	  discrete-valued, otherwise 0. If <argname>name</argname>
	  does not identify a series, returns <lit>NA</lit>.
	</para>
      </description>
    </function>

    <function name="isdummy" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>
      <description>
	<para>
	  If all the values contained in <argname>x</argname> are 0 or
	  1 (or missing), returns the number of ones, otherwise 0.
	</para>
      </description>
    </function>

    <function name="isnan" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-matrix">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Given a scalar argument, returns 1 if <argname>x</argname>
	  is <quote>Not a Number</quote> (NaN), otherwise 0. Given a
	  matrix argument, returns a matrix of the same dimensions
	  with 1s in positions where the corresponding element of the
	  input is NaN and 0s elsewhere.
	</para>
      </description>
    </function>

    <function name="isnull" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">name</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns 0 if <argname>name</argname> is the identifier for a
	  currently defined object, be it a scalar, a series, a matrix,
	  list, string or bundle; otherwise returns 1.
	</para>
	<para>
	  This function is deprecated: the recommended replacment is
	  (the negation of) <fncref targ="exists"/>.
	</para>
      </description>
    </function>

    <function name="isoconv" section="calendar" output="scalar">
      <fnargs>
	<fnarg type="series">date</fnarg>
	<fnarg type="seriesref">&amp;year</fnarg>
	<fnarg type="seriesref">&amp;month</fnarg>
	<fnarg type="seriesref" optional="true">&amp;day</fnarg>
      </fnargs>
      <description>
	<para>
	  Given a series <argname>date</argname> holding dates in
	  ISO 8601 <quote>basic</quote> format (<lit>YYYYMMDD</lit>),
	  this function writes the year, month and (optionally)
	  day components into the series named by the second and
	  subsequent arguments. An example call, assuming the
	  series <lit>dates</lit> contains suitable 8-digit values:
	</para>
	<code>
	  series y, m, d
	  isoconv(dates, &amp;y, &amp;m, &amp;d)
	</code>
	<para>
	  The return value from this function is 0 on successful
	  completion, non-zero on error.
	</para>
      </description>
    </function>

    <function name="isodate" section="calendar" output="seebelow">
      <fnargs>
	<fnarg type="scalar-or-series">ed</fnarg>
	<fnarg type="bool" optional="true">as-string</fnarg>
      </fnargs>
      <description>
	<para>
	  The argument <argname>ed</argname> is interpreted as an
	  epoch day (which equals 1 for the first of January in the
	  year 1 AD). The default return value &mdash; of the same
	  type as <argname>ed</argname> &mdash; is an 8-digit number,
	  or a series of such numbers, on the pattern
	  <lit>YYYYMMDD</lit> (ISO 8601 <quote>basic</quote> format),
	  giving the calendar date corresponding to the epoch day.
	</para>
	<para>
	  If <argname>ed</argname> is a scalar (only) and the optional
	  second argument <argname>as-string</argname> is non-zero,
	  the return value is not numeric but rather a string on the
	  pattern <lit>YYYY-MM-DD</lit> (ISO 8601
	  <quote>extended</quote> format).
	</para>
	<para>
	  For the inverse function, see <fncref targ="epochday"/>.
	</para>
      </description>
    </function>

    <function name="iwishart" section="stats" output="matrix">
      <fnargs>
	<fnarg type="symmat">S</fnarg>
	<fnarg type="int">v</fnarg>
      </fnargs>
      <description>
	<para>
	  Given <argname>S</argname> (a positive definite <by r="p"
	  c="p"/> scale matrix), returns a drawing from the Inverse
	  Wishart distribution with <argname>v</argname> degrees of
	  freedom. The returned matrix is also <by r="p" c="p"/>.  The
	  algorithm of <cite key="odell-feiveson66">Odell and Feiveson
	  (1966)</cite> is used.
	</para>
      </description>
    </function>

    <function name="jsonget" section="data-utils" output="string">
      <fnargs>
	<fnarg type="string">buf</fnarg>
	<fnarg type="string">path</fnarg>
      </fnargs>
      <description>
	<para>
	  The argument <argname>buf</argname> should be a JSON
	  buffer, as may be retrieved from a suitable website via the
	  <fncref targ="curl"/> function, and the
	  <argname>path</argname> argument should be a JsonPath
	  specification.
	</para>
	<para>
	  This function returns a string representing the data found
	  in the buffer at the specified path. Data types of double
	  (floating-point), int (integer) and string are supported. In
	  the case of doubles or ints, their string representation is
	  returned (using the <quote>C</quote> locale for doubles).
	  If the object to which <argname>path</argname> refers is an
	  array, the members are printed one per line in the returned
	  string.
	</para>
	<para>
	  An accurate account of JsonPath syntax can be found at
	  <url>http://goessner.net/articles/JsonPath/</url>. However,
	  please note that the back-end for <lit>jsonget</lit> is
	  provided by <lit>json-glib</lit>, which does not necessarily
	  support all elements of JsonPath. Moreover, the exact
	  functionality of <lit>json-glib</lit> may differ depending
	  on the version you have on your system. See
	  <url>http://developer.gnome.org/json-glib/</url> if you
	  need details.
	</para>
	<para>
	  That said, the following operators should be available
	  to <lit>jsonget</lit>:
	</para>
	  <ilist>
	    <li>
              <para>
		root node, via the <lit>$</lit> character
              </para>
	    </li>
	    <li>
              <para>
		recursive descent operator: <lit>..</lit>
              </para>
	    </li>
	    <li>
              <para>
		wildcard operator: <lit>*</lit>
              </para>
	    </li>
	    <li>
              <para>
		subscript operator: <lit>[]</lit>
              </para>
	    </li>
	    <li>
              <para>
		set notation operator, for example <lit>[i,j]</lit>
              </para>
	    </li>
	    <li>
              <para>
		slice operator: <lit>[start:end:step]</lit>
              </para>
	    </li>
	  </ilist>
      </description>
    </function>    

    <function name="kdensity" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg type="scalar" optional="true">scale</fnarg>
	<fnarg type="bool" optional="true">control</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes a kernel density estimate for the series or vector
	  <argname>x</argname>. The returned matrix has two columns, the
	  first holding a set of evenly spaced abscissae and the second
	  the estimated density at each of these points.
	</para>
	<para>
	  The optional <argname>scale</argname> parameter can be used to
	  adjust the degree of smoothing relative to the default of 1.0
	  (higher values produce a smoother result). The
	  <argname>control</argname> parameter acts as a boolean: 0 (the
	  default) means that the Gaussian kernel is used; a non-zero
	  value switches to the Epanechnikov kernel.
	</para>
	<para>
	  A plot of the results may be obtained using the <cmdref
	  targ="gnuplot"/> command, as in
	</para>
	<code>
	  matrix d = kdensity(x)
	  gnuplot 2 1 --matrix=d --with-lines --suppress-fitted
	</code>
      </description>
    </function>

    <function name="kdsmooth" section="sspace" output="scalar">
      <fnargs>
	<fnarg type="bundleref">&amp;Mod</fnarg>
	<fnarg type="bool" optional="true">MSE</fnarg>
      </fnargs>
      <description>
	<para>
	  Performs disturbance smoothing for a Kalman bundle
	  previously set up by means of <fncref targ="ksetup"/>
	  and returns 0 on successful completion or 1 if numerical
	  problems are encountered.
	</para>
	<para>
	  On successful completion, the smoothed disturbances will be
	  available as <lit>Mod.smdist</lit>.
	</para>
	<para>
	  The optional <argname>MSE</argname> argument determines the
	  contents of the <lit>Mod.smdisterr</lit> key. If 0 or
	  omitted, this matrix will contain the unconditional standard
	  errors of the smoothed residuals, which are normally used to
	  compute the so-called <it>auxiliary
	  residuals</it>. Otherwise, <lit>Mod.smdisterr</lit> will
	  contain the estimated root mean square deviations of the
	  auxiliary residuals from their true value.
	</para>
	<para>
	  For more details see <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="ksetup"/>
            <fncref targ="kfilter"/>
            <fncref targ="ksmooth"/>
            <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function> 

    <function name="kfilter" section="sspace" output="scalar">
      <fnargs>
	<fnarg type="bundleref">&amp;Mod</fnarg>
      </fnargs>
      <description>
	<para>
	  Performs a forward, filtering pass on a Kalman bundle
	  previously set up by means of <fncref targ="ksetup"/>
	  and returns 0 on successful completion or 1 if numerical
	  problems are encountered.
	</para>
	<para>
	  On successful completion, the one-step-ahead prediction
	  errors will be available as <lit>Mod.prederr</lit> and the
	  sequence of their covariance matrices as
	  <lit>Mod.pevar</lit>. Moreover, the key <lit>Mod.llt</lit>
	  gives access to a <math>T</math>-vector containing the
	  log-likelihood by observation.
	</para>
	<para>
	  For more details see <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="kdsmooth"/>
            <fncref targ="ksetup"/>
            <fncref targ="ksmooth"/>
            <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="kpsscrit" section="stats" output="matrix">
      <fnargs>
	<fnarg type="scalar">T</fnarg>
	<fnarg type="bool">trend</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a row vector containing critical values at the 10, 5
	  and 1 percent levels for the KPSS test for stationarity of a
	  time series. <argname>T</argname> should give the number of
	  observations and <argname>trend</argname> should be 1 if
	  the test includes a trend, 0 otherwise.
	</para>
	<para>
	  The critical values given are based on response surfaces
	  estimated in the manner set out by <cite
	  key="sephton95">Sephton (Economics Letters,
	  1995)</cite>. See also the <cmdref targ="kpss"/> command.
 	</para>
      </description>
    </function> 

    <function name="ksetup" section="sspace" output="bundle">
      <fnargs>
	<fnarg type="smlist">Y</fnarg>
	<fnarg type="scalar-or-matrix">H</fnarg>
	<fnarg type="scalar-or-matrix">F</fnarg>
	<fnarg type="scalar-or-matrix">Q</fnarg>
	<fnarg optional="true" type="matrix">C</fnarg>
      </fnargs>
      <description>
	<para>
	  Sets up a Kalman bundle, that is an object which contains
	  all the information needed to define a linear state space
	  model of the form
	  <equation status="display" 
		    tex="\[y_t=H'\alpha_t\]"
		    ascii="y(t) = H'a(t)"
		    graphic="kalman1"/> 
	  and state transition equation
	  <equation status="display" 
		    tex="\[\alpha_{t+1}=F \alpha_t + u_t\]"
		    ascii="a(t+1) = F a(t) + u(t)"
		    graphic="kalman2"/> 
	  where Var<math>(u) = Q</math>.
	</para>
	<para>
	  Objects created via this function can be later used via the
	  dedicated functions <fncref targ="kfilter"/> for filtering,
	  <fncref targ="ksmooth"/> and <fncref targ="kdsmooth"/> for
	  smoothing and <fncref targ="ksimul"/> for performing
	  simulations.
	</para>
	<para>
	  The class of models that gretl can handle is in fact much
	  wider than the one implied by the representation above: it
	  is possible to have time-varying models, models with diffuse
	  priors and exogenous variable in the measurement equation
	  and models with cross-correlated innovations. For further
	  details, see <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="kdsmooth"/>
            <fncref targ="kfilter"/>
            <fncref targ="ksmooth"/>
            <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function> 

    <function name="ksimul" section="sspace" output="scalar">
      <fnargs>
	<fnarg type="bundleref">&amp;Mod</fnarg>
      </fnargs>
      <description>
	<para>
	  Uses a Kalman bundle previously set up by means of
	  <fncref targ="ksetup"/> to simulate data.
	</para>
	<para>
	  For details see <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="ksetup"/>
            <fncref targ="kfilter"/>
            <fncref targ="ksmooth"/>
	  </seelist>
	</para>
      </description>
    </function> 

    <function name="ksmooth" section="sspace" output="matrix">
      <fnargs>
	<fnarg type="bundleref">&amp;Mod</fnarg>
      </fnargs>
      <description>
	<para>
	  Performs a fixed-point smoothing (backward) pass on a
	  Kalman bundle previously set up by means of <fncref
	  targ="ksetup"/> and returns 0 on successful completion or 1
	  if numerical problems are encountered.  
	</para>
	<para>
	  On successful completion, the smoothed states will be
	  available as <lit>Mod.state</lit> and the sequence of their
	  covariance matrices as <lit>Mod.stvar</lit>.  For more
	  details see <guideref targ="chap:kalman"/>.
	</para>
	<para>
	  <seelist>
            <fncref targ="kdsmooth"/>
            <cmdref targ="kalman"/>
            <fncref targ="kfilter"/>
            <fncref targ="ksimul"/>
	  </seelist>
	</para>
      </description>
    </function> 

    <function name="kurtosis" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the excess kurtosis of the series <argname>x</argname>,
	  skipping any missing observations.
	</para>
      </description>
    </function>

    <function name="lags" section="transforms" output="list">
      <fnargs>
	<fnarg type="scalar-or-vec">p</fnarg>
	<fnarg type="series-or-list">y</fnarg>
	<fnarg type="bool" optional="true">bylag</fnarg>
      </fnargs>
      <description>
	<para>
	  If the first argument is a scalar, generates lags 1 to
	  <argname>p</argname> of the series <argname>y</argname>, or
	  if <argname>y</argname> is a list, of all series in the
	  list.  If <argname>p</argname> = 0, the maximum lag defaults
	  to the periodicity of the data; otherwise
	  <argname>p</argname> must be positive.
	</para>
	<para>
	  If a vector is given as the first argument, the lags
	  generated are those specified in the vector. Common usage
	  in this case would be to give <argname>p</argname> as, for
	  example, <lit>seq(3,7)</lit>, hence omitting the first and
	  second lags. However, it is OK to give a vector with gaps,
	  as in <lit>{3,5,7}</lit>, although the lags should always
	  be given is ascending order.
	</para>
	<para> 
	  The generated variables are automatically named according to
	  the template <repl>varname</repl>
	  <lit>_</lit>
	  <repl>i</repl> where
	  <repl>varname</repl> is the name of the original series and
	  <repl>i</repl> is the specific lag.  The original portion of the
	  name is truncated if necessary, and may be adjusted in case of
	  non-uniqueness in the set of names thus constructed.  
	</para>
	<para>
	  When <argname>y</argname> is a list and the lag order is
	  greater than 1, the default ordering of the terms in the
	  returned list is by variable: all lags of the first series
	  in the input list followed by all lags of the second series,
	  and so on. The optional third argument can be used to
	  change this: if <argname>bylag</argname> is non-zero then
	  the terms are ordered by lag: lag 1 of all the input series,
	  then lag 2 of all the series, and so on.
	</para>
      </description>
    </function>

    <function name="lastobs" section="data-utils" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the 1-based index of the last non-missing
	  observation for the series <argname>y</argname>. Note that
	  if some form of subsampling is in effect, the value returned
	  may be larger than the dollar variable <fncref targ="$t2"/>.
	  <seelist>
            <fncref targ="firstobs"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ldet" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the natural log of the determinant of <math>A</math>,
	  computed via the LU factorization.
	  <seelist> 
            <fncref targ="det"/>
            <fncref targ="rcond"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ldiff" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-or-list">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes log differences; starting values are set to
	  <lit>NA</lit>.
	</para>
	<para> 
	  When a list is returned, the individual variables are
	  automatically named according to the template
	  <lit>ld_</lit><repl>varname</repl> where
	  <repl>varname</repl> is the name of the original series.
	  The name is truncated if necessary, and may be adjusted in
	  case of non-uniqueness in the set of names thus constructed.
	</para> 
	<para>
	  <seelist> 
            <fncref targ="diff"/>
            <fncref targ="sdiff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="lincomb" section="transforms" output="series">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg type="vector">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes a new series as a linear combination of the series in the
	  list <argname>L</argname>.  The coefficients are given by the vector
	  <argname>b</argname>, which must have length equal to the number of
	  series in <argname>L</argname>.
	</para>
	<para>
	  <seelist> 
            <fncref targ="wmean"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="linearize" section="filters" output="series">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Depends on having TRAMO installed. Returns a
	  <quote>linearized</quote> version of the input series; that
	  is, a series in which any missing values are replaced by
	  interpolated values and outliers are adjusted. TRAMO's fully
	  automatic mechanism is used; consult the TRAMO documentation
	  for details.
	</para>
	<para>
	  Note that if the input series has no missing values and no
	  values that TRAMO regards as outliers, this function will
	  return a copy of the original series.
	</para>
      </description>
    </function>
    
    <function name="ljungbox" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int">p</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes the Ljung&ndash;Box Q' statistic for the series
	  <argname>y</argname> using lag order <argname>p</argname>,
	  over the currently defined sample range.  The lag order must
	  be greater than or equal to 1 and less than the number of
	  available observations.
	</para>
	<para>
	  This statistic may be referred to the chi-square
	  distribution with <argname>p</argname> degrees of freedom as
	  a test of the null hypothesis that the series
	  <argname>y</argname> is not serially correlated.
	  <seelist>
            <fncref targ="pvalue"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="lngamma" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the log of the gamma function of <argname>x</argname>.
	</para>
      </description>
    </function>

    <function name="log" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the natural logarithm of <argname>x</argname>; produces
	  <lit>NA</lit> for non-positive values. Note: <lit>ln</lit> is an
	  acceptable alias for <lit>log</lit>.
	</para>
	<para> 
	  When a list is returned, the individual variables are
	  automatically named according to the template
	  <lit>l_</lit><repl>varname</repl> where <repl>varname</repl>
	  is the name of the original series.  The name is truncated
	  if necessary, and may be adjusted in case of non-uniqueness
	  in the set of names thus constructed.
	</para> 
      </description>
    </function>

    <function name="log10" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the base-10 logarithm of <argname>x</argname>; produces
	  <lit>NA</lit> for non-positive values.
	</para>
      </description>
    </function>

    <function name="log2" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the base-2 logarithm of <argname>x</argname>; produces
	  <lit>NA</lit> for non-positive values.
	</para>
      </description>
    </function>

    <function name="loess" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series">x</fnarg>
	<fnarg optional="true" type="int">d</fnarg>
	<fnarg optional="true" type="scalar">q</fnarg>
	<fnarg optional="true" type="bool">robust</fnarg>
      </fnargs>
      <description>
	<para>
	  Performs locally-weighted polynomial regression and returns
	  a series holding predicted values of <argname>y</argname>
	  for each non-missing value of <argname>x</argname>.  The
	  method is as described by <cite key="cleveland79">William
	  Cleveland (1979)</cite>.
	</para>
	<para>
	  The optional arguments <argname>d</argname> and
	  <argname>q</argname> specify the order of the polynomial in
	  <argname>x</argname> and the proportion of the data points
	  to be used in local estimation, respectively.  The default
	  values are <argname>d</argname> = 1 and <argname>q</argname>
	  = 0.5. The other acceptable values for <argname>d</argname>
	  are 0 and 2. Setting <argname>d</argname> = 0 reduces the
	  local regression to a form of moving average. The value
	  of <argname>q</argname> must be greater than 0 and cannot
	  exceed 1; larger values produce a smoother outcome.
	</para>
	<para>
	  If a non-zero value is given for the <argname>robust</argname>
	  argument the local regressions are iterated twice, with the
	  weights being modified based on the residuals from the previous
	  iteration so as to give less influence to outliers.
	</para>
	<para>
	  See also <fncref targ="nadarwat"/>, and in addition see
	  <guideref targ="chap:nonparam"/> for details on
	  nonparametric methods.
	</para>
      </description>
    </function>

    <function name="logistic" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para context="tex">
	  Returns the logistic function of the argument <argname>x</argname>,
	  that is, $\Lambda(x) = e^x/(1+e^x)$. If <argname>x</argname> is a
	  matrix, the function is applied element by element.
	</para>
	<para context="notex">
	  Returns the logistic function of the argument
	  <argname>x</argname>, that is, <math>e</math><sup>x</sup>/(1
	  + <math>e</math><sup>x</sup>).  If <argname>x</argname> is a
	  matrix, the function is applied element by element.
	</para>
      </description>
    </function>

    <function name="lower" section="matbuild" output="smatrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Returns an <by r="n" c="n"/> lower triangular matrix: the elements
	  on and below the diagonal are equal to the corresponding elements of
	  <argname>A</argname>; the remaining elements are zero.
	</para>
	<para context="tex">
	  Returns an $n\times n$ lower triangular matrix <math>B</math>
	  for which $B_{ij} = A_{ij}$ if $i \ge j$, and 0 otherwise.
	</para>
	<para>
	  <seelist>
            <fncref targ="upper"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="lrvar" section="filters" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
	<fnarg type="int">k</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the long-run variance of <argname>y</argname>,
	  calculated using a Bartlett kernel with window size
	  <argname>k</argname>. The default window size, namely the
	  integer part of the cube root of the sample size, can be
	  selected by giving a negative value for
	  <argname>k</argname>.
	</para>
	<para context="tex">
	  In formulae: 
	  \[ \hat{\omega}^2(k) = \frac{1}{T} \sum_{t=k}^{T-k}
	  \left[ \sum_{i=-k}^k w_i (y_t - \bar{X}) (y_{t-i} - \bar{Y})
	  \right] \] 
	  with 
	  \[ w_i = 1 - \frac{|i|}{k + 1} \]
	</para>
      </description>
    </function>

    <function name="max" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">y</fnarg>
      </fnargs>
      <description>
	<para>
	  If the argument <argname>y</argname> is a series, returns the
	  (scalar) maximum of the non-missing observations in the series.
	  If the argument is a list, returns a series each of whose
	  elements is the maximum of the values of the listed variables at
	  the given observation.
	</para>
	<para>
	  <seelist>
            <fncref targ="min"/>
            <fncref targ="xmax"/>
            <fncref targ="xmin"/>
	  </seelist>
	</para> 
      </description>
    </function>

    <function name="maxc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a row vector containing the maxima of the columns of
	  <argname>X</argname>. 
	</para>
	<para>
	  <seelist>
            <fncref targ="imaxc"/>
            <fncref targ="maxr"/>
            <fncref targ="minc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="maxr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a column vector containing the maxima of the rows of
	  <argname>X</argname>. 
	</para>
	<para>
	  <seelist>
            <fncref targ="imaxc"/>
            <fncref targ="maxc"/> 
            <fncref targ="minr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mcorr" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes a correlation matrix treating each column of
	  <argname>X</argname> as a variable. 
	  <seelist> 
            <fncref targ="corr"/>
            <fncref targ="cov"/>
            <fncref targ="mcov"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mcov" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes a covariance matrix treating each column of
	  <argname>X</argname> as a variable. 
	  <seelist> 
            <fncref targ="corr"/>
            <fncref targ="cov"/>
            <fncref targ="mcorr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mcovg" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg optional="true" type="vector">u</fnarg>
	<fnarg optional="true" type="vector">w</fnarg>
	<fnarg type="int">p</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the matrix covariogram for a <by r="T" c="k"/> matrix
	  <argname>X</argname> (typically containing regressors), an
	  (optional) <math>T
	  </math>-vector <argname>u</argname> (typically
	  containing residuals), an (optional) (<math>p</math>+1)-vector
	  of weights <argname>w</argname>, and a lag order
	  <argname>p</argname>, which must be greater than or equal to 0.
	</para>
	<para context="tex">
	  The returned matrix is given by
	  \[\sum_{j=-p}^{p} \sum_j w_{|j|} (X_t' u_t
	  u_{t-j} X_{t-j})\]
	</para>
	<para context="notex">
	  The returned matrix is given by
	</para>
	<para context="notex">  
	  sum_{j=-p}^p sum_j w_{|j|} (X_t' u_t u_{t-j} X_{t-j})
	</para>
	<para>
	  If <argname>u</argname> is given as <lit>null</lit> the
	  <math>u</math> terms are omitted, and if
	  <argname>w</argname> is given as <lit>null</lit> all the weights
	  are taken to be 1.0.
	</para>
      </description>
    </function>

    <function name="mean" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  If <argname>x</argname> is a series, returns the (scalar)
	  sample mean, skipping any missing observations.
	</para>
	<para>
	  If <argname>x</argname> is a list, returns a series
	  <math>y</math> such that <math>y</math><sub>t</sub> is the
	  mean of the values of the variables in the list at
	  observation <math>t</math>, or <lit>NA</lit> if there are
	  any missing values at <math>t</math>.
	</para>
      </description>
    </function>

    <function name="meanc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the means of the columns of <argname>X</argname>. 
	  <seelist>
            <fncref targ="meanr"/>
            <fncref targ="sumc"/>
            <fncref targ="sdc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="meanr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the means of the rows of <argname>X</argname>. 
	  <seelist>
            <fncref targ="meanc"/>
            <fncref targ="sumr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="median" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  The median of the non-missing observations in series
	  <argname>y</argname>. 
	  <seelist>
            <fncref targ="quantile"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mexp" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Computes the matrix exponential of <argname>A</argname>,
	  using algorithm 11.3.1 from <cite key="golub96">Golub and
	  Van Loan (1996)</cite>.
	</para>
	<para context="tex">
	  Computes the matrix exponential,
	  \[ e^A = \sum_{k=0}^{\infty} \frac{A^k}{k!}
	  = \frac{I}{0!} + \frac{A}{1!} + \frac{A^2}{2!} + \frac{A^3}{3!}
	  + \cdots\] 
	  (This series is sure to converge.) The algorithm used
	  is 11.3.1 from <cite key="golub96">Golub and Van Loan 
	  (1996)</cite>.
	</para>
      </description>
    </function>

    <function name="min" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">y</fnarg>
      </fnargs>
      <description>
	<para>
	  If the argument <argname>y</argname> is a series, returns the
	  (scalar) minimum of the non-missing observations in the series.
	  If the argument is a list, returns a series each of whose
	  elements is the minimum of the values of the listed variables at
	  the given observation.
	</para>
	<para>
	  <seelist>
            <fncref targ="max"/>
            <fncref targ="xmax"/>
            <fncref targ="xmin"/>
	  </seelist>
	</para> 
      </description>
    </function>

    <function name="minc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the minima of the columns of <argname>X</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="iminc"/>
            <fncref targ="maxc"/> 
            <fncref targ="minr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="minr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the minima of the rows of <argname>X</argname>. 
	</para>
	<para>
	  <seelist>
            <fncref targ="iminr"/>
            <fncref targ="maxr"/> 
            <fncref targ="minc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="missing" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="sslist">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a binary variable holding 1 if <argname>x</argname> is
	  <lit>NA</lit>. If <argname>x</argname> is a series, the comparison
	  is done element by element; if <argname>x</argname> is a list of
	  series, the output is a series with 1 at observations for which
	  at least one series in the list has a missing value, and 0
	  otherwise.
	</para>
	<para>
	  <seelist> 
            <fncref targ="misszero"/>
            <fncref targ="ok"/>
            <fncref targ="zeromiss"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="misszero" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Converts <lit>NA</lit>s to zeros. If <argname>x</argname> is a
	  series, the conversion is done element by element. 
	  <seelist>
            <fncref targ="missing"/>
            <fncref targ="ok"/>
            <fncref targ="zeromiss"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mlag" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="scalar-or-vec">p</fnarg>
	<fnarg type="scalar" optional="true">m</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Shifts up or down the rows of <argname>X</argname>.  If
	  <argname>p</argname> is a positive scalar, returns a matrix
	  in which the columns of <argname>X</argname> are shifted
	  down by <argname>p</argname> rows and the first
	  <argname>p</argname> rows are filled with the value
	  <argname>m</argname>. If <argname>p</argname> is a negative
	  number, <argname>X</argname> is shifted up and the last rows
	  are filled with the value <argname>m</argname>. If
	  <argname>m</argname> is omitted, it is understood to be
	  zero.
	</para>
	<para context="tex">
	  Shifts up or down the rows of <argname>X</argname>. If $p$
	  is a positive scalar, the returned matrix $Y$ has typical
	  element $Y_{i,j} = X_{i-p,j}$ for $i \ge p$ and zero
	  otherwise. In other words, the columns of
	  <argname>X</argname> are shifted down by
	  <argname>p</argname> rows and the first <argname>p</argname>
	  rows are filled with the value <argname>m</argname>. If
	  <argname>p</argname> is a negative number,
	  <argname>X</argname> is shifted up and the last rows are
	  filled with the value <argname>m</argname>. If
	  <argname>m</argname> is omitted, it is understood to be
	  zero.
	</para>
	<para context="notex">
	  If <argname>p</argname> is a vector, the above operation is
	  carried out for each element in <argname>p</argname>,
	  joining the resulting matrices horizontally.
	</para>
	<para context="tex">
	  If $p$ is a vector, the above operation is carried out for
	  each element in $p$, joining the resulting matrices
	  horizontally.
	</para>
      </description>
    </function>

    <function name="mnormal" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a matrix with <argname>r</argname> rows and
	  <argname>c</argname> columns, filled with standard normal
	  pseudo-random variates. 
	  <seelist> 
            <fncref targ="normal"/>
            <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mols" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;V</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a <by r="k" c="n"/> matrix of parameter estimates obtained
	  by OLS regression of the <by r="T" c="n"/> matrix
	  <argname>Y</argname> on the <by r="T" c="k"/> matrix
	  <argname>X</argname>.
	</para>
	<para>
	  If the third argument is not <lit>null</lit>, the <by r="T"
	  c="n"/> matrix <argname>U</argname> will contain the
	  residuals. If the final argument is given and is not
	  <lit>null</lit> then the <by r="k" c="k"/> matrix
	  <argname>V</argname> will contain (a) the covariance matrix
	  of the parameter estimates, if <argname>Y</argname> has just
	  one column, or (b) <math>X'X</math><sup>-1</sup> if
	  <argname>Y</argname> has multiple columns.
	</para>
	<para>
	  By default, estimates are obtained via Cholesky decomposition, with
	  a fallback to QR decomposition if the columns of
	  <argname>X</argname> are highly collinear.  The use of SVD
	  can be forced via the command <lit>set svd on</lit>.
	</para>
	<para>
	  <seelist> 
            <fncref targ="mpols"/>
            <fncref targ="mrls"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="monthlen" section="calendar" output="int">
      <fnargs>
	<fnarg type="int">month</fnarg>
	<fnarg type="int">year</fnarg>
	<fnarg type="int">weeklen</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the number of (relevant) days in the specified month in
	  the specified year; <argname>weeklen</argname>, which must equal
	  5, 6 or 7, gives the number of days in the week that should be
	  counted (a value of 6 omits Sundays, and a value of 5 omits both
	  Saturdays and Sundays).
	</para>
      </description>
    </function>

    <function name="movavg" section="filters" output="series">
      <fnargs>
	<fnarg type="series">x</fnarg>
	<fnarg type="scalar">p</fnarg>
	<fnarg type="int" optional="true">control</fnarg>
	<fnarg type="scalar" optional="true">y0</fnarg>
      </fnargs>
      <description>
	<para>
	  Depending on the value of the parameter <argname>p</argname>,
	  returns either a simple or an exponentially weighted
	  moving average of the input series <argname>x</argname>.
	</para>
	<para context="notex">
	  If <argname>p</argname> &gt; 1, a simple
	  <argname>p</argname>-term moving average is computed, that
	  is, the arithmetic mean of <math>x</math> from period
	  <math>t</math> to <math>t-p+1</math>. If a non-zero value is
	  supplied for the optional <argname>control</argname>
	  parameter the MA is centered, otherwise it is
	  <quote>trailing</quote>. The optional <argname>y0</argname>
	  argument is ignored.
	</para>
	<para context="tex">
	  If $p&gt;1$, a simple <argname>p</argname>-term moving
	  average is computed, that is, $\frac{1}{p} \sum_{i=0}^{p-1}
	  x_{t-i}$. If a non-zero value is supplied for the optional
	  <argname>control</argname> parameter the MA is centered,
	  otherwise it is <quote>trailing</quote>. The optional
	  <argname>y0</argname> argument is ignored.
	</para>
	<para context="notex">
	  If <argname>p</argname> is a positive fraction, an
	  exponential moving average is computed:
	</para>
	<para context="notex">
	  <math>y(t) = p*x(t) + (1-p)*y(t-1)</math>
	</para>
	<para context="notex">
	  By default the output series, <math>y</math>, is initialized
	  using the first value of <argname>x</argname>, but the
	  <argname>control</argname> parameter may be used to specify
	  the number of initial observations that should be averaged
	  to produce <math>y(0)</math>. A zero value for
	  <argname>control</argname> indicates that all the
	  observations should be used. Alternatively, an initializer
	  may be specified using the optional <argname>y0</argname>
	  argument; in that case the <argname>control</argname>
	  argument is ignored.
	</para>
	<para context="tex">
	  If $0 &lt; p &lt; 1$, an exponential moving average is
	  computed: \[y_t = p x_t + (1-p)y_{t-1}\]. (This is the formula
	  of <cite key="roberts59">Roberts (1959)</cite>.) By default
	  the output series $y$ is initialized using the first valid
	  value of $x$, but the <argname>control</argname> parameter
	  may be used to specify the number of initial observations
	  that should be averaged to produce $y_0$.  A zero value for
	  <argname>control</argname> indicates that all the
	  observations should be used. Alternatively, an initializer
	  may be specified using the optional <argname>y0</argname>
	  argument; in that case the <argname>control</argname>
	  argument is ignored.
	</para> 
      </description>
    </function>

    <function name="mpols" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
      </fnargs>
      <description>
	<para>
	  Works exactly as <fncref targ="mols"/>, except that the calculations
	  are done in multiple precision using the GMP library.
	</para>
	<para>
	  By default GMP uses 256 bits for each floating point number, but
	  you can adjust this using the environment variable
	  <lit>GRETL_MP_BITS</lit>, &eg; <lit>GRETL_MP_BITS=1024</lit>.
	</para>
      </description>
    </function>

    <function name="mrandgen" section="probdist" output="matrix">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="scalar">p1</fnarg>
	<fnarg type="scalar" conditional="true">p2</fnarg>
	<fnarg type="scalar" conditional="true">p3</fnarg>
	<fnarg type="int">rows</fnarg>
	<fnarg type="int">cols</fnarg>
      </fnargs>
      <examples>
	<example>matrix mx = mrandgen(u, 0, 100, 50, 1)</example>
	<example>matrix mt14 = mrandgen(t, 14, 20, 20)</example>
      </examples>
      <description>
	<para>
	  Works like <fncref targ="randgen"/> except that the return
	  value is a matrix rather than a series. The initial
	  arguments to this function (the number of which depends on
	  the selected distribution) are as described for
	  <lit>randgen</lit>, but they must be followed by two
	  integers to specify the number of rows and columns of
	  the desired random matrix.
	</para>
	<para>
	  The first example above calls for a uniform random column
	  vector of length 50, while the second example specifies a
	  <by r="20" c="20"/> random matrix with drawings from the
	  <math>t</math> distribution with 14 degrees of freedom.
	</para>
	<para>
	  <seelist>
            <fncref targ="mnormal"/>
            <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mread" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="string">fname</fnarg>
	<fnarg optional="true" type="bool">import</fnarg>
      </fnargs>
      <description>
	<para>
	  Reads a matrix from a file named
	  <argname>fname</argname>. If the filename has the suffix
	  <quote><lit>.gz</lit></quote> it is assumed that gzip
	  compression has been applied in writing the data; if it has
	  the suffix <quote><lit>.bin</lit></quote> the file is
	  assumed to be in binary format (see <fncref targ="mwrite"/>
	  for details). Otherwise the file is assumed to be plain
	  text, conforming to the following specification:
	</para>
	<ilist>
	  <li>
            <para>
	      It may start with any number of comments, defined
	      as lines that start with the hash mark, <lit>#</lit>;
	      such lines are ignored.
            </para>
	  </li>	  
	  <li>
            <para>
              The first non-comment line must contain two integers,
              separated by a space or a tab, indicating the number of
              rows and columns, respectively.
            </para>
	  </li>
	  <li>
            <para>
              The columns must be separated by spaces or tab
              characters.
            </para>
	  </li>
	  <li>
            <para>
              The decimal separator must be the dot character,
              <quote><lit>.</lit></quote>.
            </para>
	  </li>
	</ilist>
	<para>
	  If the file name does not contain a full path specification,
	  it will be looked for in several <quote>likely</quote>
	  locations, beginning with the currently set <cmdref
	  targ="workdir"/>. However, if a non-zero value is given for
	  the optional <argname>import</argname> argument, the input
	  file is looked for in the user's <quote>dot</quote>
	  directory. This is intended for use with the
	  matrix-exporting functions offered in the context of the
	  <cmdref targ="foreign"/> command. In this case the
	  <argname>fname</argname> argument should be a plain
	  filename, without any path component.
	</para>
	<para>
	  <seelist>
            <fncref targ="bread"/>
            <fncref targ="mwrite"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mreverse" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a matrix containing the rows of <argname>X</argname> in
	  reverse order.  If you wish to obtain a matrix in which the columns
	  of <argname>X</argname> appear in reverse order you can do:
	</para>
	<code>
	  matrix Y = mreverse(X')'
	</code>
      </description>
    </function>  

    <function name="mrls" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">Y</fnarg>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrix">R</fnarg>
	<fnarg type="cvec">q</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;V</fnarg>
      </fnargs>
      <description>
	<para>
	  Restricted least squares: returns a <by r="k" c="n"/> matrix
	  of parameter estimates obtained by least-squares regression
	  of the <by r="T" c="n"/> matrix <argname>Y</argname> on the
	  <by r="T" c="k"/> matrix <argname>X</argname> subject to the
	  linear restriction <math>RB</math> = <math>q</math>, where
	  <math>B</math> denotes the stacked coefficient vector.
	  <argname>R</argname> must have <math>kn</math> columns; each
	  row of this matrix represents a linear restriction. The
	  number of rows in <argname>q</argname> must match the number
	  of rows in <argname>R</argname>.
	</para>
	<para>
	  If the fifth argument is not <lit>null</lit>, the <by r="T"
	  c="n"/> matrix <argname>U</argname> will contain the
	  residuals. If the final argument is given and is not
	  <lit>null</lit> then the <by r="k" c="k"/> matrix
	  <argname>V</argname> will hold the restricted counterpart to
	  the matrix <math>X'X</math><sup>-1</sup>. The variance
	  matrix of the estimates for equation <math>i</math> can be
	  constructed by multiplying the appropriate sub-matrix of
	  <argname>V</argname> by an estimate of the error variance
	  for that equation.
	</para>
      </description>
    </function>  

    <function name="mshape" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">r</fnarg>
	<fnarg type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Rearranges the elements of <argname>X</argname> into a matrix
	  with <argname>r</argname> rows and <argname>c</argname> columns.
	  Elements are read from <argname>X</argname> and written to the
	  target in column-major order.  If <argname>X</argname> contains
	  fewer than <math>k</math> = <math>rc</math> elements, the
	  elements are repeated cyclically; otherwise, if
	  <argname>X</argname> has more elements, only the first
	  <math>k</math> are used.
	</para>
	<para>
	  <seelist>
            <fncref targ="cols"/>
            <fncref targ="rows"/> 
            <fncref targ="unvech"/>
            <fncref targ="vec"/> 
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="msortby" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">j</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a matrix in which the rows of <argname>X</argname>
	  are reordered by increasing value of the elements in
	  column <argname>j</argname>. This is a stable sort: 
	  rows that share the same value in column <argname>j</argname>
	  will not be interchanged.
	</para>
      </description>
    </function>

    <function name="muniform" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a matrix with <argname>r</argname> rows and
	  <argname>c</argname> columns, filled with uniform (0,1)
	  pseudo-random variates. Note: the preferred method for
	  generating a scalar uniform r.v. is to use the <fncref
	  targ="randgen1"/> function.
	</para>
	<para>
	  <seelist>
            <fncref targ="mnormal"/>
            <fncref targ="uniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mwrite" section="data-utils" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="string">fname</fnarg>
	<fnarg optional="true" type="bool">export</fnarg>
      </fnargs>
      <description>
	<para>
	  Writes the matrix <argname>X</argname> to a file named
	  <argname>fname</argname>. By default this file will be plain
	  text; the first line will hold two integers, separated by a
	  tab character, representing the number of rows and columns;
	  on the following lines the matrix elements appear, in
	  scientific notation, separated by tabs (one line per row).
	  See below for alternative formats.
	</para>
	<para>
	  If a file <argname>fname</argname> already exists, it will be
	  overwritten. The return value is 0 on successful completion;
	  if an error occurs, such as the file being unwritable, the
	  return value will be non-zero.
	</para>
	<para>
	  The output file will be written in the currently set <cmdref
	  targ="workdir"/>, unless the <repl>filename</repl> string
	  contains a full path specification. However, if a non-zero
	  value is given for the <argname>export</argname> argument,
	  the output file will be written into the user's
	  <quote>dot</quote> directory, where it is accessible by
	  default via the matrix-loading functions offered in the
	  context of the <cmdref targ="foreign"/> command. In this
	  case a plain filename, without any path component, should be
	  given for the second argument.
	</para>
	<para>
	  Matrices stored via the <lit>mwrite</lit> function in its
	  default form can be easily read by other programs; see
	  <guideref targ="chap:matrices"/> for details.
	</para>
	<para>
	  Two mutually exclusive inflections of this function are
	  available, as follows:
	</para>
	<ilist>
	  <li>
	    <para>
	      If <argname>fname</argname> has the suffix
	      <quote><lit>.gz</lit></quote> the the file is written
	      with gzip compression. The format is basically as
	      described above except that the matrix elements are
	      written in a single column, in column-major order.
	    </para>
	  </li>
	  <li>
	    <para>
	      If <argname>fname</argname> has the suffix
	      <quote><lit>.bin</lit></quote> the the file is written
	      in binary format. In this case the first 19 bytes
	      contain the characters <lit>gretl_binary_matrix</lit>,
	      the next 8 bytes contain two 32-bit integers giving the
	      number of rows and columns, and the remainder of the
	      file contains the matrix elements as little-endian
	      <quote>doubles</quote>, in column-major order. If gretl
	      is run on a big-endian system, the binary values are
	      converted to little endian on writing, and converted to
	      big endian on reading.
	    </para>
	  </li>	  
	</ilist>
	<para>
	  Note that if the matrix file is to be read by a third-party
	  program it is not advisable to use the gzip or binary
	  options. But if the file is intended for reading by gretl
	  the alternative formats save space, and the binary format
	  allows for much faster reading of large matrices.
	</para>
	<para>
	  <seelist>
            <fncref targ="mread"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="mxtab" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a matrix holding the cross tabulation of the values
	  contained in <argname>x</argname> (by row) and
	  <argname>y</argname> (by column). The two arguments should be of
	  the same type (both series or both column vectors), and because
	  of the typical usage of this function, are assumed to contain
	  integer values only.
	</para>
	<para>
	  <seelist>
            <fncref targ="values"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="nadarwat" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series">x</fnarg>
	<fnarg type="scalar">h</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the Nadaraya&ndash;Watson nonparametric estimator of
	  the conditional mean of <argname>y</argname> given
	  <argname>x</argname>. It returns a series holding the
	  nonparametric estimate of
	  <math>E(y</math><sub>i</sub><math>|x</math><sub>i</sub><math>)</math>
	  for each nonmissing element of the series
	  <argname>x</argname>.
	</para>
	<para context="tex">
	  \[
	  m(x_i) = \frac{ \sum_{j=1}^{n} y_j \cdot K_h(x_i -
	  x_j)} {\sum_{j=1}^{n} K_h(x_i - x_j)}
	  \]
	  where the kernel function <math>K_h(\cdot)</math> is given
	  by
	  \[
	  K_h(x) = \exp\left(-\frac{x^2}{2h}\right)
	  \]
	  for $|x| &lt; \tau$ and zero otherwise.
	</para>
	<para context="notex">
	  The kernel function <math>K</math> is given
	  by <math>K = exp(-x</math><sup>2</sup><math> / 2h)</math>
	  for <math>|x| &lt; T</math> and zero otherwise.
	</para>
	<para context="tex">
	  The argument <argname>h</argname>, known as the
	  \emph{bandwidth}, is a parameter (a positive real number)
	  given by the user. This is usually a small number: larger
	  values of $h$ make $m(x)$ smoother; a popular choice is
	  $n^{-0.2}$. More details are given in <guideref
	  targ="chap:nonparam"/>.
	</para>
	<para context="notex">
	  The argument <argname>h</argname>, known as the bandwidth,
	  is a parameter (a positive real number) given by the
	  user. This is usually a small number: larger values
	  of <argname>h</argname> make <math>m(x)</math> smoother; a
	  popular choice is <math>n</math><sup>-0.2</sup>. More
	  details are given in <guideref targ="chap:nonparam"/>.
	</para>
	<para context="tex">
	  The scalar $\tau$ is used to prevent numerical problems when
	  the kernel function is evaluated too far away from zero
	  and is called the trim parameter.
	</para>
	<para context="notex">
	  The scalar <math>T</math> is used to prevent numerical
	  problems when the kernel function is evaluated too far away
	  from zero and is called the trim parameter.
	</para>
	<para>
	  The trim parameter can be adjusted via
	  the <lit>nadarwat_trim</lit> setting, as a multiple
	  of <argname>h</argname>. The default value is 4.  
	</para>
	<para>
	  The user may provide a negative value for the bandwidth:
	  this is interpreted as conventional syntax to obtain the
	  leave-one-out estimator, that is a variant of the estimator
	  that does not use the <math>i</math>-th observation for
	  evaluating <math>m(x</math><sub>i</sub><math>)</math>. This
	  makes the Nadaraya&ndash;Watson estimator more robust
	  numerically and its usage is normally advised when the
	  estimator is computed for inference purposes. Of course, the
	  bandwidth actually used is the absolute value of
	  <argname>h</argname>.
	</para>
	<para context="tex">
          In formulae, the leave-one-out estimator is
          \[
          m(x_i) = \frac{ \sum_{j \ne i} y_j \cdot K_h(x_i -
          x_j)} {\sum_{j \ne i} K_h(x_i - x_j)}
          \]
	</para>

      </description>
    </function>

    <function name="nelem" section="data-utils" output="int">
      <fnargs>
	<fnarg type="listetc">L</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the number of elements in the argument, which
	  may be a list, a matrix, a bundle, or an array (but not a
	  series).
	</para>
      </description>
    </function>

    <function name="ngetenv" section="strings" output="scalar">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>    
      <description>
	<para>
	  If an environment variable by the name of
	  <argname>s</argname> is defined and has a numerical value,
	  returns that value; otherwise returns NA.  See also <fncref
	  targ="getenv"/>.
	</para>
      </description>
    </function>

    <function name="nlines" section="strings" output="scalar">
      <fnargs>
	<fnarg type="string">buf</fnarg>
      </fnargs>    
      <description>
	<para>
	  Returns a count of the complete lines (that is, lines that
	  end with the newline character) in <argname>buf</argname>.
	</para>
    <para>
        Example:
    </para>
    <code>
        string web_page = readfile("http://gretl.sourceforge.net/")
        scalar number = nlines(web_page)
        print number
    </code>
      </description>
    </function>

    <function name="nobs" section="stats" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the number of non-missing observations for the variable
	  <argname>y</argname> in the currently selected sample.
	</para>
      </description>
    </function>

    <function name="normal" section="probdist" output="series">
      <fnargs>
	<fnarg type="scalar">&mu;</fnarg>
	<fnarg type="scalar">&sigma;</fnarg>
      </fnargs>
      <description>
	<para>
	  Generates a series of Gaussian pseudo-random variates with
	  mean &mu; and standard deviation &sigma;. If no arguments
	  are supplied, standard normal variates <math>N</math>(0,1)
	  are produced.  The values are produced using the Ziggurat
	  method <cite key="marsaglia00" p="true">(Marsaglia and
	  Tsang, 2000)</cite>.
	</para>
	<para>
	  <seelist>
            <fncref targ="randgen"/>
            <fncref targ="mnormal"/>
            <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="npv" section="math" output="scalar">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg type="scalar">r</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the Net Present Value of <argname>x</argname>,
	  considered as a sequence of payments (negative) and receipts
	  (positive), evaluated at annual discount rate
	  <argname>r</argname>, which must be expressed as a decimal
	  fraction, not a percentage (0.05 rather than 5<lit>%</lit>).
	  The first value is taken as dated <quote>now</quote> and is
	  not discounted.  To emulate an NPV function in which the
	  first value is discounted, prepend zero to the input
	  sequence.
	</para>
	<para>
	  Supported data frequencies are annual, quarterly, monthly, and
	  undated (undated data are treated as if annual).
	</para>
	<para>
	  <seelist>
            <fncref targ="irr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="NRmax" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="fncall" optional="true">g</fnarg>
	<fnarg type="fncall" optional="true">h</fnarg>
      </fnargs>
      <description>
	<para>
	  Numerical maximization via the Newton&ndash;Raphson method.
	  On input the vector <argname>b</argname> should hold the
	  initial values of a set of parameters, and the argument
	  <argname>f</argname> should specify a call to a function
	  that calculates the (scalar) criterion to be maximized,
	  given the current parameter values and any other relevant
	  data. If the object is in fact minimization, this function
	  should return the negative of the criterion.  On successful
	  completion, <lit>NRmax</lit> returns the maximized value of
	  the criterion, and <argname>b</argname> holds the parameter
	  values which produce the maximum.
	</para>
	<para>
	  The optional third and fourth arguments provide means of
	  supplying analytical derivatives and an analytical
	  (negative) Hessian, respectively. The functions referenced
	  by <argname>g</argname> and <argname>h</argname> must take
	  as their first argument a pre-defined matrix that is of the
	  correct size to contain the gradient or Hessian,
	  respectively, given in pointer form. They also must take the
	  parameter vector as an argument (in pointer form or
	  otherwise).  Other arguments are optional. If either or
	  both of the optional arguments are omitted, a numerical
	  approximation is used.
	</para>
	<para>
	  For more details and examples see the chapter on numerical
	  methods in <guideref targ="chap:numerical"/>.
	  <seelist>
            <fncref targ="BFGSmax"/>
            <fncref targ="fdjac"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="nullspace" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Computes the right nullspace of <argname>A</argname>, via the
	  singular value decomposition: the result is a matrix
	  <math>B</math> such that the product <math>AB</math> is a zero
	  matrix, except when <argname>A</argname> has full column rank,
	  in which case an empty matrix is returned. Otherwise, if
	  <argname>A</argname> is <by r="m" c="n"/>,
	  <math>B</math> will be <math>n</math> by (<math>n</math> &minus;
	  <math>r</math>), where <math>r</math> is the rank of
	  <argname>A</argname>. 
	</para>
	<para context="tex">
	  Computes the right nullspace of <argname>A</argname>, via the
	  singular value decomposition: the result is a matrix $B$ such
	  that $AB = [0]$, except when $A$ has full column rank, in which
	  case an empty matrix is returned. Otherwise, if $A$ is $m \times
	  n$, $B$ will be an $n \times (n-r)$ matrix, where $r$ is the
	  rank of $A$.  
	</para>
	<para>
	  <seelist>
            <fncref targ="rank"/>
            <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="obs" section="data-utils" output="series">
      <description>
	<para>
	  Returns a series of consecutive integers, setting 1 at the
	  start of the dataset. Note that the result is invariant to
	  subsampling. This function is especially useful with
	  time-series datasets. Note: you can write <lit>t</lit>
	  instead of <lit>obs</lit> with the same effect.
	</para>
	<para>
	  <seelist>
            <fncref targ="obsnum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="obslabel" section="data-utils" output="string">
      <fnargs>
	<fnarg type="int">t</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the observation label for observation
	  <argname>t</argname>, where <argname>t</argname> is a
	  1-based index.  The inverse function is provided by <fncref
	  targ="obsnum"/>.
	</para>
      </description>
    </function>

    <function name="obsnum" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns an integer corresponding to the observation specified by
	  the string <math>s</math>. Note that the result is invariant to
	  subsampling. This function is especially useful with time-series
	  datasets.  For example, the following code
	</para>
	<code>
	  open denmark 
	  k = obsnum(1980:1)
	</code>
	<para>
	  yields <lit>k = 25</lit>, indicating that the first quarter of
	  1980 is the 25th observation in the <lit>denmark</lit> dataset.
	</para>
	<para>
	  <seelist>
            <fncref targ="obs"/>
            <fncref targ="obslabel"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ok" section="data-utils" output="seebelow">
      <fnargs>
	<fnarg type="anyfloat-or-list">x</fnarg>
      </fnargs>
      <description>
	<para>
	  If <argname>x</argname> is a scalar, returns 1 if
	  <argname>x</argname> is not <lit>NA</lit>, otherwise 0.  If
	  <argname>x</argname> is a series, returns a series with
	  value 1 at observations with non-missing values and zeros
	  elsewhere. If <argname>x</argname> is a list, the output is
	  a series with 0 at observations for which at least one
	  series in the list has a missing value, and 1 otherwise.
	</para>
	<para>
	  If <argname>x</argname> is a matrix the behavior is a little
	  different, since matrices cannot contain <lit>NA</lit>s: the
	  function returns a matrix of the same dimensions as
	  <argname>x</argname>, with 1s in positions corresponding to
	  finite elements of <argname>x</argname> and 0s in positions
	  where the elements are non-finite (either infinities or
	  not-a-number, as per the IEEE 754 standard).
	</para>
	<para>
	  <seelist>
            <fncref targ="missing"/>
            <fncref targ="misszero"/>
            <fncref targ="zeromiss"/>
	  </seelist>
	  But note that these functions are not applicable to matrices.
	</para>
      </description>
    </function>

    <function name="onenorm" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Returns the 1-norm of the matrix <argname>X</argname>, that is,
	  the maximum across the columns of <argname>X</argname> of the
	  sum of absolute values of the column elements.
	</para>
	<para context="tex">
	  Returns the 1-norm of the $r \times c$ matrix
	  <argname>X</argname>: 
	  \[\| X \|_1 = \max_j \sum_{i=1}^r |X_{ij}| \]
	</para>
	<para>
	  <seelist>
            <fncref targ="infnorm"/>
            <fncref targ="rcond"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ones" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg type="int">c</fnarg>
      </fnargs>
      <description>
	<para>
	  Outputs a matrix with <math>r</math> rows and <math>c</math>
	  columns, filled with ones.
	</para>
	<para>
	  <seelist>
            <fncref targ="seq"/>
            <fncref targ="zeros"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="orthdev" section="transforms" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Only applicable if the currently open dataset has a panel
	  structure. Computes the forward orthogonal deviations for
	  variable <argname>y</argname>.
	</para>
	<para context="tex">
	  Only applicable if the currently open dataset has a panel
	  structure. Computes the forward orthogonal deviations for
	  variable <argname>y</argname>, that is 
	  \[ \tilde{y}_{i,t} =
	  \sqrt{ \frac{T_i - t}{T_i - t + 1}} \left( y_{i,t} -
	  \frac{1}{T_i - t} \sum_{s=t+1}^{T_i} y_{i,s} \right) \]
	</para>
	<para>
	  This transformation is sometimes used instead of
	  differencing to remove individual effects from panel data.
	  For compatibility with first differences, the deviations are
	  stored one step ahead of their true temporal location (that
	  is, the value at observation <math>t</math> is the deviation
	  that, strictly speaking, belongs at <math>t</math> &minus;
	  1).  That way one loses the first observation in each time
	  series, not the last.
	</para>
	<para>
	  <seelist>
            <fncref targ="diff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pdf" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <examples>
	<example>f1 = pdf(N, -2.5)</example>
	<example>f2 = pdf(X, 3, y)</example>
	<example>f3 = pdf(W, shape, scale, y)</example>
      </examples>
      <description>
	<para>
	  Probability density function calculator. Returns the density
	  at <argname>x</argname> of the distribution identified by
	  the code <argname>d</argname>.  See <fncref targ="cdf"/> for
	  details of the required (scalar) arguments.  The
	  distributions supported by the <lit>pdf</lit> function are
	  the normal, Student's <math>t</math>, chi-square,
	  <math>F</math>, Gamma, Weibull, Generalized Error, Binomial
	  and Poisson. Note that for the Binomial and the Poisson
	  what's calculated is in fact the probability mass at the
	  specified point. For Student's <math>t</math>, chi-square,
	  <math>F</math> the noncentral variants are supported too.
	</para>
	<para>
	  For the normal distribution, see also <fncref targ="dnorm"/>.
	</para>
      </description>
    </function>

    <function name="pergm" section="stats" output="matrix">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
	<fnarg optional="true" type="scalar">bandwidth</fnarg>
      </fnargs>
      <description>
	<para>
	  If only the first argument is given, computes the sample periodogram
	  for the given series or vector. If the second argument is given,
	  computes an estimate of the spectrum of <argname>x</argname> using a
	  Bartlett lag window of the given bandwidth, up to a maximum of half
	  the number of observations (<math>T</math>/2).
	</para>
	<para>
	  Returns a matrix with two columns and <math>T</math>/2 rows:
	  the first column holds the frequency, &omega;, from
	  2&pi;/<math>T</math> to &pi;, and the second the
	  corresponding spectral density.
	</para>
      </description>
    </function>

    <function name="pexpand" section="data-utils" output="series">
      <fnargs>
	<fnarg type="vector">v</fnarg>
      </fnargs>
      <description>
	<para>
	  Only applicable if the currently open dataset has a panel
	  structure. Performs the inverse operation of <fncref
	  targ="pshrink"/>. That is, given a vector of length
	  equal to the number of individuals in the current
	  panel sample, it returns a series in which each value
	  is repeated <math>T</math> times, for <math>T</math>
	  the time-series length of the panel. The resulting
	  series is therefore non-time varying.
	</para>
      </description>
    </function>    

    <function name="pmax" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para>
	  Only applicable if the current dataset has a panel
	  structure. Returns a series holding the maxima of variable
	  <argname>y</argname> for each cross-sectional unit (repeated
	  for each time period).
	</para>
	<para>
	  If the optional second argument is provided then
	  observations for which the value of <argname>mask</argname>
	  is zero are ignored.
	</para>
	<para>
	  <seelist> 
            <fncref targ="pmin"/>
            <fncref targ="pmean"/>
            <fncref targ="pnobs"/>
            <fncref targ="psd"/>
            <fncref targ="pxsum"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pmean" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Only applicable if the currentl dataset has a panel
	  structure. Returns a series holding the time-mean of
	  variable <argname>y</argname> for each cross-sectional unit,
	  the values being repeated for each period. Missing
	  observations are skipped in calculating the means.
	</para>
	<para context="tex">
	  Only applicable if the current dataset has a panel
	  structure. Computes the time-mean of variable
	  <argname>y</argname> for each cross-sectional unit; that is,
	  \[ \bar{y}_i = \frac{1}{T_i} \sum_{t=1}^{T_i} y_{i,t}\]
	  where $T_i$ is the number of valid observations for unit
	  $i$.
	</para>
	<para>
	  If the optional second argument is provided then
	  observations for which the value of <argname>mask</argname>
	  is zero are ignored.
	</para>
	<para>
	  <seelist> 
            <fncref targ="pmax"/>
            <fncref targ="pmin"/>
            <fncref targ="pnobs"/>
            <fncref targ="psd"/>
            <fncref targ="pxsum"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pmin" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para>
	  Only applicable if the current dataset has a panel
	  structure. Returns a series holding the minima of variable
	  <argname>y</argname> for each cross-sectional unit (repeated
	  for each time period).
	</para>
	<para>
	  If the optional second argument is provided then
	  observations for which the value of <argname>mask</argname>
	  is zero are ignored.
	</para> 
	<para>
	  <seelist> 
            <fncref targ="pmax"/>
            <fncref targ="pmean"/>
            <fncref targ="pnobs"/>
            <fncref targ="psd"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pnobs" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para>
	  Only applicable if the current dataset has a panel
	  structure. Returns a series holding the number of valid
	  observations of variable <argname>y</argname> for each
	  cross-sectional unit (repeated for each time period).
	</para>
	<para>
	  If the optional second argument is provided then
	  observations for which the value of <argname>mask</argname>
	  is zero are ignored.
	</para>
	<para>
	  <seelist> 
            <fncref targ="pmax"/>
            <fncref targ="pmin"/>
            <fncref targ="pmean"/>
            <fncref targ="psd"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="polroots" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="vector">a</fnarg>
      </fnargs>
      <description>
	<para>
	  Finds the roots of a polynomial.  If the polynomial is of degree
	  <math>p</math>, the vector <argname>a</argname> should contain
	  <math>p</math> + 1 coefficients in ascending order, &ie; starting
	  with the constant and ending with the coefficient on
	  <math>x</math><sup>p</sup>.
	</para>
	<para>
	  If all the roots are real they are returned in a column vector of
	  length <math>p</math>, otherwise a <by r="p" c="2"/> matrix
	  is returned, the real parts in the first column and the imaginary
	  parts in the second.
	</para>
      </description>
    </function>

    <function name="polyfit" section="filters" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="int">q</fnarg>
      </fnargs>
      <description>
	<para>
	  Fits a polynomial trend of order <argname>q</argname> to the
	  input series <argname>y</argname> using the method of
	  orthogonal polynomials. The series returned holds the
	  fitted values.
	</para>
      </description>
    </function>

    <function name="princomp" section="stats" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">p</fnarg>
	<fnarg optional="true" type="bool">covmat</fnarg>
      </fnargs>
      <description>
	<para>
	  Let the matrix <argname>X</argname> be <by r="T" c="k"/>,
	  containing <math>T</math> observations on <math>k</math>
	  variables.  The argument <argname>p</argname> must be a
	  positive integer less than or equal to <math>k</math>. This
	  function returns a <by r="T" c="p"/> matrix, <math>P</math>,
	  holding the first <math>p</math> principal components of
	  <argname>X</argname>.
	</para>
	<para>
	  The optional third argument acts as a boolean switch: if it is
	  non-zero the principal components are computed on the basis of
	  the covariance matrix of the columns of <argname>X</argname>
	  (the default is to use the correlation matrix).
	</para>
	<para context="notex">
	  The elements of <math>P</math> are computed as the sum from
	  <math>i</math> to <math>k</math> of
	  <math>Z</math><sub>ti</sub> times
	  <math>v</math><sub>ji</sub>, where
	  <math>Z</math><sub>ti</sub> is the standardized value of
	  variable <math>i</math> at observation <math>t</math> and
	  <math>v</math><sub>ji</sub> is the <math>j</math>th
	  eigenvector of the correlation (or covariance) matrix of the
	  <math>X</math><sub>i</sub>s, with the eigenvectors ordered
	  by decreasing value of the corresponding eigenvalues.
	</para>
	<para context="tex">
	  The elements of $P$ are computed as 
	  \[ P_{tj} = \sum_{i=1}^{k} Z_{ti} \, v^{(j)}_i \] 
	  where $Z_{ti}$ is the standardized value
	  of variable $i$ at observation $t$, $Z_{ti} = (X_{ti} -
	  \bar{X}_i) / \hat{\sigma}_i$, and $v^{(j)}$ is the $j$th
	  eigenvector of the correlation (or covariance) matrix of the
	  $X_i$s, with the eigenvectors ordered by decreasing value 
	  of the corresponding eigenvalues.
	</para> 
	<para>
	  <seelist>
            <fncref targ="eigensym"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="prodc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the product of the elements of <argname>X</argname>,
	  by column.
	  <seelist>
            <fncref targ="prodr"/>
            <fncref targ="meanc"/>
            <fncref targ="sdc"/>
            <fncref targ="sumc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="prodr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the product of the elements of <argname>X</argname>,
	  by row.
	  <seelist>
            <fncref targ="prodc"/>
            <fncref targ="meanr"/>
            <fncref targ="sumr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="psd" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Only applicable if the current dataset has a panel
	  structure. Returns a series holding the sample standard
	  deviation of variable <math>y</math> for each
	  cross-sectional unit (with the values repeated for each time
	  period).  The denominator used is the sample size for each
	  unit minus 1, unless the number of valid observations for
	  the given unit is 1 (in which case 0 is returned) or 0 (in
	  which case <lit>NA</lit> is returned).
	</para>
	<para context="tex">
	  Only applicable if the current dataset has a panel
	  structure. Computes the per-unit sample standard deviation
	  for variable <math>y</math>, that is \[ \sigma_i =
	  \sqrt{\frac{1}{T_i - 1} \sum_{t=1}^{T_i} (y_{i,t} -
	  \bar{y}_i)^2 } \] The above formula holds for $T_i \ge 2$,
	  where $T_i$ is the number of valid observations for unit
	  $i$; if $T_i = 0$, <lit>NA</lit> is returned; if $T_i = 1$,
	  0 is returned.
	</para>
	<para>
	  If the optional second argument is provided then
	  observations for which the value of <argname>mask</argname>
	  is zero are ignored.
	</para>
	<para>
	  Note: this function makes it possible to check whether a given
	  variable (say, <lit>X</lit>) is time-invariant via the condition
	  <lit>max(psd(X)) == 0</lit>.
	</para> 
	<para>
	  <seelist>
            <fncref targ="pmax"/>
            <fncref targ="pmin"/>
            <fncref targ="pmean"/>
            <fncref targ="pnobs"/>
            <fncref targ="pshrink"/>
            <fncref targ="psum"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="psdroot" section="linalg" output="smatrix">
      <fnargs>
	<fnarg type="symmat">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Performs a generalized variant of the Cholesky decomposition of
	  the matrix <argname>A</argname>, which must be positive
	  semidefinite (but which may be singular). If the input matrix is
	  not square an error is flagged, but symmetry is assumed and not
	  tested; only the lower triangle of <argname>A</argname> is read.
	  The result is a lower-triangular matrix <math>L</math> which
	  satisfies <equation status="inline" ascii="A = LL'" tex="$A =
	  LL'$"/>.  Indeterminate elements in the solution are set to
	  zero.
	</para>
	<para>
	  For the case where <argname>A</argname> is positive definite,
	  see <fncref targ="cholesky"/>.
	</para>
      </description>
    </function>

    <function name="pshrink" section="data-utils" output="matrix">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Only applicable if the current dataset has a panel
	  structure. Returns a column vector holding the first valid
	  observation for the series <argname>y</argname> for each
	  cross-sectional unit in the panel, over the current sample
	  range. If a unit has no valid observations for the input
	  series it is skipped.
	</para>
	<para>
	  This function provides a means of compacting the series
	  returned by functions such as <fncref targ="pmax"/> and
	  <fncref targ="pmean"/>, in which a value pertaining to
	  each cross-sectional unit is repeated for each time
	  period. 
	</para>
	<para>
	  See <fncref targ="pexpand"/> for the inverse operation.
	</para>
      </description>
    </function>

    <function name="psum" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  This function is applicable only if the current dataset has
	  a panel structure. It returns a series holding the sum over
	  time of variable <argname>y</argname> for each
	  cross-sectional unit, the values being repeated for each
	  period. Missing observations are skipped in calculating the
	  sums.
	</para>
	<para context="tex">
	  This function is applicable only if the current dataset has
	  a panel structure. It computes the sum over time of variable
	  <argname>y</argname> for each cross-sectional unit; that is,
	  \[ S_i = \sum_{t=1}^{T_i} y_{i,t}\] where $T_i$ is the
	  number of valid observations for unit $i$.
	</para>
	<para>
	  If the optional second argument is provided then
	  observations for which the value of <argname>mask</argname>
	  is zero are ignored.
	</para>
	<para>
	  <seelist> 
            <fncref targ="pmax"/>
            <fncref targ="pmean"/>
            <fncref targ="pmin"/>
            <fncref targ="pnobs"/>
            <fncref targ="psd"/>
            <fncref targ="pxsum"/>
            <fncref targ="pshrink"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pvalue" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="char">c</fnarg>
	<fnarg type="seebelow">&hellip;</fnarg>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs> 
      <examples>
	<example>p1 = pvalue(z, 2.2)</example>
	<example>p2 = pvalue(X, 3, 5.67)</example>
	<example>p2 = pvalue(F, 3, 30, 5.67)</example>
      </examples>
      <description>
	<para>
	  <math>P</math>-value calculator. Returns <equation
	  status="inline" ascii="P(X > x)" tex="$P(X > x)$"/>, where
	  the distribution of <math>X</math> is determined by the
	  character <argname>c</argname>. Between the arguments
	  <argname>c</argname> and <argname>x</argname>, zero or more
	  additional arguments are required to specify the parameters
	  of the distribution; see <fncref targ="cdf"/> for details.
	  The distributions supported by the <lit>pval</lit> function
	  are the standard normal, <math>t</math>, Chi square,
	  <math>F</math>, gamma, binomial, Poisson, Weibull and
	  Generalized Error.
	</para>
	<para>
	  <seelist>
            <fncref targ="critical"/>
            <fncref targ="invcdf"/>
            <fncref targ="urcpval"/>
            <fncref targ="imhof"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="pxnobs" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para>
	  Only applicable if the current dataset has a panel
	  structure. Returns a series holding the number of valid
	  observations of <argname>y</argname> in each time period
	  (this count being repeated for each unit).
	</para>
	<para>
	  If the optional second argument is provided then
	  observations for which the value of <argname>mask</argname>
	  is zero are ignored.
	</para>
	<para>
	  Note that this function works in a different dimension from
	  the <fncref targ="pnobs"/> function.
	</para>
      </description>
    </function>    

    <function name="pxsum" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="series" optional="true">mask</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Only applicable if the current dataset has a panel
	  structure. Returns a series holding the sum of the values of
	  <argname>y</argname> for each cross-sectional unit in each
	  period (the values being repeated for each unit).
	</para>
	<para context="tex">
	  Only applicable if the currently open dataset has a panel
	  structure. Computes the cross-sectional sum for variable
	  <argname>y</argname> in each period; that is, 
	  \[ \tilde{y}_t = \sum_{i=1}^{N} y_{i,t}\] 
	  where $N$ is the number of cross-sectional units.
	</para>
	<para>
	  If the optional second argument is provided then
	  observations for which the value of <argname>mask</argname>
	  is zero are ignored.
	</para>
	<para>
	  Note that this function works in a different dimension from
	  the <fncref targ="psum"/> function.
	</para>
      </description>
    </function>

    <function name="qform" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">x</fnarg>
	<fnarg type="symmat">A</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Computes the quadratic form <equation status="inline"
	  ascii="Y = xAx'" tex="$Y = x A x'$"/>.  Using this function
	  instead of ordinary matrix multiplication guarantees more
	  speed and better accuracy, when <argname>A</argname> is a
	  generic symmetric matrix. However, in the special case when
	  <argname>A</argname> is the identity matrix, the simple
	  expression <lit>x'x</lit> performs much better than
	  <lit>qform(x',I(rows(x))</lit>.
	</para>
	<para context="tex">
	  Computes the quadratic form <equation status="inline"
	  ascii="Y = xAx'" tex="$Y = x A x'$"/>.  Using this function
	  instead of ordinary matrix multiplication guarantees more
	  speed and better accuracy, when <argname>A</argname> is a
	  generic symmetric matrix.  However, in the special case <equation
	  status="inline" ascii="A = I" tex="$A = I$"/>, the simple
	  expression <lit>x'x</lit> performs much better than
	  <lit>qform(x',I(rows(x))</lit>.
	</para>
	<para>
	If <argname>x</argname> and <argname>A</argname> are not
	conformable, or <argname>A</argname> is not symmetric, an error
	is returned.
	</para>
      </description>
    </function>

    <function name="qlrpval" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="scalar">X2</fnarg>
	<fnarg type="int">df</fnarg>
	<fnarg type="scalar">p1</fnarg>
	<fnarg type="scalar">p2</fnarg>
      </fnargs>
      <description>
	<para>
	  <math>P</math>-values for the test statistic from the QLR
	  sup-Wald test for a structural break at an unknown point
	  (see <cmdref targ="qlrtest"/>), as per <cite
	  key="hansen97">Bruce Hansen (1997)</cite>.
	</para>
	<para>
	  The first argument, <argname>X2</argname>, denotes the
	  (chi-square form of) the maximum Wald test statistic and
	  <argname>df</argname> denotes its degrees of freedom.  The
	  third and fourth arguments represent, as decimal fractions
	  of the overall estimation range, the starting and ending
	  points of the central range of observations over which the
	  successive Wald tests are calculated. For example if the
	  standard approach of 15 percent trimming is adopted, you
	  would set <argname>p1</argname> to 0.15 and
	  <argname>p2</argname> to 0.85.
	</para>
	<para>
	  <seelist> 
            <fncref targ="pvalue"/>
	    <fncref targ="urcpval"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="qnorm" section="probdist" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns quantiles for the standard normal distribution. If
	  <argname>x</argname> is not between 0 and 1, <lit>NA</lit> is
	  returned. 
	  <seelist>
            <fncref targ="cnorm"/>
            <fncref targ="dnorm"/>
	  </seelist>
	</para>
      </description>
    </function>  

    <function name="qrdecomp" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;R</fnarg>
      </fnargs>
      <description>
	<para>
	  Computes the QR decomposition of an <by r="m" c="n"/> matrix
	  <argname>X</argname>, that is <math>X = QR</math> where
	  <math>Q</math> is an <by r="m" c="n"/> orthogonal matrix and
	  <math>R</math> is an <by r="n" c="n"/> upper triangular matrix. The
	  matrix <math>Q</math> is returned directly, while <math>R</math> can
	  be retrieved via the optional second argument.
	</para>
	<para>
	  <seelist>
            <fncref targ="eigengen"/>
            <fncref targ="eigensym"/>
            <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="quadtable" section="stats" output="matrix">
      <fnargs>
	<fnarg type="int">n</fnarg>
	<fnarg type="int" optional="true">type</fnarg>
	<fnarg type="scalar" optional="true">a</fnarg>
	<fnarg type="scalar" optional="true">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns an <by r="n" c="2"/> matrix for use with Gaussian
	  quadrature (numerical integration). The first column holds
	  the nodes or abscissae, the second the weights.
	</para>
	<para>
	  The first argument specifies the number of points (rows) to
	  compute. The second argument codes for the type of
	  quadrature: use 1 for Gauss&ndash;Hermite (the default);
	  2 for Gauss&ndash;Legendre; or 3 for Gauss&ndash;Laguerre.
	  The significance of the optional parameters
	  <argname>a</argname> and <argname>b</argname> depends on the
	  selected <argname>type</argname>, as explained below.
	</para>
	<para context="notex">
	  Gaussian quadrature is a method of approximating numerically
	  the definite integral of some function of interest. Let the
	  function be represented as the product
	  <math>f(x)W(x)</math>. The types of quadrature differ in the
	  specification of the component <math>W(x)</math>: in the
	  Hermite case this is exp(&minus;<math>x</math><sup>2</sup>);
	  in the Laguerre case, exp(&minus;<math>x</math>); and in the
	  Legendre case simply <math>W(x)</math> = 1.
	</para>
	<para context="tex">
	  Gaussian quadrature is a method of approximating numerically
	  the definite integral of some function of interest. Let the
	  function be represented as the product $f(x)W(x)$. The types
	  of quadrature differ in the specification of the component
	  $W(x)$: in the Hermite case we have $W(x) = \exp(-x^2)$; in
	  the Laguerre case, $W(x) = \exp(-x)$; and in the Legendre
	  case simply $W(x) = 1$.
	</para>
	<para context="notex">
	  For each specification of <math>W</math>, one can compute a
	  set of nodes, <math>x</math><sub>i</sub>, and weights,
	  <math>w</math><sub>i</sub>, such that the sum from
	  <math>i</math>=1 to <math>n</math> of
	  <math>w</math><sub>i</sub>
	  <math>f</math>(<math>x</math><sub>i</sub>) approximates the
	  desired integral. The method of <cite key="golub69">Golub
	  and Welsch (1969)</cite> is used.
	</para>
	<para context="tex">
	  For each specification of $W(x)$, one can compute a set of
	  nodes, $x_i$, and weights, $w_i$, such that $\sum_{i=1}^n
	  f(x_i) w_i$ approximates the desired integral. The method of
	  <cite key="golub69">Golub and Welsch (1969)</cite> is used.
	</para>
	<para context="notex">
	  When the Gauss&ndash;Legendre type is selected, the 
	  optional arguments <argname>a</argname> and
	  <argname>b</argname> can be used to control the lower and
	  upper limits of integration, the default values being
	  &minus;1 and 1. (In Hermite quadrature the
	  limits are fixed at minus and plus infinity, while in
	  the Laguerre case they are fixed at 0 and infinity.)
	</para>
	<para context="tex">
	  When the Gauss&ndash;Legendre type is selected, the optional
	  arguments <argname>a</argname> and <argname>b</argname> can
	  be used to control the lower and upper limits of
	  integration, the default values being $-1$ and 1. (In Hermite
	  quadrature the limits are fixed at $-\infty$ and $+\infty$,
	  while in the Laguerre case they are fixed at 0 and $\infty$.)
	</para>
	<para context="notex">
	  In the Hermite case <argname>a</argname> and
	  <argname>b</argname> play a different role: they can be used
	  to replace the default form of
	  <math>W</math>(<math>x</math>) with the (closely related)
	  normal distribution with mean <argname>a</argname> and
	  standard deviation <argname>b</argname>. Supplying values of
	  0 and 1 for these parameters, for example, has the effect of
	  making <math>W</math>(<math>x</math>) into the standard
	  normal pdf, which is equivalent to multiplying the default
	  nodes by the square root of two and dividing the weights by
	  the square root of &pi;.
	</para>
	<para context="tex">
	  In the Hermite case <argname>a</argname> and
	  <argname>b</argname> play a different role: they can be used
	  to replace the default form of $W(x)$ with the
	  (closely related) normal distribution with mean
	  <argname>a</argname> and standard deviation
	  <argname>b</argname>. Supplying values of 0 and 1 for these
	  parameters, for example, has the effect of making
	  $W(x)$ into the standard normal pdf, which is equivalent
	  to multiplying the default $x_i$ values by $\sqrt{2}$
	  and dividing the default $w_i$ by $\sqrt{\pi}$.
	</para>
      </description>
    </function>    

    <function name="quantile" section="stats" output="scalar" altout="matrix">
      <fnargs>
	<fnarg type="series-or-mat">y</fnarg>
	<fnarg type="pscalar">p</fnarg>
      </fnargs>
      <description>
	<para>
	  If <argname>y</argname> is a series, returns the
	  <argname>p</argname>-quantile for the series. For example, when
	  <math>p</math> = 0.5, the median is returned.
	</para>
	<para>
	  If <argname>y</argname> is a matrix, returns a row vector
	  containing the <argname>p</argname>-quantiles for the columns of
	  <argname>y</argname>; that is, each column is treated as a
	  series.
	</para>
	<para>
	  In addition, for matrix <argname>y</argname> an alternate form
	  of the second argument is supported: <argname>p</argname> may be
	  given as a vector. In that case the return value is an <by r="m"
	  c="n"/> matrix, where <repl>m</repl> is the number of elements
	  in <argname>p</argname> and <repl>n</repl> is the number of
	  columns in <argname>y</argname>.
	</para>
	<para context="tex">
	  For a series of length $n$, the $p$-quantile, $q$, is defined
	  as:
	  \[q = y_{[k]} + [(n+1) \cdot p - k] (y_{[k+1]} - y_{[k]})\] 
	  where $k$ is the integer part of $(n+1) \cdot p$ and 
	  $y_{[i]}$ is the $i$-th element of the series when
	  sorted from smallest to largest.
	</para>
      </description>
    </function>

    <function name="randgen" section="probdist" output="series">
      <fnargs>
	<fnarg type="string">d</fnarg>
	<fnarg type="scalar-or-series">p1</fnarg>
	<fnarg type="scalar-or-series" conditional="true">p2</fnarg>
	<fnarg type="scalar" conditional="true">p3</fnarg>
      </fnargs>
      <examples>
	<example>series x = randgen(u, 0, 100)</example>
	<example>series t14 = randgen(t, 14)</example>
	<example>series y = randgen(B, 0.6, 30)</example>
	<example>series g = randgen(G, 1, 1)</example>
	<example>series P = randgen(P, mu)</example>
      </examples>
      <description>
	<para>
	  All-purpose random number generator. The argument
	  <argname>d</argname> is a string (in most cases just a
	  single character) which specifies the distribution from
	  which the pseudo-random numbers should be drawn. The
	  arguments <argname>p1</argname> to <argname>p3</argname>
	  specify the parameters of the selected distribution; the
	  number of such parameters depends on the distribution.  For
	  distributions other than the beta-binomial, the parameters
	  <argname>p1</argname> and (if applicable)
	  <argname>p2</argname> may be given as either scalars or
	  series: if they are given as scalars the output series is
	  identically distributed, while if a series is given for
	  <argname>p1</argname> or <argname>p2</argname> the
	  distribution is conditional on the parameter value at each
	  observation. In the case of the beta-binomial all the
	  parameters must be scalars.
	</para>
	<para>
	  Specifics are given below: the string code for each
	  distribution is shown in parentheses, followed by the
	  interpretation of the argument <argname>p1</argname> and,
	  where applicable, <argname>p2</argname> and
	  <argname>p3</argname>.
	</para>
	
	<ilist context="notex">
	  <li>
            <para>
              Uniform (continuous) (u or U): minimum, maximum
            </para>
	  </li>
	  <li>
            <para>
              Uniform (discrete) (i): minimum, maximum
            </para>
	  </li>
	  <li>
            <para>
              Normal (z, n, or N): mean, standard deviation
            </para>
	  </li>
	  <li>
            <para>
              Student's t (t): degrees of freedom
            </para>
	  </li>
	  <li>
            <para>
              Chi square (c, x, or X): degrees of freedom
            </para>
	  </li>
	  <li>
            <para>
              Snedecor's F (f or F): df (num.), df (den.)
            </para>
	  </li>
	  <li>
            <para>
              Gamma (g or G): shape, scale
            </para>
	  </li>   
	  <li>
            <para>
              Binomial (b or B): probability, number of trials
            </para>
	  </li>   
	  <li>
            <para>
              Poisson (p or P): mean
            </para>
	  </li> 
	  <li>
            <para>
              Weibull (w or W): shape, scale
            </para>
	  </li> 
	  <li>
            <para>
              Generalized Error (E): shape
            </para>
	  </li>
	  <li>
            <para>
              Beta (beta): shape1, shape2
            </para>
	  </li>
	  <li>
            <para>
              Beta-Binomial (bb): trials, shape1, shape2
            </para>
	  </li>
	</ilist>
	<para context="tex">
	  \begin{center}
	  \begin{tabular}{lllll}
	  \textbf{Distribution} &amp; \textsl{d} &amp; \textsl{p1} &amp; \textsl{p2} &amp; \textsl{p3}\\[4pt]
	  Uniform (continuous) &amp; \texttt{u} or \texttt{U} &amp; minimum &amp; maximum &amp; --\\
	  Uniform (discrete) &amp; \texttt{i} &amp; minimum &amp; maximum &amp; --\\
	  Normal &amp; \texttt{z}, \texttt{n} or \texttt{N} &amp; mean &amp; standard deviation &amp; --\\
	  Student's $t$ &amp; \texttt{t} &amp; degrees of freedom &amp; -- &amp; --\\
	  Chi square &amp; \texttt{c}, \texttt{x} or \texttt{X} &amp; degrees of freedom &amp; -- &amp; --\\
	  Snedecor's $F$ &amp; \texttt{f} or \texttt{F} &amp; df (num.) &amp; df (den.) &amp; --\\
	  Gamma &amp; \texttt{g} or \texttt{G} &amp; shape &amp; scale  &amp; --\\
	  Binomial &amp; \texttt{b} or \texttt{B} &amp; $p$ &amp; $n$  &amp; --\\
	  Poisson &amp; \texttt{p} or \texttt{P} &amp; mean &amp; --  &amp; --\\
	  Weibull &amp; \texttt{w} or \texttt{W} &amp; shape &amp; scale &amp; --\\
	  Generalized Error &amp; \texttt{e} or \texttt{E} &amp; shape &amp; -- &amp; --\\
	  Beta &amp; \texttt{beta} &amp; shape1 &amp; shape2 &amp; --\\
	  Beta-Binomial &amp; \texttt{bb} &amp; $n$ &amp; shape1 &amp; shape2
	  \end{tabular}
	  \end{center}
	</para>
	<para>
	  <seelist>
            <fncref targ="normal"/>
            <fncref targ="uniform"/> 
            <fncref targ="mrandgen"/>
            <fncref targ="randgen1"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="randgen1" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="char">d</fnarg>
	<fnarg type="scalar">p1</fnarg>
	<fnarg type="scalar" conditional="true">p2</fnarg>
      </fnargs>
      <examples>
	<example>scalar x = randgen1(z, 0, 1)</example>
	<example>scalar g = randgen1(g, 3, 2.5)</example>
      </examples>
      <description>
	<para>
	  Works like <fncref targ="randgen"/> except that the return
	  value is a scalar rather than a series.
	</para>
	<para>
	  The first example above calls for a value from the standard
	  normal distribution, while the second specifies a drawing
	  from the Gamma distribution with shape 3 and scale 2.5.
	</para>
	<para>
	  <seelist>
            <fncref targ="mrandgen"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="randint" section="probdist" output="int">
      <fnargs>
	<fnarg type="int">min</fnarg>
	<fnarg type="int">max</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a pseudo-random integer in the closed interval
	  [<argname>min</argname>, <argname>max</argname>]. 
	  <seelist>
	    <fncref targ="randgen"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="rank" section="linalg" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the rank of <argname>X</argname>, numerically computed
	  via the singular value decomposition. 
	  <seelist> 
            <fncref targ="svd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="ranking" section="stats" output="asinput">
      <fnargs>
	<fnarg type="series-or-vec">y</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns a series or vector with the ranks of
	  <math>y</math>. The rank for observation <math>i</math> is
	  the number of elements that are less than
	  <math>y</math><sub>i</sub> plus one half the number of
	  elements that are equal to
	  <math>y</math><sub>i</sub>. (Intuitively, you may think of
	  chess points, where victory gives you one point and a draw
	  gives you half a point.) One is added so the lowest rank is
	  1 instead of 0.
	</para>
	<para context="tex">
	  Formally, 
	  \[ \mathrm{rank}(y_i) = 1 + \sum_{j \ne i} \left[
	  I(y_j &lt; y_i) + 0.5 \cdot I(y_j = y_i) \right] \] 
	  where $I$ denotes the indicator function.
	</para>
	<para>
	  <seelist>
            <fncref targ="sort"/>
            <fncref targ="sortby"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="rcond" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the reciprocal condition number for <argname>A</argname>
	  with respect to the 1-norm.  In many circumstances, this is a better
	  measure of the sensitivity of <argname>A</argname> to numerical
	  operations such as inversion than the determinant.
	</para>
	<para context="notex">
	  The value is computed as the reciprocal of the product, 1-norm
	  of <argname>A</argname> times 1-norm of
	  <argname>A</argname>-inverse.
	</para>
	<para context="tex">
	  Given that <math>A</math> is non-singular, we may define
	  \[\kappa(A) = ||A||_1 \cdot ||A^{-1}||_1\] 
	  This function returns $\kappa(A)^{-1}$.
	</para>
	<para>
	  <seelist>
            <fncref targ="det"/>
            <fncref targ="ldet"/>
            <fncref targ="onenorm"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="readfile" section="strings" output="string">
      <fnargs>
	<fnarg type="string">fname</fnarg>
	<fnarg type="string" optional="true">codeset</fnarg>
      </fnargs>    
      <description>
	<para>
	  If a file by the name of <argname>fname</argname> exists and
	  is readable, returns a string containing the content of this
	  file, otherwise flags an error.  If <argname>fname</argname>
	  does not contain a full path specification, it will be
	  looked for in several <quote>likely</quote> locations,
	  beginning with the currently set <cmdref targ="workdir"/>.
	</para>
	<para>
	  If <argname>fname</argname> starts with the identifier of a
	  supported internet protocol (<lit>http://</lit>,
	  <lit>ftp://</lit> or <lit>https://</lit>), libcurl is invoked to
	  download the resource. See also <fncref targ="curl"/> for
	  more elaborate downloading operations.
	</para>
	<para>
	  If the text to be read is not encoded in UTF-8, gretl will
	  try recoding it from the current locale codeset if that is
	  not UTF-8, or from ISO-8859-15 otherwise. If this simple
	  default does not meet your needs you can use the optional
	  second argument to specify a codeset. For example, if you
	  want to read text in Microsoft codepage 1251 and that is not
	  your locale codeset, you should give a second argument of
	  <lit>"cp1251"</lit>.
	</para>
    <para>
        Examples:
    </para>
    <code>
        string web_page = readfile("http://gretl.sourceforge.net/")
        print web_page
        
        string current_settings = readfile("@dotdir/.gretl2rc")
        print current_settings
    </code>
	<para>
	  Also see the <fncref targ="sscanf"/> and <fncref
	  targ="getline"/> functions.
	</para>
      </description>
    </function>

    <function name="regsub" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg type="string">match</fnarg>
	<fnarg type="string">repl</fnarg>
      </fnargs>  
      <description>
	<para>
	  Returns a copy of <argname>s</argname> in which all
	  occurrences of the pattern <argname>match</argname> are
	  replaced using <argname>repl</argname>. The arguments
	  <argname>match</argname> and <argname>repl</argname>
	  are interpreted as Perl-style regular expressions.
	</para>
	<para>
	  See also <fncref targ="strsub"/> for simple substitution of
	  literal strings.
	</para>
      </description>
    </function>

    <function name="remove" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">fname</fnarg>
      </fnargs>    
      <description>
	<para>
	  If a file by the name of <argname>fname</argname> exists and
	  is writable by the user, removes (deletes) the named
	  file. Returns 0 on successful completion, non-zero if there
	  is no such file or the file cannot be removed.
	</para>
	<para>
	  If <argname>fname</argname> contains a full path
	  specification, gretl will attempt to delete that file and
	  return an error if the file doesn't exist or can't be
	  deleted for some reason (such as insufficient
	  privileges). If <argname>fname</argname> does not contain a
	  full path, then it will be assumed that the given file name
	  is relative to <cmdref targ="workdir"/>. If the file doesn't
	  exist or is unwritable, no other directories will be
	  searched.
	</para>
      </description>
    </function>

    <function name="replace" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
	<fnarg type="scalar-or-vec">find</fnarg>
	<fnarg type="scalar-or-vec">subst</fnarg>
      </fnargs>    
      <description>
	<para>
	  Replaces each element of <argname>x</argname> equal to
	  the <math>i</math>-th element of <argname>find</argname>
	  with the corresponding element of <argname>subst</argname>.
	</para>
	<para>
	  If <argname>find</argname> is a scalar, <argname>subst</argname>
	  must also be a scalar.  If <argname>find</argname> and
	  <argname>subst</argname> are both vectors, they must have the same
	  number of elements.  But if <argname>find</argname> is a vector and
	  <argname>subst</argname> a scalar, then all matches will be replaced
	  by <argname>subst</argname>.
	</para>
	<para>
	  Example:
	</para>
	<code>
	  a = {1,2,3;3,4,5}
	  find = {1,3,4}
	  subst = {-1,-8, 0}
	  b = replace(a, find, subst)
	  print a b
	</code>
	<para>
	  produces
	</para>
	<code>
          a (2 x 3)
          
          1   2   3 
          3   4   5 
          
          b (2 x 3)
          
          -1    2   -8 
          -8    0    5 
	</code>
      </description>
    </function>

    <function name="resample" section="stats" output="asinput">
      <fnargs>
	<fnarg type="series-or-mat">x</fnarg>
	<fnarg optional="true" type="int">blocksize</fnarg>
      </fnargs>    
      <description>
	<para>
	  The initial description of this function pertains to
	  cross-sectional or time-series data; see below for
	  the case of panel data.
	</para>
	<para>
	  Resamples from <argname>x</argname> with replacement.  In
	  the case of a series argument, each value of the returned
	  series, <math>y</math><sub>t</sub>, is drawn from among all
	  the values of <math>x</math><sub>t</sub> with equal
	  probability.  When a matrix argument is given, each row of
	  the returned matrix is drawn from the rows of
	  <argname>x</argname> with equal probability.
	</para>
	<para>
	  The optional argument <argname>blocksize</argname>
	  represents the block size for resampling by moving blocks.
	  If this argument is given it should be a positive integer
	  greater than or equal to 2. The effect is that the output is
	  composed by random selection with replacement from among all
	  the possible contiguous sequences of length
	  <argname>blocksize</argname> in the input.  (In the case of
	  matrix input, this means contiguous rows.) If the length of
	  the data is not an integer multiple of the block size, the
	  last selected block is truncated to fit.
	</para>
	<para>
	  If the argument <argname>x</argname> is a series and the
	  dataset takes the form of a panel, resampling by moving
	  blocks is not supported. The basic form of resampling is
	  supported, but has this specific interpretation: the data
	  are resampled <quote>by individual</quote>. Suppose you have
	  a panel in which 100 individuals are observed over 5
	  periods. Then the returned series will again be composed of
	  100 blocks of 5 observations: each block will be drawn with
	  equal probability from the 100 individual time series, with
	  the time-series order preserved.
	</para>
      </description>
    </function>

    <function name="round" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Rounds to the nearest integer. Note that when <math>x</math>
	  lies halfway between two integers, rounding is done "away
	  from zero", so for example 2.5 rounds to 3, but 
	  <lit>round(-3.5)</lit> gives &minus;4. This is a common
	  convention in spreadsheet programs, but other software may
	  yield different results.
	  <seelist>
            <fncref targ="ceil"/>
            <fncref targ="floor"/>
            <fncref targ="int"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="rownames" section="matbuild" output="int">
      <fnargs>
	<fnarg type="matrix">M</fnarg>
	<fnarg type="strings-or-list">S</fnarg>
      </fnargs>
      <description>
	<para>
	  Attaches names to the rows of the <by r="m" c="n"/> matrix
	  <argname>M</argname>. If <argname>S</argname> is a named
	  list, the names are taken from the names of the listed
	  series; the list must have <math>m</math> members. If
	  <argname>S</argname> is an array of strings, it should
	  contain <math>m</math> elements. For backward
	  caompatibility, a single string may also be given as the
	  second argument; in that case it should contain
	  <math>m</math> space-separated substrings.
	</para>
	<para>
	  The return value is 0 on successful completion, non-zero on
	  error. See also <fncref targ="colnames"/>.	  
	</para>
	<para>
	  Example:
	</para>
	<code>
	  matrix M = {1, 2; 2, 1; 4, 1}
	  strings S = array(3)
	  S[1] = "Row1"
	  S[2] = "Row2"
	  S[3] = "Row3"
	  rownames(M, S)
	  print M      
	</code>
      </description>
    </function>

    <function name="rows" section="matshape" output="int">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the number of rows of the matrix <argname>X</argname>.
	  <seelist>
            <fncref targ="cols"/>
            <fncref targ="mshape"/>
            <fncref targ="unvech"/> 
            <fncref targ="vec"/>
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sd" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
      </fnargs>     
      <description>
	<para>
	  If <argname>x</argname> is a series, returns the (scalar) sample
	  standard deviation, skipping any missing observations.
	</para>
	<para>
	  If <argname>x</argname> is a list, returns a series
	  <math>y</math> such that <math>y</math><sub>t</sub> is the
	  sample standard deviation of the values of the variables in
	  the list at observation <math>t</math>, or <lit>NA</lit> if
	  there are any missing values at <math>t</math>.
	</para>
	<para>
	  <seelist> 
            <fncref targ="var"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sdc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="scalar" optional="true">df</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the standard deviations of the columns of
	  <argname>X</argname>. If <argname>df</argname> is positive
	  it is used as the divisor for the column variances,
	  otherwise the divisor is the number of rows in
	  <argname>X</argname> (that is, no degrees of freedom
	  correction is applied).
	  <seelist>
            <fncref targ="meanc"/>
            <fncref targ="sumc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sdiff" section="transforms" output="asinput">
      <fnargs>
	<fnarg type="series-or-list">y</fnarg>
      </fnargs>   
      <description>
	<para>
	  Computes seasonal differences: <equation status="inline" 
	  ascii="y(t) - y(t-k)"  tex="$y_t - y_{t-k}$"/>, where
	  <math>k</math> is the periodicity of the current dataset (see
	  <fncref targ="$pd"/>). Starting values are set to
	  <lit>NA</lit>.
	</para>
	<para> 
	  When a list is returned, the individual variables are
	  automatically named according to the template
	  <lit>sd_</lit><repl>varname</repl> where
	  <repl>varname</repl> is the name of the original series.
	  The name is truncated if necessary, and may be adjusted in
	  case of non-uniqueness in the set of names thus constructed.
	</para> 
	<para>
	  <seelist> 
            <fncref targ="diff"/>
            <fncref targ="ldiff"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="seasonals" section="data-utils" output="list">
      <fnargs>
	<fnarg optional="true" type="int">baseline</fnarg>
	<fnarg optional="true" type="bool">center</fnarg>
      </fnargs>     
      <description>
	<para>
	  Applicable only if the dataset has a time-series structure
	  with periodicity greater than 1. Returns a list of dummy
	  variables coding for the period or season, named
	  <lit>S1</lit>, <lit>S2</lit> and so on.
	</para>
	<para>
	  The optional <argname>baseline</argname> argument can be
	  used to exclude one period from the set of dummies. For
	  example, if you give a baseline value of 1 with quarterly
	  data the returned list will hold dummies for quarters 2, 3
	  and 4 only.  If this argument is omitted or set to zero a
	  full set of dummies is generated; if non-zero, it must be an
	  integer from 1 to the periodicity of the data.
	</para>
	<para>
	  The <argname>center</argname> argument, if non-zero, calls
	  for the dummies to be centered; that is, to have their
	  population mean subtracted. For example, with quarterly data
	  centered seasonals will have values &minus;0.25 and 0.75
	  rather than 0 and 1.
	</para>
      </description>
    </function>    

    <function name="selifc" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="rvec">b</fnarg>
      </fnargs>   
      <description>
	<para>
	  Selects from <argname>A</argname> only the columns for which
	  the corresponding element of <argname>b</argname> is
	  non-zero. <argname>b</argname> must be a row vector with
	  the same number of columns as <argname>A</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="selifr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="selifr" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="cvec">b</fnarg>
      </fnargs>   
      <description>
	<para>
	  Selects from <argname>A</argname> only the rows for which
	  the corresponding element of <argname>b</argname> is
	  non-zero. <argname>b</argname> must be a column vector with
	  the same number of rows as <argname>A</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="selifc"/>
            <fncref targ="trimr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="seq" section="matbuild" output="rvec">
      <fnargs>
	<fnarg type="scalar">a</fnarg>
	<fnarg type="scalar">b</fnarg>
	<fnarg optional="true" type="scalar">k</fnarg>
      </fnargs>   
      <description>
	<para>
	  Given only two arguments, returns a row vector filled with
	  values from <argname>a</argname> to <argname>b</argname>
	  with an increment of 1, or a decrement of 1 if
	  <argname>a</argname> is greater than <argname>b</argname>.
	</para>
	<para>
	  If the third argument is given, returns a row vector
	  containing a sequence of values starting with
	  <argname>a</argname> and incremented (or decremented, if
	  <argname>a</argname> is greater than <argname>b</argname>)
	  by <argname>k</argname> at each step.  The final value is
	  the largest member of the sequence that is less than or
	  equal to <argname>b</argname> (or mutatis mutandis for
	  <argname>a</argname> greater than <argname>b</argname>).
	  The argument <argname>k</argname> must be positive.
	</para>
	<para>
	  <seelist>
            <fncref targ="ones"/>
            <fncref targ="zeros"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="setnote" section="data-utils" output="int">
      <fnargs>
	<fnarg type="bundle">b</fnarg>
	<fnarg type="string">key</fnarg>
	<fnarg type="string">note</fnarg>
      </fnargs>   
      <description>
	<para>
	  Sets a descriptive note for the object identified by
	  <argname>key</argname> in the bundle <argname>b</argname>.
	  This note will be shown when the <lit>print</lit> command is
	  used on the bundle. This function returns 0 on success or
	  non-zero on failure (for example, if there is no object in
	  <argname>b</argname> under the given
	  <argname>key</argname>).
	</para>
      </description>
    </function>    

    <function name="simann" section="numerical" output="scalar">
      <fnargs>
	<fnarg type="matrixref">&amp;b</fnarg>
	<fnarg type="fncall">f</fnarg>
	<fnarg type="int" optional="true">maxit</fnarg>
      </fnargs>
      <description>
	<para>
	  Implements simulated annealing, which may be helpful in
	  improving the initialization for a numerical optimization
	  problem.
	</para>
	<para>
	  On input the first argument holds the initial value of a
	  parameter vector and the second argument specifies a
	  function call which returns the (scalar) value of the
	  maximand. The optional third argument specifies the maximum
	  number of iterations (which defaults to 1024). On successful
	  completion, <lit>simann</lit> returns the final value of the
	  maximand and <argname>b</argname> holds the associated
	  parameter vector.
	</para>
	<para>
	  For more details and an example see the chapter on numerical
	  methods in <guideref targ="chap:numerical"/>.
	  <seelist>
            <fncref targ="BFGSmax"/>
            <fncref targ="NRmax"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sin" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>       
      <description>
	<para>
	  Returns the sine of <argname>x</argname>.
	  <seelist>
            <fncref targ="cos"/>
            <fncref targ="tan"/>
            <fncref targ="atan"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sinh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the hyperbolic sine of <argname>x</argname>.
	</para>
	<para context="tex">
	  \[ \sinh x = \frac{e^x - e^{-x}}{2}  \]
	</para>
	<para>
	  <seelist>
            <fncref targ="asinh"/>
            <fncref targ="cosh"/>
            <fncref targ="tanh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="skewness" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the skewness value for the series <argname>x</argname>,
	  skipping any missing observations.
	</para>
      </description>
    </function>

    <function name="sort" section="matshape" output="asinput">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>     
      <description>
	<para>
	  Sorts <argname>x</argname> in ascending order, skipping
	  observations with missing values when <math>x</math> is a
	  series.  
	  <seelist>
            <fncref targ="dsort"/>
            <fncref targ="values"/>
	  </seelist>
	  For matrices specifically, see <fncref targ="msortby"/>.
	</para>
      </description>
    </function>

    <function name="sortby" section="stats" output="series">
      <fnargs>
	<fnarg type="series">y1</fnarg>
	<fnarg type="series">y2</fnarg>
      </fnargs>     
      <description>
	<para>
	  Returns a series containing the elements of
	  <argname>y2</argname> sorted by increasing value of the first
	  argument, <argname>y1</argname>. 
	  <seelist>
            <fncref targ="sort"/>
            <fncref targ="ranking"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sprintf" section="strings" output="string">
      <fnargs>
	<fnarg type="string">format</fnarg>
	<fnarg type="varargs"/>
      </fnargs>     
      <description>
	<para>
	  The returned string is constructed by printing the values of
	  the trailing arguments, indicated by the dots above, under
	  the control of <argname>format</argname>. It is meant to
	  give you great flexibility in creating strings. The
	  <argname>format</argname> is used to specify the precise way
	  in which you want the arguments to be printed.
	</para>
	<para>
	  In general, <argname>format</argname> must be an expression
	  that evaluates to a string, but in most cases will just be a
	  string literal (an alphanumeric sequence surrounded by
	  double quotes). Some character sequences in the format have
	  a special meaning: those beginning with the percent
	  character (%) are interpreted as <quote>placeholders</quote>
	  for the items contained in the argument list; moreover,
	  special characters such as the newline character are
	  represented via a combination beginning with a backslash.
	</para>
	<para>
	  For example, the code below
	</para>	
	<code>
	  scalar x = sqrt(5)
	  string claim = sprintf("sqrt(%d) is (roughly) %6.4f.\n", 5, x)
	  print claim
	</code>
	<para>
	  will output
	</para>
	<code>
	  sqrt(5) is (roughly) 2.2361.
	</code>
	<para>
	  where <lit>%d</lit> indicates that we want an integer at
	  that place in the output; since it is the leftmost
	  <quote>percent</quote> expression, it is matched to the
	  first argument, that is 5. The second special sequence is
	  <lit>%6.4f</lit>, which stands for a decimal value with 4
	  digits after the decimal separator and at least 6 digits
	  wide. The number of such sequences must match the number
	  of arguments following the format string.
	</para>
	<para>
	  See the help page for the <cmdref targ="printf"/> command
	  for more details about the syntax you can use in format
	  strings.
	</para>
      </description>
    </function>

    <function name="square" section="transforms" output="list">
      <fnargs>
	<fnarg type="list">L</fnarg>
	<fnarg optional="true" type="bool">cross-products</fnarg>
      </fnargs>     
      <description>
	<para>
	  Returns a list that references the squares of the variables
	  in the list <argname>L</argname>, named on the pattern
	  <lit>sq_</lit><repl>varname</repl>.  If the optional second
	  argument is present and has a non-zero value, the returned
	  list also includes the cross-products of the elements of
	  <argname>L</argname>; these are named on the pattern
	  <repl>var1</repl><lit>_</lit><repl>var2</repl>.  In these
	  patterns the input variable names are truncated if need be,
	  and the output names may be adjusted in case of duplication
	  of names in the returned list.
	</para>
      </description>
    </function>    

    <function name="sqrt" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>     
      <description>
	<para>
	  Returns the positive square root of <argname>x</argname>; produces
	  <lit>NA</lit> for negative values.
	</para>
	<para>
	  Note that if the argument is a matrix the operation is performed
	  element by element and, since matrices cannot contain <lit>NA</lit>,
	  negative values generate an error.  For the <quote>matrix square
          root</quote> see <fncref targ="cholesky"/>.
	</para>
      </description>
    </function>

    <function name="sscanf" section="strings" output="int">
      <fnargs>
	<fnarg type="string">src</fnarg>
	<fnarg type="string">format</fnarg>
	<fnarg type="varargs"/>
      </fnargs>  
      <description>
	<para>
	  Reads values from <argname>src</argname> under the control
	  of <argname>format</argname> and assigns these values to one
	  or more trailing arguments, indicated by the dots above.
	  Returns the number of values assigned. This is a simplified
	  version of the <lit>sscanf</lit> function in the C
	  programming language.
	</para>
	<para>
	  <repl>src</repl> may be either a literal string, enclosed
	  in double quotes, or the name of a predefined string
	  variable.  <repl>format</repl> is defined similarly to the
	  format string in <cmdref targ="printf"/> (more on this
	  below). <repl>args</repl> should be a comma-separated list
	  containing the names of pre-defined variables: these are the
	  targets of conversion from <repl>src</repl>.  (For those
	  used to C: one can prefix the names of numerical variables
	  with <lit>&amp;</lit> but this is not required.)
	</para>
	<para>
	  Literal text in <repl>format</repl> is matched against
	  <repl>src</repl>.  Conversion specifiers start with
	  <lit>%</lit>, and recognized conversions include
	  <lit>%f</lit>, <lit>%g</lit> or <lit>%lf</lit> for
	  floating-point numbers; <lit>%d</lit> for integers;
	  <lit>%s</lit> for strings; and <lit>%m</lit> for matrices.
	  You may insert a positive integer after the percent sign:
	  this sets the maximum number of characters to read for the
	  given conversion (or the maximum number of rows in the case
	  of matrix conversion). Alternatively, you can insert a
	  literal <lit>*</lit> after the percent to suppress the
	  conversion (thereby skipping any characters that would
	  otherwise have been converted for the given type).  For
	  example, <lit>%3d</lit> converts the next 3 characters in
	  <repl>source</repl> to an integer, if possible;
	  <lit>%*g</lit> skips as many characters in
	  <repl>source</repl> as could be converted to a single
	  floating-point number.
	</para>
	<para>
	  Matrix conversion works thus: the scanner reads a line of
	  input and counts the (space- or tab-separated) number of
	  numeric fields.  This defines the number of columns in the
	  matrix.  By default, reading then proceeds for as many lines
	  (rows) as contain the same number of numeric columns, but
	  the maximum number of rows to read can be limited as
	  described above.
	</para>
	<para>
	  In addition to <lit>%s</lit> conversion for strings, a
	  simplified version of the C format
	  <lit>%</lit><repl>N</repl><lit>[</lit><repl>chars</repl><lit>]</lit>
	  is available.  In this format <repl>N</repl> is the maximum
	  number of characters to read and <repl>chars</repl> is a set
	  of acceptable characters, enclosed in square brackets:
	  reading stops if <repl>N</repl> is reached or if a character
	  not in <repl>chars</repl> is encountered. The function of
	  <repl>chars</repl> can be reversed by giving a circumflex,
	  <lit>^</lit>, as the first character; in that case reading
	  stops if a character in the given set is found.  (Unlike C,
	  the hyphen does not play a special role in the
	  <repl>chars</repl> set.)
	</para>
	<para>
	  If the source string does not (fully) match the format, the
	  number of conversions may fall short of the number of
	  arguments given.  This is not in itself an error so far as
	  gretl is concerned.  However, you may wish to check the
	  number of conversions performed; this is given by the
	  return value.
	</para>
	<para>
	  Some examples follow:
	</para>
	<code>
	  scalar x
	  scalar y
	  sscanf("123456", "%3d%3d", x, y)

	  sprintf S, "1 2 3 4\n5 6 7 8"
	  S
	  matrix m
	  sscanf(S, "%m", m)
	  print m
	</code>
      </description>
    </function>

    <function name="sst" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>  
      <description>
	<para>
	  Returns the sum of squared deviations from the mean for the
	  non-missing observations in series <argname>y</argname>.
	  <seelist> 
            <fncref targ="var"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="stringify" section="strings" output="int">
      <fnargs>
	<fnarg type="series">y</fnarg>
	<fnarg type="strings">S</fnarg>
      </fnargs>  
      <description>
	<para>
	  Provides a means of defining string values for the series
	  <argname>y</argname>. Two conditions must be satisfied for
	  this to work: the target series must have nothing but
	  integer values, none of them less than 1, and the array
	  <argname>S</argname> must have at least <math>n</math>
	  elements where <math>n</math> is the largest value in
	  <argname>y</argname>.  In addition each element of
	  <argname>S</argname> must be valid UTF-8.
	  <seelist> 
            <fncref targ="strvals"/>
	  </seelist>	  
	</para>
	<para>
	  The value returned is zero on success or a positive error
	  code on error.
	</para>
      </description>
    </function>

    <function name="strlen" section="strings" output="int">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>  
      <description>
	<para>
	  Returns the number of characters in the string
	  <argname>s</argname>. Note that this does not necessarily
	  equal the number of bytes if some characters are outside
	  of the printable-ASCII range.
	</para>
    <para>
        Example:
    </para>
    <code>
        string s = "regression"
        scalar number = strlen(s)
        print number
    </code>
      </description>
    </function>

    <function name="strncmp" section="strings" output="int">
      <fnargs>
	<fnarg type="string">s1</fnarg>
	<fnarg type="string">s2</fnarg>
	<fnarg optional="true" type="int">n</fnarg>
      </fnargs>  
      <description>
	<para>
	  Compares the two string arguments and returns an integer less
	  than, equal to, or greater than zero if <argname>s1</argname> is
	  found, respectively, to be less than, to match, or be greater
	  than <argname>s2</argname>, up to the first <argname>n</argname>
	  characters.  If <argname>n</argname> is omitted the comparison
	  proceeds as far as possible.
	</para>
	<para> 
	  Note that if you just want to compare two strings for
	  equality, that can be done without using a function, as in
	  <lit>if (s1 == s2) ...</lit>
	</para>
      </description>
    </function>

    <function name="strsplit" section="strings" output="string-or-strings">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg optional="true" type="int">i</fnarg>
      </fnargs>  
      <description>
	<para>
	  With no second argument, returns the array of strings
	  that results from the splitting of <argname>s</argname>
	  on white space.
	</para>
	<para>
	  If the second argument is provided, returns space-separated
	  element <argname>i</argname> from the string
	  <argname>s</argname>. The index <argname>i</argname> is
	  1-based, and it is an error if <argname>i</argname> is less
	  than 1. In case <argname>s</argname> contains no spaces and
	  <argname>i</argname> equals 1, a copy of the entire input
	  string is returned; otherwise, in case <argname>i</argname>
	  exceeds the number of space-separated elements an empty
	  string is returned.
	</para>
    <para>
        Examples:
    </para>
    <code>
        string basket = "banana apple jackfruit orange"
        
        strings fruits = strsplit(basket)
        eval fruits[1]
        eval fruits[2]
        eval fruits[3]
        eval fruits[4]
        
        string favorite = strsplit(basket, 3)
        eval favorite
    </code>
      </description>
    </function>

    <function name="strstr" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s1</fnarg>
	<fnarg type="string">s2</fnarg>
      </fnargs>  
      <description>
	<para>
	  Searches <argname>s1</argname> for an occurrence of the string
	  <argname>s2</argname>.  If a match is found, returns a copy of the
	  portion of <argname>s1</argname> that starts with
	  <argname>s2</argname>, otherwise returns an empty string.
	</para>
    <para>
        Example:
    </para>
    <code>
        string s1 = "Gretl is an econometrics package"
        string s2 = strstr(s1, "an")
        print s2
    </code>
      </description>
    </function>

    <function name="strstrip" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>  
      <description>
	<para>
	  Returns a copy of the argument <argname>s</argname> from
	  which leading and trailing white space have been removed.
	</para>
    <para>
        Example:
    </para>
    <code>
        string s1 = "    A lot of white space.  "
        string s2 = strstrip(s1)
        print s1 s2
    </code>
      </description>
    </function>

    <function name="strsub" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg type="string">find</fnarg>
	<fnarg type="string">subst</fnarg>
      </fnargs>  
      <description>
	<para>
	  Returns a copy of <argname>s</argname> in which all
	  occurrences of <argname>find</argname> are replaced by
	  <argname>subst</argname>. See also <fncref targ="regsub"/>
	  for more complex string replacement via regular expressions.
	</para>
    <para>
        Example:
    </para>
    <code>
        string s1 =  "Hello, Gretl!"
        string s2 = strsub(s1, "Gretl", "Hansl")
        print s2
    </code>
      </description>
    </function>

    <function name="strvals" section="strings" output="strings">
      <fnargs>
	<fnarg type="series">y</fnarg>
      </fnargs>  
      <description>
	<para>
	  If the series <argname>y</argname> is string-valued,
	  returns an array containing all its distinct values,
	  ordered by the associated numerical values starting
	  at 1. If <argname>y</argname> is not string-valued an
	  empty strings array is returned.
	  <seelist> 
            <fncref targ="stringify"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="substr" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
	<fnarg type="int">start</fnarg>
	<fnarg type="int">end</fnarg>
      </fnargs>  
      <description>
	<para>
	  Returns a substring of <argname>s</argname>, from the
	  character with (1-based) index <argname>start</argname> to
	  that with index <argname>end</argname>, inclusive.
	</para>
    <para>
        Examples:
    </para>
    <code>
        string s1 = "Hello, Gretl!"
        string s2 = substr(s1, 8, 12)
        print s2
        
        string s3 = substr("Hello, Gretl!", 8, 12)
        print s3
    </code>
      </description>
    </function>

    <function name="sum" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="smlist">x</fnarg>
      </fnargs>      
      <description>
	<para>
	  If <argname>x</argname> is a series, returns the (scalar) sum of the
	  non-missing observations in <argname>x</argname>. See also
	  <fncref targ="sumall"/>.
	</para>
	<para>
	  If <argname>x</argname> is a matrix, returns the sum of the
	  elements of the matrix.
	</para> 
	<para>
	  If <argname>x</argname> is a list, returns a series
	  <math>y</math> such that <math>y</math><sub>t</sub> is the
	  sum of the values of the variables in the list at
	  observation <math>t</math>, or <lit>NA</lit> if there are
	  any missing values at <math>t</math>.
	</para> 
      </description>
    </function>

    <function name="sumall" section="stats" output="scalar">
      <fnargs>
	<fnarg type="series">x</fnarg>
      </fnargs>      
      <description>
	<para>
	  Returns the sum of the observations of <argname>x</argname>
	  over the current sample range, or <lit>NA</lit> if there are
	  any missing values. Use <fncref targ="sum"/> is you want
	  missing values to be skipped.
	</para>
      </description>
    </function>

    <function name="sumc" section="stats" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>     
      <description>
	<para>
	  Returns the sums of the columns of <argname>X</argname>.
	  <seelist>
            <fncref targ="meanc"/>
            <fncref targ="sumr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="sumr" section="stats" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>  
      <description>
	<para>
	  Returns the sums of the rows of <argname>X</argname>.
	  <seelist> 
            <fncref targ="meanr"/>
            <fncref targ="sumc"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="svd" section="linalg" output="rvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="matrixref" optional="true">&amp;U</fnarg>
	<fnarg type="matrixref" optional="true">&amp;V</fnarg>
      </fnargs>
      <description>
	<para context="notex">
	  Performs the singular values decomposition of the matrix
	  <argname>X</argname>.
	</para>
	<para context="tex">
	  Performs the singular values decomposition of the $r \times c$
	  matrix $X$: 
	  \[ X = U \left[
	  \begin{array}{cccc} 
	  \sigma_1 \\ 
	  &amp; \sigma_2 \\ 
	  &amp; &amp; \ddots \\ 
	  &amp; &amp; &amp; \sigma_n ,
	  \end{array}
	  \right] V \] 
	  where $n = \min(r,c)$. $U$ is $r \times
	  n$ and $V$ is $n \times c$, with $U'U = I$ and $VV' = I$.
	</para>
	<para>
	  The singular values are returned in a row vector.  The left
	  and/or right singular vectors <math>U</math> and <math>V</math>
	  may be obtained by supplying non-null values for arguments 2 and
	  3, respectively.  For any matrix <lit>A</lit>, the code
	</para>
	<code>
	  s = svd(A, &amp;U, &amp;V) 
	  B = (U .* s) * V
	</code>
	<para>
	  should yield <lit>B</lit> identical to <lit>A</lit> (apart from
	  machine precision).
	</para>
	<para>
	  <seelist>
            <fncref targ="eigengen"/>
            <fncref targ="eigensym"/>
            <fncref targ="qrdecomp"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="tan" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the tangent of <argname>x</argname>.
	  <seelist>
            <fncref targ="atan"/>
            <fncref targ="cos"/>
            <fncref targ="sin"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="tanh" section="math" output="asinput">
      <fnargs>
	<fnarg type="anyfloat">x</fnarg>
      </fnargs>
      <description>
	<para>
	  Returns the hyperbolic tangent of <argname>x</argname>. 
	</para>
	<para context="tex">
	  \[ \tanh x = \frac{e^{2x} - 1}{e^{2x} + 1}  \]
	</para>
	<para>
	  <seelist>
            <fncref targ="atanh"/>
            <fncref targ="cosh"/>
            <fncref targ="sinh"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="toepsolv" section="linalg" output="cvec">
      <fnargs>
	<fnarg type="vector">c</fnarg>
	<fnarg type="vector">r</fnarg>
	<fnarg type="vector">b</fnarg>
      </fnargs>
      <description>
	<para>
	  Solves a Toeplitz system of linear equations, that is
	  <math>Tx = b</math> where <math>T </math> is a square matrix
	  whose element <math>T</math><sub>i,j</sub> equals
	  <math>c</math><sub>i-j</sub> for 
	  <equation status="inline"
	  ascii="i&gt;=j" tex="$i\ge j$"/> 
	  and <math>r</math><sub>j-i</sub> for 
	  <equation status="inline" ascii="i&lt;=j"
	  tex="$i\le j$"/>. 
	  Note that the first elements of <math>c</math> and
	  <math>r</math> must be equal, otherwise an error is
	  returned. Upon successful completion, the function returns
	  the vector <math>x</math>.
	</para>
	<para>
	  The algorithm used here takes advantage of the special
	  structure of the matrix <math>T</math>, which makes it much
	  more efficient than other unspecialized algorithms,
	  especially for large problems. Warning: in certain cases,
	  the function may spuriously issue a singularity error when
	  in fact the matrix <math>T</math> is nonsingular; this
	  problem, however, cannot arise when <math>T</math> is
	  positive definite.
	</para>
      </description>
    </function>

    <function name="tolower" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>    
      <description>
	<para>
	  Returns a copy of <argname>s</argname> in which any upper-case
	  characters are converted to lower case.
	</para>
    <para>
        Examples:
    </para>
    <code>
        string s1 = "Hello, Gretl!"
        string s2 = tolower(s1)
        print s2
        
        string s3 = tolower("Hello, Gretl!")
        print s3
    </code>
      </description>
    </function>

    <function name="toupper" section="strings" output="string">
      <fnargs>
	<fnarg type="string">s</fnarg>
      </fnargs>    
      <description>
	<para>
	  Returns a copy of <argname>s</argname> in which any lower-case
	  characters are converted to upper case.
	</para>
    <para>
        Examples:
    </para>
    <code>
        string s1 = "Hello, Gretl!"
        string s2 = toupper(s1)
        print s2
        
        string s3 = toupper("Hello, Gretl!")
        print s3
    </code>
      </description>
    </function>

    <function name="tr" section="linalg" output="scalar">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>    
      <description>
	<para>
	  Returns the trace of the square matrix <argname>A</argname>, that
	  is, the sum of its diagonal elements.
	  <seelist> 
            <fncref targ="diag"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="transp" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>      
      <description>
	<para>
	  Returns the transpose of <argname>X</argname>. Note: this is rarely
	  used; in order to get the transpose of a matrix, in most cases you
	  can just use the prime operator: <lit>X'</lit>.
	</para>
      </description>
    </function>

    <function name="trimr" section="matshape" output="matrix">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
	<fnarg type="int">ttop</fnarg>
	<fnarg type="int">tbot</fnarg>
      </fnargs>   
      <description>
	<para>
	  Returns a matrix that is a copy of <argname>X</argname> with
	  <argname>ttop</argname> rows trimmed at the top and
	  <argname>tbot</argname> rows trimmed at the bottom.  The
	  latter two arguments must be non-negative, and must sum to
	  less than the total rows of <argname>X</argname>.
	</para>
	<para>
	  <seelist>
            <fncref targ="selifr"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="typestr" section="data-utils" output="string">
      <fnargs>
	<fnarg type="int">typecode</fnarg>
      </fnargs>      
      <description>
	<para>
	  Returns the name of the gretl data-type corresponding to
	  <argname>typecode</argname>. This may be used in conjunction
	  with the function <fncref targ="inbundle"/>.  The value
	  returned is one of <quote>scalar</quote>,
	  <quote>series</quote>, <quote>matrix</quote>,
	  <quote>string</quote>, <quote>bundle</quote>,
	  <quote>array</quote> or <quote>null</quote>.
	</para>
      </description>
    </function>

    <function name="uniform" section="probdist" output="series">
      <fnargs>
	<fnarg type="scalar">a</fnarg>
	<fnarg type="scalar">b</fnarg>
      </fnargs>     
      <description>
	<para>
	  Generates a series of uniform pseudo-random variates in the
	  interval (<argname>a</argname>, <argname>b</argname>), or,
	  if no arguments are supplied, in the interval (0,1). The
	  algorithm used by default is the SIMD-oriented Fast Mersenne
	  Twister developed by <cite key="saito_matsumoto08">Saito and
	  Matsumoto (2008)</cite>.
	</para>
	<para>
	  <seelist>
            <fncref targ="randgen"/>
            <fncref targ="normal"/>
            <fncref targ="mnormal"/>
            <fncref targ="muniform"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="uniq" section="stats" output="cvec">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>      
      <description>
	<para>
	  Returns a vector containing the distinct elements of
	  <argname>x</argname>, not sorted but in their order of
	  appearance. See <fncref targ="values"/> for a variant
	  that sorts the elements.
	</para>
      </description>
    </function>

    <function name="unvech" section="matbuild" output="smatrix">
      <fnargs>
	<fnarg type="vector">v</fnarg>
      </fnargs>      
      <description>
	<para>
	  Returns an <by r="n" c="n"/> symmetric matrix obtained by
	  rearranging the elements of <math>v</math>. The number of elements
	  in <math>v</math> must be a triangular integer &mdash; &ie;, a
	  number <math>k</math> such that an integer <math>n</math> exists
	  with the property <equation
          status="inline" ascii="k = n(n+1)/2" 
          tex="$k = n(n+1)/2$"/>. This is the inverse of the function
	  <fncref targ="vech"/>. 
	</para>
	<para>
	  <seelist>
            <fncref targ="mshape"/>
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="upper" section="matbuild" output="smatrix">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>  
      <description>
	<para context="notex">
	  Returns an <by r="n" c="n"/> upper triangular matrix: the elements
	  on and above the diagonal are equal to the corresponding elements of
	  <argname>A</argname>; the remaining elements are zero.
	</para>
	<para context="tex">
	  Returns an $n\times n$ upper triangular matrix <math>B</math>
	  for which $B_{ij} = A_{ij}$ if $i \le j$ and 0 otherwise.
	</para>
	<para>
	  <seelist>
            <fncref targ="lower"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="urcpval" section="probdist" output="scalar">
      <fnargs>
	<fnarg type="scalar">tau</fnarg>
	<fnarg type="int">n</fnarg>
	<fnarg type="int">niv</fnarg>
	<fnarg type="int">itv</fnarg>
      </fnargs>
      <description>
	<para>
	  <math>P</math>-values for the test statistic from the
	  Dickey&ndash;Fuller unit-root test and the
	  Engle&ndash;Granger cointegration test, as per <cite
	  key="mackinnon96">James MacKinnon (1996)</cite>.
	</para>
	<para>
	  The arguments are as follows: <argname>tau</argname> denotes
	  the test statistic; <argname>n</argname> is the number of
	  observations (or 0 for an asymptotic result);
	  <argname>niv</argname> is the number of potentially
	  cointegrated variables when testing for cointegration (or 1
	  for a univariate unit-root test); and <argname>itv</argname>
	  is a code for the model specification: 1 for no constant, 2
	  for constant included, 3 for constant and linear trend, 4
	  for constant and quadratic trend.
	</para>
	<para>
	  Note that if the test regression is <quote>augmented</quote>
	  with lags of the dependent variable, then you should give an
	  <argname>n</argname> value of 0 to get an asymptotic result.
	</para>
	<para>
	  <seelist> 
            <fncref targ="pvalue"/>
	    <fncref targ="qlrpval"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="values" section="stats" output="cvec">
      <fnargs>
	<fnarg type="series-or-vec">x</fnarg>
      </fnargs>      
      <description>
	<para>
	  Returns a vector containing the distinct elements of
	  <argname>x</argname> sorted in ascending order.  If you wish
	  to truncate the values to integers before applying this
	  function, use the expression <lit>values(int(x))</lit>.
	</para>
	<para>
	  <seelist>
            <fncref targ="uniq"/>
            <fncref targ="dsort"/>
            <fncref targ="sort"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="var" section="stats" output="scalar-or-series">
      <fnargs>
	<fnarg type="series-or-list">x</fnarg>
      </fnargs>     
      <description>
	<para>
	  If <argname>x</argname> is a series, returns the (scalar) sample
	  variance, skipping any missing observations.
	</para>
	<para>
	  If <argname>x</argname> is a list, returns a series
	  <math>y</math> such that <math>y</math><sub>t</sub> is the
	  sample variance of the values of the variables in the list
	  at observation <math>t</math>, or <lit>NA</lit> if there are
	  any missing values at <math>t</math>.
	</para>
	<para>
	  In each case the sum of squared deviations from the mean is
	  divided by (<math>n</math> &minus; 1) for <math>n</math>
	  &gt; 1. Otherwise the variance is given as zero if
	  <math>n</math> = 1, or as <lit>NA</lit> if <math>n</math> =
	  0.
	</para>
	<para>
	  <seelist>
            <fncref targ="sd"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="varname" section="strings" output="string">
      <fnargs>
	<fnarg type="int-or-list">v</fnarg>
      </fnargs>     
      <description>
	<para>
	  If given an integer argument, returns the name of the
	  variable with ID number <argname>v</argname>, or generates
	  an error if there is no such variable.
	</para>
	<para>
	  If given a list argument, returns a string containing the
	  names of the variables in the list, separated by commas.  If
	  the supplied list is empty, so is the returned string. To
	  get an array of strings as return value, use <fncref
	  targ="varnames"/> instead.
	</para>
    <para>
        Example:
    </para>
    <code>
        open broiler.gdt
        string s = varname(7)
        print s
    </code>
      </description>
    </function>

    <function name="varnames" section="strings" output="strings">
      <fnargs>
	<fnarg type="list">L</fnarg>
      </fnargs>     
      <description>
	<para>
	  Returns an array of strings containing the names of the
	  variables in the list <argname>L</argname>. If the supplied
	  list is empty, so is the returned array.
	</para>
    <para>
        Example:
    </para>
    <code>
        open keane.gdt
        list L = year wage status
        strings S = varnames(L)
        eval S[1]
        eval S[2]
        eval S[3]
    </code>
      </description>
    </function>    

    <function name="varnum" section="data-utils" output="int">
      <fnargs>
	<fnarg type="string">varname</fnarg>
      </fnargs>     
      <description>
	<para>
	  Returns the ID number of the variable called
	  <argname>varname</argname>, or NA is there is no such
	  variable.
	</para>
      </description>
    </function>

    <function name="varsimul" section="linalg" output="matrix">
      <fnargs>
	<fnarg type="matrix">A</fnarg>
	<fnarg type="matrix">U</fnarg>
	<fnarg type="matrix">y0</fnarg>
      </fnargs>
      <description>
	<para>
	  Simulates a <math>p</math>-order <math>n</math>-variable
	  VAR, that is
	  <equation status="inline"
		    ascii="y(t) = A1 y(t-1) + ... + Ap y(t-p) + u(t)." 
		    tex="$y_t = \sum_{i=1}^p A_i y_{t-i} + u_t$."/>
	  The coefficient matrix <argname>A</argname> is composed by
	  stacking the <math>A</math><sub>i</sub> matrices horizontally;
	  it is <by r="n" c="np"/>, with one row per equation. This
	  corresponds to the first <math>n</math> rows of the matrix
	  <lit>$compan</lit> provided by gretl's <lit>var</lit> and
	  <lit>vecm</lit> commands.
	</para>
	<para>
	  The <math>u_t</math> vectors are contained (as rows) in
	  <argname>U</argname> (<by r="T" c="n"/>). Initial values are in
	  <argname>y0</argname> (<by r="p" c="n"/>).
	</para>
	<para>
	  If the VAR contains deterministic terms and/or exogenous
	  regressors, these can be handled by folding them into the
	  <argname>U</argname> matrix: each row of <argname>U</argname>
	  then becomes 
	  <equation status="inline"
		    ascii="u(t) = B'x(t) + e(t)." 
		    tex="$u_t = B' x_t + e_t$."/>
	</para>
	<para>
	  The output matrix has <math>T</math> + <math>p</math> rows
	  and <math>n</math> columns; it holds the initial
	  <math>p</math> values of the endogenous variables plus
	  <math>T</math> simulated values.
	</para>
	<para>
	  <seelist> 
            <fncref targ="$compan"/>
            <cmdref targ="var"/>
            <cmdref targ="vecm"/>
	  </seelist>
	</para>

      </description>
    </function>

    <function name="vec" section="matbuild" output="cvec">
      <fnargs>
	<fnarg type="matrix">X</fnarg>
      </fnargs>     
      <description>
	<para>
	  Stacks the columns of <argname>X</argname> as a column vector.
	  <seelist>
            <fncref targ="mshape"/>
            <fncref targ="unvech"/>
            <fncref targ="vech"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="vech" section="matbuild" output="cvec">
      <fnargs>
	<fnarg type="smatrix">A</fnarg>
      </fnargs>    
      <description>
	<para>
	  Returns in a column vector the elements of <argname>A</argname>
	  on and above the diagonal. Typically, this function is used on
	  symmetric matrices; in this case, it can be undone by the
	  function <fncref targ="unvech"/>. 
	  <seelist> 
            <fncref targ="vec"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="weekday" section="calendar" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-series">year</fnarg>
	<fnarg type="scalar-or-series">month</fnarg>
	<fnarg type="scalar-or-series">day</fnarg>
      </fnargs>    
      <description>
	<para>
	  Returns the day of the week (Sunday = 0, Monday = 1, etc.)
	  for the date(s) specified by the three arguments, or
	  <lit>NA</lit> if the date is invalid. Note that all three
	  arguments must be of the same type, either scalars
	  (integers) or series.
	</para>
      </description>
    </function>

    <function name="wmean" section="stats" output="series">
      <fnargs>
	<fnarg type="list">Y</fnarg>
	<fnarg type="list">W</fnarg>
      </fnargs>    
      <description>
	<para>
	  Returns a series <math>y</math> such that
	  <math>y</math><sub>t</sub> is the weighted mean of the
	  values of the variables in list <argname>Y</argname> at
	  observation <math>t</math>, the respective weights given by
	  the values of the variables in list <argname>W</argname> at
	  <math>t</math>.  The weights can therefore be
	  time-varying. The lists <argname>Y</argname> and
	  <argname>W</argname> must be of the same length and the
	  weights must be non-negative.
	</para>
	<para>
	  <seelist> 
            <fncref targ="wsd"/>
            <fncref targ="wvar"/>
	  </seelist>
	</para> 
      </description>
    </function>

    <function name="wsd" section="stats" output="series">
      <fnargs>
	<fnarg type="list">Y</fnarg>
	<fnarg type="list">W</fnarg>
      </fnargs>    
      <description>
	<para>
	  Returns a series <math>y</math> such that
	  <math>y</math><sub>t</sub> is the weighted sample standard
	  deviation of the values of the variables in list
	  <argname>Y</argname> at observation <math>t</math>, the
	  respective weights given by the values of the variables in
	  list <argname>W</argname> at <math>t</math>.  The weights
	  can therefore be time-varying. The lists
	  <argname>Y</argname> and <argname>W</argname> must be of the
	  same length and the weights must be non-negative.
	</para>
	<para>
	  <seelist> 
            <fncref targ="wmean"/>
            <fncref targ="wvar"/>
	  </seelist>
	</para> 
      </description>
    </function>

    <function name="wvar" section="stats" output="series">
      <fnargs>
	<fnarg type="list">X</fnarg>
	<fnarg type="list">W</fnarg>
      </fnargs>    
      <description>
	<para>
	  Returns a series <math>y</math> such that
	  <math>y</math><sub>t</sub> is the weighted sample variance
	  of the values of the variables in list <argname>X</argname>
	  at observation <math>t</math>, the respective weights given
	  by the values of the variables in list <argname>W</argname>
	  at <math>t</math>.  The weights can therefore be
	  time-varying. The lists <argname>Y</argname> and
	  <argname>W</argname> must be of the same length and the
	  weights must be non-negative.
	</para>
	<para context="tex">
	  The weighted sample variance is computed as
	  \[ s^2_w = \frac{n'}{n'-1} \,
	  \frac{\sum_{i=1}^n w_i(x_i - \bar{x}_w)^2}{\sum_{i=1}^n w_i} \]
	  where $n'$ is the number of non-zero weights and $\bar{x}_w$ is
	  the weighted mean.
	</para>
	<para>
	  <seelist> 
            <fncref targ="wmean"/>
            <fncref targ="wsd"/>
	  </seelist>
	</para> 
      </description>
    </function>

    <function name="xmax" section="math" output="scalar">
      <fnargs>
	<fnarg type="scalar">x</fnarg>
	<fnarg type="scalar">y</fnarg>
      </fnargs>     
      <description>
	<para>
	  Returns the greater of <argname>x</argname> and
	  <argname>y</argname>, or <lit>NA</lit> if either value
	  is missing.  
	</para>
	<para>
	  <seelist> 
            <fncref targ="xmin"/>
            <fncref targ="max"/>
            <fncref targ="min"/>
	  </seelist>
	</para> 
      </description>
    </function>

    <function name="xmin" section="math" output="scalar">
      <fnargs>
	<fnarg type="scalar">x</fnarg>
	<fnarg type="scalar">y</fnarg>
      </fnargs>     
      <description>
	<para>
	  Returns the lesser of <argname>x</argname> and
	  <argname>y</argname>, or <lit>NA</lit> if either value
	  is missing.
	</para>
	<para>
	  <seelist> 
            <fncref targ="xmax"/>
            <fncref targ="max"/>
            <fncref targ="min"/>
	  </seelist>
	</para> 
      </description>
    </function>

    <function name="zeromiss" section="data-utils" output="asinput">
      <fnargs>
	<fnarg type="scalar-or-series">x</fnarg>
      </fnargs>     
      <description>
	<para>
	  Converts zeros to <lit>NA</lit>s. If <argname>x</argname> is a
	  series, the conversion is done element by element.
	  <seelist>
            <fncref targ="missing"/>
            <fncref targ="misszero"/>
            <fncref targ="ok"/>
	  </seelist>
	</para>
      </description>
    </function>

    <function name="zeros" section="matbuild" output="matrix">
      <fnargs>
	<fnarg type="int">r</fnarg>
	<fnarg type="int">c</fnarg>
      </fnargs> 
      <description>
	<para>
	  Outputs a zero matrix with <math>r</math> rows and
	  <math>c</math> columns. 
      <seelist> 
        <fncref targ="ones"/>
        <fncref targ="seq"/>
      </seelist>
    </para>
      </description>
    </function>

  </funclist>
</funcref>
