<?xml version="1.0"?>
<!DOCTYPE funclist SYSTEM "genr_funcs.dtd">

<funclist language="english">

<?PSGML NOFILL code altforms altform menu-path equation other-access?>

  <function name="$ahat" output="series">
    <description>
      <para>
	Must follow the estimation of a fixed-effect panel data model.
	Returns the estimates of individual fixed effects (per-unit
	intercepts).
      </para>
    </description>
  </function>

  <function name="$aic" output="scalar">
    <description>
      <para>
	Returns the Akaike Information Criterion for the last estimated
	model. 
      </para>
    </description>
  </function>

  <function name="$bic" output="scalar">
    <description>
      <para>
	Returns Schwarz's Bayesian Information Criterion for the last
	estimated model.
      </para>
    </description>
  </function>

  <function name="$coeff" output="scalar" altout="matrix">
    <fnargs>
      <fnarg optional="true" type="coeffname">s</fnarg>
    </fnargs>
    <description>
      <para>
	The <lit>$coeff</lit> accessor can be used in two ways: with no
	arguments, it returns a column vector containing the estimated
	coefficients for the last model. With the optional argument, it
	returns a scalar, which is the estimated parameter named
	<mathvar>s</mathvar> (see also <fncref targ="$stderr"/> and <fncref
	    targ="$vcv"/>).
      </para>
      <para>
	Example:
      </para>
      <code>
	open bjg
	arima 0 1 1 ; 0 1 1 ; lg
	b = $coeff
	macoef = $coeff(theta_1)
      </code>
      <para>
	If the <quote>model</quote> in question is actually a system (a
	VAR or VECM, or system of simultaneous equations),
	<lit>$coeff</lit> with no parameters returns the matrix of
	coefficients, one column per equation.
      </para>
    </description>
  </function>

  <function name="$compan" output="matrix">
    <description>
      <para>
	Must follow the estimation of a VAR or a VECM; returns the
	companion matrix.
      </para>
    </description>
  </function>

  <function name="$df" output="scalar">
    <description>
      <para>
	Returns the degrees of freedom of the last estimated model.
      </para>
    </description>
  </function>

  <function name="$ess" output="scalar">
    <description>
      <para>
	Returns the error sum of squares of the last estimated model.
      </para>
    </description>
  </function>

  <function name="$gmmcrit" output="scalar">
    <description>
      <para>
	Must follow a <lit>gmm</lit> block. Returns the value of the
	objective function at its minimum.
      </para>
    </description>
  </function>

  <function name="$h" output="series">
    <description>
      <para>
	Must follow a <lit>garch</lit> command. Returns the estimated
	conditional variance.
      </para>
    </description>
  </function>

  <function name="$hqc" output="scalar">
    <description>
      <para>
	Returns the Hannan-Quinn Information Criterion for the last
	estimated model.
      </para>
    </description>
  </function>

  <function name="$jalpha" output="matrix">
    <description>
      <para>
	Must follow the estimation of a VECM, and returns the loadings
	matrix. It has as many rows as variables in the VECM and as many
	columns as the cointegration rank.
      </para>
    </description>
  </function>

  <function name="$jbeta" output="matrix">
    <description>
      <para>
	Must follow the estimation of a VECM, and returns the
	cointegration matrix. It has as many rows as variables in the VECM
	and as many columns as the cointegration rank.
      </para>
    </description>
  </function>

  <function name="$jvbeta" output="matrix">
    <description>
      <para>
	Must follow the estimation of a VECM, and returns the estimated
	covariance matrix for the elements of the cointegration vectors.
      </para>
      <para>
	In the case of unrestricted estimation, it has a number of rows
	equal to the unrestricted elements of the cointegration space
	after the Phillips normalization. If, however, a restricted system
	is estimated via the <lit>restrict</lit> command with the
	<lit>--full</lit> option, a singular matrix with <equation
	  status="inline" ascii="n*r" graphic="" tex="$n \cdot
	  r$"/> rows will be returned (<mathvar>n</mathvar> being the
	number of variables and <mathvar>r</mathvar> the cointegration
	rank).
      </para>
      <para>
	Example: the code
      </para>
      <code>
	open denmark.gdt
	vecm 2 1 LRM LRY IBO IDE --rc --seasonals -q
	s0 = $jvbeta

	restrict --full
	  b[1,1] = 1
	  b[1,2] = -1
	  b[1,3] + b[1,4] = 0
	end restrict
	s1 = $jvbeta

	print s0
	print s1
      </code>
      <para>
	produces the following output.
      </para>
      <code>
	s0 (4 x 4)

	0.019751     0.029816  -0.00044837     -0.12227 
	0.029816      0.31005     -0.45823     -0.18526 
	-0.00044837     -0.45823       1.2169    -0.035437 
	-0.12227     -0.18526    -0.035437      0.76062 

	s1 (5 x 5)

	0.0000       0.0000       0.0000       0.0000       0.0000 
	0.0000       0.0000       0.0000       0.0000       0.0000 
	0.0000       0.0000      0.27398     -0.27398    -0.019059 
	0.0000       0.0000     -0.27398      0.27398     0.019059 
	0.0000       0.0000    -0.019059     0.019059    0.0014180 
      </code>
    </description>
  </function>

  <function name="$lnl" output="scalar">
    <description>
      <para>
	Returns the log-likelihood for the last estimated model (where
	applicable).
      </para>
    </description>
  </function>


  <function name="$ncoeff" output="scalar">
    <description>
      <para>
	Total number of coefficients estimated in the last model.
      </para>
    </description>
  </function>


  <function name="$nobs" output="scalar">
    <description>
      <para>
	Returns the number of observations in the currently selected
	sample.
      </para>
    </description>
  </function>

  <function name="$nvars" output="scalar">
    <description>
      <para>
	Returns the number of variables in the dataset (including the
	constant).
      </para>
    </description>
  </function>

  <function name="$pd" output="scalar">
    <description>
      <para>
	Returns the frequency or periodicity of the data (e.g. 4 for
	quarterly data).
      </para>
    </description>
  </function>

  <function name="$pvalue" output="scalar">
    <description>
      <para>
	Returns the p-value of the test statistic that was generated by
	the last explicit hypothesis-testing command, if any (e.g.
	<lit>chow</lit>). (See also <fncref targ="$test"/>.)
      </para>
    </description>
  </function>

  <function name="$rho" output="scalar">
    <fnargs>
      <fnarg optional="true" type="scalar">n</fnarg>
    </fnargs>
    <description>
      <para>
	Without arguments, returns the first-order autoregressive
	coefficient for the residuals of the last model. After estimating
	a model via the <lit>ar</lit> command, the syntax
	<lit>$rho(n)</lit> returns the corresponding estimate of <equation
	  status="inline" ascii="rho(n)" graphic="" tex="$\rho(n)$"/>.
      </para>
    </description>
  </function>

  <function name="$rsq" output="scalar">
    <description>
      <para>
	Returns the unadjusted <equation status="inline" ascii="R^2"
	graphic="" tex="$R^2$"/>
	from the last estimated model.
      </para>
    </description>
  </function>

  <function name="$sigma" output="scalar">
    <description>
      <para>
	Returns the standard error of residuals of the last model.
      </para>
    </description>
  </function>

  <function name="$stderr" output="scalar" altout="matrix">
    <fnargs>
      <fnarg optional="true" type="coeffname">s</fnarg>
    </fnargs>
    <description>
      <para>
	The <lit>$stderr</lit> accessor can be used in two ways: with no
	arguments, it returns a column vector containing the estimated
	coefficients for the last model. With the optional argument, it
	returns a scalar, which is the estimated parameter named
	<mathvar>s</mathvar> (see also <fncref targ="$coeff"/> and <fncref
	  targ="$vcv"/>).
      </para>
    </description>
  </function>


<function name="$stopwatch" output="scalar">
    <description>
      <para>
	Must follow a <lit>set stopwatch</lit> command, which activates
	the measurement of CPU time, which stops the first time the
	accessor <lit>$stopwatch</lit> is used, either in assigning it to
	a variable or simply by printing it. The accessor
	<lit>$stopwatch</lit> will yield the seconds of CPU time that have
	elapsed between the <lit>set stopwatch</lit> statement and its
	invocation.
      </para>
    </description>
</function>

  <function name="$T" output="scalar">
    <description>
      <para>
	Number of observations used in estimating the last model.
      </para>
    </description>
  </function>


  <function name="$t1" output="scalar">
    <description>
      <para>
	First observation of the currently selected sample.
      </para>
    </description>
  </function>

  <function name="$t2" output="scalar">
    <description>
      <para>
	Last observation of the currently selected sample.
      </para>
    </description>
  </function>

  <function name="$test" output="scalar">
    <description>
      <para>
	Returns the value of the test statistic that was generated by the
	last explicit hypothesis-testing command, if any (e.g.
	<lit>chow</lit>). (See also <fncref targ="$pvalue"/>.)
      </para>
    </description>
  </function>

  <function name="$trsq" output="scalar">
    <description>
      <para>
	<equation status="inline" ascii="T*R^2" graphic="" 
	  tex="$T\cdot R^2$"/> (sample size times
	R-squared) in the last model.
      </para>
    </description>
  </function>

  <function name="$uhat" output="series">
    <description>
      <para>
	Returns the residuals from the last model. This may have different
	meanings for different estimators. For example, after an ARMA
	estimation <lit>$uhat</lit> will contain the one-step-ahead
	forecast error; after a probit model, it will contain the
	generalized residuals.
      </para>
      <para>
	If the <quote>model</quote> in question is actually a system (a
	VAR or VECM, or system of simultaneous equations),
	<lit>$uhat</lit> with no parameters retrieves the matrix of
	residuals, one column per equation.
      </para>
    </description>
  </function>

  <function name="$vcv" output="scalar" altout="matrix">
    <fnargs>
      <fnarg optional="true" type="coeffname">s1</fnarg>
      <fnarg optional="true" type="coeffname">s2</fnarg>
    </fnargs>
    <description>
      <para>
	The <lit>$stderr</lit> accessor can be used in two ways: with no
	arguments, it returns a square matrix containing the estimated
	covariance matrix for the coefficients of the last model. With the
	optional arguments, it returns a scalar, which is the estimated
	covariance between the parameters named <argname>s1</argname> and
	<argname>s2</argname>.  See also <fncref targ="$coeff"/> and 
	<fncref targ="$stderr"/>).
      </para>
      <para>
	If the <quote>model</quote> in question is actually a system (a
	VAR or VECM, or system of simultaneous equations), <lit>$vcv</lit>
	with no parameters returns the cross-equation covariance matrix.
      </para>
    </description>
  </function>

  <function name="$yhat" output="series">
    <description>
      <para>
	Returns the fitted values from the last regression.
      </para>
    </description>
  </function>

  <function name="abs" output="asinput">
    <fnargs>
      <fnarg type="anyfloat">x</fnarg>
    </fnargs>
    <description>
      <para>
	Absolute value of <mathvar>x</mathvar>.
      </para>
    </description>
  </function>

  <function name="atan" output="asinput">
    <fnargs>
      <fnarg type="anyfloat">x</fnarg>
    </fnargs>
    <description>
      <para>
	Arctangent.
      </para>
    </description>
  </function>

  <function name="bkfilt" output="series">
    <fnargs>
      <fnarg type="series">y</fnarg>
    </fnargs>
    <description>
      <para>
	Extracts the cyclical component of series <mathvar>y</mathvar> via
	the Baxter&ndash;King bandpass filter, a two-sided symmetric
	filter. See XXX for details; see also <fncref targ="hpfilt"/>.
      </para>
    </description>
  </function>

  <function name="cdemean" output="matrix">
    <fnargs>
      <fnarg type="matrix">X</fnarg>
    </fnargs>
    <description>
      <para>
	Centers the columns of matrix <mathvar>X</mathvar> around their
	means.
      </para>
    </description>
  </function>

  <!-- cdf -->

  <function name="cdiv" output="matrix">
    <fnargs>
      <fnarg type="matrix">X</fnarg>
      <fnarg type="matrix">Y</fnarg>
    </fnargs>
    <description>
      <para>
	Complex division. The two arguments must have the same number of
	rows, <mathvar>n</mathvar>, and either one or two columns.  The
	first column contains the real part and the second (if present)
	the imaginary part.  The return value is an <mathvar>n</mathvar>
	by 2 matrix or, if the result has no imaginary part, an
	<mathvar>n</mathvar>-vector. See also <fncref targ="cmult"/>.
      </para>
    </description>
  </function>

  <function name="ceil" output="asinput">
    <fnargs>
      <fnarg type="anyfloat">x</fnarg>
    </fnargs>
    <description>
      <para>
	Ceiling function: returns the smallest integer greater than or
	equal to <mathvar>x</mathvar>. See also <fncref targ="floor"/> and
	<fncref targ="int"/>.
      </para>
    </description>
  </function>  

  <function name="cholesky" output="matrix">
    <fnargs>
      <fnarg type="matrix">A</fnarg>
    </fnargs>
    <description>
      <para>
	Peforms a Cholesky decomposition of the matrix
	<mathvar>A</mathvar>, which is assumed to be symmetric and
	positive definite. The result is a lower-triangular matrix
	<mathvar>K</mathvar> which satisfies <equation status="inline"
	  ascii="A = KK'" graphic="" tex="$A = KK'$"/>. The function will
	fail if <mathvar>A</mathvar> is not symmetric and/or not positive
	definite.
      </para>
    </description>
  </function>

  <function name="cmult" output="matrix">
    <fnargs>
      <fnarg type="matrix">X</fnarg>
      <fnarg type="matrix">Y</fnarg>
    </fnargs>
    <description>
      <para>
	Complex multiplication. The two arguments must have the same
	number of rows, <mathvar>n</mathvar>, and either one or two
	columns.  The first column contains the real part and the second
	(if present) the imaginary part.  The return value is an 
	<mathvar>n</mathvar> by 2 matrix, or, if the result has no
	imaginary part, an <mathvar>n</mathvar>-vector. See also
	<fncref targ="cdiv"/>.
      </para>
    </description>
  </function>

  <function name="cnorm" output="asinput">
    <fnargs>
      <fnarg type="anyfloat">x</fnarg>
    </fnargs>
    <description>
      <para>
	Returns the cumulative distribution function for a standard
	normal. See also <fncref targ="dnorm"/> and <fncref targ="qnorm"/>.
      </para>
    </description>
  </function>

  <function name="cols" output="scalar">
    <fnargs>
      <fnarg type="matrix">X</fnarg>
    </fnargs>
    <description>
      <para>
	Number of columns of <mathvar>X</mathvar>. See also <fncref
	  targ="mshape"/>, <fncref targ="rows"/>,
	<fncref targ="unvech"/>, <fncref targ="vec"/> and 
	<fncref targ="vech"/>.
      </para>
    </description>
  </function>

  <function name="corr" output="scalar">
    <fnargs>
      <fnarg type="series">y1</fnarg>
      <fnarg type="series">y2</fnarg>
    </fnargs>
    <description>
      <para>
	Computes the correlation coefficient between <argname>y1</argname>
	and <argname>y2</argname>. See also <fncref targ="cov"/>, <fncref
	  targ="mcov"/> and <fncref targ="mcorr"/>.
      </para>
    </description>
  </function>

  <function name="cos" output="asinput">
    <fnargs>
      <fnarg type="anyfloat">x</fnarg>
    </fnargs>
    <description>
      <para>
	Cosine.
      </para>
    </description>
  </function>

  <function name="cov" output="scalar">
    <fnargs>
      <fnarg type="series">y1</fnarg>
      <fnarg type="series">y2</fnarg>
    </fnargs>
    <description>
      <para>
	Computes the covariance between <argname>y1</argname> and
	<argname>y2</argname>. See also <fncref targ="corr"/>, 
	<fncref targ="mcov"/> and <fncref targ="mcorr"/>.
      </para>
    </description>
  </function>

  <!-- critical -->

  <function name="cum" output="series">
    <fnargs>
      <fnarg type="series">x</fnarg>
    </fnargs>
    <description>
      <para>
	Cumulates <argname>x</argname>. That is, produces a series $S_t =
	\sum_{s=m}^t x_s$. The starting point <mathvar>m</mathvar> is the
	first non-missing observation of the currently selected sample. If
	any missing values are encountered in <mathvar>x</mathvar>,
	subsequent values of <mathvar>y</mathvar> will be set to missing.
	See also <fncref targ="diff"/>.
      </para>
    </description>
  </function>


  <function name="det" output="scalar">
    <fnargs>
      <fnarg type="matrix">A</fnarg>
    </fnargs>
    <description>
      <para>
	Returns the determinant of <argname>A</argname>, computed via the
	LU factorization. See also <fncref targ="ldet"/> and <fncref
	  targ="rcond"/>.
      </para>
    </description>
  </function>  

  <function name="diag" output="matrix">
    <fnargs>
      <fnarg type="matrix">X</fnarg>
    </fnargs>
    <description>
      <para>
	Returns the principal diagonal of <argname>X</argname> in a column
	vector. Note: if <argname>X</argname> is an <mathvar>m</mathvar>
	by <mathvar>n</mathvar> marix, the number of elements of the
	output vector is min(<mathvar>m</mathvar>, <mathvar>n</mathvar>).
	See also <fncref targ="tr"/>.
      </para>
    </description>
  </function>

  <function name="diff" output="series">
    <fnargs>
      <fnarg type="series">y</fnarg>
    </fnargs>
    <description>
      <para>
	Computes first differences; starting values are set to
	<lit>NA</lit>.
      </para>
    </description>
  </function>

  <function name="dnorm" output="asinput">
    <fnargs>
      <fnarg type="anyfloat">x</fnarg>
    </fnargs>
    <description>
      <para>
	Returns the density function for a standard normal. See also
	<fncref targ="cnorm"/> and <fncref targ="qnorm"/>.
      </para>
    </description>
  </function>

  <function name="dsort" output="asinput">
    <fnargs>
      <fnarg type="series-or-vec">x</fnarg>
    </fnargs>
    <description>
      <para>
	Sorts <argname>x</argname> in descending order, skipping
	observations with missing values when <argname>x</argname> is a
	series. See also <fncref targ="sort"/> and 
	<fncref targ="values"/>.
      </para>
    </description>
  </function>

  <function name="eigengen" output="matrix">
    <fnargs>
      <fnarg type="matrix">A</fnarg>
      <fnarg type="matrix">&amp;U or null</fnarg>
    </fnargs>
    <description>
      <para>
	Computes the eigenvalues, and optionally the right eigenvectors,
	of the <mathvar>n</mathvar> by <mathvar>n</mathvar> matrix
	<argname>A</argname>.  If all the eigenvalues are real, an
	<mathvar>n</mathvar> by 1 matrix is returned; otherwise, the
	result is an <mathvar>n</mathvar> by 2 matrix, the first column
	holding the real components and the second column the imaginary
	components.
      </para>
      <para>
	The second argument must be either the name of an existing matrix
	preceded by <lit>&amp;</lit> (to indicate the
	<quote>address</quote> of the matrix in question), in which case
	an auxiliary result is written to that matrix, or the keyword
	<lit>null</lit>, in which case the auxiliary result is not
	produced.
      </para>
      <para>
	If a non-null second argument is given, the specified matrix
	will be over-written with the auxiliary result.  (It is not
	required that the existing matrix be of the right dimensions to
	receive the result.) It will be organized as follows:
      </para>
      <ilist>
	<li>
	  <para>If the <mathvar>i</mathvar>-th eigenvalue is real, the
	    <mathvar>i</mathvar>-th column of <mathvar>U</mathvar> will
	    contain the corresponding eigenvector;
	  </para>
	</li>
	<li>
	  <para>
	    If the <mathvar>i</mathvar>-th eigenvalue is complex, the
	    <mathvar>i</mathvar>-th column of <argname>U</argname> will
	    contain the real part of the corresponding eigenvector and the
	    next column the imaginary part. The eigenvector for the
	    conjugate eigenvalue is the conjugate of the eigenvector.
	  </para>
	</li>
      </ilist>
      <para>
	In other words, the eigenvectors are stored in the same order as
	the eigenvalues, but the real eigenvectors occupy one column,
	whereas complex eigenvectors take two (the real part comes first);
	the total number of columns is still <mathvar>n</mathvar>, because
	the conjugate eigenvector is skipped.
      </para>
      <para>
	  See also <fncref targ="eigensym"/>,
	<fncref targ="qrdecomp"/> and <fncref targ="svd"/>.
      </para>
    </description>
  </function>

  <function name="exp" output="asinput">
    <fnargs>
      <fnarg type="anyfloat">x</fnarg>
    </fnargs>
    <description>
      <para>
	Exponential. Note: in case of matrices, the function acts element
	by element. For the matrix exponential function, see <fncref
	  targ="mexp"/>.
      </para>
    </description>
  </function>

  <function name="fft" output="matrix">
    <fnargs>
      <fnarg type="matrix">X</fnarg>
    </fnargs>
    <description>
      <para>
	Discrete real Fourier transform. If the input matrix
	<argname>X</argname> has <mathvar>n</mathvar> columns, the output
	has 2<mathvar>n</mathvar> columns, where the real parts are stored
	in the odd columns and the complex parts in the even ones.
      </para>
      <para>
	Should it be necessary to compute the Fourier transform on several
	vectors with the same number of elements, it is numerically more
	efficient to group them into a matrix rather than invoking
	<lit>fft</lit> for each vector separately.  See also <fncref
	  targ="ffti"/>.
      </para>
    </description>
  </function>

  <function name="ffti" output="matrix">
    <fnargs>
      <fnarg type="matrix">X</fnarg>
    </fnargs>
    <description>
      <para>
	Inverse discrete real Fourier transform. It is assumed that
	<argname>X</argname> contains <mathvar>n</mathvar> complex column
	vectors, with the real part in the odd columns and the imaginary
	part in the even ones, so the total number of columns should be
	2<mathvar>n</mathvar>. A matrix with <mathvar>n</mathvar> columns
	is returned.
      </para>
      <para>
	Should it be necessary to compute the inverse Fourier transform on
	several vectors with the same number of elements, it is
	numerically more efficient to group them into a matrix rather than
	invoking <lit>ffti</lit> for each vector separately.  See also
	<fncref targ="fft"/>.
      </para>
    </description>
  </function>

  <function name="firstobs" output="scalar">
    <fnargs>
      <fnarg type="series">y</fnarg>
    </fnargs>
    <description>
      <para>
	First non-missing observation for the variable
	<argname>y</argname>. Note that if some form of subsampling is in
	effect, the value returned may be smaller than the dollar variable
	<fncref targ="$t1"/>. See also <fncref targ="lastobs"/>.
      </para>
    </description>
  </function>

  <function name="floor" output="asinput">
    <fnargs>
      <fnarg type="anyfloat">y</fnarg>
    </fnargs>    
    <description>
      <para>
	Floor function: returns the greatest integer less than or equal to
	<argname>x</argname>. Note: <fncref targ="int"/> and <fncref
	  targ="floor"/> differ in their effect for negative arguments:
	\texttt{int(-3.5)} gives -3, while \texttt{floor(-3.5)} gives -4.
	See also and <fncref targ="int"/>.
      </para>
    </description>
  </function>

  <function name="fracdiff" output="series">
    <fnargs>
      <fnarg type="series">y</fnarg>
      <fnarg type="scalar">d</fnarg>
    </fnargs>    
    <description>
      <para>
	Returns the fractional difference of order <argname>d</argname>
	for the series <mathvar>y</mathvar>.
	<equation status="display" ascii="" graphic=""
	  tex="\[
	  \Delta^d y_t = y_t - \sum_{i=1}^{\infty} \psi_i y_{t-i}
	  \]" />
	where
	<equation status="display" ascii="" graphic=""
	  tex="\[\psi_i = \frac{\Gamma(i-d)}{\Gamma(-d) \Gamma(i+1)}\]"
	  />
      </para>
      <para> 
	Note that in theory fractional differentiation is an
	infinitely long filter. In practice, presample values of 
	<mathvar>y<sub>t</sub></mathvar> are assumed to be zero.
      </para>
    </description>
  </function>

  <function name="gammafunc" output="asinput">
    <fnargs>
      <fnarg type="anyfloat">x</fnarg>
     </fnargs>    
    <description>
      <para>
	Returns the gamma function of <argname>x</argname>. 
      </para>
    </description>
  </function>

  <function name="gini" output="scalar">
    <fnargs>
      <fnarg type="series">y</fnarg>
     </fnargs>    
    <description>
      <para>
	Returns Gini's inequality index for the series
	<argname>y</argname>.
      </para>
    </description>
  </function>

  <function name="ginv" output="matrix">
    <fnargs>
      <fnarg type="matrix">A</fnarg>
     </fnargs>    
    <description>
      <para>
	Returns <equation status="inline" ascii="A+" graphic="" 
	  tex="$A^+$"/>, the Moore-Penrose inverse of
	<argname>A</argname>, which has the properties
	<equation status="display" ascii="" graphic=""
	  tex="\begin{eqnarray*}
	  A A^+ A &amp; = &amp; A \\
	  A^+ A A^+ &amp; = &amp; A^+ 
	  \end{eqnarray*}"
	  />
      </para>
      <para>
	The result <equation status="inline" ascii="A+" graphic=""
	  tex="$A^+$"/> is computed via the singular value decomposition.
	See also <fncref targ="inv"/> and <fncref targ="svd"/>.
      </para>
    </description>
  </function>

  <function name="hpfilt" output="series">
    <fnargs>
      <fnarg type="series">y</fnarg>
    </fnargs>
    <description>
      <para>
	Returns the cycle from the Hodrick&ndash;Prescott filter applied
	to series <argname>y</argname>.  See FIXME for details. See also
	<fncref targ="bkfilt"/>.
      </para>
    </description>
  </function>

  <function name="I" output="matrix">
    <fnargs>
      <fnarg type="scalar">n</fnarg>
    </fnargs>
    <description>
      <para>
	Returns an identity matrix with <argname>n</argname> rows and
	columns.
      </para>
    </description>
  </function>

  <function name="imaxc" output="matrix">
    <fnargs>
      <fnarg type="matrix">X</fnarg>
    </fnargs>
    <description>
      <para>
	Returns a vector containing the row indices of the maxima of the
	columns of <argname>X</argname>. See also <fncref targ="imaxr"/>, 
	<fncref targ="iminc"/> and <fncref targ="maxc"/>.
      </para>
    </description>
  </function>

  <function name="imaxr" output="matrix">
    <fnargs>
      <fnarg type="matrix">X</fnarg>
    </fnargs>    
    <description>
      <para>
	Returns a vector containing the column indices of the maxima of
	the rows of <argname>X</argname>. See also <fncref targ="imaxc"/>,
	<fncref targ="iminr"/> and <fncref targ="maxr"/>.
      </para>
    </description>
  </function>

  <function name="iminc" output="matrix">
    <fnargs>
      <fnarg type="matrix">X</fnarg>
    </fnargs>    
    <description>
      <para>
	Returns the row indices of the minima of the columns of
	<mathvar>X</mathvar>. See also <fncref targ="imaxc"/>, <fncref
	  targ="iminr"/> and <fncref
	  targ="minc"/>.
      </para>
    </description>
  </function>

  <function name="iminr" output="matrix">
    <fnargs>
      <fnarg type="matrix">X</fnarg>
    </fnargs>    
    <description>
      <para>
	Returns the column indices of the maxima of the rows of
	<mathvar>X</mathvar>. See also <fncref targ="imaxr"/>, 
	<fncref targ="iminc"/> and <fncref targ="minr"/>.
      </para>
    </description>
  </function>

  <function name="infnorm" output="scalar">
    <fnargs>
      <fnarg type="matrix">X</fnarg>
    </fnargs>    
    <description>
      <para>
	Returns the <equation status="inline" 
	  ascii="infinity-norm" graphic="" tex="$\infty$-norm"/> of the
	<mathvar>r</mathvar> by <mathvar>c</mathvar> matrix
	<argname>X</argname>: 
	<equation status="display" ascii="" graphic=""
	  tex="\[
	  || X ||_{\infty} = \max_i \sum_{j=1}^c |X_{ij}|"
	  />
      </para>
      <para>
	See also <fncref targ="onenorm"/>.
      </para>
    </description>
  </function>

  <function name="int" output="asinput">
    <fnargs>
      <fnarg type="anyfloat">x</fnarg>
    </fnargs>  
    <description>
      <para>
	Truncates the fractional part of <argname>x</argname>. Note:
	<lit>int</lit> and <fncref targ="floor"/> differ in their effect
	for negative arguments: <lit>int(-3.5)</lit> gives &minus;3, while
	<lit>floor(-3.5)</lit> gives &minus;4. See also 
      <fncref targ="ceil"/>.
    </para>
    </description>
  </function>

  <function name="inv" output="matrix">
    <fnargs>
      <fnarg type="matrix">A</fnarg>
    </fnargs>  
    <description>
      <para>
	Returns the inverse of <argname>A</argname>. If
	<argname>A</argname> is singular or not square, an error message
	is produced and nothing is returned. Note that gretl checks
	automatically the structure of <argname>A</argname> and uses the
	most efficient numerical procedure to perform the inversion.
      </para>
      <para>
	The matrix types gretl checks for are:
      </para>
      <ilist>
	<li><para>Identity</para>
	</li>
	<li><para>Diagonal</para>
	</li>
	<li><para>Symmetric and positive definite</para>
	</li>
	<li><para>Symmetric but not positive definite</para>
	</li>
	<li><para>Triangular</para>
	</li>
      </ilist>
      <para>
	See also <fncref targ="ginv"/>.
      </para>
    </description>
  </function>

  <!-- invcdf -->

  <function name="islist" output="scalar">
    <fnargs>
      <fnarg type="string">s</fnarg>
    </fnargs>
    <description>
      <para>
	Returns 1 if <argname>s</argname> is the identifier for a
	currently defined list. Mainly used for checking arguments passed
	to functions.  See also <fncref targ="isnull"/>, <fncref
	  targ="isseries"/> and <fncref targ="isstring"/>.
      </para>
    </description>
  </function>

  <function name="isnull" output="scalar">
    <fnargs>
      <fnarg type="string">s</fnarg>
    </fnargs>
    <description>
      <para>
	Returns 0 if <argname>s</argname> is the identifier for a
	currently defined object, be it a scalar, a series, a matrix or a
	list. Mainly used for checking arguments passed to functions.  See
	also <fncref targ="islist"/>, <fncref targ="isnull"/> 
	and <fncref targ="isseries"/>.
      </para>
    </description>
  </function>  

  <function name="isseries" output="scalar">
    <fnargs>
      <fnarg type="string">s</fnarg>
    </fnargs>
    <description>
      <para>
	Returns 1 if <argname>s</argname> is the identifier for a
	currently defined series. Mainly used for checking arguments
	passed to functions.  See also <fncref targ="islist"/>, <fncref
	  targ="isnull"/>, and <fncref targ="isseries"/>.
      </para>
    </description>
  </function>

  <function name="isstring" output="scalar">
    <fnargs>
      <fnarg type="string">s</fnarg>
    </fnargs>
    <description>
      <para>
	Returns 1 if <mathvar>s</mathvar> is the identifier for a
	currently defined series. Mainly used for checking arguments
	passed to functions.  See also <fncref targ="isseries"/>, <fncref
	  targ="islist"/> and <fncref targ="isnull"/>.
      </para>
    </description>
  </function>

  <function name="lastobs" output="scalar">
    <fnargs>
      <fnarg type="series">y</fnarg>
    </fnargs>
    <description>
      <para>
	Last non-missing observation for the variable
	<argname>y</argname>. Note that if some form of subsampling is in
	  effect, the value returned may be larger than the dollar
	  variable <fncref targ="$t2"/>.  See also
	<fncref targ="firstobs"/>.
      </para>
    </description>
  </function>

  <function name="ldet" output="scalar">
    <fnargs>
      <fnarg type="matrix">A</fnarg>
    </fnargs>
    <description>
      <para>
	Returns the natural log of the determinant of
	<mathvar>A</mathvar>, computed via the LU factorization. See also
	<fncref targ="det"/> and <fncref targ="rcond"/>.
      </para>
    </description>
  </function>

  <function name="ldiff" output="series">
    <fnargs>
      <fnarg type="series">y</fnarg>
    </fnargs>
    <description>
      <para>
	Computes log differences; starting values are set to <lit>NA</lit>.
      </para>
    </description>
  </function>

  <function name="log" output="asinput">
    <fnargs>
      <fnarg type="anyfloat">x</fnarg>
    </fnargs>
    <description>
      <para>
	Natural logarithm; produces <lit>NA</lit> for non-positive values.
	Note: <lit>ln</lit> is an acceptable alias for <lit>log</lit>.
      </para>
    </description>
  </function>

  <function name="lngamma" output="asinput">
    <fnargs>
      <fnarg type="anyfloat">x</fnarg>
    </fnargs>
    <description>
      <para>
	Log of the gamma function of <argname>x</argname>.
      </para>
    </description>
  </function>

  <function name="log10" output="asinput">
    <fnargs>
      <fnarg type="anyfloat">x</fnarg>
    </fnargs>
    <description>
      <para>
	Base-10 logarithm; produces <lit>NA</lit> for non-positive values.
      </para>
    </description>
  </function>

  <function name="log2" output="asinput">
    <fnargs>
      <fnarg type="anyfloat">x</fnarg>
    </fnargs>
    <description>
      <para>
	Base-2 logarithm; produces <lit>NA</lit> for non-positive values.
      </para>
    </description>
  </function>

  <function name="lower" output="matrix">
    <fnargs>
      <fnarg type="matrix">A</fnarg>
    </fnargs>
    <description>
      <para>
	Returns an <mathvar>n</mathvar> by <mathvar>n</mathvar > 
	lower triangular matrix <mathvar>B</mathvar> for
	which
	<equation status="inline" ascii="XXX" graphic="" 
	  tex="$B_{ij} = A_{ij}$ if $i \ge j$"/>, and 0 otherwise. 
	See also <fncref targ="upper"/>.
      </para>
    </description>
  </function>

  <function name="lrvar" output="scalar">
    <fnargs>
      <fnarg type="series">y</fnarg>
      <fnarg type="scalar">k</fnarg>
    </fnargs>
    <description>
      <para>
	Returns the long-run variance of <argname>y</argname>, calculated
	using a Bartlett kernel with window size <argname>k</argname>. In
	formulae:
	<equation status="display" ascii="" graphic=""
	  tex="\[
	  \hat{\omega}^2(k) = \frac{1}{T} \sum_{t=k}^{T-k} 
	  \left[ \sum_{i=-k}^k w_i (y_t - \bar{X}) (y_{t-i} - 
	  \bar{Y}) \right]" />
	with
	<equation status="display" ascii="" graphic=""
	  tex="\[
	  w_i = 1 - \frac{|i|}{k + 1}" />
      </para>
    </description>
  </function>

  <function name="makemask" output="matrix">
    <fnargs>
      <fnarg type="series">y</fnarg>
    </fnargs>
    <description>
      <para>
	Produces a column vector containing the observation numbers
	corresponding to the non-zero entries in the series
	<argname>y</argname>. This function is typically useful for
	filtering out rows of a matrix built from data series.
      </para>
    </description>
  </function>

  <function name="max" output="scalar">
    <fnargs>
      <fnarg type="series">y</fnarg>
    </fnargs>
    <description>
      <para>
	Maximum of the non-missing observations in series
	<argname>y</argname>.
      </para>
    </description>
  </function>


</funclist>
