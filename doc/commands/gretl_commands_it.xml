<?xml version="1.0" encoding="ISO-8859-1" ?>
<!DOCTYPE commandlist SYSTEM "gretl_commands.dtd">

<commandlist language="italian">

<?PSGML NOFILL label code altforms altform menu-path equation other-access?>

  <command name="add" section="Tests" label="Aggiunge variabili al modello">

    <usage>
      <arguments>
        <argument>lista-variabili</argument>
      </arguments>
      <options>
	<option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>non mostra le stime del modello aumentato</effect>
	</option>
 	<option>
 	  <flag>--silent</flag>
 	  <effect>non mostra nulla</effect>
 	</option>
        <option>
          <flag>--inst</flag>
          <effect>aggiunge come strumento, solo per TSLS</effect>
        </option>
        <option>
          <flag>--both</flag>
          <effect>aggiunge come regressore e come strumento, solo per TSLS</effect>
        </option>
      </options>
      <examples>
        <example>add 5 7 9</example>
        <example>add xx yy zz --quiet</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
	Va invocato dopo un comando di stima. Aggiunge al modello precedente
        le variabili nella <repl>lista-variabili</repl> e stima il nuovo
        modello. Viene eseguito anche un test per la significatività congiunta 
        delle variabili aggiunte: nel caso di stime OLS, la statistica test è la
        <math>F</math>, negli altri casi è il chi-quadro asintotico di
        Wald. Un p-value inferiore a 0.05 indica che i coefficienti sono
        congiuntamente significativi al livello del 5 per cento.
      </para>
      <para context="cli">
	Se viene usata l'opzione <lit>--quiet</lit> viene mostrato solo
	il risultato del test per la significatività congiunta delle
	variabili aggiunte, altrimenti vengono mostrate anche le stime
	per il modello aumentato. Nell'ultimo caso, l'opzione
	<lit>--vcv</lit> mostra anche la matrice di covarianza dei coefficienti.
 	Usando l'opzione <lit>--silent</lit>, non viene mostrato nulla; tuttavia
        i risultati del test possono essere recuperati usando le variabili
        speciali <lit>$test</lit> e <lit>$pvalue</lit>.
      </para>
      <para context="cli">
       Se il modello originale è stato stimato con i minimi quadrati a due
       stadi, può sorgere un'ambiguità: le nuove variabili vanno aggiunte come
       regressori, come strumenti o con entrambe le funzioni? Per risolvere
       l'ambiguità, nella modalità predefinita le variabili sono aggiunte come
       regressori endogeni, se si usa l'opzione <lit>--inst</lit> sono aggiunte
       come strumenti, mentre se si usa l'opzione <lit>--both</lit> sono aggiunte
       come regressori esogeni.
      </para>
      <para context="gui">
	Aggiunge le variabili selezionate al modello precedente e stima il
        nuovo modello. Viene eseguito anche un test per la significatività congiunta 
        delle variabili aggiunte: nel caso di stime OLS, la statistica test è la
        <math>F</math>, negli altri casi è il chi-quadro asintotico di
        Wald. Un p-value inferiore a 0.05 indica che i coefficienti sono
        congiuntamente significativi al livello del 5 per cento.
      </para>
    </description>

    <gui-access>
      <menu-path>Finestra del modello, /Test/ADD - Aggiungi variabili</menu-path>
    </gui-access>

  </command>

  <command name="adf" section="Tests" label="Test Dickey-Fuller aumentato">

    <usage>
      <arguments>
        <argument>ordine</argument>
        <argument>lista-variabili</argument>
      </arguments>
      <options>
	<option>
	  <flag>--nc</flag>
	  <effect>test senza costante</effect>
	</option>
	<option>
	  <flag>--c</flag>
	  <effect>solo con la costante</effect>
	</option>
	<option>
	  <flag>--ct</flag>
	  <effect>con costante e trend</effect>
	</option>
	<option>
	  <flag>--ctt</flag>
	  <effect>con costante, trend e trend al quadrato</effect>
	</option>
        <option>
	  <flag>--seasonals</flag>
	  <effect>include variabili dummy stagionali</effect>
        </option>
        <option>
         <flag>--gls</flag>
         <effect>rimuove la media o il trend usando GLS</effect>
        </option>
	<option>
	  <flag>--verbose</flag>
	  <effect>mostra i risultati della regressione</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>non mostra i risultati</effect>
	</option>
	<option>
	  <flag>--difference</flag>
	  <effect>usa la differenza prima della variabile</effect>
	</option>
	<option>
	  <flag>--test-down</flag>
	  <effect>ordine di ritardo automatico</effect>
	</option>
      </options>
      <examples>
	<example>adf 0 y</example>
        <example>adf 2 y --nc --c --ct</example>
        <example>adf 12 y --c --test-down</example>
	<demos>
	  <demo>jgm-1996.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para context="gui">Questo comando richiede un ordine di ritardo intero;
       se si indica un ordine pari a zero, viene eseguito un test
       Dickey&ndash;Fuller standard (non aumentato). Il comando calcola una
       serie di test Dickey&ndash;Fuller sulla variabile selezionata, assumendo
       come ipotesi nulla che la variabile abbia una radice unitaria. Se si usa
       l'opzione di differenziazione, i test vengono condotti sulla differenza
       prima della variabile e la discussione che segue va riferita a questa
       trasformazione della variabile.
       </para>
       
      <para context="cli">
	Calcola una serie di test Dickey&ndash;Fuller sulle variabili
        specificate, assumendo come ipotesi nulla che le variabili
        abbiano una radice unitaria. Se si usa l'opzione <lit>--difference</lit>,
        i test vengono condotti sulla differenza prima delle variabili e la
        discussione che segue va riferita a questa trasformazione delle
        variabili.
      </para>

      <para context="cli">
        Per impostazione predefinita, vengono mostrate due varianti del
        test: una basata su una regressione che contiene solo una costante,
        e una che include la costante e un trend lineare. È possibile
        controllare le varianti specificando una o più opzioni.
      </para>
      
      <para>In tutti i casi, la variabile dipendente è la differenza prima
        della variabile specificata, <math>y</math>, e la variabile
        dipendente più importante è il ritardo (di ordine uno) di
        <math>y</math>. Il modello è costruito in modo che il coefficiente
        della variabile ritardata <math>y</math> è pari a 1 meno
        la radice. Ad esempio, il modello con una costante può essere
        scritto come <equation status="display"
        tex="\[(1-L)y_t=\beta_0+(\alpha-1)y_{t-1}+\epsilon_t\]"
        ascii="(1 - L)y(t) = b0 + (a-1)y(t-1) + e(t)"
	graphic="adf1"/></para>

      <para context="cli">
        Se l'ordine di ritardi, <math>k</math>, è maggiore di 0, ai
        regressori di ognuna delle regressioni calcolate per il test saranno
        aggiunti <math>k</math> ritardi della variabile dipendente, con la
        precisazione che segue. Se si usa l'opzione <lit>--test-down</lit>,
        <math>k</math> viene interpretato come ritardo massimo, mentre
        l'ordine di ritardo effettivamente usato viene ottenuto testando
        "all'indietro" con il seguente algoritmo:
      </para>

      <para context="gui">
        Se l'ordine di ritardi, <math>k</math>, è maggiore di 0, ai
        regressori di ognuna delle regressioni calcolate per il test saranno
        aggiunti <math>k</math> ritardi della variabile dipendente, con la
        precisazione che segue. Se viene selezionata la casella <quote>test per
        il ritardo massimo</quote>, l'ordine selezionato verrà considerato come
        ordine massimo, e l'ordine da usare effettivamente sarà ricavato
        applicando la seguente procedura di test "all'indietro":
      </para>

      <nlist>
	<li><para>Stima la regressione Dickey&ndash;Fuller con
	    <math>k</math> ritardi della variabile dipendente.
	  </para>
	</li>
	<li><para>Se questo ordine di ritardi è significativo, esegue il test
        con l'ordine di ritardo <math>k</math>.  Altrimenti, prova il test
        con <math>k</math> = <math>k</math> &minus; 1; se
	    <math>k</math> = 0, esegue il test con ordine di ritardo 0,
            altrimenti va al punto 1.
	  </para>
	</li>
      </nlist>

      <para>
        Durante il punto 2 spiegato sopra, <quote>significativo</quote>
        significa che la statistica <math>t</math> per l'ultimo ritardo
        abbia un <emphasis>p</emphasis>-value asintotico a due code per la
        distribuzione normale pari a 0.10 o inferiore.
      </para> 
      <para context="cli">
        L'opzione <lit>--gls</lit> può essere usata insieme a una delle altre due
        opzioni <lit>--c</lit> e <lit>--ct</lit> (il modello con costante o quello
        con costante e trend). L'effetto di questa opzione è di rimuovere la
        media o il trend della variabile da testare, usando la procedura GLS
        suggerita da Elliott, Rothenberg e Stock (1996), che fornisce un test di
        potenza maggiore rispetto a quell'approccio standard di
        Dickey&ndash;Fuller approach. Questa opzione non è compatibile con le
        opzioni <lit>--nc</lit>, <lit>--ctt</lit> o <lit>--seasonals</lit>.
      </para>
      <para>
        I <emphasis>p-</emphasis>value per questo test sono basati su
	MacKinnon (1996). Il codice rilevante è incluso per gentile concessione
        dell'autore. Nel caso del test con trend lineare usando la procedura GLS
        questi <emphasis>P</emphasis>-value non sono utilizzabili; vengono usati
        i valori critici contenuti nella Tabella 1 di Elliott, Rothenberg e Stock
        (1996).
      </para>
    </description>

    <gui-access>
      <menu-path>/Variabile/Test Dickey-Fuller aumentato</menu-path>
    </gui-access>

  </command>

  <command name="append" section="Dataset" label="Aggiunge dati" context="cli">

    <usage>
      <arguments>
        <argument>file-dati</argument>
      </arguments>
      <options>
	<option>
	  <flag>--time-series</flag>
	  <effect>si veda oltre</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
        Apre un file di dati e aggiunge il suo contenuto al dataset
        attuale, se i nuovi dati sono compatibili. Il programma cerca
        di riconoscere il formato del file di dati (interno, testo semplice,
        CSV, Gnumeric, Excel, ecc.).
      </para>
      <para>
	I dati aggiunti possono avere la forma di osservazioni aggiuntive su
        variabili già presenti nel dataset, o di nuove variabili. In
        quest'ultimo caso occorre che il numero delle nuove osservazioni sia
        pari a quello delle osservazioni presenti nel dataset, oppure che i
        nuovi dati includano informazioni precise sulle osservazioni in modo che
        gretl possa capire come aggiungere i valori.
      </para>
      <para>
	Nel caso di aggiunta di dati a un dataset panel, c'è una possibilità
        speciale. Detti <math>n</math> il numero di unità cross-section, 
	<math>T</math> il numero di periodi temporali, e <math>m</math> il
        numero di nuove osservazioni da aggiungere. Se <math>m = n</math> i nuovi
        dati saranno considerati invarianti nel tempo, e saranno copiati per
        ognuno dei periodi temporali. D'altra parte, se <math>m = T</math> i dati
        saranno trattati come invarianti tra le unità. Se il panel è
	<quote>quadrato</quote>, ed <math>m</math> è pari sia ad <math>n</math>
        che a <math>T</math>, il comportamento predefinito consiste nel trattare
        i nuovi casi come invarianti nel tempo, ma è possibile forzare
        l'interpretazione dei nuovi dati come serie storiche usando l'opzione
	<lit>--time-series</lit> (che verrà ignorata in tutti gli altri casi).
      </para>
    </description>

    <gui-access>
      <menu-path>/File/Aggiungi dati</menu-path>
    </gui-access>

  </command>

  <command name="ar" section="Estimation" label="Stima autoregressiva">

    <usage>
      <arguments>
        <argument>ritardi</argument>
	<argument separated="true">variabile-dipendente</argument>
        <argument>variabili-indipendenti</argument>
      </arguments>
      <options>
	<option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
	</option>
      </options>
      <examples>
        <example>ar 1 3 4 ; y 0 x1 x2 x3</example>
      </examples>
    </usage>

    <description>
      <para>
	Calcola le stime parametriche usando la procedura iterativa generalizzata
	di Cochrane&ndash;Orcutt (si veda il Capitolo 9.5 di
	Ramanathan, 2002). La procedura termina quando le somme dei quadrati degli errori
	consecutivi non differiscono per più dello 0.005 per cento, oppure dopo
	20 iterazioni.</para>

      <para context="gui">
	La <quote>lista dei ritardi AR</quote> specifica la struttura del processo
	dell'errore.  Ad esempio, l'indicazione <quote>1 3 4</quote> corrisponde
	al processo: 
	<equation status="display" 
	  tex="\[u_t = \rho_1u_{t-1} + \rho_3 u_{t-3} +
	    \rho_4 u_{t-4} + e_t\]"
	  ascii="u(t) = rho1*u(t-1) + rho3*u(t-3) + rho4*u(t-4)"
	  graphic="arlags"/>
      </para>

      <para context="cli">
	<repl quote="true">ritardi</repl> è una lista di ritardi nei residui, conclusa
	da un punto e virgola. Nell'esempio precedente, il termine di errore è
	specificato come
	<equation status="display" 
	  tex="\[u_t = \rho_1u_{t-1} + \rho_3 u_{t-3} +
	    \rho_4 u_{t-4} + e_t\]"
	  ascii="u(t) = rho(1)*u(t-1) + rho(3)*u(t-3) + rho(4)*u(t-4)"
	  graphic="arlags"/>
      </para>

    </description>

    <gui-access>
      <menu-path>/Modello/Serie storiche/AR - Stima autoregressiva</menu-path>
    </gui-access>

  </command>

  <command name="ar1" section="Estimation" label="Stima AR(1)">

    <usage>
      <arguments>
        <argument>depvar</argument>
        <argument>indepvars</argument>
      </arguments>
      <options>
	<option>
	  <flag>--hilu</flag>
	  <effect>usa la procedura di Hildreth&ndash;Lu</effect>
	</option>
	<option>
	  <flag>--pwe</flag>
	  <effect>usa lo stimatore di Prais&ndash;Winsten</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
	</option>
	<option>
	  <flag>--no-corc</flag>
	  <effect>non affinare i risultati con Cochrane-Orcutt</effect>
	</option>
      </options>
      <examples>
        <example>ar1 1 0 2 4 6 7</example>
	<example>ar1 y 0 xlist --hilu --no-corc</example>
	<example>ar1 y 0 xlist --pwe</example>
      </examples>
    </usage>

    <description>
      <para>
        Calcola stime feasible GLS per un modello in cui il termine di errore
        segue un processo autoregressivo del prim'ordine.
      </para>
      <para>
	Il metodo predefinito è la procedura iterativa di Cochrane&ndash;Orcutt
        (si veda ad esempio il capitolo 9.4 di Ramanathan, 2002). La procedura
        termina quando le stime successive del coefficiente di
        autocorrelazione non differiscono per più di 0.001, oppure dopo 20 iterazioni.
      </para>
      <para>
	Se si usa l'opzione <lit>--hilu</lit>, verrà usata la procedura di ricerca
        di Hildreth&ndash;Lu.  I risultati sono quindi ottimizzati con la
        procedura iterativa di Cochrane&ndash;Orcutt, a meno che non si usi
        l'opzione <lit>--no-corc</lit> (che viene ignorata se non viene
        specificata <lit>--hilu</lit>).
      </para>
      <para>
        Se si usa l'opzione <lit>--pwe</lit>, viene usato lo stimatore di
        Prais&ndash;Winsten, che prevede una procedura simile a quella di
        Cochrane&ndash;Orcutt; la differenza è che mentre Cochrane&ndash;Orcutt
        tralascia la prima osservazione, Prais&ndash;Winsten ne fa uso.  Per i
        dettagli, si veda per esempio il capitolo 13 di <book>Econometric
        Analysis</book> (2000) di Greene.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modello/Serie storiche/Cochrane-Orcutt</menu-path>
      <menu-path>/Modello/Serie storiche/Hildreth-Lu</menu-path>
      <menu-path>/Modello/Serie storiche/Prais-Winsten</menu-path>
    </gui-access>

  </command>

  <command name="arbond" section="Estimation" label="Modelli panel dinamici">

    <usage>
      <arguments>
	<argblock>
	  <argument>p</argument>
	  <argument optional="true">q</argument>
	</argblock>
	<argblock separated="true">
          <argument>variabile-dipendente</argument>
	  <argument>variabili-indipendenti</argument>
	</argblock>
	<argblock optional="true" separated="true">
	  <argument>strumenti</argument>
	</argblock>
      </arguments>
      <options>
	<option>
	  <flag>--quiet</flag>
	  <effect>non stampa il modello stimato</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>mostra matrice di covarianza</effect>
	</option>
        <option>
	  <flag>--two-step</flag>
	  <effect>usa stima GMM 2-step</effect>
        </option>
        <option>
	  <flag>--time-dummies</flag>
	  <effect>aggiunge variabili dummy temporali</effect>
        </option>
        <option>
	  <flag>--asymptotic</flag>
	  <effect>calcola gli errori standard asintotici nel modo consueto</effect>
        </option>
      </options>
      <examples>
        <example>arbond 2 ; y Dx1 Dx2</example>
        <example>arbond 2 5 ; y Dx1 Dx2 ; Dx1</example>
	<example>arbond 1 ; y Dx1 Dx2 ; Dx1 GMM(x2,2,3)</example>
	<demos>
	  <demo>arbond91.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para>
	Esegue la stima di modelli panel dinamici (ossia, modelli panel che
        includono uno o più ritardi della variabile dipendente) usando il
        metodo GMM proposto da Arellano e Bond (1991).  
      </para>
      <para context="cli">
	Il parametro <repl>p</repl> rappresenta l'ordine dell'autoregressione
        per la variabile dipendente. Il parametro opzionale <repl>q</repl>
        indica il  massimo ritardo del livello della variabile dipendente da
        usare come strumento; se si omette questo argomento, o lo si pone uguale
        a 0, vengono usati tutti i ritardi disponibili.
      </para>
      <para>
	La variabile dipendente andrebbe specificata sotto forma di livello;
        viene differenziata automaticamente, visto che lo stimatore usa la
        differenziazione per eliminare gli effetti individuali. Le variabili
        indipendenti invece non vengono differenziate automaticamente: se si
        intende usare le differenze (tipicamente lo si vorrà fare per le
        variabili quantitative, ma non ad esempio per le dummy temporali),
        occorrerà prima creare le variabili differenziate e poi specificarle
        come regressori.
      </para>
      <para context="cli">
	L'ultimo campo (opzionale) del comando consente di specificare gli
        strumenti. Se non viene usato, si assumerà che tutte le variabili
        indipendenti sono strettamente esogene. Se si specifica uno strumento,
        occorre includere nell'elenco tutte le variabili indipendenti
        strettamente esogene. Per i regressori predeterminati, è possibile usare
        la funzione <lit>GMM</lit> per includere un intervallo specifico di
        ritardi in stile "diagonale". Questo modo di procedere è illustrato nel
        terzo esempio visto sopra. Il primo argomento di <lit>GMM</lit> è il
        nome della variabile in questione, il secondo è il ritardo minimo da
        usare, mentre il terzo è quello massimo. Se il terzo argomento è pari a
        0, vengono usati tutti i ritardi disponibili.
      </para>
      <para context="gui">
	A proposito degli strumenti, si veda la documentazione per
        la versione testuale di questo comando. Al momento non è possibile
        specificare gli strumenti nell'interfaccia grafica: tutte le variabili
        indipendenti sono considerate strettamente esogene.
      </para>
      <para>
	Per impostazione predefinita, vengono mostrati i risultati della
        stima a un passo (con errori standard robusti), ma è possibile scegliere
        una stima a due passi. In entrambi i casi, vengono mostrati i testi per
        l'autocorrelazione di ordine 1 e 2, oltre al test di
        sovraidentificazione di Sargan. Si noti che in questo modello
        differenziato l'autocorrelazione del prim'ordine non contrasta con la
        validità del modello, mentre quella di ordine 2 viola le ipotesi
        statistiche che ne sono alla base. 
      </para>
      <para context="cli">
        Nel caso della stima in due passi, gli errori standard sono calcolati
        usando la correzione per campioni finiti suggerita da Windmeijer (2005).
        Gli errori standard asintotici calcolati nel modo consueto non sono
        generalmente ritenuti affidabili nel caso dello stimatore a due passi,
        ma se per qualche motivo si vuole usarli, è possibile usare l'opzione
        <lit>--asymptotic</lit> per disabilitare la correzione di Windmeijer.
      </para>
      <para context="cli">
	Se si usa l'opzione <lit>--time-dummies</lit>, viene aggiunto ai
        regressori un insieme di variabili dummy temporali. Il numero di
        variabili dummy è pari al numero massimo dei periodi usati nella stima
        meno uno, per evitare la perfetta collinearità in presenza della
        costante. Le dummy sono specificate in livelli; se si intende usare
        variabili dummy sotto forma di differenze temporali, occorre definirle
        ed aggiungerle manualmente.
       </para>
    </description>

    <gui-access>
      <menu-path>/Model/Panel</menu-path>
    </gui-access>

  </command>

  <command name="arch" section="Estimation" label="Modello ARCH">

    <usage>
      <arguments>
        <argument>ordine</argument>
        <argument>variabile-dipendente</argument>
	<argument>variabili-indipendenti</argument>
      </arguments>
      <examples>
        <example>arch 4 y 0 x1 x2 x3</example>
      </examples>
    </usage>

    <description>
      <para>
	Stima il modello specificato tenendo conto della possibile
        eteroschedasticità condizionale autoregressiva (ARCH,
	Autoregressive Conditional Heteroskedasticity). Per prima cosa il
        modello viene stimato con OLS, quindi viene eseguita una regressione
        ausiliaria, in cui i quadrati dei residui della prima regressione
        vengono regrediti sui loro valori ritardati. Il passo finale è una stima
        con minimi quadrati ponderati, in cui i pesi sono i reciproci delle
        varianze dell'errore della regressione ausiliaria (se la varianza
        prevista di qualche osservazione nella regressione ausiliaria non
        risulta positiva, viene usato il corrispondente residuo al quadrato).
       </para>

      <para>
	I valori <lit>alpha</lit> mostrati sotto i coefficienti sono i parametri
        del processo ARCH stimati nella regressione ausiliaria.
      </para>
      <para>
	Si veda anche <cmdref targ="garch"/> e <cmdref targ="lmtest"/>
        (l'opzione <lit>--arch</lit>).
      </para>
    </description>

    <gui-access>
      <menu-path>/Modello/Serie storiche/ARCH</menu-path>
    </gui-access>

  </command>

  <command name="arima" section="Estimation" label="Stima ARMA/ARIMA">

    <usage>
      <arguments>
        <argblock>
          <argument>p</argument>
          <argument>d</argument>
          <argument>q</argument>
        </argblock>
 	<argblock separated="true" optional="true">
 	  <argument>P</argument>
	  <argument>D</argument>
 	  <argument>Q</argument>
 	</argblock>
	<argument separated="true">variabile-dipendente</argument>
	<argument optional="true">variabili-indipendenti</argument>
      </arguments>
      <options>
	<option>
	  <flag>--verbose</flag>
	  <effect>mostra i dettagli delle iterazioni</effect>
        </option>
        <option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
        </option>
        <option>
         <flag>--opg</flag>
	 <effect>si veda sotto</effect>
        </option>
        <option>
         <flag>--nc</flag>
         <effect>non include l'intercetta</effect>
        </option>
        <option>
	  <flag>--conditional</flag>
	  <effect>usa la massima verosimiglianza condizionale</effect>
        </option>
        <option>
	  <flag>--x-12-arima</flag>
	  <effect>usa X-12-ARIMA per la stima</effect>
        </option>
      </options>
      <examples>
        <example>arima 1 0 2 ; y</example>
	<example>arima 2 0 2 ; y 0 x1 x2 --verbose</example>
	<example>arima 0 1 1 ; 0 1 1 ; y --nc</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
	Se non viene fornita una lista di <repl>variabili-indipendenti</repl>,
        stima un modello autoregressivo integrato a media mobile (ARIMA: Autoregressive,
        Integrated, Moving Average) univariato.  I valori <repl>p</repl>,
        <repl>d</repl> e <repl>q</repl> rappresentano rispettivamente gli ordini
        dei termini autoregressivi (AR), l'ordine di differenziazione, e quello dei termini
        a media mobile (MA).  Questi valori possono essere indicati in forma
        numerica o con i nomi di variabili scalari preesistenti. Ad esempio, un
        valore <repl>d</repl> pari a 1 significa che prima di stimare i
        parametri ARMA occorre prendere la differenza della variabile
        dipendente.
      </para>

      <para context="cli">
        Se si vuole includere solo alcuni specifici ritardi AR o MA (invece che
        tutti i ritardi fino all'ordine specificato) è possibile sostituire
        <repl>p</repl> e/o <repl>q</repl> in due modi: col nome di una matrice
        predefinita che contiene un insieme di valori interi, oppure con
        un'espressione come <lit>{1 4}</lit>, osia un insieme di ritardi
        separati da spazi e racchiusi tra parentesi graffe.
      </para>
        
      <para context="cli">
        I valori interi opzionali <repl>P</repl>, <repl>D</repl> e
        <repl>Q</repl> rappresentano rispettivamente, l'ordine dei termini AR
        stagionali, l'ordine di differenziazione stagionale e l'ordine dei
        termini MA stagionali. Essi sono rilevanti solo la frequenza dei dati è
        superiore a 1 (ad esempio, dati trimestrali o mensili). Questi
        valori devono essere indicati in forma numerica o come variabili
        scalari.
      </para>
      
      <para context="cli">
        Nel caso univariato la scelta predefinita include un'intercetta nel
        modello, ma questa può essere soppressa con l'opzione
        <lit>--nc</lit>.  Se vengono aggiunte delle
        <repl>variabili-indipendenti</repl>, il modello diventa un ARMAX: in
        questo caso occorre indicare esplicitamente la costante se si
        desidera un'intercetta (come nel secondo degli esempi proposti).
      </para>
      
      <para context="cli">
        È disponibile una sintassi alternativa per questo comando: se non si
        intende applicare alcuna operazione di differenziazione (stagionale o
        non stagionale), è possibile omettere totalmente i termini
        <repl>d</repl> e <repl>D</repl>, invece che impostarli esplicitamente
        pari a 0. Inoltre, <lit>arma</lit> è un sinonimo di <lit>arima</lit>,
        quindi ad esempio il comando seguente è un modo valido per specificare
        un modello ARMA(2,1):
      </para>
      <code context="cli">
	arma 2 1 ; y
      </code>
      
      <para context="gui">
	Stima un modello ARMA, con o senza regressori esogeni. Se l'ordine di
        differenziazione è maggiore di zero, il modello diventa un ARIMA. Se i
        dati hanno una frequenza superiore a 1, viene offerta la possibilità di
        includere termini stagionali.
      </para>

      <para context="gui">
        Se si vuole includere solo alcuni specifici ritardi AR o MA (invece che
        tutti i ritardi fino all'ordine specificato) è possibile marcare la
        casella a destra del selettore e scrivere nel campo disponibile
        un elenco di ritardi, separati da spazi. In alternativa, se è stata
        definita una matrice che contiene l'insieme dei ritardi desiderati, è
        possibile scrivere il suo nome nel campo.
      </para>

      <para>
        Il funzionamento predefinito utilizza la funzionalità ARMA 
        <quote>interna</quote> di gretl, che usa la stima di massima
        verosimiglianza esatta usando il filtro di Kalman; come opzione è
        possibile usare la stima di massima verosimiglianza condizionale.
        Se è stato installato il programma <program>X-12-ARIMA</program> è
        possibile usare questo al posto del codice interno di gretl.
        Per i dettagli su queste opzioni si veda la <guideref targ="arma-estimation"/>.
      </para>

      <para>
        L'algoritmo interno di gretl per ARMA utilizza una procedura di
	massima verosimiglianza condizionale, implementata attraverso la stima 
	iterata	con minimi quadrati della regressione del prodotto esterno del
	gradiente (OPG). Si veda la <guideref targ="jack-arma"/> per la logica della
	procedura. I coefficienti AR (e quelli per gli eventuali regressori 
	aggiuntivi) sono inizializzati usando una auto-regressione OLS, mentre
	i coefficienti MA sono inizializzati a zero.
      </para>

      <para context="cli">
        Quando si usa il codice ARMA interno, le deviazioni standard sono stimate
        basandosi su un'approssimazione numerica all'inversa negativa dell'Hessiana.
        Se si usa l'opzione <lit>--opg</lit> viene invece usato il prodotto
        esterno del gradiente. L'opzione è ignorata se si sceglie la stima con
        <program>X-12-ARIMA</program>.
      </para>

      <para>
        Il valore AIC mostrato nei modelli ARIMA è calcolato secondo la
	definizione usata in <program>X-12-ARIMA</program>, ossia
	  <equation status="display" 
	  tex="\[\mbox{AIC}=-2\ell+2k\]"
	  ascii="AIC = -2L + 2k"
	  graphic="aic"/> dove 
	<equation status="inline" 
	  tex="$\ell$" ascii="L"
	  graphic="ell"/>
        è la log-verosimiglianza e <math>k</math> è il numero totale di
        parametri stimati. Si noti che <program>X-12-ARIMA</program> non produce
        criteri di informazione come l'AIC quando la stima è effettuata col
        metodo della massima verosimiglianza condizionale.
      </para> 

      <para> 
	Il valore di <quote>frequenza</quote> mostrato insieme alle radici
	AR e MA è il valore di &lgr; che risolve
	  <equation status="display" 
	  tex="\[z=re^{i2\pi\lambda}\]"
	  ascii="z = r * exp(i*2*pi*lambda)"
	  graphic="lambda"/> dove <math>z</math> è la radice in questione
	  e <math>r</math> è il suo modulo.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modello/Serie Storiche/ARIMA</menu-path>
      <other-access>Menù pop-up nella finestra principale (selezione singola)</other-access>
    </gui-access>

  </command>
 
  <command name="bootstrap" section="Tests" label="Opzioni bootstrap"
    context="gui">

    <description>

      <para>In questa finestra di dialogo è possibile scegliere:</para>

      <ilist>
	<li>
	  <para>
	    La variabile o il coefficiente da esaminare (è possibile testare
            solo un coefficiente alla volta usando questo metodo).
	  </para>
	</li>
	<li>
	  <para>
            Il tipo di analisi da eseguire. L'intervallo di confidenza
            predefinito (95 per cento) è basato direttamente sui quantili delle
            stime bootstrap del coefficiente. La versione
	    <quote>studentizzata</quote> corrisponde a quella presentata nel
            capitolo 5 di <book>Economic Theory and Methods</book> (ETM) di
            Davidson e MacKinnon: ad ogni replicazione bootstrap, viene
            calcolato un rapporto
	    <math>t</math> come (a) la differenza tra la stima attuale
            del coefficiente e quella di riferimento, divisa per (b) l'errore
            standard di riferimento. Quindi l'intervallo di confidenza viene
            calcolato usando i quantili di questo rapporto t, come spiegato in
            ETM. L'opzione p-value si basa sulla distribuzione del rapporto
	    <math>t</math> bootstrap: è la proporzione delle replicazioni
            in cui il valore assoluto di questa statistica eccede il valore
            assoluto del rapporto <math>t</math> di riferimento.
	  </para>
	</li>
	<li>
	  <para>Residui ricampionati o simulazione degli errori normali. Nel
            primo caso i residui originali (riscalati, come suggerito in ETM)
            vengono ricampionati con rimpiazzo. Nel secondo caso, vengono generati
	    valori normali pseudo-casuali con la varianza dei residui originali.
	  </para>
	</li>
	<li>
	  <para>Il numero di replicazioni da eseguire. Si noti che quando si
            costruisce un intervallo di confidenza al 95 per cento è opportuno
            che 0.05(<math>B</math> + 1)/2 sia un intero
	    (dove <math>B</math> è il numero di replicazioni), quindi
            gretl può aggiustare il numero scelto di replicazioni per assicurare
            questa condizione.
	  </para>
	</li>
	<li>
	  <para>Se produrre o no un grafico della distribuzione bootstrap.
            Questa opzione usa la procedura di stima kernel di gretl.
	  </para>
	</li>
      </ilist>

    </description>
  </command>


  <command name="boxplot" section="Graphs" label="Grafici boxplot">

    <usage>
      <arguments>
        <argument>lista-variabili</argument>
      </arguments>
      <options>
	<option>
	  <flag>--notches</flag>
	  <effect>mostra l'intervallo di confidenza al 90 per cento per la mediana</effect>
	</option>
      </options>
    </usage>

    <description>

      <para>Questo tipo di grafici (da Tukey e Chambers) mostra la distribuzione
        di una variabile. La <quote>scatola</quote> centrale (box) racchiude il
        50 per cento centrale dei dati, ossia è delimitato dal primo e terzo
        quartile. I <quote>baffi</quote> (whiskers) si estendono fino ai valori
        minimo e massimo. Una linea trasversale sulla scatola indica la mediana,
        mentre un segno <quote>+</quote> indica la media.
      </para> 

      <para>Nel caso dei grafici a tacca ("notches"), una tacca indica i limiti
        dell'intervallo di confidenza approssimato al 90 per cento per la
        mediana, ottenuto col metodo bootstrap.</para>

      <para context="gui">Dopo ogni variabile specificata nel comando
	boxplot, è possibile aggiungere un'espressione booleana tra
        parentesi per limitare il campione per la variabile in questione.
	Occorre inserire uno spazio tra il nome o il numero della variabile
        e l'espressione. Si supponga di avere dati sui salari di uomini e
        donne e di avere una variabile dummy <lit>GENERE</lit> che vale 1
	per gli uomini e 0 per le donne. In questo caso, è possibile generare
        dei boxplot comparativi usando la seguente riga nella finestra di
        dialogo dei boxplot:</para>

      <para context="cli">Dopo ogni variabile specificata nel comando
	boxplot, è possibile aggiungere un'espressione booleana tra
        parentesi per limitare il campione per la variabile in questione.
	Occorre inserire uno spazio tra il nome o il numero della variabile
        e l'espressione. Si supponga di avere dati sui salari di uomini e
        donne e di avere una variabile dummy <lit>GENERE</lit> che vale 1
	per gli uomini e 0 per le donne. In questo caso, è possibile generare
        dei boxplot comparativi usando la seguente <repl
	  quote="true">lista-variabili</repl>:</para>

      <code>
	salario (GENERE=1) salario (GENERE=0)
      </code>

      <para>Alcuni dettagli del funzionamento dei boxplot di gretl possono
        essere controllati attraverso un file testuale chiamato
        <filename>.boxplotrc</filename>.  Per ulteriori dettagli, si veda
	la <guideref targ="sect-boxplots"/>.</para>

    </description>

    <gui-access>
      <menu-path>/Visualizza/Grafico/Boxplot</menu-path>
    </gui-access>

  </command>

  <command name="break" section="Programming" label="Esce da un ciclo" context="cli">

    <description>

      <para>Esce da un ciclo. Questo comando può essere usato solo all'interno
        di un ciclo e causa l'immediata interruzione dell'esecuzione del ciclo
        (o di quello più interno, nel caso di cicli nidificati). Si veda anche
        il comando <cmdref targ="loop"/>.
      </para> 

    </description>

  </command>

  <command name="chow" section="Tests" label="Test di Chow">

    <usage>
      <arguments>
        <argument>osservazione</argument>
      </arguments>
      <options>
	<option>
	  <flag>--quiet</flag>
	  <effect>non mostra le stime del modello aumentato</effect>
	</option>
      </options>
      <examples>
        <example>chow 25</example>
        <example>chow 1988:1</example>
      </examples>
    </usage>

    <description>
      <para context="gui">Questo comando richiede un numero di osservazione
       (o una data, se il dataset lo consente).</para>

      <para>
	Va eseguito dopo una regressione OLS e fornisce un test per 
        l'ipotesi nulla che non esista un break strutturale del modello
        in corrispondenza del punto di rottura specificato. La procedura
        consiste nel creare una variabile dummy che vale 1 a partire dal punto
        di rottura specificato da <repl>osservazione</repl> fino alla fine del
        campione, 0 altrove; inoltre vengono creati dei termini di interazione
        tra questa dummy e i regressori originali.  Viene quindi stimata una
        regressione che include questi termini.
      </para>
      <para>
        Per impostazione predefinita viene calcolata una statistica <math>F</math>,
        prendendo la regressione aumentata come non vincolata e la regressione
        originale come vincolata. Se il modello originale usa uno stimatore
        robusto per la matrice di covarianza, come statistica test viene usato
        un valore chi-quadro di Wald, basato su uno stimatore robusto della
        matrice di covarianza della regressione aumentata.
      </para>
    </description>

    <gui-access>
      <menu-path>Finestra del modello, /Test/CHOW</menu-path>
    </gui-access>

  </command>

  <command name="coeffsum" section="Tests" label="Somma dei coefficienti">

    <usage>
      <arguments>
        <argument>lista-variabili</argument>
      </arguments>
      <examples>
        <example>coeffsum xt xt_1 xr_2</example>
	<demos>
	  <demo>restrict.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para context="gui">Questo comando richiede una lista di variabili,
        selezionate tra le variabili indipendenti di un modello.
      </para>
      <para context="gui">
	Calcola la somma dei coefficienti delle variabili nella lista
        e mostra l'errore standard e il p-value per l'ipotesi nulla che la
        somma sia zero.
      </para>
      <para context="cli">
	Deve essere usato dopo una regressione. Calcola la somma dei 
        coefficienti delle variabili nella <repl>lista-variabili</repl>
        e ne mostra l'errore standard e il p-value per l'ipotesi nulla
        che la loro somma sia zero.
      </para>
      <para>Si noti la differenza tra questo test e <cmdref
	  targ="omit"/>, che assume come ipotesi nulla l'uguaglianza a zero
          di <emphasis>tutti</emphasis> i coefficienti di un gruppo di variabili
          indipendenti.</para>
    </description>

    <gui-access>
      <menu-path>Finestra del modello, /Test/Somma dei coefficienti</menu-path>
    </gui-access>

  </command>

  <command name="coint" section="Tests" 
    label="Test di cointegrazione di Engle-Granger">

    <usage>
      <arguments>
        <argument>ordine</argument>
        <argument>variabile-dipendente</argument>
	<argument>variabili-indipendenti</argument>
      </arguments>
      <options>
	<option>
	  <flag>--nc</flag>
	  <effect>non include la costante</effect>
	</option>
 	<option>
	  <flag>--ct</flag>
	  <effect>include la costante e il trend</effect>
	</option>
	<option>
	  <flag>--ctt</flag>
	  <effect>include la costante e il trend quadratico</effect>
	</option>
	<option>
	  <flag>--skip-df</flag>
	  <effect>non esegue i test DF sulle variabili individuali</effect>
	</option>
      </options>
      <examples>
        <example>coint 4 y x1 x2</example>
        <example>coint 0 y x1 x2 --ct --skip-df</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
        Il test di cointegrazione di Engle&ndash;Granger. La procedura
        predefinita è la seguente: (1) eseguire dei test Dickey&ndash;Fuller
        aumentati, sull'ipotesi nulla che ognuna delle variabili elencate abbia
        una radice unitaria; (2) stimare la regressione di cointegrazione;
        (3) eseguire un test DF sui residui della regressione di
        cointegrazione. Se si usa l'opzione <lit>--skip-df</lit>, il passo
        (1) viene saltato.
      </para>
      <para context="cli">
        Se l'ordine di ritardo specificato è positivo, tutti i test
        Dickey&ndash;Fuller utilizzano questo ordine. Se l'ordine indicato viene
        preceduto da un segno meno, viene interpretato come l'ordine massimo, e
        l'ordine utilizzato effettivamente viene ricavato con la stessa
        procedura di test "all'indietro" descritta per il comando
        <cmdref targ="adf"/>.
      </para>
       <para context="cli">
	L'impostazione predefinita consiste nell'includere una costante nella
        regressione di cointegrazione; se si vuole omettere la costante, basta
        usare l'opzione <lit>--nc</lit>. Se si vuole aggiungere all'elenco dei
        termini deterministici della regressione un trend lineare o quadratico,
        basta usare le opzioni <lit>--ct</lit> o <lit>--ctt</lit>. Queste opzioni
        sono mutualmente esclusive.
      </para>
      <para context="cli">
        Il test di cointegrazione di Engle&ndash;Granger. La procedura
        predefinita è la seguente: (1) eseguire dei test Dickey&ndash;Fuller
        aumentati, sull'ipotesi nulla che ognuna delle variabili elencate abbia
        una radice unitaria; (2) stimare la regressione di cointegrazione;
        (3) eseguire un test DF sui residui della regressione di
        cointegrazione. Se si attiva la casella <lit>Salta i test DF iniziali</lit>,
        il passo (1) viene saltato.
      </para>
      <para context="gui">
	Se l'ordine di ritardo, <math>k</math>, è maggior di 0, verranno
        inclusi <math>k</math> ritardi della variabile dipendente al
        secondo membro di ognuna delle regressioni di test, a meno che non si
        usi la casella <quote>test dal massimo ordine di ritardi all'indietro</quote>:
        in questo caso, l'ordine specificato viene considerato come massimo e
        l'ordine usato effettivamente viene determinato con la procedura di
        test "all'indietro" descritta per il comando <cmdref targ="adf"/>.
      </para>
      <para context="gui">
	L'impostazione predefinita consiste nell'includere una costante nella
        regressione di cointegrazione. Se si vuole omettere la costante, o
        aggiungere un trend lineare o quadratico, basta selezionare le relative
        opzioni nella finestra di dialogo.
      </para>
      <para>
        I <emphasis>pvalue</emphasis> per questo test si basano su
	MacKinnon (1996). Il codice relativo è stato incluso per gentile
        concessione dell'autore.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modello/Serie storiche/Test di cointegrazione/Engle-Granger</menu-path>
    </gui-access>

  </command>

  <command name="coint2" section="Tests" label="Test di cointegrazione di Johansen">

    <usage>
      <arguments>
        <argument>ordine</argument>
        <argument>lista-y</argument>
	<argblock optional="true" separated="true">
	  <argument>lista-x</argument>
	</argblock>
	<argblock optional="true" separated="true">
	  <argument>lista-rx</argument>
	</argblock>
      </arguments>
      <options>
        <option>
	  <flag>--nc</flag>
	  <effect>senza costante</effect>
        </option>
        <option>
	  <flag>--rc</flag>
	  <effect>costante vincolata</effect>
        </option>
        <option>
	  <flag>--crt</flag>
	  <effect>costante e trend vincolato</effect>
        </option>
        <option>
	  <flag>--ct</flag>
	  <effect>costante e trend non vincolato</effect>
        </option>
        <option>
	  <flag>--seasonals</flag>
	  <effect>include dummy stagionali centrate</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>mostra solo i test</effect>
        </option>
        <option>
	  <flag>--verbose</flag>
	  <effect>mostra i dettagli delle regressioni ausiliarie</effect>
        </option>
      </options>
      <examples>
        <example>coint2 2 y x</example>
	<example>coint2 4 y x1 x2 --verbose</example>
	<example>coint2 3 y x1 x2 --rc</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
        Esegue il test di Johansen per la cointegrazione tra le variabili della
        <repl>lista-y</repl> per l'ordine specificato di ritardi.I valori critici
        sono calcolati con l'approssimazione gamma di J. Doornik (Doornik,
        1998). Per i dettagli su questo test, si veda Hamilton, <book>Time
        Series Analysis</book> (1994), Cap. 20.
      </para>
      <para context="gui">
        Esegue il test di Johansen per la cointegrazione tra le variabili
        elencate per l'ordine specificato di ritardi.I valori critici
        sono calcolati con l'approssimazione gamma di J. Doornik (Doornik,
        1998). Per i dettagli su questo test, si veda Hamilton, <book>Time
        Series Analysis</book> (1994), Cap. 20.
      </para>
      <para context="cli">
	L'inclusione di trend deterministici nel modello è controllata dalle
        opzioni del comando. Se non si indica alcuna opzione, viene inclusa una
	<quote>costante non vincolata</quote>, che permette la presenza di
        un'intercetta diversa da zero nelle relazioni di cointegrazione e di un
        trend nei livelli delle variabili endogene. Nella letteratura originata
        dal lavoro di Johansen (si veda ad esempio il suo libro del 1995),
        si fa riferimento a questo come al <quote>caso 3</quote>.  Le prime
        quattro opzioni mostrate sopra, che sono mutualmente esclusive,
        producono rispettivamente i casi 1, 2, 4 e 5. Il significato di questi
        casi e i criteri per scegliere tra di essi sono spiegati nella
	<guideref targ="chap:vecm"/>.
      </para>
      <para context="gui">
	L'inclusione di termini deterministici nel modello è controllata dai
        pulsanti delle opzioni. L'opzione predefinita è di includere una
	<quote>costante non vincolata</quote>, che permette la presenza di
        un'intercetta diversa da zero nelle relazioni di cointegrazione e di un
        trend nei livelli delle variabili endogene. Nella letteratura originata
        dal lavoro di Johansen (si veda ad esempio il suo libro del 1995),
        si fa riferimento a questo come al <quote>caso 3</quote>.  Le prime
        quattro opzioni mostrate sopra, che sono mutualmente esclusive,
        producono rispettivamente i casi 1, 2, 4 e 5. Il significato di questi
        casi e i criteri per scegliere tra di essi sono spiegati nella
	<guideref targ="chap:vecm"/>.
      </para>
      <para context="cli">
	Le liste opzionali <repl>lista-x</repl> e <repl>lista-rx</repl> permettono
        di controllare per specifiche variabili esogene che entrano nel sistema
        in modo non vincolato (<repl>lista-x</repl>) o vincolate allo spazio di
        cointegrazione (<repl>lista-rx</repl>). Queste liste vanno separate tra
        di loro e dalla <repl>lista-y</repl> usando il carattere punto e
        virgola.
      </para>
      <para context="gui">
	È possibile controllare per le variabili esogene aggiungendole nel campo
        inferiore. Per impostazione predefinita, le variabili vengono aggiunte al
        modello in forma non vincolata (indicata da una lettera <lit>N</lit> vicino
        al nome della variabile). Se si vuole che una certa variabile esogena
        sia vincolata allo spazio di cointegrazione, basta fare clic col tasto
        destro e selezionare <quote>Vincolata</quote> dal menu pop-up. Il simbolo
        vicino alla variabile diventerà una V.
      </para>
      <para context="cli">
        L'opzione <lit>--seasonals</lit>, che può accompagnare una qualsiasi
        delle altre opzioni, specifica l'inclusione di un gruppo di variabili
        dummy stagionali centrate. Questa opzione è disponibile solo per dati
        trimestrali o mensili.
      </para>
      <para context="gui">
	Se i dati sono trimestrali o mensili, è presente anche una casella che
        permette di includere un gruppo di variabili dummy stagionali centrate.
	In tutti i casi, la casella <quote>Mostra dettagli</quote> permette di
        vedere il risultato delle regressioni ausiliarie che sono il punto di
        partenza per la procedura di stima di massima verosimiglianza di
        Johansen.
      </para>
      <para context="notex">
	La tabella seguente fornisce un esempio di interpretazione dei
	risultati del test nel caso di 3 variabili. <lit>H0</lit> denota
        l'ipotesi nulla, <lit>H1</lit> l'ipotesi alternativa e <lit>c</lit>
        il numero delle relazioni di cointegrazione.
      </para>
      <code context="notex">
                 Rango    Test traccia       Test Lmax
                          H0     H1          H0     H1
                 ---------------------------------------
                  0      c = 0  c = 3       c = 0  c = 1
                  1      c = 1  c = 3       c = 1  c = 2
                  2      c = 2  c = 3       c = 2  c = 3
                 ---------------------------------------
      </code>

      <para context="tex">
	La tabella seguente fornisce un esempio di interpretazione dei
	risultati del test nel caso di 3 variabili. $H_0$ denota
        l'ipotesi nulla, $H_1$ l'ipotesi alternativa e $c$
        il numero delle relazioni di cointegrazione.

	\begin{center}
	\begin{tabular}{cllll}
	&amp; \multicolumn{2}{c}{Test traccia} &amp;
	   \multicolumn{2}{c}{Test $\lambda$-max} \\
	Rango &amp;  \multicolumn{1}{c}{$H_0$} &amp; 
	       \multicolumn{1}{c}{$H_1$} &amp; 
	       \multicolumn{1}{c}{$H_0$} &amp; 
	       \multicolumn{1}{c}{$H_1$} \\ [4pt]
 	0 &amp; $c$ = 0 &amp; $c$ = 3 &amp; $c$ = 0 &amp; $c$ = 1 \\
	1 &amp; $c$ = 1 &amp; $c$ = 3 &amp; $c$ = 1 &amp; $c$ = 2 \\
	2 &amp; $c$ = 2 &amp; $c$ = 3 &amp; $c$ = 2 &amp; $c$ = 3 
	\end{tabular}
	\end{center}
      </para>      
 
      <para>
	Si veda anche il comando <cmdref targ="vecm"/>.
      </para>

    </description>

    <gui-access>
      <menu-path>/Modello/Serie storiche/Test do cointegrazione/Johansen</menu-path>
    </gui-access>

  </command>

  <command name="compact" section="Dataset" context="gui"
    label="Compattamento dei dati">

    <description>

      <para>Quando viene aggiunta a un dataset una serie di frequenza
        maggiore, occorre <quote>compattare</quote> la nuova serie.
	Ad esempio, una serie mensile deve essere compattata per
        adattarsi a un dataset trimestrale.</para>  

      <para>Inoltre, a volte può essere necessario compattare un intero
	dataset abbassandone la frequenza (ad esempio, prima di aggiungere
	al dataset una variabile a frequenza minore).</para>

      <para>Ci sono quattro opzioni per il compattamento:</para>

      <ilist>
	<li><para>Media: i nuovi valori saranno la media aritmetica
	    dei corrispondenti valori della serie a frequenza maggiore.
            Ad esempio, il valore per il primo trimestre del 1990 sarà la
            media dei valori di gennaio, febbraio e marzo del 1990.</para>
	</li>

	<li><para>Somma: i nuovi valori saranno la somma dei 
            corrispondenti valori della serie a frequenza maggiore.
            Ad esempio, il valore per il primo trimestre sarà la somma dei
            valori di gennaio, febbraio e marzo.</para>
	</li>

	<li><para>Valori di fine periodo: il nuovo valore è l'ultimo
            valore corrispondente nella serie a frequenza maggiore.
	    Ad esempio, il valore del primo trimestre del 1990 sarà quello
            del marzo 1990.</para>
	</li>

	<li><para>Valori di inizio periodo: il nuovo valore è il primo
            valore corrispondente nella serie a frequenza maggiore.
            Ad esempio, il valore del primo trimestre del 1990 sarà quello
            del gennaio 1990.</para>
	</li>
      </ilist>

      <para>Se si compatta un intero dataset, il metodo di compattamento
        scelto diventa quello predefinito, ma se si è scelto un metodo di
        compattamento per una certa variabile (nel menù <quote>Variabile/Modifica
        attributi</quote>) viene usato quel metodo al posto di quello predefinito.
        Se il metodo di compattamento è già stato scelto per tutte le variabili, non
        viene presentata la scelta per il metodo di compattamento predefinito.
	</para>

    </description>
  </command>

  <command name="controlled" section="Graphs" context="gui"
    label="Grafici a dispersione con controllo">

    <description>
      <para>
        Questo comando richiede la scelta di tre variabili, una per l'asse X,
        una per l'asse Y e una variabile di controllo (chiamata Z). Il grafico
        mostra le variabili X e Y controllate per la variabile Z, ossia i
        residui della regressione OLS di ogni variabile su Z.
      </para>
      <para>
	Esempio: si hanno dati sui salari, l'esperienza e il livello
        educativo in un campione di persone e si vuole un grafico dei salari
        rispetto all'educazione, controllando per l'esperienza. In questo caso,
        basta selezionare i salari per l'asse Y, l'educazione per l'asse X e
        l'esperienza come variabile di controllo: il grafico mostrerà la
        relazione tra le due variabili <quote>depurate</quote> dall'effetto
        dell'esperienza.
      </para>
    </description>

  </command>

  <command name="copy-formats" section="Utilities" context="gui"
    label="Formati di copia">

    <description>
      <para>
	Per copiare i dati da questa finestra, è possibile scegliere il formato
        testo semplice o altri due formati.
      </para>

      <para>
	Separato da tab: i dati vengono copiati sotto forma di testo semplice, con
        le colonne separate dal carattere tab. È una buona scelta se si vuole
        incollare i dati in un programma di videoscrittura: in MS Word o Writer
        di OpenOffice.org, ad esempio, è possibile selezionare il materiale
        incollato e convertirlo in una tabella, usando comandi come
	<quote>Formattazione automatica tabella</quote> o <quote>Converti il testo
        in tabella</quote>.
      </para>

      <para>
	Separato da virgola: i dati sono copiati negli appunti in formato CSV
        (Comma Separated Values). Questo metodo è consigliabile se occorre
        incollare i dati in un foglio elettronico.
      </para>

    </description>

  </command>

  <command name="corr" section="Statistics" label="Coefficienti di correlazione">

    <usage>
      <arguments>
        <argument optional="true">lista-variabili</argument>
      </arguments>
      <options>
 	<option>
	 <flag>--uniform</flag>
         <effect>assicura l'uniformità del campione</effect>
	</option>
	<option>
	  <flag>--spearman</flag>
	  <effect>Rho di Spearman</effect>
	</option>
	<option>
	  <flag>--kendall</flag>
	  <effect>Tau di Kendall</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>mostra i ranghi</effect>
	</option>
      </options>
      <examples>
        <example>corr y x1 x2 x3</example>
	<example>corr ylist --uniform</example>
	<example>corr x y --spearman</example>
      </examples>
    </usage>

    <description context="gui">
      <para>
        Mostra le coppie di coefficienti di correlazione (la correlazione del
        prodotto dei momenti di Pearson) per le variabili selezionate. Il
        comportamento predefinito consiste nell'usare tutte le osservazioni
        disponibili per calcolare ognuno dei coefficienti, ma attivando
        l'opportuna casella il campione verrà limitato (se necessario) in modo
        che per tutti i coefficienti venga usato lo stesso insieme di
        osservazioni. Questa opzione ha effetto solo se le diverse variabili
        contengono un numero diverso di valori mancanti.
      </para>
    </description>

    <description context="cli">
      <para>
        Per impostazione predefinita, mostra le coppie di coefficienti di
        correlazione (la correlazione del prodotto dei momenti di Pearson)
        per le variabili date nella <repl>lista-variabili</repl>, o
        per tutte le variabili del dataset se non viene specificata alcuna
        <repl>lista-variabili</repl>. Il comportamento predefinito consiste
        nell'usare tutte le osservazioni disponibili per calcolare ognuno dei
        coefficienti, ma se si usa l'opzione <flag>--uniform</flag> il campione
        verrà limitato (se necessario) in modo che per tutti i coefficienti
        venga usato lo stesso insieme di osservazioni. Questa opzione ha effetto
        solo se le diverse variabili contengono un numero diverso di valori
        mancanti.
      </para>
      <para>
	Le opzioni (mutualmente esclusive) <lit>--spearman</lit> e
	<lit>--kendall</lit> producono rispettivamente, la correlazione di rango
        di Spearman (rho) e la correlazione di rango di Kendall (tau), invece
        del solito coefficiente di Pearson. Quando si usa una di queste opzioni,
        la <repl>lista-variabili</repl> deve contenere solo due variabili.
       </para>
      <para>
        Quando viene calcolata la correlazione di rango, si può usare l'opzione
        <lit>--verbose</lit> per mostrare i dati originali e ordinati
        (altrimenti questa opzione verrà ignorata).
      </para>
    </description>

    <gui-access>
      <menu-path>/Visualizza/Matrice di correlazione</menu-path>
      <other-access>Menù pop-up nella finestra principale (selezione multipla)</other-access>
    </gui-access>

  </command>

  <command name="corrgm" section="Statistics" label="Correlogramma">

    <usage>
      <arguments>
        <argument>variabile</argument>
        <argument optional="true">max-ritardo</argument>
      </arguments>
      <examples>
        <example>corrgm x 12</example>
      </examples>
    </usage>

    <description>
      <para>
	Mostra i valori della funzione di autocorrelazione per la
	<repl>variabile</repl> specificata (dal nome o dal numero).
        I valori sono definiti come
	<equation status="inline" 
	  tex="$\hat{\rho}(u_t, u_{t-s})$"
	  ascii="rho(u(t), u(t-s))"
	  graphic="autocorr"/> dove <math>u</math><sub>t</sub>
	è la <math>t</math>-esima osservazione della variabile
	<math>u</math> e <math>s</math> è il numero dei
	ritardi.
      </para>

      <para>
	Vengono mostrate anche le autocorrelazioni parziali (calcolate con
        l'algoritmo di Durbin&ndash;Levinson), ossia al
	netto dell'effetto dei ritardi intermedi. Il comando produce anche
        un grafico del correlogramma e mostra la statistica
        <math>Q</math> di Box&ndash;Pierce per testare l'ipotesi nulla
        che la serie sia <quote>white noise</quote> (priva di
        autocorrelazione). La statistica si distribuisce asintoticamente come
        chi-quadro con gradi di libertà pari al numero di ritardi specificati.
      </para>

      <para>
	Se viene specificato un valore <repl>max-ritardo</repl>, la lunghezza
        del correlogramma viene limitata al numero di ritardi specificato, altrimenti
        viene scelta automaticamente in funzione della frequenza dei dati e del
        numero di osservazioni.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variabile/Correlogramma</menu-path>
      <other-access>Menù pop-up nella finestra principale (selezione singola)</other-access>
    </gui-access>

  </command>

  <command name="criteria" section="Utilities" label="Criteri di selezione dei modelli" context="cli">

    <usage>
      <arguments>
        <argument>ess</argument>
        <argument>T</argument>
        <argument>k</argument>
      </arguments>
      <examples>
        <example>criteria 23.45 45 8</example>
      </examples>
    </usage>

    <description>
      <para>
	Calcola il criterio di informazione di Akaike (AIC) e il criterio
        di informazione bayesiana di Schwarz (BIC), dati <repl>ess</repl> (somma
        dei quadrati degli errori), il numero delle osservazioni
	(<math>T</math>) e quello dei coefficienti (<math>k</math>).
	<math>T</math>, <math>k</math> e
	<repl>ess</repl> possono essere valori numerici o nomi di
        variabili definite in precedenza.
      </para>
      <para>
	L'AIC è calcolato come nella formulazione originale di Akaike (1974),
        ossia
	<equation status="display"
	  tex="\[{\rm AIC} = -2 \ell + 2k\]"
	  ascii="AIC = -2L + 2k"
          graphic="aic"/>
	dove <equation status="inline" 
	  tex="$\ell$" ascii="L"
	  graphic="ell"/> denota la log-verosimiglianza massimizzata.
	Il BIC è calcolato come
	<equation status="display"
	  tex="\[{\rm BIC} = -2 \ell + k \log T\]"
	  ascii="BIC = -2L + k log T"
          graphic="bic_orig"/>
	Si veda la <guideref targ="select-criteria"/> per ulteriori dettagli.
      </para>
    </description>

  </command>

  <command name="cusum" section="Tests" label="Test CUSUM">

    <usage>
      <options>
	<option>
	  <flag>--squares</flag>
	  <effect>esegue il test CUSUMSQ</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>stampa solamente il test di Harvey&ndash;Collier</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Va eseguito dopo la stima di un modello OLS. Esegue il test
	CUSUM (o, se si usa l'opzione <lit>--squares</lit>, il test
        CUSUMSQ ) per la stabilità dei parametri. Viene calcolata una 
        serie di errori di previsione per il periodo successivo,
        attraverso una serie di regressioni: la prima usa le prime
	<math>k</math> osservazioni e viene usata per generare
        la previsione della variabile dipendente per l'osservazione 
	<math>k</math> + 1; la seconda usa le prime
        <math>k</math> + 1 osservazioni per generare una previsione
        per l'osservazione <math>k</math> + 2 e così via (dove
	<math>k</math> è il numero dei parametri nel modello originale).
      </para>
      <para>
	Viene mostrata, anche graficamente, la somma cumulata degli errori 
        scalati di previsione (o dei quadrati degli errori). L'ipotesi nulla della stabilità dei parametri
        è rifiutata al livello di significatività del 5 per cento se la somma
        cumulata va al di fuori delle bande di confidenza al 95 per cento.
      </para>

      <para>
        Nel caso di test CUSUM, viene mostrata anche la statistica
        <math>t</math> di Harvey&ndash;Collier per testare l'ipotesi nulla
        della stabilità dei parametri. Si veda il Capitolo 7 di
        <book>Econometric Analysis</book> di Greene, per i dettagli. Per il test
	CUSUMSQ, la banda di confidenza al 95% è calcolata usando l'algoritmo
        descritto in Edgerton e Wells (1994).

      </para>
    </description>

    <gui-access>
      <menu-path>Finestra del modello, /Test/CUSUM(SQ)</menu-path>
    </gui-access>

  </command>

  <command name="data" section="Dataset" label="Importazione da database" context="cli">

    <usage>
      <arguments>
        <argument>lista-variabili</argument>
      </arguments>
    </usage>

    <description>
      <para>
        Legge le variabili nella <repl>lista-variabili</repl> da un
	database (gretl, RATS 4.0 o PcGive), che deve essere stato precedentemente
        aperto con il comando <cmdref targ="open"/>. La frequenza dei dati l'intervallo
        del campione possono essere impostati usando i comandi <cmdref targ="setobs"/>
        e <cmdref targ="smpl"/> prima di questo comando. Ecco un esempio completo:</para>

      <code>
	open macrodat.rat
	setobs 4 1959:1
	smpl ; 1999:4
	data GDP_JP GDP_UK
      </code>

      <para>Questi comandi aprono un database chiamato
	<filename>macrodat.rat</filename>, impostano un dataset trimestrale
	che inizia nel primo trimestre del 1959 e finisce nel quarto trimestre
	del 1999 e infine importano le serie <lit>GDP_JP</lit> e <lit>GDP_UK</lit>.
      </para>
      <para>
        Se non si specificano <lit>setobs</lit> e <lit>smpl</lit> nel modo descritto,
        la frequenza dei dati e l'intervallo del campione vengono impostati
        usando la prima variabile letta dal database.
      </para>
      <para>
        Se le serie da leggere hanno frequenza maggiore di quella impostata
        nel dataset, è possibile specificare un metodo di compattamento, come mostrato
        di seguito
      </para>

      <code>
	data (compact=average) LHUR PUNEW
      </code>

      <para>I quattro metodi di compattamento disponibili sono
	<quote>average</quote> (usa la media delle osservazioni ad alta
	frequenza), <quote>last</quote> (usa l'ultima osservazione),
	<quote>first</quote> e <quote>sum</quote>. Se non si specifica alcun
        metodo, verrà usata la media delle osservazioni.
      </para> 

    </description>

    <gui-access>
      <menu-path>/File/Database</menu-path>
    </gui-access>

  </command>

  <command name="dataset" section="Dataset" 
    label="Manipola il dataset" context="cli">

    <usage>
      <arguments>
        <argument>parola-chiave</argument>
	<argument>parametri</argument>
      </arguments>
      <examples>
        <example>dataset addobs 24</example>
        <example>dataset compact 1</example>
        <example>dataset compact 4 last</example>
        <example>dataset expand 12</example>
        <example>dataset transpose</example>
        <example>dataset sortby x1</example>
	<example>dataset resample 500</example>
      </examples>
    </usage>

    <description>
      <para>
	Esegue varie operazioni sull'intero dataset, a seconda della
        <repl>parola-chiave</repl> usata, che può essere
	<lit>addobs</lit>, <lit>compact</lit>, <lit>expand</lit>,
	<lit>transpose</lit>, <lit>sortby</lit>, <lit>dsortby</lit> o
        <lit>resample</lit>.
        Nota: questi comandi non sono disponibili quando
        sul dataset è definito un sotto-campione ottenuto selezionando le
        osservazioni con un criterio Booleano.
      </para>
      <para>
	<lit>addobs</lit>: deve essere seguito da un intero positivo. Aggiunge
        il numero specificato di osservazioni alla fine del dataset, tipicamente
        a scopo di ottenere delle previsioni. I valori della maggior parte delle
        variabili nell'intervallo aggiunto sono impostati come valori mancanti,
        ma alcune variabili deterministiche, ad esempio le tendenze lineari e le
        variabili dummy periodiche, sono riconosciute ed estese.
      </para>
      <para>
	<lit>compact</lit>: deve essere seguito da un intero positivo che
        rappresenta la nuova frequenza dei dati, che dovrebbe essere minore di
        quella attuale (ad esempio un valore 4 quando la frequenza attuale è 12
        significa che si compatterà un dataset mensile in uno trimestrale).
        Questo comando è disponibile solo se il dataset contiene serie storiche:
        compatta tutte le serie del dataset alla nuova frequenza. È possibile
        dare un secondo parametro, tra <lit>sum</lit>,
	<lit>first</lit> o <lit>last</lit>, per specificare, rispettivamente, di
        compattare usando la somma dei valori alla frequenza maggior, i valori
        di inizio periodo, o di fine periodo. Il comportamento predefinito
        consiste nel prendere la media dei valori sul periodo.
      </para>
      <para>
	<lit>expand</lit>: deve essere seguito da un intero positivo che
        rappresenta la nuova frequenza dei dati, che dovrebbe essere maggiore di
        quella attuale. Questo comando è disponibile solo per serie storiche
        annuali o trimestrali. I dati annuali possono essere espansi a
        trimestrali o mensili; quelli trimestrali possono essere espansi a
        mensili. Tutte le serie nel dataset verranno espanse assegnando alle
        nuove osservazioni i valori del periodo corrispondente nel vecchio
        dataset.
      </para>
      <para>
	<lit>transpose</lit>: non richiede parametri aggiuntivi. Traspone il
        dataset attuale: ogni osservazione (riga) del dataset attuale diventerà
        una variabile (colonna), e ogni variabile un'osservazione. Questo
        comando è utile quando si importano da fonti esterne dei dati
        organizzati con le variabili disposte per riga.
      </para>
      <para>
        <lit>sortby</lit>: richiede il nome di una variabile, che viene usata
        come criterio di ordinamento. Le osservazioni di tutte le altre
        variabili del dataset sono riordinate secondo valori crescenti della
        variabile indicata. Questo comando è disponibile solo per dati non
        datati.
      </para>
      <para>
       <lit>dsortby</lit>: funziona come <lit>sortby</lit> ma riordina le
       osservazioni secondo i valori decrescenti della variabile specificata.
      </para>
      <para>
	<lit>resample</lit>: costruisce un nuovo dataset attraverso un
        campionamento causale, con reimmissione, delle righe del dataset
        attuale. È richiesto un argomento, ossia il numero di righe da
        includere, che può essere minore, uguale o maggiore del numero di
        osservazioni nei dati originali. Il dataset originale può essere
        recuperato usando il comando <lit>smpl full</lit>.  
      </para>
    </description>

    <gui-access>
      <menu-path>/Dati</menu-path>
    </gui-access>

  </command>

  <command name="datasort" section="Dataset" context="gui"
    label="Ordina i dati">
  
    <description>
      <para>
        La variabile selezionata viene usata come chiave di ordinamento per
        l'intero dataset. Le osservazioni di tutte le variabili sono riordinate
        secondo valori crescenti della variabile indicata, o secondo valori
        decrescenti, se si usa l'opzione <quote>Decrescente</quote>.
      </para>
    </description>
  </command>

  <command name="delete" section="Dataset" label="Elimina variabili" context="cli">

    <usage>
      <arguments>
        <argument optional="true">lista-variabili</argument>
      </arguments>
      <options>
       <option>
         <flag>--db</flag>
         <effect>rimuove dal database aperto</effect>
       </option>
      </options>
    </usage>

    <description>
      <para>
        Per impostazione predefiinita, rimuove dal dataset le variabili
        elencate (specificate tramite il nome o il numero). <emphasis>Usare con
        cautela</emphasis>: non viene chiesta conferma dell'operazione e le
        variabili con numeri identificativi più alti vengono ri-numerate.
      </para>
      <para>
        Se non viene specificata alcuna <repl>lista-variabili</repl>
        viene eliminata dal dataset l'ultima variabile (quella col numero
        identificativo più alto).
      </para>
      <para>
       Se si usa l'opzione <lit>--db</lit>, il comando rimuove le variabili
       elencate non dal dataset attuale ma da un database gretl, assumendo che
       questo sia stato aperto in precedenza e che l'utente abbia il permesso
       di scrittura sul file che contiene il database. Si veda anche il comando
       <cmdref targ="open"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>Pop-up nella finestra principale (selezione singola)</menu-path>
    </gui-access>

  </command>

  <command name="density" section="Statistics" context="gui"
    label="Stima kernel di densità">

    <description>

      <para>La stima kernel di densità avviene definendo un insieme di punti di
      riferimento distanziati in modo uniforme su un appropriato intervallo dei
      dati, e attribuendo ad ognuno di essi un valore di densità
      basato sui valori delle osservazioni circostanti.</para>
      
      <para>
        La formula usata per calcolare la densità stimata in ognuno dei punti di
        riferimento <math>x</math> è
      <equation status="display"
	tex="\[f(x)=(1/nh) \sum_{t-1}^{n} k\left((x-x_t)/h\right)\]"
	ascii="f(x) = (1/nh) sum(t=1 to n) k((x - x(t)) / h)"
	graphic="kernel1"/>
      dove <math>n</math> denota il numero delle osservazioni,
      <math>h</math> è un parametro di "larghezza di banda" e
      <math>k</math>() è la funzione kernel. All'aumentare del parametro
      di banda, aumenta il livellamento della densità stimata.
      </para>

      <para>È possibile usare un kernel Gaussiano (la densità normale
        standard) o il kernel di Epanechnikov, mentre la larghezza di banda
        predefinita è quella suggerita da Silverman (1986), ossia
	<equation status="display"
	  tex="\[h=0.9 {\rm min}(s, {\rm IQR}/1.349) n^{1/5}\]"
	  ascii="h = 0.9 min(s, IQR/1.349) n^{1/5}"
	  graphic="kernel2"/>

      dove <math>s</math> denota lo scarto quadratico medio dei dati e IQR
      denota il range interquartile. È possibile allargare o restringere la
      banda usando il <quote>fattore di aggiustamento della banda</quote>: la
      banda effettivamente utilizzata si ottiene moltiplicando il valore di
      Silverman per il fattore di aggiustamento.
      </para>

      <para>Per una buona discussione introduttiva della stima kernel, si veda
      il capitolo 15 di <book>Econometric Theory and Methods</book> di Davidson
      e MacKinnon.
      </para>

    </description>

  </command>  

  <command name="dfgls" section="Tests" context="gui"
    label="Il test ADF-GLS">

    <description>
      <para>
       Il test ADF-GLS è una variante del test Dickey&ndash;Fuller per radici
       unitarie, per il caso in cui la variabile da testare ha media diversa da
       zero o esibisce un trend lineare. La differenza consiste nel fatto che la
       rimozione della media o del trend è eseguita secondo la procedura
       suggerita da Elliott, Rothenberg e Stock (1996). Questa produce un test
       di potenza maggiore rispetto a quello dell'approccio standard di
       Dickey&ndash;Fuller.
      </para>
      <para>
       Si veda anche l'opzione <lit>--gls</lit> del comando <cmdref
       targ="adf"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variable/ADF-GLS test</menu-path>
    </gui-access>

  </command>

  <command name="dialog" section="Estimation" context="gui"
    label="Finestra di dialogo Modello">

    <description>
      <para>Per selezionare la variabile dipendente, fare clic su una variabile
        nella lista di sinistra e premere il pulsante <quote>Scegli</quote>
	con la freccia che punta verso il riquadro della variabile dipendente.
	Selezionando la casella <quote>Imposta come predefinito</quote>, la
        variabile scelta verrà sempre pre-selezionata come variabile dipendente
        durante le prossime aperture della finestra di dialogo.
        Trucco: facendo doppio clic su una variabile sulla sinistra, viene
        selezionata come variabile dipendente e impostata come scelta predefinita.
	</para>

      <para>Per selezionare le variabili indipendenti, fare clic su di esse nella
        lista di sinistra e premere il pulsante <quote>Aggiungi</quote> (o fare clic
        col pulsante destro del mouse). È possibile selezionare più variabili
        contigue trascinando il mouse; se le variabili da selezionare non sono
        contigue, occorre fare clic tenendo premuto il tasto <lit>Ctrl</lit>.</para>

    </description>

  </command>

  <command name="diff" section="Transformations" label="Differenze prime" context="cli">

    <usage>
      <arguments>
        <argument>lista-variabili</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Calcola la differenza prima di ogni variabile nella <repl>lista-variabili</repl>
	e la salva in una nuova variabile il cui nome è prefissato con
	<lit>d_</lit>.  Quindi <cmd>diff x y</cmd> crea le nuove variabili
      </para>
      <code>
	d_x = x(t) - x(t-1)
        d_y = y(t) - y(t-1)
      </code>
    </description>

    <gui-access>
      <menu-path>/Aggiungi/Differenze</menu-path>
    </gui-access>

  </command>

  <command name="difftest" section="Tests" 
    label="Test non parametrici per le differenze" context="cli">

    <usage>
      <arguments>
        <argument>var1</argument>
	<argument>var2</argument>
      </arguments>
      <options>
	<option>
	  <flag>--sign</flag>
	  <effect>Test del segno, scelta predefinita</effect>
	</option>
	<option>
	  <flag>--rank-sum</flag>
	  <effect>Test "rank-sum" di Wilcoxon</effect>
	</option>
	<option>
	  <flag>--signed-rank</flag>
	  <effect>Test "signed-rank" di Wilcoxon</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>Mostra informazioni aggiuntive</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
        Esegue un test non parametrico per la differenza tra due popolazioni o
        gruppi; il tipo di test dipende dall'opzione usata.
      </para>
      <para>
	Con l'opzione <lit>--sign</lit>, viene eseguito il test del segno,
        che si basa sul fatto che per due campioni
	<math>x</math> e <math>y</math> estratti casualmente dalla
        stessa distribuzione, la probabilità che valga
	<math>x</math><sub>i</sub> &gt;
	<math>y</math><sub>i</sub> per ogni osservazione
	<math>i</math> dovrebbe valere 0.5. La statistica test è
	<math>w</math>, ossia il numero di osservazioni per cui vale
	<math>x</math><sub>i</sub> &gt;
	<math>y</math><sub>i</sub>. Sotto l'ipotesi nulla, questa
        grandezza si distribuisce come una binomiale con parametri
	(<math>n</math>, 0.5), dove <math>n</math> è il numero di
        osservazioni.
      </para>
      <para>
	Con l'opzione <lit>--rank-sum</lit>, viene eseguito il test "rank-sum"
        di Wilcoxon. Questo test procede ordinando le osservazioni estratte da
        entrambi i campioni dalla più piccola alla più grande, e quindi calcolando
        la somma dei ranghi delle osservazioni da uno dei campioni. I due
        campioni non devono necessariamente avere la stessa dimensione: se sono
        diversi, viene usato il campione più piccolo per calcolare la somma dei
        ranghi. Sotto l'ipotesi nulla che i campioni siano estratti da
        popolazioni con la stessa mediana, la distribuzione di probabilità della
        somma dei ranghi può essere calcolata per ogni valore dell'ampiezza dei
        due campioni, mentre per campioni abbastanza ampi essa approssima la
        distribuzione normale.
      </para>
      <para>
	Con l'opzione <lit>--signed-rank</lit>, viene eseguito il test
        "signed-rank" di Wilcoxon. Questo test è valido per "coppie di
        campioni", come possono essere ad esempio i valori di una variabile in
        un gruppo di individui prima e dopo un certo trattamento. Il test
        procede calcolando le differenze tra le coppie di osservazioni
	<math>x</math><sub>i</sub> &minus;
	<math>y</math><sub>i</sub>, ordinando queste differenze per valore
        assoluto e assegnando ad ogni coppia un valore di rango con segno, in
        cui il segno rispecchia il segno della differenza. Quindi viene
        calcolato <math>W</math><sub>+</sub>, la somma di tutti i ranghi
        con segno positivo. Come avviene per il test rank-sum, questa
        statistica ha una distribuzione precisa nell'ipotesi nulla che la
        differenza mediana sia zero, distribuzione che converte alla normale nel
        caso di campioni abbastanza ampi.
      </para>
      <para>
        Usando l'opzione <lit>--verbose</lit> con i test di Wilcoxon viene
        mostrato l'ordinamento delle osservazioni (l'opzione non ha effetto se
        usata con il test del segno).
      </para>
    </description>

  </command>
  
  <command name="discrete" section="Transformations" label="Marca variabili discrete" context="cli">

    <usage>
      <arguments>
        <argument>lista-variabili</argument>
      </arguments>
      <options>
	<option>
	  <flag>--reverse</flag>
	  <effect>marca le variabili come continue</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
        Marca ogni variabile della <repl>lista-variabili</repl> come discreta.
        In modalità predefinita, tutte le variabili sono considerate come
        continue; marcando una variabile come discreta, essa viene trattata in
        modo speciale nei diagrammi di frequenza, e può esere usata con il
        comando <cmdref targ="dummify"/>.
      </para>
      <para>
        Usando l'opzione <lit>--reverse</lit>, l'operazione viene invertita,
        ossia, le variabili nella <repl>lista-variabili</repl> sono marcate come
        continue.
      </para>
    </description>
    
    <gui-access>
      <menu-path>/Variabile/Modifica attributi</menu-path>
    </gui-access>

  </command>

  <command name="dummify" section="Transformations" label="Crea variabili dummy" context="cli">

    <usage>
      <arguments>
        <argument>lista-variabili</argument>
      </arguments>
      <options>
	<option>
	  <flag>--drop-first</flag>
	  <effect>omette dalla codifica il valore minimo</effect>
	</option>
	<option>
	  <flag>--drop-last</flag>
	  <effect>omette dalla codifica il valore massimo</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Per ogni variabile rilevante nella <repl>lista-variabili</repl>,
        crea un insieme di variabili dummy che codificano i valori distinti di
        quella variabile. Le variabili rilevanti sono quelle che sono state
        marcate esplicitamente come discrete, o quelle che assumono un numero
        limitato di valori che devono essere <quote>abbastanza arrotondati</quote>
        (multipli di 0.25).
      </para>
      <para>
	Per impostazione predefinita, viene aggiunta una variabile dummy per
        ognuno dei valori distinti della variabile in questione.
        Ad esempio, se una variabile discreta <lit>x</lit> ha 5 valori distinti,
        verranno
        create 5 variabili dummy, di nome <lit>Dx_1</lit>, <lit>Dx_2</lit> e
        così via. La prima variabile dummy avrà valore 1 per le osservazioni in
        cui <lit>x</lit> assume il suo valore minimo, e 0 altrove; la successiva
        variabile dummy avrà valore 1 dove <lit>x</lit> assume il secondo tra i
        suoi valori, e così via. Se viene usata una delle opzioni
	<lit>--drop-first</lit> o <lit>--drop-last</lit>, il più basso o il più
        alto dei valori della variabile viene omesso dalla codifica (questa
        funzione può essere utile per evitare la cosiddetta
	<quote>trappola delle variabili dummy</quote>).
      </para>
      <para>
	Questo comando può anche essere usato nel contesto di una regressione.
        Ad esempio, la riga seguente specifica un modello in cui
	<lit>y</lit> viene regredita sull'insieme di variabili dummy che
        codificano <lit>x</lit> (in questo contesto non è possibile passare
        opzioni al comando <cmd>dummify</cmd>).
      </para>
      <code>
	ols y dummify(x)
      </code>
    </description>

  </command>
 
  <command name="elif" section="Programming" label="Strutture di controllo" context="cli">

    <description><para>Si veda <cmdref targ="if"/>.</para>
    </description>

  </command>

  <command name="else" section="Programming" label="Strutture di controllo" context="cli">

    <description><para>Si veda <cmdref targ="if"/>.</para>
    </description>

  </command>

  <command name="end" section="Programming" label="Chiude un blocco di comandi" context="cli">

    <description>
      <para>
	Termina un blocco di comandi di qualsiasi tipo.
        Ad esempio, <cmd>end system</cmd> termina un <cmdref targ="system"/>
        (sistema di equazioni).
      </para>
    </description>

  </command>

  <command name="endif" section="Programming" label="Strutture di controllo" context="cli">

    <description><para>Si veda <cmdref targ="if"/>.</para>
    </description>

  </command>

  <command name="endloop" section="Programming" label="Chiude un ciclo di comandi" context="cli">

    <description>
      <para>
	Indica la fine di un ciclo (loop) di comandi.  Si veda <cmdref targ="loop"/>.
      </para>
    </description>

  </command>

  <command name="eqnprint" section="Printing" label="Stampa un modello come equazione" context="cli">

    <usage>
      <arguments>
        <argument optional="true">-f nomefile</argument>
      </arguments>
      <options>
        <option>
	  <flag>--complete</flag>
	  <effect>crea un documento completo</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Va eseguito dopo la stima di un modello. Stampa il modello
        stimato sotto forma di equazione &latex;. Se viene specificato
        un nome di file usando l'opzione <lit>-f</lit>, il risultato
        viene scritto in quel file, altrimenti viene scritto in un file
        il cui nome ha la forma <filename>equation_N.tex</filename>, dove
        <lit>N</lit> è il numero di modelli stimati finora nella sessione
        in corso. Si veda anche <cmdref targ="tabprint"/>.
      </para>

      <para>
	Usando l'opzione <lit>--complete</lit>, il file &latex; è un
        documento completo, pronto per essere processato; altrimenti il
        file va incluso in un documento.
      </para>
    </description>

    <gui-access>
      <menu-path>Finestra del modello, /LaTeX</menu-path>
    </gui-access>

  </command>

  <command name="equation" section="Estimation" label="Definisce un'equazione in un sistema" context="cli">

    <usage>
      <arguments>
        <argument>variabile-dipendente</argument>
        <argument>variabili-indipendenti</argument>
      </arguments>
      <examples>
        <example>equation y x1 x2 x3 const</example>
      </examples>
    </usage>

    <description>
      <para>
	Specifica un'equazione all'interno di un sistema di equazioni
        (si veda <cmdref targ="system"/>). La sintassi per specificare
        un'equazione in un sistema SUR è la stessa usata ad esempio in <cmdref
        targ="ols"/>. Per un'equazione in un sistema con minimi quadrati 
        a tre stadi, invece è possibile usare una specificazione simile a quella
        usata per OLS e indicare una lista di strumenti comuni usando l'istruzione
        <cmd>instr</cmd> (si veda ancora <cmdref targ="system"/>), oppure si può
        usare la stessa sintassi di <cmdref targ="tsls"/>.
      </para>
    </description>

  </command>

  <command name="estimate" section="Estimation" label="Stima sistemi di equazioni" context="cli">

    <usage>
      <arguments>
        <argument>nome-sistema</argument>
        <argument>stimatore</argument>
      </arguments>
      <options>
       <option>
         <flag>--iterate</flag>
         <effect>itera fino alla convergenza</effect>
       </option>
       <option>
         <flag>--no-df-corr</flag>
         <effect>nessuna correzione per i gradi di libertà</effect>
       </option>
       <option>
         <flag>--geomean</flag>
         <effect>si veda oltre</effect>
       </option>
	<option>
	  <flag>--verbose</flag>
	  <effect>mostra i dettagli delle iterazioni</effect>
	</option>
      </options>
      <examples>
        <example>estimate "Klein Model 1" method=fiml</example>
	<example>estimate Sys1 method=sur</example>
        <example>estimate Sys1 method=sur --iterate</example>
      </examples>
    </usage>

    <description>
      <para>
	Esegue la stima di un sistema di equazioni, che deve essere stato
        definito in precedenza usando il comando <cmdref targ="system"/>.
        Per prima cosa va indicato il nome del sistema, racchiuso tra
        virgolette se contiene spazi, quindi il tipo di stimatore, preceduto
        dalla stringa <lit>method=</lit>. Gli stimatori disponibili sono:
        <cmd>ols</cmd>, <cmd>tsls</cmd>, <cmd>sur</cmd>, <cmd>3sls</cmd>,
        <cmd>fiml</cmd> o <cmd>liml</cmd>.
      </para>
      <para>Se al sistema in questione sono stati imposti dei vincoli (si veda
       il comando <cmdref targ="restrict"/>), la stima sarà soggetta a tali
       vincoli.
      </para>
      <para>
       Se il metodo di stima è <cmd>sur</cmd> o <cmd>3sls</cmd>
       e viene usata l'opzione <lit>--iterate</lit>, lo stimatore verrà
       iterato. Nel caso di SUR, se la procedura converge, i risultati
       saranno stime di massima verosimiglianza. Invece l'iterazione della
       procedura dei minimi quadrati a tre stadi non produce in genere
       risultati di massima verosimiglianza a informazione completa.
       L'opzione <lit>--iterate</lit> viene ignorata con gli altri metodi di
       stima.
      </para>
      <para>Se vengono scelti gli stimatori "equazione per equazione"
      <cmd>ols</cmd> o <cmd>tsls</cmd>, nel calcolo degli errori standard viene
      applicata in modo predefinito una correzione per i gradi di libertà, che
      può essere disabilitata usando l'opzione <lit>--no-df-corr</lit>. Questa
      opzione non ha effetti nel caso vengano usati altri stimatori, che non
      prevedono correzioni per i gradi di libertà.
      </para>
      <para>La formula usata in modo predefinito per calcolare gli elementi della matrice
       di covarianza tra equazioni è
       <equation status="display"
       tex="\[\hat{\sigma}_{i,j}=\frac{\hat{u}_i' \hat{u}_j}{T}\]"
       ascii="sigma(i,j) = u(i)' * u(j) / T"
       graphic="syssigma1"/>
       Se viene usata l'opzione <lit>--geomean</lit>, viene applicata una correzione
       per i gradi di libertà secondo la formula
       <equation status="display"
       tex="\[\hat{\sigma}_{i,j}=\frac{\hat{u}_i' \hat{u}_j}{\sqrt{(T-k_i)(T-k_j)}}\]"
       ascii="sigma(i,j) = u(i)' * u(j) / sqrt((T - ki) * (T - kj))"
       graphic="syssigma2"/>
       dove i <math>k</math> indicano il numero di parametri indipendenti in
       ogni equazione.
      </para>
      <para>
        Se si usa l'opzione <lit>--verbose</lit> e un metodo iterativo, vengono
        mostrati i dettagli delle iterazioni.
      </para>
    </description>

  </command>

  <command name="expand" section="Dataset" context="gui"
    label="Espansione dei dati">

    <description>

      <para>
	Se si vuole aggiungere a un dataset una serie di frequenza inferiore, è
        necessario <quote>espandere</quote> la nuova serie. Ad esempio, una serie
        trimestrale dovrà essere espansa per essere aggiunta a un dataset
        mensile. Altre volte occorrerà espandere un intero dataset a una
        frequenza superiore prima di aggiungervi una serie che ha una frequenza
        superiore.
      </para>

      <para>
        L'operazione di espansione dei dati è riservata gli utenti
        <quote>esperti</quote>: occorre sapere bene cosa si sta facendo. In
        pratica, gretl replica i valori della serie a minore frequenza tante
        volte quanto è richiesto dai dati. Ad esempio, se si ha una
        serie trimestrale con il valore 35.5 per l'osservazione 1990:1 (il primo
        trimestre del 1990), espandendo la serie, il valore 35.5 verrà assegnato
        alle osservazioni per gennaio, febbraio e marzo del 1990. La variabile
        espansa non potrà quindi essere utilizzata per analisi temporali
        "a grana fine", tranne nel caso si abbia ragione di ritenere che la
        variabile in questione rimanga costante nei vari sotto-periodi.
      </para>

      <para>
	È utile tenere presenti due altri comandi. Per prima cosa, se si
        combinano serie di diversa frequenza in un dataset, è opportuno
        considerare la possibilità di compattare i dati a frequenza più alta,
        invece che espandere quelli a frequenza più bassa, utilizzando il
        comando presente nel menù Campione. In secondo luogo, se si sceglie di
        espandere una serie, può essere utile applicare un'operazione di
        smorzamento (smoothing) ai dati, fra quelle disponibili utilizzando il
        comando <cmd>genr</cmd>.
      </para>

    </description>
  </command>

  <command name="export" section="Dataset" context="gui"
    label="Esportazione dei dati">

    <description>
      <para>È possibile esportare dati in formato separato da virgole
        (CSV: Comma-Separated Values), in modo che possano essere aperti
        con fogli elettronici e molti altri programmi applicativi.
	</para>

      <para>È anche possibile esportare i dati nei formati specifici di
        GNU R o GNU octave.  Per ulteriori informazioni in questi programmi
        (entrambi utili per l'analisi statistica avanzata) si vedano i 
        rispettivi siti web: http://www.r-project.org/ e http://www.octave.org/
      </para>
    </description>
  </command>

  <command name="factorized" section="Graphs" context="gui"
    label="Grafici X-Y con fattore">

    <description>
      <para>Questo comando richiede che si selezionino tre variabili,
        l'ultima delle quali deve essere una variabile dummy (con valori
        1 o 0). La variabile Y è rappresentata rispetto alla variabile X,
        con i punti colorati diversamente a seconda del valore della terza
        variabile.</para>

      <para>Esempio: si hanno dati sui salari e il livello di scolarità
        per un campione di persone; si dispone anche di una variabile
        dummy che vale 1 per gli uomini e 2 per le donne (come nel file
	<filename>data7-2</filename> di Ramanathan).  Un <quote>Grafico
        X-Y con fattore</quote> di <lit>WAGE</lit> rispetto a <lit>EDUC</lit>
	usando la dummy <lit>GENDER</lit> mostrerà le osservazioni che si
        riferiscono agli uomini in un colore e quelle delle donne in un altro
        (insieme a una legenda per identificarli).</para>

    </description>

  </command>
  

  <command name="fcast" section="Prediction" label="Genera previsioni">

    <usage>
      <arguments>
        <argument optional="true" >oss-iniziale oss-finale</argument>
	<argument optional="true">nome-variabile</argument>
      </arguments>
      <options>
        <option>
	  <flag>--dynamic</flag>
	  <effect>crea previsioni dinamiche</effect>
        </option>
        <option>
	  <flag>--static</flag>
	  <effect>crea previsioni statiche</effect>
        </option>
        <option>
	  <flag>--out-of-sample</flag>
	  <effect>genera previsioni fuori dal campione</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>non mostra le previsioni</effect>
        </option>
      </options>
      <examples>
        <example>fcast 1997:1 2001:4 f1</example>
	<example>fcast fit2</example>
      </examples>
    </usage>

    <description>
      <para contest="gui">
	Deve seguire un comando di stima.  Calcola previsioni
        per l'intervallo specificato. A seconda del tipo di modello, calcola
        anche gli errori standard (si veda oltre).
      </para>
      <para context="cli">
	Deve seguire un comando di stima.  Calcola previsioni
        per un certo intervallo delle osservazioni. L'intervallo può essere
        specificato indicando <repl>oss-iniziale</repl>
        e <repl>oss-finale</repl>, oppure con l'opzione
        <lit>--out-of-sample</lit> (in questo caso la previsione sarà per le
        osservazioni successive a quelle su cui è stato stimato il modello); se
        non si usa alcuna opzione, l'intervallo sarà quello attualmente
        impostato. Se si sceglie una previsione fuori dal campione ma non sono
        disponibili osservazioni, viene segnalato un errore. A seconda del tipo
        di modello, calcola anche gli errori standard (si veda oltre).
      </para>
      <para context="cli">
	Se l'ultimo modello stimato consiste in un'equazione singola,
        l'argomento opzionale <repl>nome-variabile</repl> ha l'effetto seguente:
	i valori della previsione non sono mostrati, ma vengono salvati nel
        dataset con il nome di variabile indicato. Se l'ultimo modello stimato è
        un sistema di equazioni, <repl>nome-variabile</repl> ha un effetto
        diverso, ossia seleziona una particolare varabile endogena per cui
        effettuare la previsione (l'impostazione predefinita consiste nel
        produrre previsioni per tutte le variabili endogene). Nel caso del
        sistema, o se non viene specificata <repl>nome-variabile</repl>, i
        valori della previsione possono essere recuperati usando la varaiabile
        accessoria <lit>$fcast</lit>, mentre gli errori standard, se
        disponibili, con <lit>$fcerr</lit>.
      </para>
      <para>
	La scelta tra previsione statica e dinamica è rilevante solo nel caso di
        modelli dinamici, che comprendono un processo di errore autoregressivo,
        o che comprendono uno o più valori ritardati della variabile dipendente
        come regressori. Le previsioni statiche sono per il periodo successivo,
        basate sui valori effettivi nel periodo precedente, mentre quelle
        dinamiche usano la regola della previsione a catena.
        Ad esempio, se la previsione per <math>y</math> nel 2008
 	richiede come input il valore di <math>y</math> nel 2007,
        non è possibile calcolare una previsione statica se non si hanno dati
        per il 2007. È possibile calcolare una previsione dinamica per il 2008
        se si dispone di una precedente previsione per
 	<math>y</math> nel 2007.
       </para>
 
       <para>
 	La scelta predefinita consiste nel fornire una previsione statica per
        ogni porzione dell'intervallo di previsione che fa parte dell'intervallo
        del campione su cui il modello è stato stimato, e una previsione
        dinamica (se rilevante) fuori dal campione. L'opzione
 	<lit>dynamic</lit> richiede di produrre previsioni dinamiche a partire
        dalla prima data possibile, mentre l'opzione <lit>static</lit>
        richiede di produrre previsioni statiche anche fuori dal campione.
       </para>
 
       <para>
 	La natura degli errori standard della previsione (se disponibili)
        dipende dalla natura del modello e della previsione. Per i modelli
        lineari statici, gli errori standard sono calcolati seguendo il metodo
        delineato in Davidson and MacKinnon (2004); essi incorporano sia
        l'incertezza dovuta al processo d'errore, sia l'incertezza dei parametri
        (sintetizzata dalla matrice di covarianza delle stime dei parametri).
        Per modelli dinamici, gli errori standard della previsione sono
        calcolati solo nel caso di previsione dinamica, e non incorporano
        incertezza dei parametri. Per modelli non lineari, al momento non sono
        disponibili errori standard della previsione.
       </para>

    </description>

    <gui-access>
      <menu-path>Finestra del modello, /Analisi/Previsioni</menu-path>
    </gui-access>

  </command>

  <command name="foreign" section="Programming"
    label="Script esterni" context="cli">

    <usage>
      <arguments>
        <argument optional="true">linguaggio</argument>
      </arguments>
      <options>
       <option>
         <flag>--send-data</flag>
         <effect>pre-carica il dataset attuale</effect>
       </option>
       <option>
         <flag>--quiet</flag>
         <effect>sopprime l'output dal programma esterno</effect>
       </option>
      </options>
    </usage>

    <description>
     <para>
       Questo comando apre una modalità speciale, in cui vengono accettati
       comandi che verranno eseguiti da un programma esterno.
       Con il comando <lit>end foreign</lit> si esce da questa modalità e i comandi
       verranno eseguiti.
      </para>
      <para>
       Al momento, l'unico programma esterno compatibile con questa modalità è
       GNU R, e l'unico argomento <repl>linguaggio</repl> accettabile è
       <lit>language=R</lit> (che è il valore predefinito, e può essere omesso).
       In futuro potranno essere supportati altri programmi.
      </para>
      <para>
       Si veda la <guideref targ="chap:gretlR"/> per dettagli ed esempi.
      </para>
    </description>

  </command>

  <command name="freq" section="Statistics" label="Distribuzione di frequenza">

    <usage>
      <arguments>
        <argument>variabile</argument>
      </arguments>
      <options>
        <option>
         <flag>--quiet</flag>
         <effect>non mostra il grafico</effect>
        </option>
        <option>
         <flag>--normal</flag>
         <effect>test per la distribuzione normale</effect>
        </option>
        <option>
         <flag>--gamma</flag>
         <effect>test per la distribuzione gamma</effect>
        </option>
        <option>
         <flag>--silent</flag>
         <effect>non mostra nulla</effect>
        </option>
      </options>
    </usage>

    <description context="cli">
      <para>
        Se non vengono indicate opzioni, mostra la distribuzione di frequenza
        per la <repl>variabile</repl> (indicata con il nome o il numero).
      </para>
      <para>
       Usando l'opzione <lit>--normal</lit>, vengono mostrati i risultati del
       test chi-quadro di Doornik&ndash;Hansen per la normalità.
       Usando l'opzione <lit>--gamma</lit>, al posto del test di normalità
       viene eseguito il test non parametrico di Locke per l'ipotesi nulla che la
       variabile segua la distribuzione gamma; si veda Locke (1976), Shapiro e
       Chen (2001).
      </para>
      <para>
        In modalità interattiva viene mostrato anche un grafico della distribuzione,
        a meno che non si usi l'opzione <lit>--quiet</lit>.
      </para>
      <para>
       L'opzione <lit>--silent</lit> sopprime interamente l'output mostrato
       di solito. Ha senso usarla insieme a una delle opzioni riguardanti la
       distribuzione: in questo modo la statistica test e il suo p-value
       verranno salvati nelle variabili accessorie
       <lit>$test</lit> e <lit>$pvalue</lit>.
      </para>
    </description>
 
    <description context="gui">
      <para>
        Nella finestra di dialogo della distribuzione di frequenza è possibile
        controllare le caratteristiche del grafico in due modi diversi.
      </para>
      <para>
	Per prima cosa è possibile scegliere il numero di intervalli; in questo caso la
        larghezza e la posizione degli intervalli sono calcolate
        automaticamente.
      </para>
      <para>
        In alternativa, è possibile specificare il limite inferiore del primo
        intervallo e la larghezza degli intervalli; in questo caso il numero di
        intervalli viene calcolato automaticamente.
      </para>
      <para>
        Se si vuole che gli intervalli corrispondano a numeri interi, è
        possibile procedere in questo modo: iniziare specificando il numero di
        intervalli, controllare il grafico prodotto, prendere nota delle
        modifiche da fare (ad esempio impostare l'inizio del primo intervallo al
        valore 100 e la larghezza pari a 200), quindi ricreare il grafico
        specificando i valori scelti.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variabile/Distribuzione di frequenza</menu-path>
    </gui-access>

  </command>

  <command name="function" section="Programming" label="Definisce una funzione" context="cli">

    <usage>
      <arguments>
        <argument>nome_funzione</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Apre un blocco di istruzioni che definiscono una funzione. Il blocco va
        chiuso con <lit>end function</lit>. Per i dettagli, si veda
        la <guideref targ="chap:functions"/>.
      </para>
    </description>

  </command>  

  <command name="garch" section="Estimation" label="Stima GARCH">

    <usage>
      <arguments>
        <argument>p</argument>
	<argument>q</argument>
	<argument separated="true">variabile-dipendente</argument>
	<argument optional="true">variabili-indipendenti</argument>
      </arguments>
      <options>
	<option>
	  <flag>--robust</flag>
	  <effect>errori standard robusti</effect>
        </option>
	<option>
	  <flag>--verbose</flag>
	  <effect>mostra i dettagli delle iterazioni</effect>
        </option>
        <option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
        </option>
         <option>
	  <flag>--nc</flag>
	  <effect>non include una costante</effect>
        </option>
        <option>
	  <flag>--fcp</flag>
	  <effect>usa l'algoritmo di Fiorentini, Calzolari e Panattoni</effect>
        </option>
        <option>
	  <flag>--arma-init</flag>
	  <effect>parametri di varianza iniziale da ARMA</effect>
        </option>
      </options>
      <examples>
        <example>garch 1 1 ; y</example>
	<example>garch 1 1 ; y 0 x1 x2 --robust</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
	Stima un modello GARCH (Generalized Autoregressive
	Conditional Heteroskedasticity) univariato, o, se sono specificate delle
	<repl>variabili-indipendenti</repl>, includendo delle variabili esogene.
	I valori interi <repl>p</repl> e <repl>q</repl> (che possono essere
        indicati in forma numerica o col nome di variabili scalari preesistenti)
        rappresentano gli ordini di ritardo nell'equazione della varianza
        condizionale.
	<equation status="display"
	  tex="\[h_t = \alpha_0 + \sum_{i=1}^q \alpha_i \varepsilon^2_{t-i} +
	  \sum_{j=1}^p \beta_j h_{t-j}\]"
	  ascii="h(t) = a(0) + somma(per i da 1 a q) a(i)*u(t-i)^2 + somma( per j da 1 a p) b(j)*h(t-j)"
	  graphic="garch_h"/>
      </para>
      <para context="cli">
	Il parametro <repl>p</repl> rappresenta quinsi l'ordine generalizzato
	(o <quote>AR</quote>), mentre <repl>q</repl> rappresenta il consueto
        ordine ARCH (o <quote>MA</quote>). Se <repl>p</repl> è diverso da zero,
	anche <repl>q</repl> deve essere diverso da zero, altrimenti il modello
        non è identificato. Comunque, è possibile stimare un modello ARCH
        consueto impostando <repl>q</repl> a un valore positivo e <repl>p</repl>
        a zero. La somma di <repl>p</repl> e <repl>q</repl> non deve superare 5.
        Si noti che nell'equazione della media viene automaticamente inclusa una
        costante, a meno che non si usi l'opzione <lit>--nc</lit>.
      </para>

      <para context="gui">
        Stima un modello GARCH (Generalized Autoregressive Conditional
        Heteroskedasticity) univariato, o, se sono specificate delle
        variabili-indipendenti, includendo delle variabili esogene.
	L'equazione della varianza condizionale è la seguente:
	<equation status="display" tex="\[h_t = \alpha_0 + 
	\sum_{i=1}^q \alpha_i \varepsilon^2_{t-i} + \sum_{j=1}^p
	\beta_i h_{t-j}\]" ascii="h(t) = a(0) + somma (i da 1 a q) a(i)*u(t-i) +
	somma(j da 1 a p) b(j)*h(t-j)" graphic="garch_h"/>
      </para>
      <para context="gui">
	Il parametro <repl>p</repl> rappresenta quinsi l'ordine generalizzato
	(o <quote>AR</quote>), mentre <repl>q</repl> rappresenta il consueto
        ordine ARCH (o <quote>MA</quote>). Se <repl>p</repl> è diverso da zero,
	anche <repl>q</repl> deve essere diverso da zero, altrimenti il modello
        non è identificato. Comunque, è possibile stimare un modello ARCH
        consueto impostando <repl>q</repl> a un valore positivo e <repl>p</repl>
        a zero. La somma di <repl>p</repl> e <repl>q</repl> non deve superare 5.
      </para>

      <para>
        Per impostazione predefinita, i modelli GARCH vengono stimati usando il
        codice nativo gretl, ma è anche possibile usare l'algoritmo di
        Fiorentini, Calzolari e Panattoni (1996). Il primo usa il massimizzatore
        BFGS, mentre il secondo usa la matrice di informazione per massimizzare
        la verosimiglianza, con un raffinamento usando l'Hessiana.
      </para>

      <para context="cli">
        Sono disponibili varie stime della matrice di covarianza dei
        coefficienti. Il metodo predefinito è quello dell'Hessiana, a meno che
        non si usi l'opzione <lit>--robust</lit>, nel qual caso viene usata la
        matrice di covarianza QML (White).  Altre possibilità (ad es. la matrice
        di informazione, o lo stimatore di Bollerslev&ndash;Wooldridge) possono
        essere specificate con il comando <cmdref targ="set"/>.
      </para>

      <para context="gui">
        Sono disponibili varie stime della matrice di covarianza dei
        coefficienti. Il metodo predefinito è quello dell'Hessiana, a meno di
        non selezionare la casella <quote>Errori standard robusti</quote>, nel
        qual caso viene usata la matrice di covarianza QML (White). Altre
        possibilità (ad es. la matrice di informazione, o lo stimatore di
        Bollerslev&ndash;Wooldridge) possono essere specificate con il comando
        <cmdref targ="set"/>.
      </para>

      <para context="gui">La varianza condizionale stimata, insieme ai residui e
        ad altre statistiche del modello, può essere richiamata ed aggiunta al
        dataset usando il menù <quote>Analisi</quote> presente nella
        finestra del modello.
      </para>

      <para context="cli">
	In modalità predefinita, le stime dei parametri di varianza sono
	inizializzate usando la varianza dell'errore non condizionale, ottenuta
        dalla stima OLS iniziale, per la costante, e piccoli valori positivi
        per i coefficienti dei valori passati dell'errore al quadrato e
        per la varianza dell'errore. L'opzione <lit>--arma-init</lit>
	fa in modo che i valori iniziali per questi parametri siano ricavati da
        un modello ARMA iniziale, sfruttando la relazione tra GARCH
        e ARMA mostrata nel capitolo 21 di <book>Time Series Analysis</book> di Hamilton.
        In alcuni casi, questo metodo può aumentare le probabilità di convergenza.
      </para>

      <para context="cli">
        I residui GARCH e la varianza condizionale stimata sono memorizzate
        rispettivamente nelle variabili <lit>$uhat</lit> e <lit>$h</lit>. Ad
        esempio, per ottenere la varianza condizionale è possibile scrivere: 
        </para>
      <code context="cli">
        genr ht = $h
      </code>

    </description>

    <gui-access>
      <menu-path>/Modello/Serie storiche/GARCH</menu-path>
    </gui-access>

  </command>

  <command name="genr" section="Dataset"
    label="Generazione di una nuova variabile">

    <usage>
      <arguments>
        <argument>nuova-variabile</argument>
        <argument>= formula</argument>
      </arguments>
    </usage>

    <description>
      <para>
	In contesti appropriati, <lit>series</lit>, <lit>scalar</lit>
	e <lit>matrix</lit> sono sinonimi per questo comando.
      </para>
      <para>
	Crea nuove variabili, di solito per mezzo di trasformazioni di
	variabili esistenti. Si veda anche <cmdref targ="diff"/>,
        <cmdref targ="logs"/>, <cmdref targ="lags"/>, <cmdref
	  targ="ldiff"/>, <cmdref targ="sdiff"/> e <cmdref targ="square"/> per le scorciatoie. Nel
	contesto di una formula <lit>genr</lit>, le variabili esistenti
	devono essere referenziate per nome, non per numero
	identificativo. La formula dev'essere una combinazione ben
	definita di nomi di variabile, costanti, operatori e funzioni
	(descritte oltre). Ulteriori dettagli su alcuni aspetti di questo
	comando si possono trovare nella
        <guideref targ="chap-genr"/>.
      </para>

      <para>
	Il comando <lit>genr</lit> può produrre come risultato una serie o uno scalare. Ad
        esempio, la formula <lit>x2 = x * 2</lit> produce una serie se la variabile
	<lit>x</lit> è una serie e uno scalare se <lit>x</lit> è uno scalare.
        Le formule <lit>x = 0</lit> e <lit>mx = mean(x)</lit> producono degli
        scalari. In alcune circostanze, può essere utile che un risultato
        scalare sia espanso in una serie o in un vettore: è possibile ottenere
        questo risultato usando <lit>series</lit> come <quote>alias</quote> per il comando
	<lit>genr</lit>. Ad esempio, <lit>series x = 0</lit> produce una
	serie con tutti i valori pari a 0. Allo stesso modo, è possibile usare
        <lit>scalar</lit> come alias per <lit>genr</lit>, ma non è possibile
        forzare un risultato vettoriale in uno scalare: con questa parola chiave
        si indica che il risultato <emphasis>dovrebbe essere</emphasis> uno scalare;
        se non lo è, viene emesso un messaggio di errore.
      </para>

      <para>
        Quando una formula produce una serie o un vettore come risultato,
        l'intervallo su cui essi sono definiti dipende dall'impostazione attuale
        del campione. È quindi possibile definire una serie a pezzi, alternando
        l'uso dei comandi <lit>smpl</lit> e <lit>genr</lit>.
      </para>

      <para>
        Gli <emphasis>operatori aritmetici</emphasis> supportati sono, in
        ordine di precedenza: <lit>^</lit> (esponenziale); <lit>*</lit>,
        <lit>/</lit> e <lit>%</lit> (modulo o resto); <lit>+</lit> e
        <lit>-</lit>. 
      </para>

      <para>
	Gli <emphasis>operatori Booleani</emphasis> disponibili sono
	(ancora in ordine di precedenza): <lit>!</lit> (negazione),
	<lit>&amp;&amp;</lit> (AND logico), <lit>||</lit> (OR logico),
	<lit>&gt;</lit>, <lit>&lt;</lit>, <lit>=</lit>,
	<lit>&gt;=</lit> (maggiore o uguale), <lit>&lt;=</lit>
	(minore o uguale) e <lit>!=</lit> (disuguale).  Gli operatori
	Booleani possono essere usati per costuire variabili dummy:
	ad esempio <lit>(x > 10)</lit> produce 1 se <lit>x</lit>
	&gt; 10, 0 altrimenti.</para>
 
      <para>
        Le costanti predefinite sono <lit>pi</lit> e <lit>NA</lit>. L'ultima
        rappresenta il codice per i valori mancanti: è possibile inizializzare
        una variabile con valori mancanti usando <lit>scalar x = NA</lit>.
      </para>

      <para>
 	Il comando <lit>genr</lit> supporta un'ampia gamma di funzioni
        matematiche e statistiche, da quelle più comuni a quelle di uso
        specifico in econometria. Inoltre offre l'accesso a numerose variabili
        interne che vengono definite nel corso della stima di regressioni,
        dell'esecuzione di test, e così via.
	<refnote xref="false"> 
	  Per un elenco delle funzioni e degli accessori, eseguire:
	  <quote>help functions</quote>. 
	</refnote> 
	<refnote xref="true">
	  Per un elenco delle funzioni e degli accessori, si veda:
	  <gfr targ="chap:funcref"/>. 
	</refnote>
      </para>
      
      <para>
        Oltre agli operatori e alle funzioni mostrati, ci sono alcuni
        usi speciali del comando <cmd>genr</cmd>:
      </para>

      <ilist>
	<li><para><cmd>genr time</cmd> crea una variabile trend temporale
	    (1,2,3,&hellip;) chiamata <cmd>time</cmd>.
            <cmd>genr index</cmd> fa la stessa cosa, ma chiamando la variabile
	    <lit>index</lit>.</para>
	</li>
	<li><para><cmd>genr dummy</cmd> crea una serie di variabili dummy a seconda
            della periodicità dei dati. Ad esempio, nel caso di dati trimestrali
            (periodicità 4) il programma crea <lit>dummy_1</lit>, che vale 1 
            nel primo trimestre e 0 altrove, <lit>dummy_2</lit> che vale 1
            nel secondo trimestre e 0 altrove, e così via.</para>
	</li>
        <li><para><cmd>genr unitdum</cmd> e <cmd>genr timedum</cmd> creano insiemi di
            variabili dummy speciali da usare in un dataset di tipo panel. Il
            primo comando crea dummy che rappresentano le unità cross section,
            il secondo i periodi di osservazione.
	    </para>
	</li>
      </ilist>

      <para>
	<emphasis>Nota</emphasis>: nella versione a riga di comando del programma,
        i comandi <cmd>genr</cmd> che estraggono dati relativi al modello
	si riferiscono sempre al modello stimato per ultimo. Questo vale anche
        per la versione grafica del programma se si usa <cmd>genr</cmd> nel
        <quote>terminale di gretl</quote> o si immette una formula usando
        l'opzione <quote>Definisci nuova variabile</quote> nel menù Variabile
        della finestra principale. Usando la versione grafica, però, è
        possibile anche estrarre i dati da qualunque modello mostrato in una
        finestra (anche se non è il modello più recente) usando il menù
        <quote>Analisi</quote> nella finestra del modello.
      </para>

      <para>
        La variabile speciale <lit>t</lit> serve da indice per le osservazioni
        (<lit>obs</lit> è un sinonimo).  Ad esempio, <lit>genr dum =
        (t=15)</lit> crea una variabile dummy che vale 1 per l'osservazione 15 e
        0 altrove. È anche possibile usare questa variabile per selezionare
        alcune osservazioni particolari secondo la data o il nome. Ad esempio
	<lit>genr d = (obs&gt;1986:4)</lit>, <lit>genr d = (obs&gt;"2008/04/01")</lit>,
        <lit>genr d = (obs="CA")</lit>.  Quando si usa una data o un nome
        dell'osservazione, questi vanno racchiusi tra virgolette doppie, mentre
        non è strettamente necessario farlo per le date trimestrali e mensili.
      </para>

      <para>
	Nota: quando si usa <lit>t</lit> e <lit>obs</lit> con serie storiche
        annuali, il valore corrisponde sempre all'anno dell'osservazione. Quindi
        se si hanno dati annuali che iniziano nel 1970, l'osservazione per il
        1980 corrisponde a <lit>t=1980</lit>, non a <lit>t=10</lit>. Con dati
        trimestrali o mensili, invece, <lit>t=10</lit> corrisponde alla decima osservazione.
      </para>

      <para>
        È possibile estrarre dei valori scalari da una serie usando
        una formula <lit>genr</lit> con la sintassi
	<repl>nome-variabile</repl><lit>[</lit><repl>osservazione</repl><lit>]</lit>.
	Il valore di <repl>osservazione</repl> può essere specificato con
        un numero o una data.
	Esempi: <lit>x[5]</lit>, <lit>CPI[1996:01]</lit>.  Per i dati
        giornalieri occorre usare la forma <repl>AAAA/MM/GG</repl>, ad esempio
	<lit>ibm[1970/01/23]</lit>.
      </para>

      <para>
        È possibile modificare una singola osservazione in una serie
        usando <lit>genr</lit>. Per farlo, occorre aggiungere un numero
        di osservazione o una data valida tra parentesi quadre al nome
	della variabile nel lato sinistro della formula. Ad esempio:
	<lit>genr x[3] = 30</lit> o <lit>genr x[1950:04] =
	303.7</lit>.
      </para>

      <para>
        Ecco un esempio di utilizzo delle variabili dummy: si supponga che
        <lit>x</lit> abbia valori 1, 2, o 3 e si desiderino tre variabili dummy,
        <lit>d1</lit> = 1 se <lit>x</lit> = 1, e 0 altrove, <lit>d2</lit> = 1 se
        <lit>x</lit> = 2 e così via. Per crearle, basta usare i comandi:
      </para>

      <code>
	    genr d1 = (x=1)
	    genr d2 = (x=2)
	    genr d3 = (x=3)
      </code>

      <table id="tab-genr" title="Esempi di utilizzo del comando genr"
	lhead="Formula" rhead="Commento"
	lwidth="100pt" rwidth="300pt" 
	style="rpara">
	<row>
	  <cell><lit>y = x1^3</lit></cell>
	  <cell><lit>x1</lit> al cubo</cell>
	</row>          
	<row>
	  <cell><lit>y = ln((x1+x2)/x3)</lit></cell>
	  <cell></cell>
	</row>
	<row>
	  <cell><lit>z = x&gt;y</lit></cell>
	  <cell><lit>z(t)</lit> = 1 se <lit>x(t) &gt; y(t)</lit>,
	    0 altrove</cell>
	</row> 
	<row>
	  <cell><lit>y = x(-2)</lit></cell>
	  <cell><lit>x</lit> ritardata di 2 periodi</cell>
	</row>     
	<row>
	  <cell><lit>y = x(+2)</lit></cell>
	  <cell><lit>x</lit> anticipata di 2 periodi</cell>
	</row>
	<row>
	  <cell><lit>y = diff(x)</lit></cell>
	  <cell><lit>y(t) = x(t) - x(t-1)</lit></cell>
	</row>
	<row>
	  <cell><lit>y = ldiff(x)</lit></cell>
	  <cell><lit>y(t) = log x(t) - log x(t-1)</lit>, il
            tasso di crescita istantaneo di <lit>x</lit></cell>
	</row>
	<row>
	  <cell><lit>y = sort(x)</lit></cell>
	  <cell>ordina <lit>x</lit> in senso crescente e la salva in
	    <lit>y</lit></cell>
	</row>
	<row>
	  <cell><lit>y = dsort(x)</lit></cell>
	  <cell>ordina <lit>x</lit> in senso decrescente</cell>
	</row>
	<row>
	  <cell><lit>y = int(x)</lit></cell>
	  <cell>tronca <lit>x</lit> e salva il valore intero in
	    <lit>y</lit></cell>
	</row>
	<row>
	  <cell><lit>y = abs(x)</lit></cell>
	  <cell>salva il valore assoluto di <lit>x</lit></cell>
	</row>
	<row>
	  <cell><lit>y = sum(x)</lit></cell>
	  <cell>somma i valori di <lit>x</lit> escludendo i valori mancanti <lit>NA</lit></cell>
	</row>
	<row>
	  <cell><lit>y = cum(x)</lit></cell>
	  <cell>cumulativa: 
		<equation status="inline"
		  tex="$y_t = \sum_{\tau=1}^t x_{\tau}$"
		  ascii="y(t) = somma di x(s) per s da 1 a t"
		  graphic="cumulate"/>
	  </cell>
	</row>
	<row>
	  <cell><lit>aa = $ess</lit></cell>
	  <cell>imposta <lit>aa</lit> uguale alla somma dei quadrati degli errori
            dell'ultima regressione</cell>
	</row>
	<row>
	  <cell><lit>x = $coeff(sqft)</lit></cell>
	  <cell>estrae il coefficiente stimato per la variabile
	    <lit>sqft</lit> nell'ultima regressione</cell>
	</row>
	<row>
	  <cell><lit>rho4 = $rho(4)</lit></cell>
	  <cell>estrae il coefficiente di autoregressione del quarto
            ordine dall'ultimo modello (presume un modello
            <lit>ar</lit> model)</cell>
	</row>
	<row>
	  <cell><lit>cvx1x2 = $vcv(x1, x2)</lit></cell>
	  <cell>estrae il coefficiente di covarianza stimato tra le
            variabili <lit>x1</lit> e <lit>x2</lit> dall'ultimo modello</cell>
	</row>
	<row>
	  <cell><lit>foo = uniform()</lit></cell>
	  <cell>variabile pseudo-casuale uniforme nell'intervallo
	    0&ndash;1</cell>
	</row>
	<row>
	  <cell><lit>bar = 3 * normal()</lit></cell>
	  <cell>variabile pseudo-casuale normale con &mu; = 0, &sigma; =
	    3</cell>
	</row>
	<row>
	  <cell><lit>samp = ok(x)</lit></cell>
	  <cell>vale 1 per le osservazioni dove il valore di <lit>x</lit>
            non è mancante.</cell>
	</row>
      </table>

    </description>

    <gui-access>
      <menu-path>/Variabile/Definisci nuova variabile</menu-path>
      <other-access>Menù pop-up nella finestra principale</other-access>
    </gui-access>

  </command>

  <command name="genrand" section="Programming" context="gui"
    label="Generazione di variabili casuali">

    <description>
      <para>
        In questa finestra occorre specificare il nome da dare alla
        variabile da generare, seguito da alcune informazioni aggiuntive
        che dipendono dal tipo di distribuzione.
      </para>

      <ilist>
	<li>
	  <para>
	    Uniforme: limite superiore e inferiore per la distribuzione.
	  </para>
	</li>
	<li>
	  <para>
	    Normale: la media e lo scarto quadratico medio (deve essere positivo).
	  </para>
	</li>
	<li>
	  <para>
	    Chi-quadro e t di Student: i gradi di libertà (devono essere positivi).
	  </para>
	</li>
        <li>
          <para>
	    F: gradi di libertà al numeratore e denominatore.
          </para>
        </li>
        <li>
          <para>
            Gamma: parametri di forma e scala (entrambi positivi).
          </para>
        </li>
        <li>
          <para>
            Binomiale: numero di prove (un intero positivo)
            e la probabilità di <quote>successo</quote>.
          </para>
        </li>
        <li>
          <para>
            Poisson: la media (che è pari anche alla varianza).
          </para>
        </li>

      </ilist>

      <para>
	Se occorre generare sequenze ripetibili di numeri pseudo-casuali, è
        possibile impostare il seme del generatore, nel menù Strumenti.
      </para>

    </description>
  </command>

  <command name="genseed" section="Programming" context="gui"
    label="Impostare il seme per i numeri casuali">

    <description>
      <para>
	Il "seme" rappresenta il punto di partenza per la sequenza di numeri
        pseudo-casuali generati in una sessione di gretl. Per impostazione
        predefinita, il seme viene impostato all'avvio del programma, basandosi
        sull'orologio di sistema. Ciò fa sì che si ottenga una diversa sequenza
        di numeri casuali ogni volta che si usa il programma; se invece si vuole
        usare sequenze ripetibili di numeri, occorre impostare manualmente il
        seme (e ricordarsi il valore usato).
      </para>
      <para>
	Si noti che il generatore viene re-impostato ogni volta che si fa clic
        sul pulsante "OK" di questa finestra di dialogo, quindi, ad esempio,
	se si imposta il seme a 147, si genera una serie dalla distribuzione
        normale standard, si riapre questa finestra di dialogo e si fa clic su
        "OK" indicando ancora 147 come seme, e infine si genera una seconda
        serie dalla normale standard, le due serie generate saranno identiche.
      </para>
    </description>
  </command>

  <command name="gmm" section="Estimation" label="Stima GMM">

    <usage>
      <options>
	<option>
	  <flag>--two-step</flag>
	  <effect>Stima a due passi</effect>
	</option>
	<option>
	  <flag>--iterate</flag>
	  <effect>GMM iterato</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>Mostra la matrice di covarianza</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>Mostra i dettagli delle iterazioni</effect>
	</option>
      </options>
    </usage>

    <description>

      <para>
        Esegue la stima col metodo dei momenti generalizzato (Generalized Method
        of Moments, GMM) usando l'algoritmo BFGS (Broyden, Fletcher, Goldfarb,
        Shanno). Occorre specificare uno o più comandi per aggiornare le
        quantità rilevanti (tipicamente i residui GMM), una o più condizioni di
        ortogonalità, una matrice iniziale dei pesi e un elenco dei parametri da
        stimare, il tutto racchiuso tra le parole chiave
	<lit>gmm</lit> e <lit>end gmm</lit>.
      </para>
      <para>
	Si veda la <guideref targ="chap:gmm"/> per i dettagli. Quello che segue
        è un semplice esempio illustrativo.
      </para>
      <code>
	gmm e = y - X*b
	  orthog e ; W
	  weights V
	  params b
	end gmm
      </code>
      <para>
	Nell'esempio si assume che <lit>y</lit> e <lit>X</lit> siano matrici di
        dati, <lit>b</lit> sia un vettore con i valori dei parametri, <lit>W</lit>
        sia una  matrice di strumenti, e <lit>V</lit> un'appropriata matrice dei pesi.
        La dichiarazione
      </para>
      <code>
	orthog e ; W
      </code>
      <para>
	indica che il vettore dei residui <lit>e</lit> è in linea di principio
        ortogonale ad ognuno degli strumenti che compongono le colonne di
	<lit>W</lit>.
      </para>

    </description>
 
    <gui-access>
      <menu-path>/Modello/GMM</menu-path>
    </gui-access>

  </command>

  <command name="gnuplot" section="Graphs" label="Crea un grafico Gnuplot" context="cli">

    <usage>
      <arguments>
        <argument>variabili-y</argument>
        <argument>variabile-x</argument>
	<argument optional="true">variabile-dummy</argument>
      </arguments>
      <options>
        <option>
	  <flag>--with-lines</flag>
	  <effect>usa linee invece che punti</effect>
        </option>
        <option>
	  <flag>--with-impulses</flag>
	  <effect>usa linee verticali</effect>
        </option>
        <option>
	  <flag>--time-series</flag>
	  <effect>mostra rispetto al tempo</effect>
        </option>
        <option>
	  <flag>--suppress-fit</flag>
	  <effect>non mostra la linea stimata</effect>
        </option>
        <option>
	  <flag>--linear-fit</flag>
	  <effect>mostra fit minimi quadrati</effect>
        </option>
        <option>
	  <flag>--inverse-fit</flag>
	  <effect>mostra fit inverso</effect>
        </option>
        <option>
	  <flag>--quadratic-fit</flag>
	  <effect>mostra fit quadratico</effect>
        </option>
        <option>
	  <flag>--loess-fit</flag>
	  <effect>mostra fit loess</effect>
        </option>
        <option>
	  <flag>--dummy</flag>
	  <effect>si veda sotto</effect>
        </option>
      </options>
      <examples>
        <example>gnuplot y1 y2 x</example>
        <example>gnuplot x --time-series --with-lines</example>
	<example>gnuplot wages educ gender --dummy</example>
      </examples>
    </usage>

    <description>
       <para>
 	Le variabili nella lista <repl>variabili-y</repl> vengono mostrate
        rispetto alle <repl>variabili-x</repl>. Per avere un grafico storico
        è possibile usare <lit>time</lit> come <repl>variabile-x</repl>, oppure
        usare l'opzione <lit>--time-series</lit>.
       </para>

      <para>
 	Usando l'opzione <lit>--dummy</lit>, occorre fornire esattamente tre variabili:
        una variabile <math>y</math>, una variabile <math>x</math>, e una
        variabile dummy <repl>dumvar</repl>. L'effetto è quello di mostrare
 	<repl>y</repl> rispetto a <repl>x</repl> colorando in modo diverso i
        vari punti, a seconda che <repl>dumvar</repl> valga 1 o 0.
      </para>

      <para>
	In modalità interattiva il risultato è mostrato immediatamente.
        In modalità <quote>batch</quote>, viene scritto un file di comandi
        gnuplot, chiamato <filename>gpttmpN.plt</filename>, a partire da N
	= <lit>01</lit>; il grafico vero e proprio può essere generato
        usando il programma <program>gnuplot</program> (su MS Windows:
	<program>wgnuplot</program>).
      </para>
 
      <para>
	Le varie opzioni <quote>fit</quote> si applicano solo nel caso di un
        diagramma a dispersione bivariato. Il comportamento predefinito consiste
        nel mostrare la linea con le stime OLS, se e solo se il coefficiente di
        pendenza è significativo almeno al 10 per cento. Se si usa l'opzione
	<lit>suppress</lit> non viene mostrata alcuna linea.
        Se si usa l'opzione <lit>linear</lit>, la linea OLS viene mostrata a
        prescindere dalla sua significatività. Le altre opzioni
        (<lit>inverse</lit>, <lit>quadratic</lit> e <lit>loess</lit>) mostrano
        rispettivamente un fit inverso (la regressione di <math>y</math>
        su 1/<math>x</math>), un fit quadratico o un fit loess (chiamato
        a volte anche <quote>lowess</quote>, una regressione robusta con pesi locali).
      </para>

      <para>È disponibile un'ulteriore opzione per questo comando: dopo la
        specificazione delle variabili e le eventuali opzioni, è possibile
        aggiungere direttamente dei comandi gnuplot per modificare l'aspetto
        visivo del grafico (ad esempio, impostando il titolo e o gli intervalli
        degli assi). Questi comandi aggiuntivi vanno inclusi tra parentesi
        graffe e ogni comando va separato con un punto e virgola; è possibile
        usare una barra rovesciata (<lit>\</lit>) per continuare un gruppo di
        comandi gnuplot sulla riga successiva. Ecco un esempio della sintassi:
      </para>

      <para>
	<lit>{ set title 'Il mio titolo'; set yrange [0:1000]; }</lit>
      </para>

    </description>

    <gui-access>
      <menu-path>/Visualizza/Grafico</menu-path>
      <other-access>Menù pop-up nella finestra principale, pulsante grafico sulla barra degli strumenti</other-access>
    </gui-access>

  </command>

  <command name="graph" section="Graphs" label="Crea un grafico ASCII" context="cli">

    <usage>
      <arguments>
        <argument>variabili-y</argument>
        <argument>variabile-x</argument>
      </arguments>
      <options>
        <option>
	  <flag>--tall</flag>
	  <effect>usa 40 righe</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Grafici ASCII.  Le <repl>variabili-y</repl> (che possono essere
        definite per nome o numero) sono rappresentate rispetto alla
        <repl>variabile-x</repl> usando simboli ASCII. L'opzione
        <lit>--tall</lit> produce un grafico di 40 righe per 60 colonne,
        altrimenti il grafico sarà di 20 righe per 60 colonne (per la
        visualizzazione a schermo). Si veda anche <cmdref targ="gnuplot"/>.
      </para>
    </description>

  </command>

  <command name="graphing" section="Graphs" context="gui"
    label="Grafici">

    <description>

      <para>
        Gretl richiama un programma separato, gnuplot, per generare
	i grafici. Gnuplot è un programma di grafica molto completo, con
        una miriade di opzioni; gretl fornisce l'accesso, attraverso
        un'interfaccia grafica, a una parte di queste opzioni, cercando
        di scegliere dei valori, ma è possibile anche controllare
        l'aspetto di un grafico in tutti i suoi dettagli, se si vuole.
      </para>

      <para>
        Mentre un grafico viene visualizzato, facendo clic sulla
        finestra del grafico si aprirà un menù pop-up con le seguenti
        opzioni:
      </para>

      <ilist>
	<li><para>Salva come postscript: salva il grafico in formato encapsulated
	    postscript (EPS)</para>
	</li>
	<li><para>Salva come PNG: salva in formato Portable Network Graphics</para>
	</li>
	<li><para>Salva alla sessione come icona: il grafico apparirà
        sotto forma di icona quando si seleziona <quote>Visualizza
        Icone</quote> dal menù Sessione</para>
	</li>
	<li><para>Ingrandisci: permette di selezionare un'area
        all'interno del grafico per visualizzarla da vicino</para>
	</li>
        <li><para>Stampa: permette di stampare il grafico direttamente
        (disponibile solo in Gnome e MS Windows)</para>
	</li>
	<li><para>Copia negli appunti: permette di copiare il grafico
        per poi incollarlo in altri programmi Windows, come ad esempio
        MS Word (disponibile solo in MS Windows)</para>
	</li>
	<li><para>Modifica: apre una finestra che permette di modificare
        vari dettagli dell'aspetto del grafico</para>
	</li>
	<li><para>Chiudi: chiude la finestra del grafico</para>
	</li>
      </ilist>

      <para>
	Se si conosce gnuplot e si desidera un controllo sull'aspetto
        del grafico più preciso di quello fornito dalla finestra di
        modifica del grafico (opzione <quote>Modifica</quote>), ci sono
        due possibilità:
      </para>

      <ilist>
	<li>
          <para>
            Una volta salvato il grafico come icona di sessione,
            facendo clic col tasto destro sull'icona si apre un altro menù
            pop-up. Una delle opzioni disponibili è <quote>Comandi per
            modificare il grafico</quote>, che apre una finestra di modifica
            con i comandi di gnuplot. È possibile modificare questi comandi
            e salvarli per il futuro, oppure inviarli direttamente a
            gnuplot (con il comando <quote>File/Invia a gnuplot</quote> del
            menù della finestra di modifica dei comandi).
          </para>
        </li>
        <li>
          <para>
            Un altro modo per salvare i comandi del grafico (o per
            salvare il grafico in formati diversi da EPS o PNG) è quello di
            usare il comando <quote>Modifica</quote> nel menù pop-up del
            grafico per aprire la finestra di modifica del grafico, quindi
            fare clic su <quote>File</quote>: verrà visualizzato un menù a
            discesa con i formati in cui è possibile salvare il grafico.
          </para>
	</li>
      </ilist>

      <para>
	Per saperne di più su gnuplot, si veda
	http://www.gnuplot.info
      </para>

    </description>

  </command>

  <command name="graphpag" section="Graphs" context="gui"
    label="Pagina dei grafici">

    <description>

      <para>
        La <quote>pagina dei grafici</quote> funzionerà solo se
        si è installato il sistema di composizione &latex; e si è
        in grado di generare e visualizzare file in formato postscript.
      </para>

      <para>
        Nella finestra della sessione, è possibile trascinare fino
	a otto grafici sull'icona della pagina dei grafici. Facendo doppio
	clic sull'icona della pagina dei grafici (o facendo clic col tasto
        destro e selezionando <quote>Mostra</quote>), la pagina contenente
        i grafici selezionati verrà composta e aperta con il proprio
        visualizzatore di file postscript, da cui sarà possibile stamparla.
      </para>

      <para>
        Per pulire la pagina dei grafici, fare clic col tasto destro
        sull'icona e selezionare <quote>Pulisci</quote>.
      </para> 

      <para>
        Su sistemi diversi da MS Windows, può essere necessario modificare
        l'impostazione del programma per visualizzare il postscript, che si
        trova nella sezione <quote>Programmi</quote> della finestra di dialogo
        delle Preferenze di gretl (nel menù Strumenti della finestra principale).
      </para>

    </description>

  </command>

  <command name="3-D" section="Graphs" context="gui"
    label="Grafici tridimensionali">

    <description>
      <para>
        Questa funzionalità migliora se è stata installata una
        versione di gnuplot pari o superiore alla 3.8, che consente
        di manipolare il grafico 3D con il mouse (ruotandolo ed
        allungando o riducendo gli assi).
      </para>

      <para>
        Nella composizione di un grafico 3D, si noti che l'asse Z
        sarà l'asse verticale, quindi se si ha una variabile dipendente
        che si pensa possa essere influenzata da due variabili indipendenti,
        è meglio mettere la variabile dipendente sull'asse Z e le altre
        due variabili sugli assi X e Y.
      </para>  

      <para>
        A differenza di molti altri grafici di gretl, i grafici 3D
        sono controllati da gnuplot invece che da gretl, quindi il menù
        di modifica dei grafici in questo caso non è disponibile.
      </para>

    </description>
  </command>

  <command name="gui-htest" section="Tests" context="gui"
    label="Calcolatore per le statistiche test">

    <description>
      <para>
	Il calcolatore dei test di Gretl calcola statistiche test e p-value
        per molti tipi di test di ipotesi su una o più popolazioni.
        Per utilizzarlo, occorre indicare le statistiche campionarie derivate
        da uno o due campioni, a seconda del test scelto. Queste possono essere
        indicate esplicitamente in forma numerica, oppure, se si ha un file di
        dati aperto, è possibile far calcolare a gretl le statistiche test per
        una o più variabili selezionate dal dataset (nel caso delle medie e
        varianze, ma non nel caso delle proporzioni).
      </para>

      <para>
	Per eseguire un test indicando una variabile del dataset, occorre per
        prima cosa attivare questa opzione selezionando la casella "Usa
        variabile dal dataset", e poi scegliere la variabile nella lista.
        Appena si sceglie una variabile, i valori della statistica rilevante
        sono automaticamente inseriti nelle caselle sottostanti.
      </para>

      <para>
	Oltre che selezionare semplicemente una variabile, è possibile
        specificare un sotto-campione. Ad esempio, si ipotizzi di avere dei dati
        sui salari in una variabile chiamata "salari" e una variabile dummy
        chiamata "genere", pari a 1 per gli uomini e 0 per le donne (o
        viceversa). Quindi, nel test per la differenza fra le medie, è possibile
        selezionare "salari" in entrambi i campi, ma aggiungendo nel campo
        superiore "(genere=0)" e nel campo inferiore "(genere=1)" si otterrà
        un test per la differenza tra il reddito medio degli uomini e delle
        donne. Quando si specifica un vincolo che identifica un sotto-campione,
        occorre premere il tasto Invio perché le statistiche campionarie siano
        calcolate.
      </para>

      <para>
	Il vincolo che definisce il sotto-campione deve essere indicato tra
        parentesi e in generale prende la forma "variabile operatore valore",
        dove "variabile" è il nome di una variabile nel dataset attuale,
        "valore" è un valore numerico e "operatore" è un operatore di confronto,
        da scegliere tra =, !=, &lt;, &gt;, &lt;= or &gt;= (rispettivamente uguale
        diverso, minore, maggiore, minore o uguale, maggiore o uguale). Gli
        spazi prima e dopo l'operatore sono opzionali.
      </para>

    </description>
  </command>

  <command name="gui-htest-np" section="Tests" context="gui"
    label="Test non parametrici">

    <description>
      <para>
       Nella finestra <quote>Test delle differenze</quote> è possibile svolgere
       dei test non parametrici per la differenza tra due popolazioni o gruppi;
       è possibile scegliere vari tipi specifici di test:
      </para>
      <para>
       Test del segno: si basa sul fatto che per due campioni
	<math>x</math> e <math>y</math> estratti casualmente dalla
        stessa distribuzione, la probabilità che valga
	<math>x</math><sub>i</sub> &gt;
	<math>y</math><sub>i</sub> per ogni osservazione
	<math>i</math> dovrebbe valere 0.5. La statistica test è
	<math>w</math>, ossia il numero di osservazioni per cui vale
	<math>x</math><sub>i</sub> &gt;
	<math>y</math><sub>i</sub>. Sotto l'ipotesi nulla, questa
        grandezza si distribuisce come una binomiale con parametri
	(<math>n</math>, 0.5), dove <math>n</math> è il numero di
        osservazioni.
      </para>
      <para>
       Test rank sum di Wilcoxon. Questo test procede ordinando le osservazioni estratte da
        entrambi i campioni dalla più piccola alla più grande, e quindi calcolando
        la somma dei ranghi delle osservazioni da uno dei campioni. I due
        campioni non devono necessariamente avere la stessa dimensione: se sono
        diversi, viene usato il campione più piccolo per calcolare la somma dei
        ranghi. Sotto l'ipotesi nulla che i campioni siano estratti da
        popolazioni con la stessa mediana, la distribuzione di probabilità della
        somma dei ranghi può essere calcolata per ogni valore dell'ampiezza dei
        due campioni, mentre per campioni abbastanza ampi essa approssima la
        distribuzione normale.
      </para>
      <para>
       Test signed rank di Wilcoxon.  Questo test è valido per "coppie di
       campioni", come possono essere ad esempio i valori di una variabile in un
       gruppo di individui prima e dopo un certo trattamento. Il test procede
       calcolando le differenze tra le coppie di osservazioni
       <math>x</math><sub>i</sub> &minus;
       <math>y</math><sub>i</sub>, ordinando queste differenze per valore
       assoluto e assegnando ad ogni coppia un valore di rango con segno, in cui
       il segno rispecchia il segno della differenza. Quindi viene calcolato
       <math>W</math><sub>+</sub>, la somma di tutti i ranghi con segno
       positivo. Come avviene per il test rank-sum, questa statistica ha una
       distribuzione precisa nell'ipotesi nulla che la differenza mediana sia
       zero, distribuzione che converte alla normale nel caso di campioni
       abbastanza ampi.
      </para>
      <para>
       Nella finestra <quote>Test delle successioni</quote> è possibile
       eseguire un test per la casualità di una certa variabile, basato
       sul numero di successioni di valori consecutivi positivi o negativi.
       Con l'opzione <quote>Usa la differenza prima</quote>, la variabile viene
       differenziata prima dell'analisi, quindi le successioni sono
       interpretabili come sequenze di incrementi o decrementi consecutivi nel
       valore della variabile. La statistica test è basata su un'approssimazione
       normale alla distribuzione del numero di sequenze sotto l'ipotesi nulla
       di casualità.
      </para>
    </description>
  </command>
    
  <command name="hausman" section="Tests" label="Diagnosi panel">

    <description>
      <para>
        Questo test è disponibile solo dopo aver stimato un modello OLS su dati
        panel (si veda anche <cmd>setobs</cmd>). Testa il semplice modello
        <quote>pooled</quote> (con tutte le osservazioni mescolate
        indistintamente) contro le principali alternative: il modello a effetti
        fissi e quello a effetti casuali.
      </para>

      <para>
        Il modello a effetti fissi permette all'intercetta della regressione di
        variare per ogni unità cross section. Viene eseguito un test
        <math>F</math> per l'ipotesi nulla che le intercette non
        differiscano tra loro.  Il modello a effetti casuali scompone la
        varianza dei residui in due parti: una specifica all'unità cross section
        e una specifica all'osservazione particolare (la stima può essere
        eseguita solo se il numero delle unità cross section nel dataset è
        maggiore del numero dei parametri da stimare). La statistica LM di
        Breusch&ndash;Pagan testa l'ipotesi nulla che il modello pooled OLS sia
        adeguato contro l'alternativo modello a effetti casuali.
      </para>

      <para>
	Può accadere che il modello pooled OLS sia rifiutato nei confronti
        di entrambe le alternative, a effetti fissi o casuali. A patto
        che gli errori specifici di unità o di gruppo siano non
        correlati con le variabili indipendenti, lo stimatore a effetti
        casuali è più efficiente dello stimatore a effetti fissi; nel
        caso contrario lo stimatore a effetti casuali non è consistente
	e deve essergli preferito lo stimatore a effetti fissi. L'ipotesi
        nulla per il test di Hausman è che l'errore specifico di gruppo non
        sia correlato con le variabili indipendenti (e quindi che il
        modello a effetti casuali sia preferibile). Un basso p-value per
        questo test suggerisce di rifiutare il modello a effetti casuali
        in favore del modello a effetti fissi.
      </para>
    </description>

    <gui-access>
      <menu-path>Finestra del modello, /Test/HAUSMAN - Diagnosi panel</menu-path>
    </gui-access>

  </command>

  <command name="hccm" section="Estimation" context="cli" label="Stima HCCM">

    <usage>
      <arguments>
        <argument>variabile-dipendente</argument>
        <argument>variabili-indipendenti</argument>
      </arguments>
      <options>
	<option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
        Matrice di covarianza coerente con l'eteroschedasticità (HCCM:
        Heteroskedasticity-Consistent Covariance Matrix); questo comando
        esegue una regressione dove i coefficienti sono stimati con la
        procedura OLS standard, ma gli errori standard delle stime dei
	coefficienti sono calcolati in modo da essere robusti rispetto
        all'eteroschedasticità, ossia usando la procedura <quote>jackknife</quote>
        di MacKinnon&ndash;White.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modello/HCCM</menu-path>
    </gui-access>

  </command>

  <command name="hccme" section="Estimation" context="gui"
    label="Errori standard robusti">

    <description>
      <para>
	Sono disponibili vari modi di calcolare gli errori standard
        robusti in presenza di eteroschedasticità (e, nel caso dello
        stimatore HAC, di autocorrelazione).
      </para>

      <para>HC0 produce gli <quote>errori standard originali di White</quote>;
        HC1, HC2, HC3 e HC3a sono varianti che si ritiene producano risultati
        migliori (più affidabili). Per i dettagli sugli stimatori, si veda
	MacKinnon e White (Journal of Econometrics, 1985) o
	Davidson e MacKinnon, Econometric Theory and Methods
	(Oxford, 2004). Le sigle usate sono quelle proposte da
	Davidson e MacKinnon. La variante <quote>HC3a</quote> è il
	<quote>jackknife</quote> descritto da MacKinnon e White (1985); HC3 è
        una sua vicina approssimazione.
      </para>

      <para>Se si usa lo stimatore HAC per serie storiche, è possibile calibrare
        la lunghezza dei ritardi usando il comando <cmd>set</cmd>. Si veda il
        manuale di gretl o i file di aiuto per i dettagli.</para>

      <para>Quando si stima un  modello OLS su dati panel, lo stimatore robusto
        predefinito per la matrice di covarianza è quello dato da Arellano.
        L'alternativa è lo stimatore PCSE (Panel Corrected Standard Errors) di
        Beck e Katz, che tiene conto dell'eteroschedasticità, ma non
        dell'autocorrelazione.
      </para>

      <para>Per i modelli GARCH sono disponibili due stimatori robusti della
        matrice di covarianza: QML è lo stimatore di quasi massima verosimiglianza,
        e BW è lo stimatore di Bollerslev-Wooldridge.
      </para>

    </description>

  </command>

  <command name="heckit" section="Estimation" context="cli"
    label="Modello di selezione di Heckman">

    <usage>
      <arguments>
        <argument>variabile-dipendente</argument>
        <argument>variabili-indipendenti</argument>
	<argument separated="true">equazione di selezione</argument>
      </arguments>
      <options>
        <option>
	  <flag>--two-step</flag>
	  <effect>esegue la stima in due passi</effect>
        </option>
        <option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
        </option>
	<option>
	  <flag>--verbose</flag>
	  <effect>mostra risultati aggiuntivi</effect>
        </option>
      </options>      
      <examples>
        <example>heckit y 0 x1 x2 ; ys 0 x3 x4</example>
	<demos>
	  <demo>heckit.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para>
        Modello di selezione di tipo Heckman. Nella specificazione, la lista che
        precede il punto e virgola rappresenta l'equazione principale, mentre la
        seconda lista rappresenta l'equazione di selezione. La variabile
        dipendente nell'equazione di selezione (<lit>ys</lit>
        nell'esempio visto sopra) deve essere una variabile binaria.
      </para>

      <para>
	Per impostazione predefinita, i parametri sono stimati per massima
        verosimiglianza. La matrice di covarianza dei parametri è calcolata
        usando l'inversa negativa dell'Hessiana. Se si vuole usare la procedura
        di stima in due passi, basta usare l'opzione <lit>--two-step</lit>.
        In questo caso, la matrice di covarianza dei parametri dell'equazione
        principale è corretta nel modo descritto da Heckman (1979).
      </para>

      <para>
	Si noti che nella stima di massima verosimiglianza viene
	impiegata una matrice hessiana calcolata numericamente; ciò
	può condurre a una stima inaccurata della matrice di
	covarianze se l'ordine di grandezza delle variabili
	esplicative è tale per cui alcuni dei coefficienti stimati
	risultano molto piccoli in valore assoluto. Il problema verrà
	affrontato nelle versioni future; nel frattempo, si può
	aggirare il problema riscalando opportunamente i regressori
	problematici.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modello/Modelli non lineari/Heckit</menu-path>
    </gui-access>

  </command>

  <command name="help" section="Utilities" label="Aiuto sui comandi" context="cli">

    <usage>
      <altforms>
        <altform><lit>help</lit></altform>
        <altform><lit>help functions</lit></altform>
        <altform><lit>help</lit> <repl>comando</repl></altform>
        <altform><lit>help</lit> <repl>funzione</repl></altform>
      </altforms>
      <options>
       <option>
         <flag>--func</flag>
         <effect>sceglie l'aiuto sulle funzioni</effect>
       </option>
      </options>
    </usage>

    <description>
      <para>
        Se non vengono indicati argomenti, mostra un elenco dei comandi disponibili.
        Indicando l'argomento <lit quote="true">functions</lit>, mostra un
        elenco delle funzioni disponibili (si veda <cmdref targ="genr"/>).
      </para> 
      <para> 
        <cmd>help</cmd> <repl>comando</repl> descrive il <repl>comando</repl>
        (ad es.  <cmd>help smpl</cmd>). <lit>help</lit> <repl>funzione</repl>
        descrive la <repl>funzione</repl> (ad es. <lit>help ldet</lit>).
        Alcune funzioni hanno lo stesso nome dei comandi relativi (ad esempio
        <lit>diff</lit>): in questo caso verrà mostrato l'aiuto relativo al
        comando, a meno che non si usi l'opzione <lit>--func</lit>.
      </para> 
    </description>

    <gui-access>
      <menu-path>/Aiuto</menu-path>
    </gui-access>

  </command>

  <command name="hsk" section="Estimation"
    label="Stime corrette per l'eteroschedasticità">

    <usage>
      <arguments>
        <argument>variabile-dipendente</argument>
        <argument>variabili-indipendenti</argument>
      </arguments>
      <options>
	<option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
        Questo comando è utile in presenza di eteroschedasticità sotto forma di
        una funzione incognita dei regressori, che può essere approssimata da
        una relazione quadratica. In questo contesto, offre la possibilità di
        avere errori standard consistenti e stime dei parametri più efficienti,
        rispetto alla stima OLS.
      </para>
      <para>
        La procedura richiede: (a) la stima OLS del modello, (b) una regressione
        ausiliaria per generare la stima della varianza dell'errore e (c) la
        stima con minimi quadrati ponderati, usando come peso il reciproco della
        varianza stimata.
      </para>
      <para>
        Nella regressione ausiliaria (b) il logaritmo dei quadrati dei residui
        dalla prima regressione OLS viene regredito sui regressori originali e
        sui loro quadrati. La trasformazione logaritmica viene effettuata per
        assicurarsi che le varianze stimate siano non negative. Indicando con
        <math>u</math><sup>*</sup> i valori stimati da questa regressione, la
        serie dei pesi per la regressione con minimi quadrati ponderati è data
        da 1/exp(<math>u</math><sup>*</sup>).
     </para>
    </description>

    <gui-access>
      <menu-path>/Modello/Altri modelli lineari/HSK - WLS corretti per eteroschedasticità</menu-path>
    </gui-access>

  </command>

  <command name="hurst" section="Statistics"
    label="Esponente di Hurst">
  
    <usage>
      <arguments>
        <argument>nome-variabile</argument>
      </arguments>
    </usage>
  
    <description>
      <para>
       Calcola l'esponente di Hurst (una misura di persistenza, o di memoria
       lunga) per una serie storica con almeno 128 osservazioni.
      </para>
  
      <para>
       L'esponente di Hurst è discusso da Mandelbrot. In termini teorici è
       l'esponente <math>H</math> nella relazione
       <equation status="display"
         tex="\[\mathrm{RS}(x) = an^H\]"
         ascii="RS(x) = an^H"
         graphic="hurst"/>dove RS è l'<quote>intervallo riscalato</quote>
         della variabile <math>x</math> in un campione dell'ampiezza
       <math>n</math>, mentre <math>a</math> è una
       costante. L'intervallo riscalato è l'intervallo (valore massimo
       meno valore minimo) del valore cumulato, o somma parziale, di
       <math>x</math> sul periodo del campione (dopo aver sottratto la
       media campionaria), diviso per lo scarto quadratico medio campionario.
      </para>
  
      <para>
       Come punto di riferimento, se <math>x</math> è un rumore bianco
       (media zero, persistenza zero) l'intervallo dei suoi valori cumulati
       (che forma una passeggiata casuale), scalato per lo scarto quadratico medio,
       cresce come la radice quadrata dell'ampiezza campionaria, ossia ha un
       esponente di Hurst atteso pari a 0.5. Valori dell'esponente sensibilmente
       maggiori di 0.5 indicano persistenza della serie, mentre valori minori di
       0.5 indicano anti-persistenza (autocorrelazione negativa). In teoria
       l'esponente deve essere compreso tra 0 e 1, ma in campioni finiti è
       possibile ottenere delle stime per l'esponente maggiori di 1.
      </para>

      <para>
       In gretl, l'esponente è stimato usando il sotto-campionamento binario:
       si inizia dall'intero intervallo dei dati, quindi si usano le due metà
       dell'intervallo, poi i quattro quarti, e così via. Il valore RS è la
       media presa sui vari campioni. L'esponente è quindi stimato come il
       coefficiente di pendenza della regressione del logaritmo di RS sul
       logaritmo dell'ampiezza del campione.
      </para>

    </description>

    <gui-access>
      <menu-path>/Variabile/Esponente di Hurst</menu-path>
    </gui-access>

  </command>


  <command name="if" section="Programming" label="Strutture di controllo" context="cli">

    <description>
      <para>
        Struttura di controllo per l'esecuzione dei comandi. Sono supportate le
        tre forme seguenti:
      </para>

      <pre>
	<lit># Forma semplice</lit>&par;
	<lit>if</lit> <repl>condizione</repl>&par;
	<lit> </lit><lit> </lit> <repl>comandi</repl>&par;
	<lit>endif</lit>
      </pre>
      
      <pre>
	<lit># A due rami</lit>&par;
	<lit>if</lit> <repl>condizione</repl>&par;
	<lit> </lit><lit> </lit> <repl>comandi-1</repl>&par;
	<lit>else</lit>&par;
	<lit> </lit><lit> </lit> <repl>comandi-2</repl>&par;
	<lit>endif</lit>
      </pre>

      <pre>
	<lit># A tre o più rami</lit>&par;
	<lit>if</lit> <repl>condizione-1</repl>&par;
	<lit> </lit><lit> </lit> <repl>comandi-1</repl>&par;
	<lit>elif</lit> <repl>condizione-2</repl>&par;
	<lit> </lit><lit> </lit> <repl>comandi-2</repl>&par;
 	<lit>else</lit>&par;
	<lit> </lit><lit> </lit> <repl>comandi-3</repl>&par;
 	<lit>endif</lit>
      </pre>
 
      <para>
        La <repl quote="true">condizione</repl> deve essere un'espressione
        Booleana, per la cui sintassi si veda <cmdref targ="genr"/>.
        Può essere incluso più di un blocco <cmd>elif</cmd>.
        Inoltre, i blocchi <lit>if</lit> &hellip;
	<lit>endif</lit> possono essere nidificati.
      </para>

    </description>

  </command>

  <command name="include" section="Programming" label="Include definizioni di
    funzioni" context="cli">

    <usage>
      <arguments>
        <argument>file-input</argument>
      </arguments>
    </usage>

    <description>
      <para>
        Da usare in uno script di comandi, principalmente per includere
        definizioni di funzioni. Esegue i comandi nel <repl>file-input</repl>
        e ripassa il controllo allo script principale. Per includere una funzione
        che fa parte di un pacchetto, occorre specificare anche l'estensione del
        file.
      </para>
      <para>
	Si veda anche il comando <cmdref targ="run"/>.
      </para>
    </description>

  </command>


  <command name="info" section="Dataset" label="Informazioni sul dataset" context="cli">

    <description>
      <para>
	Mostra le informazioni aggiuntive contenute nel file di dati
        attuale.
      </para>
    </description>

    <gui-access>
      <menu-path>/Dati/Visualizza descrizione</menu-path>
      <other-access>Finestre di esplorazione dei dati</other-access>
    </gui-access>

  </command>

  <command name="irfboot" section="Graphs" context="gui"
    label="Bootstrap impulso-risposta">

    <description>
      <para>Se si sceglie l'intervallo di confidenza bootstrap nella
      visualizzazione delle funzioni di impulso-risposta, gretl calcola un
      intervallo di confidenza al 95 per cento per le risposte usando il metodo
      bootstrap. Si effettua un campionamento (con reimmissione) dai residui del
      VAR (o VECM) originale, viene costruito un dataset artificiale usando le
      stime originali dei parametri e i residui ri-campionati, viene ri-stimato
      il sistema e vengono ri-calcolate le funzioni di impulso-risposta.  Questa
      procedura viene ripetuta 999 volte e vengono mostrati i quantili 0.025 e
      0.975 per le risposte, insieme alle stime puntuali.
      </para>
      <para>
       L'opzione bootstrap al momento non è disponibile per il VECM vincolati.
      </para>
    </description>

  </command>


  <command name="kpss" section="Tests" label="Test KPSS di stazionarietà">

    <usage>
      <arguments>
        <argument>ordine</argument>
        <argument>lista-variabili</argument>
      </arguments>
      <options>
	<option>
	  <flag>--trend</flag>
	  <effect>include un trend</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>mostra i risultati della regressione</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>non mostra i risultati</effect>
	</option>
	<option>
	  <flag>--difference</flag>
	  <effect>usa la differenza prima della variabile</effect>
	</option>
      </options>
      <examples>
	<example>kpss 8 y</example>
        <example>kpss 4 x1 --trend</example>
      </examples>
    </usage>

    <description>
      <para context="gui">
	Calcola il test KPSS (Kwiatkowski, Phillips, Schmidt e
	Shin, 1992) per la stazionarietà di una variabile (o della sua
        differenza prima, se si usa l'opzione di differenziazione). L'ipotesi
        nulla è che la variabile in questione sia stazionaria, attorno
        a un valore fisso o, se è stata selezionata l'opzione <lit>includi un trend</lit>,
        attorno a un trend deterministico lineare.
      </para>
      <para context="cli">
	Calcola il test KPSS (Kwiatkowski, Phillips, Schmidt e
	Shin, 1992) per la stazionarietà di ognuna delle variabili specificate
        (o della loro differenza prima, se si usa l'opzione <lit>--difference</lit>. L'ipotesi
        nulla è che la variabile in questione sia stazionaria, attorno
        a un valore fisso o, se è stata usata l'opzione <lit>--trend</lit>,
        attorno a un trend deterministico lineare.
      </para>
      <para context="gui">
	L'argomento ordine determina la dimensione della finestra usata per
        il livellamento di Bartlett.  Se si usa l'opzione <lit>Mostra i risultati
        della regressione</lit>, vengono mostrati anche i risultati della
        regressione ausiliaria, insieme alla varianza stimata della componente
        random walk della variabile.
      </para>
      <para context="cli">
	L'argomento ordine determina la dimensione della finestra usata per
        il livellamento di Bartlett.  Se si usa l'opzione <lit>--verbose</lit>,
        vengono mostrati anche i risultati della regressione ausiliaria, insieme
        alla varianza stimata della componente random walk della variabile.
      </para>

    </description>

    <gui-access>
      <menu-path>/Variabile/Test KPSS</menu-path>
    </gui-access>

  </command>
  <command name="labels" section="Dataset" label="Mostra etichette delle variabili" context="cli">

    <description>
      <para>
	Mostra le etichette informative per le variabili generate con il comando
        <cmd>genr</cmd> e quelle aggiunte al dataset attraverso
        l'interfaccia grafica.
      </para>
    </description>

  </command>

  <command name="lad" section="Estimation"
    label="Stima con minime deviazioni assolute">

    <usage>
      <arguments>
        <argument>variabile-dipendente</argument>
        <argument>variabili-indipendenti</argument>
      </arguments>
      <options>
        <option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Calcola una regressione che minimizza la somma delle deviazioni
        assolute dei valori stimati dai valori effettivi della variabile
        dipendente. Le stime dei coefficienti sono derivate usando
        l'algoritmo del simplesso di Barrodale&ndash;Roberts; viene
        mostrato un messaggio di avvertimento se la soluzione non è
        unica.
      </para>
      <para>
	Gli errori standard sono derivati usando la procedura bootstrap
        con 500 estrazioni. La matrice di covarianza per le stime dei
        parametri, mostrata se si usa l'opzione <lit>--vcv</lit>, si basa
        sulla stessa procedura.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modello/Stima robusta/LAD - Minime deviazioni assolute</menu-path>
    </gui-access>

  </command>

  <command name="lags" section="Transformations" label="Crea ritardi" context="cli">

    <usage>
      <altforms>
        <altform><lit>lags</lit> <repl>lista-variabili</repl></altform>
       <altform><lit>lags</lit> <repl>ordine</repl> <lit>;</lit> <repl>lista-variabili</repl></altform>
      </altforms>
      <examples>
       <example>lags x y</example>
       <example>lags 12 ; x y</example>
      </examples>
    </usage>

    <description>
      <para>
	Crea delle nuove variabili come valori ritardati di ognuna delle
	variabili nella <repl>lista-variabili</repl>. Il numero dei ritardi può
        essere indicato dal primo parametro opzionale, altrimenti sarà pari
        alla periodicità del dataset.  Ad esempio, se la periodicità è 4
        (trimestrale), il comando <cmd>lags x y</cmd> crea
      </para>
      <code>
       x_1 = x(t-1)
       x_2 = x(t-2)
       x_3 = x(t-3)
       x_4 = x(t-4)
      </code>
      <para>
        Il numero dei ritardi creati può essere indicato come primo parametro
        opzionale.
      </para>
    </description>

    <gui-access>
      <menu-path>/Aggiungi/Ritardi delle variabili selezionate</menu-path>
    </gui-access>

  </command>

  <command name="lags-dialog" section="Estimation" context="gui"
    label="Finestra di selezione dei ritardi">

    <description>
      <para>
	In questa finestra di dialogo è possibile selezionare l'ordine dei
        ritardi per le variabili indipendenti in un modello di serie storiche, e
        in alcuni casi anche per la variabile dipendente (ma si noti che
        l'ordine di ritardi comune per modelli vettoriali come i VAR e i VECM è
        gestito separatamente attraverso un selettore nella finestra di dialogo
        principale del modello).
      </para>

      <para>
	I selettori sulla sinistra permettono di selezionare un intervallo di
        ritardi consecutivi per ogni variabile. Per specificare ritardi non
        consecutivi, occorre selezionare la casella vicino al campo intitolato
	<quote>ritardi specifici</quote>. In questo modo si attiva il campo,
        all'interno del quale è possibile inserire una lista di ritardi separati
        da spazi.
      </para>

      <para>
        La riga denominata <quote>predefinito</quote> offre un modo veloce per
        impostare una specificazione di ritardi comune a tutte le variabili
        indipendenti: i valori inseriti in questa riga vengono copiati in tutte
        le righe successive (tranne quella della variabile dipendente, se
        esiste).
      </para>

      <para>
        La variabile dipendente è trattata in modo speciale: il ritardo di
        ordine zero indica che la variabile apparirà nel modello a sinistra del
        segno uguale, mentre ulteriori ordini di ritardo saranno aggiunti a
        destra dell'uguale, insieme alle variabili indipendenti.
      </para>

      <para>
	I valori selezionati in questa finestra di dialogo vengono ricordati per
        l'intera durata della sessione di lavoro con un certo dataset.
      </para>

    </description>

  </command>

  <command name="ldiff" section="Transformations" label="Differenze logaritmiche" context="cli">

    <usage>
      <arguments>
        <argument>lista-variabili</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Calcola la differenza prima del logaritmo naturale di ogni
        variabile della <repl>lista-variabili</repl> e la salva in una
        nuova variabile con il prefisso <lit>ld_</lit>.  Così, <cmd>ldiff
	x y</cmd> crea le nuove variabili 
      </para>
      <code>
	ld_x = log(x) - log(x(-1))
	ld_y = log(y) - log(y(-1))
      </code>
    </description>

    <gui-access>
      <menu-path>/Aggiungi/Differenze logaritmiche</menu-path>
    </gui-access>

  </command>

  <command name="leverage" section="Tests" label="Osservazioni influenti">

    <usage>
      <options>
        <option>
	  <flag>--save</flag>
	  <effect>salva le variabili</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Deve seguire immediatamente un comando <cmd>ols</cmd>. Calcola
        il <quote>leverage</quote> (<math>h</math>, compreso tra 0
        e 1) di ogni osservazione nel campione su cui è stato stimato il
        precedente modello. Mostra il residuo (<math>u</math>) per
        ogni osservazione assieme al leverage corrispondente e a una
        misura della sua influenza sulla stima:
	  <equation status="inline" 
	  tex="$uh/(1 - h)$"
	  ascii="u*h/(1-h)"
	  graphic="influence"/>. I <quote>punti di leverage</quote> per
        cui il valore di <math>h</math> supera
	2<math>k</math>/<math>n</math> (dove
	<math>k</math> è il numero dei parametri stimati e
        <math>n</math> è l'ampiezza del campione) sono indicati
        con un asterisco. Per i dettagli sui concetti di leverage e
        influenza, si veda Davidson e MacKinnon (1993, capitolo 2).
      </para>

      <para>
	Vengono mostrati anche i valori DFFITS: questi sono
        <quote>residui studentizzati</quote> (ossia i residui previsti,
        divisi per i propri errori standard) moltiplicati per
	  <equation status="inline" 
	  tex="$\sqrt{h/(1 - h)}$"
	  ascii="sqrt[h/(1 - h)]"
	  graphic="dffit"/>. Per una discussione dei residui
          studentizzati e dei valori DFFITS si veda G. S. Maddala,
        <book>Introduction to Econometrics</book>, capitolo 12 e anche
        Belsley, Kuh e Welsch (1980).
        </para>
        <para>
        In breve, i <quote>residui previsti</quote>
	sono la differenza tra il valore osservato e il valore stimato 
        della variabile dipendente all'osservazione
        <math>t</math>, ottenuti da una regressione in cui
        quell'osservazione è stata omessa (oppure in cui è stata
        aggiunta una variabile dummy che vale 1 solo per l'osservazione
	<math>t</math>); il residuo studentizzato si ottiene
        dividendo il residuo previsto per il proprio errore standard.
      </para>

      <para context="cli">Se si usa l'opzione <lit>--save</lit>, il
      leverage, il valore di influenza e il valore DFFITS vengono aggiunti
      al dataset in uso.</para>

      <para context="gui">
	L'icona "+" in cima alla finestra del test di leverage apre una
        finestra di dialogo che permette di salvare nel dataset in uso
        una o più delle variabili del test.</para>

    </description>

    <gui-access>
      <menu-path>Finestra del modello, /Test/LEVERAGE - Osservazioni influenti</menu-path>
    </gui-access>

  </command>

  <command name="lmtest" section="Tests" label="Test LM">

    <usage>
      <arguments>
        <argument optional="true">ordine</argument>
      </arguments>
      <options>
        <option>
	  <flag>--logs</flag>
	  <effect>non-linearità, logaritmi</effect>
        </option>
        <option>
	  <flag>--autocorr</flag>
	  <effect>correlazione seriale</effect>
        </option>
        <option>
	  <flag>--arch</flag>
	  <effect>ARCH</effect>
        </option>
        <option>
	  <flag>--squares</flag>
	  <effect>non-linearità, quadrati</effect>
        </option>
        <option>
	  <flag>--white</flag>
	  <effect>eteroschedasticità, test di White</effect>
        </option>
        <option>
	  <flag>--white-nocross</flag>
	  <effect>eteroschedasticità, test di White (solo quadrati)</effect>
        </option>
        <option>
	  <flag>--breusch-pagan</flag>
	  <effect>eteroschedasticità, test di Breusch&ndash;Pagan</effect>
        </option>
        <option>
	  <flag>--robust</flag>
	  <effect>stima robusta della varianza per Breusch&ndash;Pagan</effect>
        </option>
        <option>
	  <flag>--panel</flag>
	  <effect>eteroschedasticità, a gruppi</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>non mostra la regressione ausiliaria</effect>
        </option>
      </options>
    </usage>

    <description context="gui">
      <para>
	Questo comando racchiude vari test di ipotesi. La caratteristica
        comune è che tutti i test prevedono la stima di una regressione
        ausiliaria in cui la variabile dipendente è il residuo di una
        regressione <quote>originale</quote>. Le variabili indipendenti
        della regressione ausiliaria comprendono quelle della
        regressione originale e alcuni termini aggiuntivi. La statistica
        test è calcolata come (ampiezza campionaria * R-quadro) della 
        regressione ausiliaria: si distribuisce come chi-quadro con
        gradi di libertà pari al numero dei termini aggiuntivi, sotto
        l'ipotesi nulla che essi non abbiano potere esplicativo sui
        residui. Un valore <quote>elevato</quote> del chi-quadro (ossia
        un basso p-value) suggerisce di rifiutare questa ipotesi nulla.
      </para>
    </description>

    <description context="cli">
      <para>
        Deve seguire immediatamente un comando di stima. A seconda dell'opzione
        usata, il comando esegue uno dei test seguenti: test dei moltiplicatori
        di Lagrange per la non-linearità (logaritmi o quadrati), test di White
        (con o senza i prodotti incrociati) o
        test di Breusch&ndash;Pagan per l'eteroschedasticità, test LMF per la
        correlazione seriale (si veda Kiviet, 1986) o test per il modello ARCH
        (Autoregressive Conditional Heteroskedasticity, si veda anche il comando
        <cmd>arch</cmd>). La maggior parte delle opzioni sono disponibili solo
        per modelli stimati con OLS, ma si veda oltre per alcuni dettagli
        riguardanti la stima con i minimi quadrati a due stadi.
      </para>
      <para>
	L'argomento opzionale <lit>ordine</lit> è rilevante solo nel caso si
        scelga l'opzione <lit>--autocorr</lit> o l'opzione <lit>--arch</lit>.
        Per impostazione predefinita, questi test sono eseguiti usando un ordine
        di ritardo pari alla periodicità dei dati, ma è possibile anche
        impostare un ordine di ritardo specifico.
      </para>
       <para>
	L'opzione <lit>--robust</lit> ha effetto solo se viene scelto il test di
	Breusch&ndash;Pagan; l'effetto è quello di usare lo stimatore robusto
        per la varianza proposto da Koenker (1981), rendendo il test meno
        sensibile all'ipotesi di normalità.
      </para>
      <para>
	L'opzione <lit>--panel</lit> è disponibile solo se il modello viene
        stimato su dati panel: in questo caso viene eseguito un test per
        eteroschedasticità a gruppi (ossia per una varianza dell'errore diversa
        fra le unità cross section).
      </para>
      <para>
	Per impostazione predefinita, il programma mostra la regressione
        ausiliaria su cui si basa la statistica test, ma è possibile evitarlo
        usando l'opzione <lit>--quiet</lit>. La statistica test e il suo p-value
        possono essere recuperati usando le variabili accessorie <lit>$test</lit>
        e <lit>$pvalue</lit>.
      </para>
      <para>
        Nel caso di modelli stimati col metodo dei minimi quadrati a due stadi
        (si veda <cmdref targ="tsls"/>), non è possibile usare il test LM, quindi
        gretl offre alcuni test equivalenti; in questo caso, l'opzione
        <flag>--autocorr</flag> calcola il test di Godfrey per
        l'autocorrelazione (si veda Godfrey 1994),
        mentre l'opzione <flag>--white</flag> produce il test HET1 per
        l'eteroschedasticità (si veda Pesaran e Taylor 1999).
      </para>
    </description>

    <gui-access>
      <menu-path>Finestra del modello, /Test</menu-path>
    </gui-access>

  </command>

  <command name="logistic" section="Estimation"
    label="Regressione logistica">

    <usage>
      <arguments>
        <argument>variabile-dipendente</argument>
        <argument>variabili-indipendenti</argument>
	<argument optional="true" flag="ymax=">valore</argument>
      </arguments>
      <options>
	<option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
	</option>
      </options>
      <examples>
        <example>logistic y const x</example>
        <example>logistic y const x ymax=50</example>
      </examples>
    </usage>

    <description>
      <para>
	Regressione logistica: esegue una regressione OLS usando la
        trasformazione logistica sulla variabile dipendente:
	<equation status="display" 
	  tex="\[\log\left(\frac{y}{y^*-y}\right)\]"
	  ascii="log(y/(y* - y))"
	  graphic="logistic1"/>
      </para>

      <para context="cli">La variabile dipendente dev'essere
        strettamente positiva. Se è una frazione decimale, compresa tra
        0 e 1, il valore predefinito per <math>y</math><sup>*</sup>
        (il massimo asintotico della variabile dipendente) è 1.
        Se la variabile dipendente è una percentuale, compresa tra 0 e
        100, il valore predefinito di <math>y</math><sup>*</sup>
        è 100.
      </para>
        
      <para context="cli">
        È possibile indicare un valore diverso per il massimo,
        usando la sintassi opzionale <lit>ymax=</lit><repl>valore</repl>,
        che segue la lista dei regressori. Il valore fornito deve essere
        maggiore di tutti i valori osservati della variabile dipendente.
      </para>
        
      <para context="gui">
        Nella finestra di dialogo del comando, è possibile specificare
        un valore diverso per il massimo. Il valore fornito
        <math>y</math><sup>*</sup> deve essere
        maggiore di tutti i valori osservati della variabile dipendente.
      </para>

      <para>I valori stimati e i residui della regressione sono
        trasformati automaticamente usando 	  
	<equation status="display" 
	  tex="\[y=\frac{y^*}{1+e^{-x}}\]"
	  ascii="y = y* / (1 + exp(-x))"
	  graphic="logistic2"/> dove <math>x</math> rappresenta
	un valore stimato oppure un residuo della regressione OLS,
        usando la variabile dipendente trasformata. I valori riportati
        sono dunque confrontabili con la variabile dipendente originale.
	</para>

      <para>Si noti che se la variabile dipendente è binaria, occorre
        usare il comando <cmdref targ="logit"/> invece di questo comando.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modello/Modelli non lineari/Logistico</menu-path>
    </gui-access>

  </command>

  <command name="logit" section="Estimation"
    label="Regressione logit">

    <usage>
      <arguments>
        <argument>variabile-dipendente</argument>
        <argument>variabili-indipendenti</argument>
      </arguments>
      <options>
	<option>
	  <flag>--robust</flag>
	  <effect>errori standard robusti</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
	</option>
	<option>
          <flag>--verbose</flag>
	  <effect>mostra i dettagli delle iterazioni</effect>
	</option>
	<option>
	  <flag>--p-values</flag>
	  <effect>mostra i p-value invece delle pendenze</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
        Se la variabile dipendente è binaria (i suoi valori sono 0 o 1),
        esegue una stima di massima verosimiglianza dei coefficienti
        per le <repl>variabili-indipendenti</repl> con il
        metodo BRMR (<quote>binary response model regression</quote>) descritto
        in Davidson e MacKinnon (2004). Visto che il modello è nonlineare, le pendenze
        dipendono dai valori delle variabili indipendenti: per impostazione
        predefinita, al posto dei p-value vengono mostrate le pendenze rispetto ad
        ognuna delle variabili indipendenti, calcolate in corrispondenza della
        media della variabile. Questo comportamento può essere soppresso usando
        l'opzione <lit>--p-values</lit>.  La statistica chi-quadro testa
        l'ipotesi nulla che tutti i coefficienti tranne la costante siano pari a
        zero.
      </para>
      <para context="cli">
        In modalità predefinita, gli errori standard sono calcolati con
        l'inversa negativa dell'Hessiana.  Se si usa l'opzione
        <lit>--robust</lit>, verranno calcolati gli errori standard QML o quelli
        di Huber&ndash;White. In questo caso, la matrice di covarianza stimata è
        un <quote>sandwich</quote> dell'inversa dell'Hessiana stimata e del
        prodotto esterno del gradiente. Per i dettagli, si veda Davidson e
        MacKinnon 2004, cap. 10.
      </para>
      <para context="gui">
        In modalità predefinita, gli errori standard sono calcolati con
        l'inversa negativa dell'Hessiana.  Se si seleziona la casella "Errori
        standard robusti", verranno calcolati gli errori standard QML o quelli
        di Huber&ndash;White. In questo caso, la matrice di covarianza stimata è
        un <quote>sandwich</quote> dell'inversa dell'Hessiana stimata e del
        prodotto esterno del gradiente. Per i dettagli, si veda Davidson e
        MacKinnon 2004, cap. 10.
      </para>
      <para>
        Se la variabile dipendente non è binaria, ma è discreta, si ottengono
        stime Logit ordinate. Se la variabile scelta come dipendente non è
        discreta, viene emesso un messaggio di errore.
      </para>
      <para>
	Per condurre un'analisi delle proporzioni (dove la variabile
	dipendente è la proporzione dei casi che hanno una certa
        caratteristica in ogni osservazione, invece che una variabile
        binaria che indica se la caratteristica è presente o no), non
        bisogna usare il comando <cmd>logit</cmd>, ma occorre costruire
        la variabile logit come
      </para>
      <code>
	genr lgt_p = log(p/(1 - p))
      </code>
      <para>
        e usare questa come variabile dipendente in una regressione OLS.
        Si veda Ramanathan 2002, capitolo 12.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modello/Modelli non lineari/Logit</menu-path>
    </gui-access>

  </command>

  <command name="logs" section="Transformations" label="Crea logaritmi" context="cli">

    <usage>
      <arguments>
        <argument>lista-variabili</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Calcola il logaritmo naturale di ognuna delle variabili
        della <repl>lista-variabili</repl> e lo salva in una nuova
        variabile col prefisso <lit>l_</lit>, ossia una
        <quote>elle</quote> seguita da un trattino basso. Ad esempio
        <cmd>logs x y</cmd> crea le nuove variabili <lit>l_x</lit> =
        ln(<lit>x</lit>) e <lit>l_y</lit> = ln(<lit>y</lit>).
      </para>
    </description>

    <gui-access>
      <menu-path>/Aggiungi/Logaritmi delle variabili selezionate</menu-path>
    </gui-access>

  </command>

  <command name="loop" section="Programming" label="Apre un ciclo di comandi" context="cli">

    <usage>
      <arguments>
        <argument>controllo</argument>
      </arguments>
      <options>
	<option>
	  <flag>--progressive</flag>
	  <effect>abilita modalità speciali di alcuni comandi</effect>
	</option>
        <option>
          <flag>--verbose</flag>
          <effect>mostra i dettagli dei comandi genr</effect>
        </option>
        <option>
          <flag>--quiet</flag>
          <effect>non mostra il numero di iterazioni eseguite</effect>
        </option>
      </options>
      <examples>
        <example>loop 1000</example>
	<example>loop 1000 --progressive</example>
        <example>loop while essdiff > .00001</example>
        <example>loop i=1991..2000</example>
        <example>loop for (r=-.99; r&lt;=.99; r+=.01)</example>
        <example>loop foreach i xlist</example>
      </examples>
    </usage>

    <description>
      <para>
        Questo comando apre una modalità speciale, in cui il programma accetta
        comandi da eseguire più volte.  Si esce dalla modalità loop con
        l'istruzione <cmd>endloop</cmd>: solo a questo punto i comandi indicati
        vengono eseguiti.
      </para>
      <para>Il parametro <repl quote="true">controllo</repl> deve
        assumere uno dei cinque valori mostrati negli esempi: un numero di volte
        per cui ripetere i comandi all'interno del loop;
        <quote><lit>while</lit></quote> seguito da una condizione numerica;
        un intervallo di valori per una variabile indice;
        <quote><lit>for</lit></quote> seguito
        da tre espressioni tra parentesi, separate da punti e virgola
        (in modo simile all'istruzione <lit>for</lit> nel
        linguaggio di programmazione C); infine, 
	<quote><lit>foreach</lit></quote> seguito da una variabile indice e una
        lista.
      </para>
      <para>
        Si veda la <guideref targ="chap:looping"/> per altri dettagli ed esempi,
        oltre che per la spiegazione dell'opzione <lit>--progressive</lit> (che
        è destinata ad essere usata nelle simulazioni Monte Carlo) e per
        l'elenco dei comandi di gretl che possono essere usati all'interno di un
        loop.
      </para>
    </description>

  </command>
  
  <command name="mahal" section="Statistics"
    label="Distanze di Mahalanobis">

    <usage>
      <arguments>
        <argument>lista-variabili</argument>
      </arguments>
      <options>
       <option>
         <flag>--save</flag>
         <effect>salva le distanze nel dataset</effect>
       </option>
       <option>
         <flag>--vcv</flag>
         <effect>mostra la matrice di covarianza</effect>
       </option>
      </options>
    </usage>

    <description>
      <para>
       La distanza di Mahalanobis è la distanza tra due punti in uno spazio
       <math>k</math>-dimensionale, scalata rispetto alla variazione
       statistica in ogni dimensione dello spazio. Ad esempio, se
       <math>p</math> e <math>q</math> sono due osservazioni su
       un insieme di <math>k</math> variabili con matrice di covarianza
       <math>C</math>, la distanza di Mahalanobis tra le due osservazioni
       è data da
       <equation status="display"
        tex="\[\sqrt{(p-q)^{\prime}C^{-1}(p-q)}\]"
        ascii="sqrt((p - q)' * C-inversa * (p - q))"
          graphic="mahal"/> dove
       <equation status="inline" tex="$(p-q)$" ascii="(p - q)" graphic="mahal2"/> è un
       vettore a <math>k</math> dimensioni. Se la matrice di covarianza è
       la matrice identità, la distanza di Mahalanobis corrisponde alla distanza
       Euclidea.
      </para>

      <para>Lo spazio in cui vengono calcolate le distanze è definito dalle
      variabili selezionate; per ogni osservazione nell'intervallo attuale
      viene calcolata la distanza tra l'osservazione e il centroide delle
      variabili selezionate. La distanza è la controparte multidimensionale di uno
      <math>z</math>-score standard e può essere usata per giudicare se una certa
      osservazione <quote>appartiene</quote> a un gruppo di altre osservazioni.
      </para>

      <para context="cli">Se si usa l'opzione <lit>--vcv</lit>, vengono mostrate
      la matrice di covarianza e la sua inversa. Se si usa l'opzione
      <lit>--save</lit>, le distanze vengono salvate nel dataset con il nome
      <lit>mdist</lit> (o <lit>mdist1</lit>, <lit>mdist2</lit> e così via, se
      esiste già una variabile con quel nome).
      </para>

      <para context="gui">Se il numero delle variabili selezionate è minore o
       uguale a 4, vengono mostrate la matrice di covarianza e la sua inversa.
       Facendo clic sul pulsante "+" in cima alla finestra che mostra le
       distanze è possibile aggiungerle al dataset come nuova variabile.
      </para>

    </description>

    <gui-access>
      <menu-path>/Visualizza/Distanze di Mahalanobis</menu-path>
    </gui-access>

  </command>

  <command name="markers" section="Dataset" context="gui"
    label="Aggiunta di marcatori">

    <description>
      <para>
	Questo comando richiede il nome di un file che contiene
        <quote>marcatori</quote> per le osservazioni, ossia brevi stringhe
        identificative per singole osservazioni del dataset (ad esempio
        nomi di paesi o città, o altri codici), che possono essere
        lunghe fino a 8 caratteri. Il file deve contenere un marcatore
        per riga e devono esserci tanti marcatori quante sono le
        osservazioni nel dataset attuale. Se queste condizioni sono
        rispettate e se il file specificato esiste, i marcatori verranno
        aggiunti al dataset e saranno visibili scegliendo <quote>Mostra valori</quote>
        dal menù Dati di gretl.</para>
    </description>
  </command>

  <command name="meantest" section="Tests" label="Differenza delle medie">

    <usage>
      <arguments>
        <argument>var1</argument>
        <argument>var2</argument>
      </arguments>
      <options>
        <option>
	  <flag>--unequal-vars</flag>
	  <effect>assume varianze diverse</effect>
        </option>
      </options>
    </usage>

    <description>
      <para context="cli">
	Calcola la statistica <math>t</math> per l'ipotesi
	nulla che le medie della popolazione siano uguali per le
        variabili <repl>var1</repl> e <repl>var2</repl>, mostrando il
        suo p-value.
      </para>
      <para>
        L'impostazione predefinita prevede di assumere che
        le varianze delle due variabili siano uguali, mentre usando
        l'opzione <lit>--unequal-vars</lit>, si assume che esse siano
        diverse. Questo è rilevante per la statistica test solo se le
        due variabili contengono un diverso numero di osservazioni
        valide (non mancanti).
      </para>
      <para context="gui">
        Calcola la statistica t per l'ipotesi nulla che le medie della
        popolazione siano uguali per due variabili selezionate,
        mostrando il suo p-value. Il comando può essere eseguito con o
        senza l'ipotesi che le varianze delle due variabili siano uguali
        (anche se questo è rilevante per la statistica test solo se le
        due variabili contengono un diverso numero di osservazioni
        valide).</para>
    </description>

    <gui-access>
      <menu-path>/Modello/Modelli bivariati/Differenza delle medie</menu-path>
    </gui-access>

  </command>

  <command name="missing" section="Dataset" context="gui"
    label="Valori dati mancanti">

    <description>
      <para>Imposta un valore numerico che sarà interpretato come
	<quote>mancante</quote> o <quote>non disponibile</quote>, per
        una serie particolare (nel menù Variabile) o globalmente per
        l'intero dataset (nel menù Campione).</para> 

      <para>Gretl ha un codice interno per i valori mancanti, che non
      sempre può coincidere con quello usato dai dati importati. Ad
      esempio, se una serie usa il valore -1 col significato di
      <quote>non disponibile</quote>, è possibile selezionare
      <quote>Imposta codice valori mancanti</quote> nel menù
      Variabile e immettere il valore <quote>-1</quote> (senza le
      virgolette); gretl interpreterà quindi i valori -1 come osservazioni
      mancanti.</para>
    </description>
  </command>

  <command name="mle" section="Estimation"
    label="Stima di massima verosimiglianza">

    <usage>
      <arguments>
        <argument>funzione di log-verosimiglianza</argument>
        <argument>derivate</argument>
      </arguments>
      <options>
	<option>
	  <flag>--quiet</flag>
	  <effect>non stampa il modello stimato</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
	</option>
	<option>
	  <flag>--hessian</flag>
	  <effect>calcola la matrice di covarianza a partire dall'Hessiana</effect>
	</option>
	<option>
	  <flag>--robust</flag>
	  <effect>matrice di covarianza QML</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>mostra i dettagli delle iterazioni</effect>
	</option>
      </options>
      <examples>
	<demos>
	  <demo>weibull.inp</demo>
	</demos>
      </examples>
    </usage>

    <description context="gui">

      <para>Esegue la stima di massima verosimiglianza (ML, Maximum
        Likelihood) usando l'algoritmo BFGS (Broyden, Fletcher, Goldfarb, Shanno).
        Occorre specificare la funzione di log-verosimiglianza, e se possibile è
        consigliabile indicare anche espressioni per le derivate di questa
        funzione, rispetto ad ognuno dei parametri.
      </para>

      <para>
        Esempio: si supponga di avere una serie <lit>X</lit> con valori 0 o 1 e di
        voler ottenere la stima di massima verosimiglianza della probabilità <lit>p</lit> 
        che <lit>X</lit> valga 1 (è semplice intuire che la stima ML di <lit>p</lit>
        corrisponderà alla proporzione dei valori 1 nel campione).
      </para>

      <para>Occorre per prima cosa aggiungere <lit>p</lit> al dataset e assegnargli un
        valore iniziale, attraverso il comando genr o i comandi del menù.
	È possibile scrivere delle istruzioni <quote>genr</quote> appropriate
        nella finestra di specificazione del comando di stima, prima di indicare
        la specificazione della funzione di log-verosimiglianza.
      </para>

      <para>Si scrivano i seguenti comandi nella finestra del comando:</para>

      <code>
	loglik = X*log(p) + (1-X)*log(1-p)
	deriv p = X/p - (1-X)/(1-p)
      </code>

      <para>
	La prima riga specifica la funzione di log-verosimiglianza, mentre
        la seconda indica la derivata della funzione rispetto a p. Se non si
        indicanto righe "deriv", viene calcolata un'approssimazione numerica
        delle derivate.
      </para>

      <para>
	Se non si era dichiarato in precedenza il parametro p, sarebbe stato
        necessario premettere alle righe precedenti la riga:
      </para>

      <code>
	genr p = 0.5
      </code>

      <para>
	Per impostazione predefinita, gli errori standard sono basati sul
        prodotto esterno del gradiente. Se si richiedono errori standard
        robusti, viene usato uno stimatore QML (ossia, un sandwich dell'inversa
        negativa dell'Hessiana e della matrice di covarianza del gradiente).
        L'Hessiana è approssimata numericamente.
      </para>

    </description>

    <description context="cli">

      <para>Esegue la stima di massima verosimiglianza (ML, Maximum
        Likelihood) usando l'algoritmo BFGS (Broyden, Fletcher, Goldfarb, Shanno).
        Occorre specificare la funzione di log-verosimiglianza e indicare dei
        valori iniziali per i parametri della funzione (utilizzando il comando
        <cmd>genr</cmd>.  Se possibile è consigliabile indicare anche
        espressioni per le derivate di questa funzione, rispetto ad ognuno dei
        parametri; se non si indicano le derivate analitiche, verrà calcolata
        un'approssimazione numerica.
      </para>

      <para>
        Esempio: si supponga di avere una serie <lit>X</lit> con valori 0 o 1 e di
        voler ottenere la stima di massima verosimiglianza della probabilità <lit>p</lit> 
        che <lit>X</lit> valga 1 (è semplice intuire che la stima ML di <lit>p</lit>
        corrisponderà alla proporzione dei valori 1 nel campione).
      </para>

      <para>Occorre per prima cosa aggiungere <lit>p</lit> al dataset e assegnargli un
        valore iniziale; è possibile farlo nel modo seguente con il comando genr:
      <lit>genr p = 0.5</lit>.
	</para>

      <para>Quindi costruiamo il blocco di comandi per la stima di massima
      verosimiglianza:</para>

      <code>
       mle loglik = X*log(p) + (1-X)*log(1-p)
       deriv p = X/p - (1-X)/(1-p)
       end mle
      </code>

      <para>
        La prima riga specifica la funzione di log-verosimiglianza: inizia con
        la parola chiave <lit>mle</lit>, quindi contiene la variabile
        dipendente e una specificazione per la log-verosimiglianza usando la
        stessa sintassi del comando <cmd>genr</cmd>. La riga seguente (che è
        opzionale), inizia con la parola chiave <lit>deriv</lit> e fornisce
        la derivata della funzione di log-verosimiglianza rispetto al parametro
        <lit>p</lit>. Se non vengono indicate derivate, occorre includere una
        dichiarazione che identifica i parametri liberi (separati da spazi)
        utilizzando la parola chiave <lit>params</lit>. Ad esempio si
        sarebbe potuto scrivere:
      </para>
      <code>
       mle loglik = X*log(p) + (1-X)*log(1-p)
       params p
       end mle
      </code>
      <para>
       e in questo caso la derivata verrebbe calcolata numericamente.
      </para>
      <para>
       Si noti che eventuali opzioni vanno indicate nella riga finale del blocco
       MLE.
      </para>

      <para>
	Per impostazione predefinita, gli errori standard sono basati sul
        prodotto esterno del gradiente. Se si usa l'opzione
        <lit>--hessian</lit>, vengono basati sull'inversa
        negativa dell'Hessiana (che è approssimata numericamente). Se si usa
        l'opzione <lit>--robust</lit>, viene usato uno stimatore QML
        (ossia, un sandwich dell'inversa negativa dell'Hessiana e della matrice
        di covarianza del gradiente).
      </para>

    </description>

    <gui-access>
      <menu-path>/Modello/Massima verosimiglianza</menu-path>
    </gui-access>

  </command>

  <command name="modeltab" section="Utilities"
    label="Tabella modelli">

    <usage>
      <arguments>
        <argument>add</argument>
        <argument alternate="true">show</argument>
        <argument alternate="true">free</argument>
      </arguments>
    </usage>

    <description context="gui"> 
      <para>
	Nella ricerca econometrica si è soliti stimare vari modelli con una
        variabile dipendente comune, che differiscono tra loro per le variabili
        indipendenti o per lo stimatore usato.  In questa situazione è comodo
        poter rappresentare i risultati delle regressioni sotto forma di una
        tabella dove ogni colonna contiene i risultati (stime dei coefficienti
        e errori standard) per un dato modello e ogni riga contiene le stime
        per una certa variabile nei differenti modelli.</para>

      <para>Gretl dà la possibilità di costruire una tabella simile (e
      di esportarla in testo semplice, &latex; o RTF - Rich Text Format).
      Ecco come fare:</para>

      <nlist>
	<li><para>1. Stimare un modello che si vuole includere nella
            tabella e selezionare, nel menù File della finestra di
            visualizzazione del modello, <quote>Salva alla sessione come
            icona</quote> o <quote>Salva come icona e chiudi</quote>.</para>
	</li>

	<li><para>2. Ripetere il punto 1 per gli alri modelli da
        includere nella tabella (fino a un massimo di sei modelli).</para>
	</li>

	<li><para>3. Completata la stima dei modelli, aprire l'icona
        della sessione di gretl (selezionando <quote>Visualizza Icone</quote>
        nel menù Sessione della finestra principale di gretl, o facendo
        clic su <quote>Finestra icone</quote> sulla barra degli
        strumenti di gretl).</para>
	</li>

        <li><para>4. La finestra delle icone contiene
        un'icona chiamata <quote>Tabella Modelli</quote>. Per aggiungere
        alla tabella modelli il modello che deve apparire nella colonna
        più a sinistra della tabella, basta trascinare l'icona del
        modello sull'icona della Tabella Modelli, oppure fare clic col
        tasto destro sull'icona del modello e selezionare
        <quote>Aggiungi alla tabella modelli</quote> dal menù
        pop-up.</para>
	</li>

	<li><para>5. Ripetere il punto 4 per gli altri modelli da
        aggiungere alla tabella. Il secondo modello scelto apparirà
        nella seconda colonna da sinistra della tabella, e così via.
	</para>
	</li>

	<li><para>6. Ultimata la composizione della tabella, è possibile
        visualizzarla facendo doppio clic sulla sua icona. Per copiare
        la tabella negli appunti in uno dei formati supportati, basta
        fare clic sul menù Modifica della finestra in cui appare la
        tabella.</para>
	</li>

	<li><para>7. Se l'ordinamento dei modelli nella tabella non è
        quello voluto, fare clic col tasto destro sull'icona della
        tabella modelli e selezionare <quote>Pulisci</quote>, quindi
        tornare al punto 4.</para>
	</li>
      </nlist>
    </description>

    <description context="cli">
      <para>Manipola la <quote>tabella modelli</quote> di gretl. Si veda la
      	<guideref targ="modes"/> per i dettagli. Le opzioni hanno i
        seguenti effetti: <cmd>add</cmd> aggiunge l'ultimo modello
        stimato alla tabella modelli, se possibile; <cmd>show</cmd>
	mostra la tabella modelli in una finestra; <cmd>free</cmd>
	pulisce la tabella.</para>
    </description>

    <gui-access>
      <menu-path>Finestra delle icone, Icona Tabella Modelli</menu-path>
    </gui-access>

  </command>

  <command name="mpols" section="Estimation"
    label="Stima OLS a precisione multipla">

    <usage>
      <arguments>
        <argument>variabile-dipendente</argument>
        <argument>variabili-indipendenti</argument>
      </arguments>
      <options>
	<option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
        </option>
	<option>
	  <flag>--simple-print</flag>
	  <effect>non mostra le statistiche ausiliarie</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>non mostra i risultati</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Calcola le stime OLS per il modello indicato usando aritmetica
        in virgola mobile a precisione multipla. Questo comando è
        disponibile solo se <program>gretl</program> è compilato con il
        supporto per la libreria Gnu Multiple Precision (GMP). Per impostazione
        predefinita, vengono usati 256 bit di precisione nei calcoli, ma è
        possibile aumentare questo valore usando la variabile d'ambiente
        <lit>GRETL_MP_BITS</lit>.  Ad esempio, usando l'interprete dei comandi
        bash, è possibile aumentare la precisione a 1024 bit eseguendo il
        comando seguente prima di avviare gretl
      </para>
      <code>
	export GRETL_MP_BITS=1024
      </code>

      <para context="cli">
	Per questo comando è disponibile un'opzione abbastanza speciale (utile
        soprattutto a scopo di test): se la lista <repl>variabili-indipendenti</repl>
        è seguita da un punto e virgola, e da un'ulteriore lista di numeri,
        questi numeri vengono interpretati come potenze di <repl>x</repl> da aggiungere
        alla regressione, dove <repl>x</repl> è l'ultima variabile della lista
        <repl>variabili-indipendeti</repl>. Questi termini addizionali vengono
        calcolati e memorizzati in precisione multipla. Nell'esempio seguente,
	<lit>y</lit> è regredita su <lit>x</lit> e sulla seconda, terza e quarta
        potenza di <lit>x</lit>:
      </para>
      <code context="cli">
	mpols y 0 x ; 2 3 4
      </code>
    </description>

    <gui-access>
      <menu-path>/Modello/Altri modelli lineari/MPOLS - Minimi quadrati in alta precisione</menu-path>
    </gui-access>

  </command>

  <command name="nls" section="Estimation" label="Minimi quadrati non-lineari">

    <usage>
      <arguments>
        <argument>funzione</argument>
        <argument optional="true">derivate</argument>
      </arguments>
      <options>
	<option>
	  <flag>--quiet</flag>
	  <effect>non stampa il modello stimato</effect>
	</option>
	<option>
	  <flag>--robust</flag>
	  <effect>errori standard robusti</effect>
        </option>
	<option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>mostra i dettagli delle iterazioni</effect>
	</option>
      </options>
      <examples>
	<demos>
	  <demo>wg_nls.inp</demo>
	</demos>
      </examples>
    </usage>

    <description context="gui">

      <para>
        Esegue una stima con minimi quadrati non-lineari (NLS:
        Nonlinear Least Squares) usando una versione modificata
        dell'algoritmo di Levenberg&ndash;Marquandt. Occorre fornire una
        specificazione di funzione e si raccomanda di specificare anche le
        espressioni per le derivate di questa funzione rispetto a ognuno
        dei parametri, se possibile. Se non si indicano le derivate, occorre
        fornire una lista dei parametri da stimare (separati da spazi o virgole),
        preceduta dalla parola chiave <lit>params</lit>.
      </para>

      <para>
        Esempio: si supponga di avere un dataset con le variabili
        <math>C</math> e <math>Y</math> (ad es.
        <lit>greene11_3.gdt</lit>) e di voler stimare una funzione di consumo
        non-lineare del tipo:
	<equation status="display"
	  tex="\[C = \alpha + \beta Y^{\gamma}\]"
	  ascii="C = alfa + beta * Y^gamma"
	  graphic="greene_Cfunc"/></para>

      <para>I parametri alfa, beta e gamma devono per prima cosa essere
      aggiunti al dataset, indicando un valore iniziale; è possibile
      farlo usando il comando genr o attraverso i menù. È possibile
      inserire i comandi <quote>genr</quote> appropriati nella finestra
      di dialogo della specificazione NLS prima di specificare la
      funzione.</para>

      <para>Nella finestra NLS si inseriranno le righe seguenti:</para>

      <code>
	C = alfa + beta * Y^gamma
	deriv alfa = 1
	deriv beta = Y^gamma
	deriv gamma = beta * Y^gamma * log(Y)
      </code>

      <para>La prima riga indica la specificazione della funzione, mentre
      le righe successive forniscono le derivate della funzione rispetto
      ad ognuno dei tre parametri. Se non vengono fornite le righe
      "deriv", viene calcolata un'approssimazione numerica del
      Jacobiano.</para>

      <para>Se i parametri alfa, beta e gamma non sono stati
      dichiarati in precedenza, è possibile premettere alle righe viste
      sopra le seguenti:</para>

      <code>
	genr alpha = 1
	genr beta = 1
	genr gamma = 1
      </code>

      <para>Per ulteriori dettagli sulla stima NLS si veda la
	<guideref targ="chap-nls"/>.</para>

    </description>

    <description context="cli">

      <para>
        Esegue una stima con minimi quadrati non-lineari (NLS: Nonlinear Least
        Squares) usando una versione modificata dell'algoritmo di
        Levenberg&ndash;Marquandt. Occorre fornire una specificazione di
        funzione e dichiarare i parametri della funzione (usando il comando
        <cmd>genr</cmd>) prima della stima.  Opzionalmente, è anche possibile
        specificare le espressioni per le derivate della funzione rispetto a
        ognuno dei parametri. Se non si indicano le derivate, occorre fornire
        una lista dei parametri da stimare (separati da spazi o virgole),
        preceduta dalla parola chiave <lit>params</lit>. In quest'ultimo caso,
        viene calcolata un'approssimazione numerica del Jacobiano.
      </para>

      <para>
	È più semplice mostrare il funzionamento con un esempio. Quello
        che segue è uno script completo per stimare la funzione di
        consumo non-lineare presentata in <book>Econometric
        Analysis</book> di William Greene (capitolo 11 della quarta
        edizione, o capitolo 9 della quinta). I numeri alla sinistra
        delle righe sono dei punti di riferimento e non fanno parte dei
        comandi. Si noti che le opzioni, come ad esempio <lit>--vcv</lit> per mostrare la
	matrice di covarianza delle stime dei parametri, vanno aggiunte al
        comando finale <lit>end nls</lit>.
      </para>

      <code>
	1   open greene11_3.gdt
	2   ols C 0 Y
	3   genr a = $coeff(0)
	4   genr b = $coeff(Y)
	5   genr g = 1.0
	6   nls C = a + b * Y^g
	7   deriv a = 1
	8   deriv b = Y^g
	9   deriv g = b * Y^g * log(Y)
	10  end nls --vcv
      </code>

      <para>
	Spesso è comodo inizializzare i parametri con riferimento a un
        modello lineare collegato, come è mostrato nelle righe da 2 a 5.
	I parametri alfa, beta e gamma possono essere impostati a
        qualunque valore iniziale (non necessariamente sulla base di un
        modello stimato con OLS), ma la convergenza della procedura NLS
        non è garantita per qualunque punto di partenza.</para>

      <para>
	I veri comandi NLS occupano le righe da 6 a 10. Sulla riga 6
        viene dato il comando <cmd>nls</cmd>: viene specificata una
        variabile dipendente, seguita dal segno uguale, seguito da una
        specificazione di funzione. La sintassi per l'espressione a
        destra è la stessa usata per il comando <cmd>genr</cmd>. Le tre
        righe successive specificano le derivate della funzione di
        regressione rispetto a ognuno dei parametri. Ogni riga inizia
        con il comando <cmd>deriv</cmd>, indica il nome di un parametro,
        il segno di uguale e un'espressione che indica come calcolare la
        derivata (anche qui la sintassi è la stessa di <cmd>genr</cmd>).
        In alternativa, invece di fornire le derivate, è possibile sostituire
        le righe dalla 7 alla 9 con la seguente:
      </para>
      <code>
	params a b g
      </code>
      <para> 
        La riga 10, <cmd>end nls</cmd>, completa il comando ed esegue la stima.
      </para>

      <para>Per ulteriori dettagli sulla stima NLS si veda la
	<guideref targ="chap-nls"/>.</para>

    </description>

    <gui-access>
      <menu-path>/Modello/Modelli non lineari/NLS - Minimi quadrati non lineari</menu-path>
    </gui-access>

  </command>
 
  <command name="normtest" section="Tests"
    label="Test di normalità">

    <usage>
      <arguments>
        <argument>series</argument>
      </arguments>
      <options>
	<option>
	  <flag>--dhansen</flag>
	  <effect>test Doornik&ndash;Hansen</effect>
        </option>
	<option>
	  <flag>--swilk</flag>
	  <effect>test di Shapiro&ndash;Wilk</effect>
        </option>
        <option>
         <flag>--lillie</flag>
         <effect>test di Lilliefors</effect>
        </option>
	<option>
	  <flag>--jbera</flag>
	  <effect>test di Jarque&ndash;Bera</effect>
        </option>
        <option>
         <flag>--all</flag>
         <effect>esegue tutti i test</effect>
        </option>
	<option>
	  <flag>--quiet</flag>
	  <effect>non mostra i dettagli dei risultati</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Conduce un test di normalità per la <repl>serie</repl> specificata. Il
        tipo di test eseguito è determinato dalle opzioni del comando (se non ne
        viene usata alcuna, viene eseguito il test di Doornik&ndash;Hansen). Si
        noti che il test di Jarque&ndash;Bera test, sebbene semplice da
        calcolare, ha un'accuratezza relativamente bassa in campioni limitati,
        quindi se ne raccomanda l'uso principalmente a scopo di confronto.
      </para>
      <para>
	La statistica test e il suo p-value possono essere recuperati usando gli
        accessori <lit>$test</lit> e <lit>$pvalue</lit>. Se si usa l'opzione
        <lit>--all</lit>, i risultati salvati saranno queslli del test di
        Doornik&ndash;Hansen.
      </para>
    </description>

  </command>

  <command name="nulldata" section="Dataset"
    label="Creazione di un dataset vuoto">

    <usage>
      <arguments>
        <argument>lunghezza_serie</argument>
      </arguments>
      <options>
	<option>
	  <flag>--preserve</flag>
	  <effect>preserva le matrici</effect>
        </option>
      </options>
      <examples>
        <example>nulldata 500</example>
      </examples>
    </usage>

    <description>
      <para>
	Crea un dataset <quote>vuoto</quote>, che contiene solo una
        costante e una variabile indice, con periodicità 1 e il numero
        indicato di osservazioni. Ad esempio, è possibile creare un dataset
        a scopo di simulazione usando alcuni comandi <cmd>genr</cmd> (come
        <cmd>genr uniform()</cmd> e <cmd>genr normal()</cmd>) per generare
        dati di prova. Questo comando può essere usato insieme a
        <cmd>loop</cmd>.  Si veda anche l'opzione <quote>seed</quote> del
        comando <cmdref targ="set"/>.
      </para>
      <para>
	Per impostazione predefinita, questo comando cancella tutti i dati
        presenti nell'ambiente di lavoro di gretl. Usando l'opzione
        <lit>--preserve</lit>, verranno mantenute tutte le matrici attualmente
        definite.
      </para>
    </description>

    <gui-access>
      <menu-path>/File/Nuovo dataset</menu-path>
    </gui-access>

  </command>

  <command name="ols" section="Estimation"
    label="Minimi quadrati ordinari">

    <usage>
      <arguments>
        <argument>variabile-dipendente</argument>
        <argument>variabili-indipendenti</argument>
      </arguments>
      <options>
        <option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
        </option>
        <option>
	  <flag>--robust</flag>
	  <effect>errori standard robusti</effect>
        </option>
        <option>
	  <flag>--simple-print</flag>
	  <effect>non mostra le statistiche ausiliarie</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>non mostra i risultati</effect>
        </option>
        <option>
	  <flag>--no-df-corr</flag>
	  <effect>sopprime la correzione per i gradi di libertà</effect>
        </option>
        <option>
	  <flag>--print-final</flag>
	  <effect>si veda sotto</effect>
        </option>
      </options>
      <examples>
        <example>ols 1 0 2 4 6 7</example>
	<example>ols y 0 x1 x2 x3 --vcv</example>
	<example>ols y 0 x1 x2 x3 --quiet</example>
      </examples>
    </usage>

    <description>
      <para context="gui">
        Calcola le stime minimi quadrati ordinari (OLS: Ordinary Least
        Squares) per il modello specificato.
      </para>

      <para context="cli">
        Calcola le stime minimi quadrati ordinari (OLS: Ordinary Least
        Squares) usando la <repl>variabile-dipendente</repl> e la lista
        di <repl>variabili-indipendenti</repl>, che possono essere 
        specificate per nome o numero. Il termine costante può essere
        indicato usando il numero 0.
      </para>

      <para>Oltre alle stime dei coefficienti e agli errori standard, il
        programma mostra i p-value per le statistiche <math>t</math>
	(a due code) e <math>F</math>.  Un p-value inferiore a
	0.01 indica significatività al livello dell'1 per cento ed è
        denotato con <lit>***</lit>. <lit>**</lit> indica invece la
        significatività tra l'1 e il 5 per cento, mentre <lit>*</lit>
	indica un livello di significatività tra il 5 e il 10 per cento.
	Vengono mostrate anche le statistiche di selezione del modello
        (il criterio di informazione di Akaike, AIC, e il criterio di
        informazione bayesiana di Schwarz, BIC). La formula usata per AIC
        è descritta in Akaike (1974), ossia meno due volte la log-verosimiglianza
        massimizzata più il doppio del numero di parametri stimati.</para>

      <para context="cli">Usando l'opzione <lit>--no-df-corr</lit> la correzione per i
	gradi di libertà non viene applicata nel calcolo della varianza
        stimata dell'errore (e quindi anche dell'errore standard delle
        stime dei parametri).</para>

      <para context="cli">L'opzione <lit>--print-final</lit> è utilizzabile solo nel contesto
	di un <cmdref targ="loop"/>. L'effetto è quello di eseguire la
        regressione in modo silenzioso per tutte le iterazioni del loop
        tranne l'ultima. Si veda la <guideref targ="loop-examples"/> per i dettagli.
      </para>

      <para context="cli">È possibile salvare alcune variabili
      interne generate durante la stima, usando il comando <cmdref
      targ="genr"/> subito dopo questo comando.
      </para>

      <para context="cli">La formula usata per generare gli errori
      standard robusti (quando viene usata l'opzione
      <lit>--robust</lit>) può essere modificata con il comando <cmdref
      targ="set"/>.  </para>
    </description>

    <gui-access>
      <menu-path>/Modello/OLS - Minimi quadrati ordinari</menu-path>
      <other-access>Pulsante Beta-hat sulla barra degli strumenti</other-access>
    </gui-access>

  </command>

  <command name="omit" section="Tests" label="Omette variabili">

    <usage>
      <arguments>
        <argument>lista-variabili</argument>
      </arguments>
      <options>
	<option>
	  <flag>--wald</flag>
	  <effect>esegue un test di Wald invece che un test F</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>non mostra le stime per il modello ridotto</effect>
	</option>
 	<option>
 	  <flag>--silent</flag>
 	  <effect>non mostra nulla</effect>
 	</option>
        <option>
         <flag>--auto</flag>
	 <optparm>alpha</optparm>
         <effect>eliminazione sequenziale, si veda oltre</effect>
       </option>
        <option>
          <flag>--inst</flag>
          <effect>omette come strumento, solo per TSLS</effect>
        </option>
        <option>
          <flag>--both</flag>
          <effect>omette come regressore e come strumento, solo per TSLS</effect>
        </option>
      </options>
      <examples>
        <example>omit 5 7 9</example>
        <example>omit seasonals --quiet</example>
        <example>omit --auto</example>
        <example>omit --auto=0.05</example>
      </examples>
    </usage>

    <description>
      <para context="gui">
	Questo comando stima di nuovo il modello dato, dopo aver omesso
	le variabili specificate o dopo aver omesso sequenzialmente le variabili
        non significative, se è stata selezionata l'apposita casella.
        Oltre ai consueti risultati della stima del modello, viene fornita una
        statistica test per la significatività congiunta delle variabili omesse:
        l'ipotesi nulla è che i coefficienti di tutte le variabili omesse siano
        pari a zero.
      </para>
      <para context="gui">
        Se il modello originale è stato stimato con OLS, la statistica test è un
        valore <math>F</math>, basato sulle somme dei quadrati dei residui
        del modello vincolato e di quello originale. Per stimatori diversi da OLS,
        o se si usa l'opzione Wald, la statistica è un valore chi-quadro di Wald
        asintotico basato sulla matrice di covarianza del modello originale.
      </para>
      <para context="gui">
        L'eliminazione sequenziale funziona nel modo seguente: ad ogni passo
        viene omessa la variabile con il p-value più alto, fino a che tutte le
        variabili restanti hanno un p-value inferiore a una certa soglia. La
        soglia predefinita è del 10 per cento (con due code), che può essere
        modificata usando l'apposito pulsante.
      </para>
      <para context="cli">
        Questo comando deve seguire un comando di stima e calcola un test per la
        significatività congiunta delle variabili nella
        <repl>lista-variabili</repl>, che deve essere un sottoinsieme delle
        variabili indipendenti del modello stimato in precedenza. In
        alternativa, se si usa l'opzione <lit>--auto</lit> viene attivata la
        procedura di eliminazione sequenziale: ad ogni passo
        viene omessa la variabile con il p-value più alto, fino a che tutte le
        variabili restanti hanno un p-value inferiore a una certa soglia. La
        soglia predefinita è del 10 per cento (con due code), che può essere
        modificata aggiungendo <quote><lit>=</lit></quote> e un valore tra 0 e 1
        (senza spazi), come nel quarto esempio mostrato sopra.
      </para>
      <para context="cli">
	Se il modello originale è stato stimato con OLS, la statistica test è
        un valore <math>F</math>, basato sulle somme dei quadrati dei
        residui del modello vincolato e di quello originale, a meno che
        quest'ultimo sia stato stimato usando errori standard robusti.
	In questo caso, il valore <math>F</math> viene calcolato delle
        stime robuste della matrice di covarianza del modello originale (è la
        versione <math>F</math> di un test di Wald).
      </para>
      <para context="cli">
	Per gli stimatori diversi da OLS, o se si usa l'opzione <lit>--wald</lit>,
        la statistica usata è un valore chi-quadro asintotico di Wald, basato
        sulla matrice di covarianza del modello originale.
      </para>
      <para context="cli">
        Per impostazione predefinita, viene stimato il modello vincolato,
        vengono mostrate le stime e il modello vincolato rimpiazza quello
        originale come <quote>modello attuale</quote> nel caso si voglia,
        ad esempio, recuperare i residui con <lit>$uhat</lit> (o eseguire
        test ulteriori, come <cmd>add</cmd> o <cmd>omit</cmd>).  
      </para>
      <para>
	Usando l'opzione Wald, il modello vincolato
        non viene stimato (quindi il modello attuale non viene rimpiazzato).
        L'opzione <lit>--quiet</lit> sopprime la stampa dei risultati del
        modello vincolato (se esso viene stimato): viene mostrato solo il
        risultato del test. Se il modello vincolato viene stimato e ne viene
        chiesta la stampa, l'opzione <lit>--vcv</lit> ha l'effetto di
        mostrare la matrice di covarianza dei coefficienti del modello
        vincolato, altrimenti quest'opzione è ignorata.
      </para>
      <para context="cli">
	Se si usa l'opzione <lit>--silent</lit>, non viene mostrato
        alcun risultato; tuttavia, i risultati del test possono essere
        recuperati usando le variabili speciali
	<lit>$test</lit> e <lit>$pvalue</lit>.
      </para>
      <para context="cli">
       Se il modello originale è stato stimato con i minimi quadrati a due
       stadi, può sorgere un'ambiguità: le nuove variabili vanno omesse come
       regressori, come strumenti o con entrambe le funzioni? Per risolvere
       l'ambiguità, nella modalità predefinita le variabili sono omesse
       dall'elenco dei regressori, se si usa l'opzione <lit>--inst</lit> sono
       omesse dall'elenco degli strumenti, mentre se si usa l'opzione
       <lit>--both</lit> sono rimosse totalmente dal modello. Queste due opzioni
       sono incompatibili con l'opzione <lit>--wald</lit>; se uno o più strumenti
       vengono omessi, il modello va ri-stimato.
      </para>
    </description>

    <gui-access>
      <menu-path>Finestra del modello, /Test/OMIT - Ometti variabili</menu-path>
    </gui-access>

  </command>

  <command name="online" section="Dataset" context="gui"
    label="Accesso ai database online">

    <description>
      <para>
	Gretl può accedere ai database della Wake Forest University
	(se il proprio computer è connesso a internet).</para>

      <para>Dal menù <quote>File, Database</quote>, selezionare
	<quote>Sul server di gretl</quote>: apparirà una finestra che
        mostra i database disponibili alla Wake Forest (a seconda della
        località e della velocità della connessione internet,
        l'operazione può richiedere alcuni secondi). Oltre al nome del
        database e a una breve descrizione, apparirà un campo
        <quote>Stato</quote>, che mostra se il database è stato
        installato localmente (sul disco del computer), e, in caso
        positivo, se la versione installata è aggiornata a quella
        disponibile sul server.</para>

      <para>Se un database è stato installato localmente ed è
      aggiornato, non c'è nessun vantaggio nell'accedervi attraverso il
      server, mentre per un database non installato o non aggiornato, può essere
      utile scaricare un elenco delle serie di dati, facendo clic su
      <quote>Scarica l'elenco delle serie</quote>. Apparirà una nuova
      finestra da cui è possibile visualizzare i valori di una serie
      scelta, vederne il grafico o importarle in gretl. È possibile
      effettuare queste operazioni usando il menù <quote>Serie</quote>,
      o attraverso il menù pop-up che appare facendo clic col tasto
      destro su una serie. È anche possibile cercare nell'elenco una
      variabile in particolare, usando il comando <quote>Trova</quote>
      del menù.</para>

      <para>Per poter accedere a un database anche offline, basta selezionare la
      riga del database desiderato nella prima finestra e premere il pulsante 
      <quote>Installa</quote>. Il database verrà scaricato in formato
      compresso, verrà decompresso e installato sul proprio disco fisso,
      in modo da poter essere caricato usando il menù <quote>File,
      Database, Gretl</quote>.</para>

    </description>
  </command>

  <command name="open" section="Dataset" label="Apre un dataset" context="cli">

    <usage>
      <arguments>
        <argument>file-dati</argument>
      </arguments>
      <options>
	<option>
	  <flag>--www</flag>
	  <effect>usa un database sul server di gretl</effect>
	</option>
	<option>
	  <note>Si veda oltre per le opzioni specifiche per i fogli elettronici</note>
	</option>
      </options>
      <examples>
        <example>open data4-1</example>
        <example>open voter.dta</example>
	<example>open fedbog --www</example>
      </examples>
    </usage>

    <description>
      <para>
        Apre un file di dati. Se è già stato aperto un file di dati, esso viene
        sostituito da quello selezionato. Se non si specifica un percorso
        completo, il programma cercherà automaticamente il file in alcuni
        percorsi predefiniti. Se non si specifica un'estensione per il file,
        come nel primo degli esempi, gretl assume che si tratti di un file di
        dati standard, con estensione <lit>.gdt</lit>. A seconda del nome del
        file e di alcune sue caratteristiche, gretl cerca di indovinare il
        formato dei dati (standard, testo semplice, CSV, MS Excel, Stata, ecc).
      </para>
      <para>
	Quando si apre un file di un foglio elettronico (Gnumeric, Open Document o XLS),
        è possibile fornire fino a tre parametri aggiuntivi, oltre al nome del
        file. Per prima cosa, è possibile selezionare un particolare foglio di
        lavoro all'interno del file, indicando il suo numero con la
        sintassi <lit>--sheet=2</lit>, oppure indicando il suo nome tra
        virgolette doppie, usando la sintassi <lit>--sheet="MacroData"</lit>.
        L'impostazione predefinita consiste nel leggere il primo foglio di
        lavoro del file. È anche possibile specificare la riga/colonna da cui
        iniziare a leggere, usando la sintassi
      </para>
      <code>
	--coloffset=3 --rowoffset=2
      </code>
      <para>
	che indica a gretl di ignorare le prime 3 colonne e le prime 2 righe.
        L'impostazione predefinita consiste nel leggere tutte le celle del
        foglio, a partire dalla prima in alto a sinistra.
      </para>

      <para>
	Questo comando può essere usato anche per aprire un database (gretl,
	RATS 4.0 o PcGive) per la lettura. In questo caso, dev'essere seguito dal comando
        <cmdref targ="data"/> per estrarre una particolare serie dal database.
        Se si usa l'opzione <lit>www</lit>, il programma cercherà di accedere al
        database specificato sul server di gretl &mdash; ad esempio il database
        "Federal Reserve interest rates" nel terzo degli esempi visti sopra.
      </para>
    </description>

    <gui-access>
      <menu-path>/File/Apri dati</menu-path>
      <other-access>Trascinare un file di dati in gretl (MS Windows o Gnome)</other-access>
    </gui-access>

  </command>

  <command name="orthdev" section="Transformations" 
    label="Deviazioni ortogonali" context="cli">

    <usage>
      <arguments>
        <argument>lista-variabili</argument>
      </arguments>
    </usage>

    <description>
      <para>
        Utilizzabile solo con dati panel. Per ognuna delle variabili nella
        <repl>lista-variabili</repl> viene generata una serie di deviazioni
        ortogonali in avanti, salvata col nome della variabile prefissata da
	<lit>o_</lit>. Quindi, <cmd>orthdev x y</cmd> crea le nuove variabili
        <lit>o_x</lit> e <lit>o_y</lit>.
      </para>
      <para>
	I valori sono salvati con un periodo di ritardo rispetto alla loro
        collocazione temporale (ossia, <lit>o_x</lit> all'osservazione <math>t</math>
        contiene la deviazione che, in senso stretto, corrisponde al periodo
        <math>t</math> &minus; 1). Questo comportamento è coerente con quello
        delle differenze prime: viene persa la prima osservazione di ogni serie,
        non l'ultima.
      </para>
    </description>

  </command>

  <command name="outfile" section="Printing" label="Stampa diretta su file" context="cli">

    <usage>
      <arguments>
        <argument>file-output</argument>
        <argument>opzione</argument>
      </arguments>
      <options>
        <option>
	  <flag>--append</flag>
	  <effect>aggiunge al file</effect>
        </option>
        <option>
	  <flag>--close</flag>
	  <effect>chiude il file</effect>
        </option>
        <option>
	  <flag>--write</flag>
	  <effect>sovrascrive il file</effect>
        </option>
      </options>
      <examples>
        <example>outfile --write regress.txt</example>
        <example>outfile --close</example>
      </examples>
    </usage>

    <description>
      <para>
        Scrive i risultati sul <repl>file-output</repl>, fino a nuovo
        ordine. Usando l'opzione <lit>--append</lit>, i risultati
        vengono aggiunti a un file esistente, mentre <lit>--write</lit>
        apre un nuovo file (o ne sovrascrive uno esistente). Può essere
        aperto solo un file alla volta.
      </para>

      <para>
        L'opzione <lit>--close</lit> può essere usata per chiudere
        un file di output aperto in precedenza, tornando a scrivere i
        risultati sul canale predefinito.
      </para>

      <para>
        Nel primo degli esempi precedenti viene aperto il file
	<filename>regress.txt</filename>, mentre nel secondo viene
        chiuso. Se prima del comando <lit>--close</lit> fosse
        eseguito un comando <cmd>ols</cmd>, i risultati della
        regressione verrebbero scritti su
        <filename>regress.txt</filename> invece che sullo schermo.
      </para>

      <para>
        Esiste una variante: se si usa la parola chiave <lit>null</lit>
        al posto di un nome di file insieme all'opzione <lit>--write</lit>,
        l'effetto è quello di sopprimere la stampa dei risultati fino alla
        successiva istruzione <lit>outfile --close</lit>.
      </para>

    </description>

  </command>

  <command name="panel" section="Estimation" label="Modelli panel">

    <usage>
      <options>
	<option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
	</option>
        <option>
	  <flag>--fixed-effects</flag>
	  <effect>stima con effetti di gruppo fissi</effect>
        </option>
 	<option>
	  <flag>--random-effects</flag>
	  <effect>effetti casuali o modello GLS</effect>
	</option>
	<option>
	  <flag>--between</flag>
	  <effect>stima il modello tra i gruppi</effect>
        </option>
        <option>
	  <flag>--time-dummies</flag>
	  <effect>include variabili dummy temporali</effect>
        </option>
        <option>
	  <flag>--unit-weights</flag>
	  <effect>minimi quadrati ponderati</effect>
	</option>
	<option>
	  <flag>--iterate</flag>
	  <effect>stima iterativa</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>mostra meno risultati</effect>
        </option>
        <option>
	  <flag>--verbose</flag>
	  <effect>mostra più risultati</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
        Stima un modello panel, per impostazione predefinita usando lo stimatore
        a effetti fissi; la stima è implementata sottraendo le
        medie di gruppo o delle unità dai dati originali.
      </para>
      <para context="cli">
        Se si usa l'opzione <lit>--random-effects</lit>, viene usato il modello
        GLS a effetti casuali, usando il metodo di Swamy e Arora.
      </para>
      <para context="cli">
        In alternativa, con l'opzione <lit>--unit-weights</lit>, il modello viene
        stimato con i minimi quadrati ponderati, con i pesi costruiti a partire
        dalla varianza residua per le rispettive unità cross section nel
        campione. Solo in questo caso, è possibile usare l'opzione
        <lit>--iterate</lit> per produrre stime iterative: nel caso di
        convergenza, le stime sono di massima verosimiglianza.
      </para>
      <para context="cli">
        Come ulteriore alternativa, se si usa l'opzione <lit>--between</lit>,
        viene stimato il modello tra i gruppi, ossia una regressione OLS usando
        le medie dei gruppi.
      </para>
      <para context="gui">
        Se si seleziona la casella "Effetti casuali", vengono calcolate stime a
        effetti casuali, usando il metodo di Swamy e Arora.
      </para>
      <para>
	Per maggiori dettagli sulla stima panel, si veda la <guideref targ="chap-panel"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modello/Panel</menu-path>
    </gui-access>

  </command>

  <command name="panel-between" section="Estimation" context="gui"
    label="Modello panel tra i gruppi">

    <description>
      <para>
        Questa finestra di dialogo permette di immettere la specificazione per
        un modello panel <quote>tra i gruppi</quote>, ossia una regressione che
        usa le medie di gruppo dei dati, ignorando quindi la variazione
        all'interno dei gruppi. Questo modello di solito non è di grande
        interesse in sé, ma può essere utile a scopo di confronto, ad esempio
        rispetto al modello a effetti fissi.
      </para>
    </description>

  </command>    
  
  <command name="panel-mode" section="Dataset" context="gui"
    label="Organizzazione dei dati panel">

    <description>
      <para>
	Questa finestra di dialogo offre tre opzioni per definire un dataset
        come panel. Le prime due opzioni richiedono che il dataset sia già
        organizzato in un formato panel (anche se gretl può non essersi accorto
        di ciò). La terza opzione richiede che il dataset contenga variabili che
        rappresentano la struttura panel.
      </para>
      <para>
        Pila di serie storiche: date N unità cross section nel dataset e T
        osservazioni temporali per ogni unità, selezionando questa opzione si
        dice a gretl che il dataset attuale è composto da N blocchi consecutivi
        di T osservazioni ciascuno. Il passo successivo consiste nello
        specificare il valore di N.
      </para>
      <para>
        Pila di dati cross section: si indica a gretl che il dataset è composto
        da T blocchi consecutivi di N osservazioni cross section ciascuno.
        observations, one for each time period.  Il passo successivo consiste
        nello specificare il valore di N.
      </para>
      <para>
	Usa variabili indice: si indica che il dataset è organizzato in modo
        qualsiasi, ma contiene due variabili che indicizzano le unità cross
        section e quelle temporali. Il passo successivo consiste nell'indicare
        queste due variabili, che devono essere strettamente positive.
       </para>
     </description>
 
  </command>

  <command name="panel-wls" section="Estimation" context="gui"
    label="Minimi quadrati ponderati a gruppi">

    <description>
      <para>
        Minimi quadrati ponderati a gruppi per dati panel. Calcola le stime WLS
	con i pesi basati sulle varianze stimate degli errori per le rispettive
        unità cross section nel campione.
      </para>
      <para>
	Selezionando l'opzione di iterazione, la procedura viene iterata: ad
        ogni passo, i residui vengono ricalcolati usando le stime WLS
        disponibili per i parametri, fornendo così un nuovo insieme di stime per
        le varianze degli errori, e quindi un nuovo insieme di pesi.
	Le iterazioni si arrestano quando la massima differenza nelle stime dei
        parametri tra un passo e l'altro scende sotto 0.0001, oppure se il
        numero di iterazioni supera 20. Se la procedura converge, le stime
        risultanti sono di massima verosimiglianza.
      </para>
    </description>

  </command>

  <command name="pca" section="Statistics"
    label="Analisi delle componenti principali">

    <usage>
      <arguments>
        <argument>lista-variabili</argument>
      </arguments>
      <options>
         <option>
	  <flag>--covariance</flag>
	  <effect>usa la matrice di covarianza</effect>
        </option>	
        <option>
	  <flag>--save</flag>
	  <effect>salva le componenti principali</effect>
        </option>
        <option>
	  <flag>--save-all</flag>
	  <effect>salva tutte le componenti</effect>
        </option>
      </options>
    </usage>

    <description context="gui">
      <para>
        Analisi delle componenti principali. Mostra gli autovalori
        della matrice di correlazione (o della matrice di covarianza, se si usa
        la casella opportuna) per le variabili selezionate, insieme alla
        proporzione della varianza comune spiegata da ogni componente. Mostra
        anche i corrispondenti autovettori (o <quote>pesi della
        componente</quote>).
      </para>
      <para>
	Nella finestra che mostra i risultati è possibile salvare le componenti
        principali come serie nel dataset.
      </para> 
    </description>

    <description context="cli">
      <para>
        Analisi delle componenti principali. Mostra gli autovalori
        della matrice di correlazione (o della matrice di covarianza, se si
        usa l'opzione <flag>--covariance</flag>) per le variabili nella
	<repl>lista-variabili</repl>, insieme alla proporzione della
        varianza comune spiegata da ogni componente. Mostra anche i
        corrispondenti autovettori (o <quote>pesi della componente</quote>).
      </para>  
      <para>
        Usando l'opzione <lit>--save</lit>, le componenti con autovalori
        maggiori di 1.0 vengono salvati nel dataset come variabili, con i nomi
        <lit>PC1</lit>, <lit>PC2</lit> e così via.  Queste variabili artificiali
        sono definite come la somma del peso della componente moltiplicato per
        <lit>Xi</lit> standardizzato, dove <lit>Xi</lit> denota la
        <math>i</math>-esima variabile nella <repl>lista-variabili</repl>.
      </para>
      <para>
        Usando l'opzione <lit>--save-all</lit>, vengono salvate
        tutte le componenti, come descritto sopra.
      </para> 
    </description>

    <gui-access>
      <menu-path>/Visualizza/Componenti principali</menu-path>
      <other-access>Pop-up nella finestra principale (selezione multipla)</other-access>
    </gui-access>

  </command>

  <command name="pergm" section="Statistics"
    label="Periodogramma">

    <usage>
      <arguments>
        <argument>nome-variabile</argument>
        <argument optional="true">banda</argument>
      </arguments>
      <options>
        <option>
	  <flag>--bartlett</flag>
	  <effect>usa la finestra di Bartlett</effect>
        </option>
        <option>
	  <flag>--log</flag>
	  <effect>usa una scala logaritmica</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Calcola e mostra (graficamente se non si è in modalità batch)
        lo spettro della variabile specificata.  Per impostazione predefinita
        viene mostrato il periodogramma nel campione, mentre usando  l'opzione
	<lit>--bartlett</lit>, lo spettro viene stimato usando una
        finestra di Bartlett per i ritardi (si veda ad esempio <book>Econometric
        Analysis</book> di Greene per una discussione su questo argomento).
        L'ampiezza predefinita della fiestra di Bartlett è pari a due volte la
        radice quadrata dell'ampiezza campionaria, ma questo valore può essere
        impostato manualmente usando il parametro <repl>banda</repl>, fino a un
        massimo pari a metà dell'ampiezza campionaria. Usando l'opzione <lit>--log</lit>,
        lo spettro viene rappresentato su una scala logaritmica.
      </para>
      <para>
        Quando viene mostrato il periodogramma del campione, vengono mostrati
        anche due test per l'integrazione frazionale (<quote>memoria
        lunga</quote>) della serie, ossia il test di Geweke e Porter-Hudak
        (GPH), e lo stimatore locale di Whittle. L'ipotesi nulla in entrambi
        i casi è che l'ordine di integrazione sia zero. Per impostazione
        predefinita, l'ordine per questi test è il valore minore tra
        <math>T</math>/2 e <math>T</math><sup>0.6</sup>; anche
        questo valore può essere modificato con il parametro di banda.
       </para>
    </description>

    <gui-access>
      <menu-path>/Variabile/Spettro</menu-path>
      <other-access>Menù pop-up nella finestra principale (selezione singola)</other-access>
    </gui-access>

  </command>

  <command name="poisson" section="Estimation" label="Stima Poisson">

    <usage>
      <arguments>
        <argument>variabile-dipendente</argument>
        <argument>variabili-indipendenti</argument>
        <argument separated="true" optional="true">offset</argument>
      </arguments>
      <options>
        <option>
          <flag>--vcv</flag>
          <effect>mostra la matrice di covarianza</effect>
        </option>
        <option>
          <flag>--verbose</flag>
          <effect>mostra i dettagli delle iterazioni</effect>
        </option>
      </options>
      <examples>
        <example>poisson y 0 x1 x2</example>
       <example>poisson y 0 x1 x2 ; S</example>
      </examples>
    </usage>

    <description>
      <para>Stima una regressione di Poisson, in cui la variabile dipendente
      rappresenta le occorrenze di un qualche tipo di evento e può assumere solo
      valori interi non negativi.
      </para>

      <para>Se una variabile casuale discreta <math>Y</math> segue la
      distribuzione di Poisson, 
        <equation status="display"
          tex="\[\mathrm{Pr}(Y = y) = \frac{e^{-v} v^y}{y!}\]"
          ascii="Pr(Y = y) = exp(-v) * v^y / y!"
          graphic="poisson1"/>
      per <math>y</math> = 0, 1,
      2,&hellip;.  La media e la varianza della distribuzione sono entrambe uguali a
      <math>v</math>. Nel modello di regressione di Poisson, il parametro
      <math>v</math> è rappresentato da una funzione di una o più varabili
      indipendenti. La versione più comune del modello (e l'unica supportata da
      gretl) ha
        <equation status="display"
          tex="\[v = \mathrm{exp}(\beta_0+\beta_1 x_1+\beta_2 x_2 + \cdots)\]"
          ascii="v = exp(b0 + b1*x1 + b2*x2 + ...)"
          graphic="poisson2"/>
      ossia il logaritmo di
      <math>v</math> è una funzione lineare delle variabili indipendenti.
      </para>

      <para>Opzionalmente è possibile aggiungere una variabile
      <quote>offset</quote> alla specificazione, ossia una variabile di scala,
       il cui logaritmo viene aggiunto alla funzione di regressione lineare
       (con un coefficiente implicito di 1.0). Ciò ha senso se si ipotizza che
       il numero di occorrenze dell'evento in questione sia proporzionale a
       qualche fattore noto, a parità di altre condizioni. Ad esempio, il numero
       di incidenti stradali può essere ipotizzato proporzionale al volume del
       traffico, che potrebbe essere specificato come una variabile di
       <quote>offset</quote> in un modello di Poisson per il tasso di incidenti.
       La variabile di offset dev'essere strettamente positiva.
      </para>

    </description>

    <gui-access>
      <menu-path>/Modello/Modelli non lineari/Poisson</menu-path>
    </gui-access>

  </command>

  <command name="plot" section="Graphs" label="Grafici ASCII" context="cli">

    <usage>
      <arguments>
        <argument>lista-variabili</argument>
      </arguments>
      <options>
        <option>
	  <flag>--one-scale</flag>
	  <effect>forza l'uso di un'unica scala</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Disegna i valori delle variabili indicate per l'intervallo di
        osservazioni attuale, usando simboli ASCII. Ogni riga
        rappresenta un'osservazione e i valori sono disegnati
        orizzontalmente. Il comportamento predefinito è di scalare la
        variabili in modo appropriato. Si veda anche <cmdref targ="gnuplot"/>.
      </para>
    </description>

  </command>

  <command name="print" section="Printing" label="Stampa dati o stringhe" context="cli">

    <usage>
      <arguments>
	<argument>lista-variabili</argument>
	<argument alternate="true">stringa-letterale</argument>
      </arguments>
      <options>
	<option>
	  <flag>--byobs</flag>
	  <effect>per osservazione</effect>
	</option>
	<option>
	  <flag>--long</flag>
	  <effect>usa 10 cifre significative, o più</effect>
	</option>
 	<option>
 	  <flag>--no-dates</flag>
 	  <effect>usa i numeri delle osservazioni</effect>
 	</option>
      </options>
      <examples>
	<example>print x1 x2 --byobs</example>
	<example>print "Questa è una stringa"</example>
      </examples>
    </usage>

    <description>
      <para>
	Se viene indicata una <repl>lista-variabili</repl>, stampa i
        valori delle variabili specificate, altrimenti stampa i valori
        di tutte le variabili nel dataset in uso. Usando l'opzione
	<lit>--byobs</lit> i dati vengono stampati per osservazione,
        altrimenti sono stampati per variabile.
      </para>
      <para>
        Usando l'opzione <lit>--long</lit> i dati vengono stampati per variabile
        con una precisione superiore al normale; in modalità predefinita,
        vengono mostrate 10 cifre significative, ma è possibile modificare
        questo numero con il comando  <cmdref targ="set"/>.
      </para>

      <para>
 	Se si usa l'opzione <lit>--byobs</lit> e i dati sono mostrati per
        osservazione, il comportamento predefinito è quello di mostrare la data
        (per serie storiche) o il marcatore (se esiste) all'inizio di ogni riga.
 	L'opzione <lit>--no-dates</lit> sopprime la visualizzazione delle date o
        dei marcatori: viene mostrato solo un semplice numero di osservazione.
      </para>
 
      <para>
	Se l'argomento di <cmd>print</cmd> è una stringa letterale (che
        deve iniziare con le virgolette doppie <lit>"</lit>), la stringa
        viene stampata così come è stata indicata. Si veda anche <cmdref
          targ="printf"/>.
      </para>
      
      <para>
        Nota: c'è un <quote>trucco</quote> con questo comando, usando 
        l'opzione <lit>--byobs</lit>, che può essere utile quando si lavora
        su un dataset con valori mancanti. Se si fornisce una lista di variabili
        seguite da un punto e virgola e da una variabile finale, la variabile
        finale non viene mostrata, ma viene usata per selezionare le
        osservazioni da mostrare. Le osservazioni per cui la variabile finale
        assume valore 0 non verranno mostrate. Ad esempio, si supponga di avere
        la serie giornaliera <lit>x</lit> e di volere la lista delle date per
        cui <lit>x</lit> ha valori mancanti. Si può procedere nel modo
        seguente:
      </para>
      <code>
	genr filt = missing(x)
	print x ; filt --byobs
      </code>

    </description>

    <gui-access>
      <menu-path>/Dati/Mostra valori</menu-path>
    </gui-access>

  </command>

  <command name="printf" section="Printing" label="Stampa formattata" context="cli">

    <usage>
      <arguments>
        <argument>formato</argument>
	<argpunct>, </argpunct>
        <argument>argomenti</argument>
      </arguments>
    </usage>

    <description>
      <para>
        Stampa valori scalari e/o stringhe formattandoli secondo le indicazioni
        di una stringa di formato (che supporta un piccolo sottoinsieme del
        comando <lit>printf()</lit> del linguaggio di programmazione C). I
        formati numerici riconosciuti sono <lit>%e</lit>, <lit>%E</lit>,
        <lit>%f</lit>, <lit>%g</lit>, <lit>%G</lit> e <lit>%d</lit>, con i
        vari modificatori disponibili in C. Esempi: la stringa di formato
        <lit>%.10g</lit> stampa un valore con 10 cifre significative;
        <lit>%12.6f</lit> stampa un valore con 6 cifre decimali e una larghezza
        di 12 caratteri. Per formattare le stringhe occorre usare la stringa
        di formato <lit>%s</lit>.
      </para>  

      <para>La stringa di formato deve essere racchiusa tra virgolette
        doppie, i valori da stampare devono seguire la stringa di
        formato, separati da virgole. I valori possono avere tre forme:
	a) i nomi di variabili nel dataset; b) espressioni valide per
        il comando <cmd>genr</cmd>; c) le funzioni speciali <lit>varname()</lit>
        o <lit>date()</lit>. L'esempio seguente stampa i valori
        di due variabili e quello di un'espressione calcolata:</para>

      <code>
	ols 1 0 2 3
	genr b = $coeff(2)
	genr se_b = $stderr(2)
	printf "b = %.8g, standard error %.8g, t = %.4f\n", b, se_b, b/se_b
      </code>

      <para>
 	Le prossime righe mostrano l'uso delle funzioni varname e date, che
        rispettivamente mostrano il nome di una variabile dato il suo numero
        identificativo, e una stringa data, dato un numero di osservazione.
      </para>
       <code>
 	printf "Il nome della variabile %d è %s\n", i, varname(i)
 	printf "La data dell'osservazione %d è %s\n", j, date(j)
      </code>
      <para>
	Se si usa un argomento matrice insieme a un formato numerico, l'intera
        matrice verrà stampata usando per ogni elemento il formato numerico
        indicato.
      </para>
      <para>
	La lunghezza massima di una stringa di formato è di 127
        caratteri. Vengono riconosciute le sequenze di escape
	<lit>\n</lit> (newline), <lit>\t</lit> (tab),
	<lit>\v</lit> (tab verticale) e <lit>\\</lit> (barra inversa).
        Per stampare un segno di percentuale, si usi <lit>%%</lit>.
      </para>
      <para>
	Come in C, i valori numerici che fanno parte del formato (larghezza e
        precisione) possono essere dati direttamente come numeri, come in
	<lit>%10.4f</lit>, o come variabili. Nell'ultimo caso, si inseriscono
        asterischi nella stringa di formato e si forniscono nell'ordine gli
        argomenti corrispondenti. Ad esempio:
      </para>
      <code>
	scalar larghezza = 12
	scalar precisione = 6
	printf "x = %*.*f\n", larghezza, precisione, x
      </code>
    </description>

  </command>

  <command name="probit" section="Estimation"
    label="Stima probit">

    <usage>
      <arguments>
        <argument>variabile-dipendente</argument>
        <argument>variabili-indipendenti</argument>
      </arguments>
      <options>
	<option>
	  <flag>--robust</flag>
	  <effect>errori standard robusti</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
	</option>
	<option>
          <flag>--verbose</flag>
	  <effect>mostra i dettagli delle iterazioni</effect>
	</option>
	<option>
	  <flag>--p-values</flag>
	  <effect>mostra i p-value invece delle pendenze</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
        Se la variabile dipendente è binaria (tutti i suoi valori sono 0 o 1),
        esegue una stima di massima verosimiglianza dei coefficienti delle
        <repl>variabili-indipendenti</repl> con il metodo
        <quote>binary response model regression</quote> (BRMR) descritto in
        Davidson e MacKinnon (2004). Visto che il modello è nonlineare, le
        pendenze dipendono dai valori delle variabili indipendenti: per
        impostazione predefinita, al posto dei p-value vengono mostrate le
        pendenze rispetto ad ognuna delle variabili indipendenti, calcolate in
        corrispondenza della media della variabile. Questo comportamento può
        essere soppresso usando l'opzione <lit>--p-values</lit>.  La statistica
        chi-quadro testa l'ipotesi nulla che tutti i coefficienti tranne la
        costante siano pari a zero.
      </para>
      <para context="cli">
        In modalità predefinita, gli errori standard sono calcolati con
        l'inversa negativa dell'Hessiana.  Se si usa l'opzione
        <lit>--robust</lit>, verranno calcolati gli errori standard QML o quelli
        di Huber&ndash;White. In questo caso, la matrice di covarianza stimata è
        un <quote>sandwich</quote> dell'inversa dell'Hessiana stimata e del
        prodotto esterno del gradiente. Per i dettagli, si veda Davidson e
        MacKinnon 2004, cap. 10.
      </para>
      <para context="gui">
        In modalità predefinita, gli errori standard sono calcolati con
        l'inversa negativa dell'Hessiana.  Se si seleziona la casella "Errori
        standard robusti", verranno calcolati gli errori standard QML o quelli
        di Huber&ndash;White. In questo caso, la matrice di covarianza stimata è
        un <quote>sandwich</quote> dell'inversa dell'Hessiana stimata e del
        prodotto esterno del gradiente. Per i dettagli, si veda Davidson e
        MacKinnon 2004, cap. 10.
      </para>
      <para>
        Se la variabile dipendente non è binaria, ma è discreta, si ottengono
        stime Logit ordinate. Se la variabile scelta come dipendente non è
        discreta, viene emesso un messaggio di errore.
      </para>
      <para>
	Il probit per l'analisi delle proporzioni non è ancora stato
        implementato in	<program>gretl</program>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modello/Modelli non lineari/Probit</menu-path>
    </gui-access>

  </command>

  <command name="pvalue" section="Utilities" label="Calcola p-value" context="cli">

    <usage>
      <arguments>
        <argument>distribuzione</argument>
        <argument optional="true">parametri</argument>
	<argument>valore-x</argument>
      </arguments>
      <examples>
        <example>pvalue z zscore</example>
	<example>pvalue t 25 3.0</example>
	<example>pvalue X 3 5.6</example>
	<example>pvalue F 4 58 fval</example>
	<example>pvalue G forma scala x</example>
        <example>pvalue B bprob 10 6</example>
	<example>pvalue P lambda x</example>
	<example>pvalue W shape scale x</example>
      </examples>
    </usage>

    <description>
      <para>
	Calcola l'area alla destra del <repl>valore-x</repl> nella
        distribuzione indicata (<lit>z</lit> per la Gaussiana,
	<lit>t</lit> per la <math>t</math> di Student, <lit>X</lit>
	per la chi-quadro, <lit>F</lit> per la <math>F</math>,
	<lit>G</lit> per la gamma, <lit>B</lit> per la binomiale,
        <lit>P</lit> per la Poisson e <lit>W</lit> for Weibull).
      </para>
      <para>
	A seconda della distribuzione, occorre fornire le seguenti informazioni,
        prima del <repl>valore-x</repl>: per le distribuzioni <math>t</math>
        e chi-quadro occorre indicare i gradi di libertà; per la
        <math>F</math> sono richiesti i gradi di libertà al numeratore e
        al denominatore; per la gamma sono richiesti il parametro di forma e
        quello di scala; per la binomiale sono richieste la probabilità di
        <quote>successo</quote> e il numero di prove; per la distribuzione di
        Poisson va indicato il parametro &lgr; (che rappresenta sia la media che
        la varianza); per la distribuzione Weibull, i parametri di forma e scala.
        Come si vede dagli esempi precedenti, gli argomenti
        numerici possono essere indicati sotto forma di numero o come nomi di
        variabili.
      </para>
      <para>
        Si noti che talvolta la distribuzione gamma viene caratterizzata dai
        parametri di media e varianza, invece che da quelli di forma e scala.
        La media è il prodotto di forma e scala, mentre la varianza è il
        prodotto tra la forma e il quadrato della scala. Quindi la scala si può
        ottenere come la varianza divisa per la media, mentre la forma come la
        media divisa per la scala.
      </para>
    </description>

    <gui-access>
      <menu-path>/Strumenti/Calcola p-value</menu-path>
    </gui-access>

  </command>
  
  <command name="qlrtest" section="Tests" label="Test del rapporto di verosimiglianza di Quandt">

    <description>
      <para>
        Per un modello stimato con OLS su serie storiche, esegue il test del
        rapporto di verosimiglianza di Quandt (QLR) per un break strutturale in
        un punto incognito del campione, escludendo il 15% delle osservazioni
        all'inizio e ella fine del campione.
      </para>
      <para>
	Per ogni possibile punto di rottura compreso nel 70% centrale delle
        osservazioni, viene eseguito un test di Chow (si veda <cmdref
          targ="chow"/>). La statistica del test QLR è il massimo dei valori
	<math>F</math> di questi test; segue una distribuzione non
        standard, i cui valori critici sono presi da <book>Introduction to
          Econometrics</book> di Stock e Watson (2003). Se la statistica QLR
        eccede il valore critico per un dato livello di significatività, è
        possibile inferire che i parametri del modello non sono costanti.
        Questa statistica può essere usata per riconoscere forme di instabilità
        diverse da un singolo punto di rottura, ad esempio più punti di rottura
        o un lento cambiamento dei parametri.
      </para>
    </description>

    <gui-access>
      <menu-path>Finestra del modello, /Test/QLR</menu-path>
    </gui-access>

  </command>

  <command name="quantreg" section="Estimation" 
    label="Regressione quantile">

    <usage>
      <arguments>
	<argument>tau</argument>
        <argument>variabile-dipendente</argument>
        <argument>variabili-indipendenti</argument>
      </arguments>
      <options>
	<option>
	  <flag>--robust</flag>
	  <effect>errori standard robusti</effect>
        </option>
        <option>
	  <flag>--intervals</flag>
	  <optparm>level</optparm>
	  <effect>calcola gli intervalli di confidenza</effect>
        </option>
        <option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
        </option>
      </options>
      <examples>
	<example>quantreg 0.25 y 0 xlist</example>
	<example>quantreg 0.5 y 0 xlist --intervals</example>
	<example>quantreg 0.5 y 0 xlist --intervals=.95</example>
	<example>quantreg tauvec y 0 xlist --robust</example>
      </examples>
	<demos>
	  <demo>mrw_qr.inp</demo>
	</demos>
    </usage>

    <description context="gui">
      <para>
        Regressione quantile. Per impostazione predefinita, gli errori standard
        sono calcolati con la formula asintotica di Koenker e Bassett
        (<book>Econometrica</book>, 1978), ma se si attiva la casella
        <quote>robusto</quote>, verrà usata la variante robusta per
        l'eteroschedasticità di Koenker e Zhao (<book>Journal of Nonparametric
        Statistics</book>, 1994).
      </para>
      <para>
	Se si abilita l'opzione <quote>Calcola intervalli di confidenza</quote>,
	gretl calcolerà gli intervalli di confidenza invece degli errori
        standard. La casella <quote>robust</quote> mantiene il suo effetto: se
        non è selezionata, gli intervalli sono calcolati nell'ipotesi di errori
        IID, altrimenti gretl usa lo stimatore robusto sviluppato da
	Koenker e Machado (<book>Journal of the American
	Statistical Association</book>, 1999).  Si noti che questi intervalli
        non sono calcolati semplicemente aggiungendo e sottraendo un certo numero
        di errori standard: in generale sono asimmetrici rispetto alle stime
        puntuali dei parametri.
      </para>	
      <para>
	È possibile indicare un elenco di quantili (il menù a discesa contiene
        alcune possibilità predefinite), e in tal caso gretl calcolerà stime
        quantili ed errori standard o intervalli di confidenza per ognuno dei
        valori specificati.
      </para>
      <para>
	Per un approfondimento, si veda la <guideref targ="chap:quantreg"/>.
      </para>
    </description>

    <description context="cli">
      <para>
        Regressione quantile. Il primo argomento, <repl>tau</repl>, è il
        quantile condizionale per cui si desiderano le stime. Può essere un
        valore numerico o il nome di una variabile scalare predefinita; il
        valore deve essere compreso nell'intervallo da 0.01 a 0.99 (in
        alternativa, può essere indicato un vettore di valori, si veda sotto per
        i dettagli). Gli argomenti dal secondo in poi compongono un elenco di
        regressori sul modello di quello usato in <cmdref targ="ols"/>.
      </para>
      <para>
        Senza l'opzione <lit>--intervals</lit>, vengono mostrati gli errori
        standard per le stime quantili; questi sono calcolati con la formula
        asintotica di Koenker e Bassett (1978), ma se si usa l'opzione
        <lit>--robust</lit>, verrà usata la variante robusta per
        l'eteroschedasticità di Koenker e Zhao (1994).
      </para>
      <para>
        Se si usa l'opzione <lit>--intervals</lit>, gretl calcolerà gli
        intervalli di confidenza invece degli errori standard.  Questi
        intervalli sono calcolati col metodo dell'inversione del rango e in
        generale sono asimmetrici rispetto alle stime puntuali dei parametri.
        Se non si usa l'opzione <quote>--robust</quote>, gli intervalli sono
        calcolati nell'ipotesi di errori IID (Koenker, 1994), mentre se viene
        indicata, sono calcolati con lo stimatore robusto sviluppato da Koenker
        e Machado (1999).
      </para>
      <para>
	Per impostazione predefinita vengono prodotti intervalli di confidenza
        al 90%. È possibile specificare un altro livello di confidenza (sotto
        forma di frazione decimale), aggiungendolo all'opzione, come in
	<lit>--intervals=0.95</lit>.
      </para>
      <para>
        Invece di indicare <repl>tau</repl> come uno scalare, è possibile usare
        un vettore, indicando il nome di una matrice predefinita. In questo
        caso le stime vengono eseguite per tutti i valori di <repl>tau</repl>, e
        i risultati mostrano la sequenza delle stime quantili per ognuno dei
        regressori.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modello/Stima robusta/Regressione quantile</menu-path>
    </gui-access>

  </command>

  <command name="quit" section="Utilities" label="Esce dal programma" context="cli">

    <description>
      <para>
	Esce dal programma, dando la possibilità di salvare i
        risultati della sessione.
      </para>
    </description>

    <gui-access>
      <menu-path>/File/Esci</menu-path>
    </gui-access>

  </command>

  <command name="rename" section="Dataset" label="Rinomina variabili" context="cli">

    <usage>
      <altforms>
	<altform><lit>rename</lit> <repl>numero-var</repl> <repl>nuovo-nome</repl></altform>
	<altform><lit>rename</lit> <repl>nome-var</repl> <repl>nuovo-nome</repl></altform>
      </altforms>
    </usage>

    <description>
      <para>Modifica il nome di una variabile con numero identificativo
        <repl>numero-var</repl> o nome <repl>nome-var</repl> in
        <repl>nuovo-nome</repl>. Il <repl>numero-var</repl> deve essere compreso
        tra 1 e il numero di variabili nel dataset. Il nuovo nome deve essere
        lungo al massimo 15 caratteri, deve iniziare con una lettera e deve
        essere composto di sole lettere, numeri e il carattere trattino basso.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variabile/Modifica attributi</menu-path>
      <other-access>Menù pop-up nella finestra principale (selezione singola)</other-access>
    </gui-access>

  </command>

  <command name="reset" section="Tests" label="Test RESET di Ramsey">

    <usage>
      <options>
	<option>
	  <flag>--quiet</flag>
	  <effect>non mostra la regressione ausiliaria</effect>
	</option>
	<option>
	  <flag>--squares-only</flag>
	  <effect>calcola il test coi soli quadrati</effect>
	</option>
	<option>
	  <flag>--cubes-only</flag>
	  <effect>calcola il test coi soli cubi</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Va eseguito dopo la stima di un modello via OLS. Esegue il test
	RESET di Ramsey per la specificazione del modello
        (non-linearità), aggiungendo alla regressione il quadrato e/o il
        cubo dei valori stimati (a meno che non siano specificate le
	opzioni <lit>--squares-only</lit> o
	<lit>--cubes-only</lit>) e calcolando la statistica
        <math>F</math> per l'ipotesi nulla che i coefficienti dei due
        termini aggiunti siano pari a zero.
      </para>
      <para context="cli">
        Vengono aggiunti sia i quadrati che i cubi, a meno che siano usate le
        opzioni <lit>--squares-only</lit> o <lit>--cubes-only</lit>.
      </para>
    </description>

    <gui-access>
      <menu-path>Finestra del modello, /Test/RESET - Ramsey</menu-path>
    </gui-access>

  </command>

  <command name="restrict" section="Tests" context="cli" label="Vincoli lineari">

    <description>
      <para>
	Impone un insieme di vincoli lineari sull'ultimo modello
        stimato o su un sistema di equazioni definito in precedenza.
        La sintassi del comando è leggermente diversa in ognuno dei due casi.
      </para>
        
      <para>
        In entrambi i casi, l'insieme di vincoli deve essere racchiuso tra i
        comandi <quote>restrict</quote> e <quote>end restrict</quote>. Nel caso
        della singola equazione, i vincoli sono applicati implicitamente
        all'ultimo modello e vengono valutati appena viene terminato il comando
        <quote>restrict</quote>. Nel caso del sistema, il comando iniziale
        <quote>restrict</quote> deve essere seguito immediatamente dal nome di
        un sistema di equazioni definito in precedenza (si veda <cmdref targ="system"/>).
        I vincoli vengono valutati nella successiva stima del sistema effettuata
        con il comando <cmdref targ="estimate"/>.
      </para>

      <para>Ogni vincolo nell'insieme va indicato sotto forma di equazione
	con una combinazione lineare dei parametri al primo membro e un
        valore numerico al secondo. Nel caso della singola equazione, i
        parametri sono indicati con la sintassi <lit>b[</lit><repl>i</repl><lit>]</lit>,
        dove <repl>i</repl> rappresenta la posizione nella lista dei regressori, a
        partire da uno, oppure con <lit>b[</lit><repl>variabile</repl><lit>]</lit>, dove
        <repl>variabile</repl> è il nome del regressore in questione.
        estion. Nel caso del sistema, i parametri vengono indicati
        con la sintassi <lit>b</lit> seguita da due numeri tra parentesi quadre.
        Il primo numero rappresenta la posizione dell'equazione all'interno del
        sistema, mentre il secondo indica la posizione nella lista dei regressori.
        Ad esempio <lit>b[2,1]</lit> indica il primo parametro della seconda
        equazione, mentre <lit>b[3,2]</lit> il secondo parametro della terza
        equazione.
      </para>

      <para>I termini <lit>b</lit> nell'equazione che rappresenta un vincolo
      possono essere prefissati da un moltiplicatore numerico, usando il segno
      <lit>*</lit> per indicare la moltiplicazione, ad esempio
      <lit>3.5*b[4]</lit>.
      </para>

      <para>Ecco un esempio di un insieme di vincoli per un modello stimato in
      precedenza:</para>

      <code>
	restrict
	 b[1] = 0
	 b[2] - b[3] = 0
	 b[4] + 2*b[5] = 1
	end restrict
      </code>

      <para>Ed ecco un esempio di un insieme di vincoli da applicare a un
      sistema (se il nome del sistema non contiene spazi, è possibile
      tralasciare le virgolette).
      </para>

      <code>
	restrict "Sistema 1"
	 b[1,1] = 0
	 b[1,2] - b[2,2] = 0
	 b[3,4] + 2*b[3,5] = 1
	end restrict
      </code>

      <para>
        Nel caso dell'equazione singola, i vincoli sono valutati attraverso un
        test <math>F</math> di Wald, usando la matrice di covarianza dei
        coefficienti del modello in questione. In modalità predefinita vengono
        mostrate le stime dei coefficienti vincolati; se si desidera solo la
        statistica test, basta aggiungere l'opzione <lit>--quiet</lit> al
        comando <lit>restrict</lit> iniziale.
      </para>
      <para>
        Nel caso del sistema, la statistica test dipende dallo stimatore scelto:
        un test del rapporto di verosimiglianza nel caso di un sistema stimato
        con un metodo di massima verosimiglianza, o un test
        <math>F</math> asintotico negli altri casi.
      </para>

    </description>

    <gui-access>
      <menu-path>Modello, /Test/Vincoli lineari</menu-path>
    </gui-access>

  </command>
  
  <command name="restrict-model" section="Tests" context="gui"
    label="Vincoli su un modello">

    <description>

      <para>Ognuno dei vincoli da imporre a un modello deve essere espresso
        sotto forma di equazione con una combinazione lineare dei parametri al
        primo membro e un valore numerico al secondo. Nel caso della singola
        equazione, i parametri sono indicati con la sintassi <lit>b[</lit><repl>i</repl><lit>]</lit>,
        dove <repl>i</repl> rappresenta la posizione nella lista dei regressori,
        a partire da uno, oppure <lit>b[</lit><repl>variabile</repl><lit>]</lit>, dove
        <repl>variabile</repl> è il nome del regressore in questione.
      </para>

      <para>I termini <lit>b</lit> nell'equazione che rappresenta un vincolo
        possono essere prefissati con un moltiplicatore numerico usando il
        carattere <lit>*</lit> per indicare la moltiplicazione, ad esempio
        <lit>3.5*b[4]</lit>.
      </para>

      <para>Ecco ad esempio un insieme di vincoli:</para>

      <code>
	b[1] = 0
	b[2] - b[3] = 0
	b[4] + 2*b[5] = 1
      </code>

    </description>

  </command>

  <command name="restrict-system" section="Tests" context="gui"
    label="Vincoli su un sistema di equazioni">

    <description>

      <para>Ognuno dei vincoli da imporre a un sistema deve essere espresso
        sotto forma di equazione con una combinazione lineare dei parametri al
        primo membro e un valore numerico al secondo. 
        I parametri vengono indicati con la sintassi <lit>b</lit> seguita da due
        numeri tra parentesi quadre.  Il primo numero rappresenta la posizione
        dell'equazione all'interno del sistema, mentre il secondo indica la
        posizione nella lista dei regressori, entrambi contati a partire da uno.
        Ad esempio <lit>b[2,1]</lit> indica il primo parametro della seconda
        equazione, mentre <lit>b[3,2]</lit> il secondo parametro della terza
        equazione.
      </para>

      <para>I termini <lit>b</lit> nell'equazione che rappresenta un vincolo
        possono essere prefissati con un moltiplicatore numerico usando il
        carattere <lit>*</lit> per indicare la moltiplicazione, ad esempio
        <lit>3.5*b[1,4]</lit>.
      </para>

      <para>Ecco ad esempio un insieme di vincoli:</para>

      <code>
	b[1,1] = 0
	b[1,2] - b[2,2] = 0
	b[3,4] + 2*b[3,5] = 1
      </code>

    </description>

  </command>

  <command name="restrict-vecm" section="Tests" context="gui"
    label="Vincoli su un VECM">

    <description>

      <para>
	Questo comando impone restrizioni lineari sulle relazioni
        di cointegrazione (beta) e/o sui coefficienti di aggiustamento (alfa)
        in un modello vettoriale a correzione d'errore (VECM).
      </para>

      <para>Ognuno dei vincoli deve essere espresso sotto forma di equazione,
        con una combinazione lineare dei parametri al primo membro e un valore
        numerico al secondo membro. Le restrizioni su beta possono essere non
        omogenee (valore diverso da zero al secondo membro), ma quelle su alfa
        devono essere omogenee (valore zero al secondo membro).
      </para>

      <para>Se il VECM è di rango 1, è possibile esprimere gli elementi di beta nella
        forma <lit>b[</lit><repl>i</repl><lit>]</lit>,  dove <repl>i</repl>
        rappresenta la posizione nel vettore di correzione dell'errore, a
        partire da uno. Ad esempio, <lit>b[2]</lit> indica il secondo elemento
        di beta. Se il rango è maggiore di 1, è possibile esprimere i parametri
        usando <lit>b</lit> seguito da due numeri tra parentesi quadre. Ad
        esempio <lit>b[2,1]</lit> rappresenta il primo elemento nel secondo
        vettore di cointegrazione.
      </para>

      <para>
	Per riferirisi agli elementi di alfa, basta usare <lit>a</lit> al posto di
	<lit>b</lit>.
      </para>

      <para>Gli identificatori dei parametri nell'equazione che rappresenta un vincolo
        possono essere prefissati con un moltiplicatore numerico usando il
        carattere <lit>*</lit> per indicare la moltiplicazione, ad esempio
        <lit>3.5*b[4]</lit>.
      </para>

      <para>Ecco ad esempio un insieme di vincoli su un VECM di rango 1.
      </para>

      <code>
	b[1] + b[2] = 0
	b[1] + b[3] = 0
      </code>

      <para>
	Si veda anche la <guideref targ="chap:vecm"/>.
      </para>

    </description>

  </command>

  <command name="rhodiff" section="Transformations" label="Quasi-differenze" context="cli">

    <usage>
      <arguments>
        <argument>lista-rho</argument>
        <argument separated="true">lista-variabili</argument>
      </arguments>
      <examples>
        <example>rhodiff .65 ; 2 3 4</example>
        <example>rhodiff r1 r2 ; x1 x2 x3</example>	
      </examples>
    </usage>

    <description>
      <para>
	Crea delle versioni rho-differenziate delle variabili indicate
        (con numero o con nome) nella <repl>lista-variabili</repl> e le
        aggiunge al dataset, usando il suffisso <lit>#</lit> per le
        nuove variabili. Ad esempio, data la variabile <lit>v1</lit> nella
	<repl>lista-variabili</repl> e i valori <lit>r1</lit> e
	<lit>r2</lit> nella <repl>lista-rho</repl>, viene creata
      </para>
      <code>
        v1# = v1 - r1*v1(-1) - r2*v1(-2)
      </code>
      <para>
	I valori nella <repl>lista-rho</repl> possono essere specificati sotto
	forma di valori numerici o di nomi di variabili definite in precedenza.
      </para>
    </description>

  </command>

  <command name="rmplot" section="Graphs"
    label="Grafici range-mean">

    <usage>
      <arguments>
        <argument>nome-variabile</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Grafici Range&ndash;mean: questo comando crea un semplice
        grafico che aiuta a capire se una serie storica
	<math>y</math>(t) ha varianza costante o no. L'intero
        campione t=1,...,T viene diviso in piccoli sotto-campioni di
        dimensione arbitraria <math>k</math>. Il primo
        sotto-campione è formato da
        <math>y</math>(1), ... ,<math>y</math>(k), il secondo
        da <math>y</math>(k+1), ... , <math>y</math>(2k), e
        così via.  Per ogni sotto-campione, vengono calcolati la media e
        il campo di variazione (range: il valore massimo meno quello
        minimo) e viene costruito un grafico con le medie sull'asse
        orizzontale e i campi di variazione su quello verticale, in modo
        che ogni sotto-campione sia rappresentato da un punto sul piano.
	Se la varianza della serie è costante, ci si aspetta che il
        campo di variazione del sotto-campione sia indipendente dalla
        media del sotto-campione; se i punti si dispongono su una linea
        crescente, la varianza della serie cresce al crescere della
        media, viceversa se i punti si dispongono su una linea
        decrescente.
      </para>

      <para>Oltre al grafico, gretl mostra anche le medie e i campi di
      variazione per ogni sotto-campione, insieme al coefficiente di
      pendenza della regressione OLS del campo di variazione sulla media
      e il p-value per l'ipotesi nulla che la pendenza sia zero.
      Se il coefficiente di pendenza è significativo al livello del 10
      per cento, viene mostrata sul grafico la linea stimata della
      regressione del campo di variazione sulla media.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variabile/Grafico range-mean</menu-path>
    </gui-access>

  </command>

  <command name="run" section="Programming" label="Esegue uno script di comandi" context="cli">

    <usage>
      <arguments>
        <argument>file-input</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Esegue i comandi nel <repl>file-input</repl> e restituisce il
        controllo al prompt interattivo. Questo comando si intende usato con il
        programma a riga di comando gretlcli, o con il <quote>terminale di gretl</quote>
        nel programma con interfaccia grafica.
      </para>
      <para>
	Si veda anche <cmdref targ="include"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>Icona Esegui nella finestra comandi</menu-path>
    </gui-access>

  </command>

  <command name="runs" section="Tests" label="Test delle successioni">

    <usage>
      <arguments>
        <argument>nome-variabile</argument>
      </arguments>
      <options>
       <option>
         <flag>--difference</flag>
         <effect>usa la differenza prima della variabile</effect>
       </option>
	<option>
	  <flag>--equal</flag>
	  <effect>i valori positivi e negativi sono equiprobabili</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Esegue il test non parametrico <quote>delle successioni</quote>
        per la casualità della variabile specificata, dove le successioni
        sono definite come sequenze di valori consecutivi positivi o negativi.
        Ad esempio, per testare la casualità delle deviazioni dalla mediana per
        una variabile chiamata <lit>x1</lit>, con una mediana diversa da zero,
        eseguire i comandi seguenti:
      </para>
      <code>
	genr signx1 = x1 - median(x1)
	runs signx1
      </code>
      <para>
       Se si usa l'opzione <lit>--difference</lit>, la variabile viene differenziata
       prima dell'analisi, quindi le successioni sono interpretabili come
       sequenze di incrementi o decrementi consecutivi nel valore della
       variabile.
      </para>
      <para>
        Se si usa l'opzione <lit>--equal</lit>, l'ipotesi nulla incorpora
        l'assunzione che i valori positivi e negativi siano equiprobabili,
        altrimenti la statistica test è invariante rispetto
        all'<quote>equilibrio</quote> del processo che genera la sequenza,
        focalizzandosi solo sull'indipendenza.
      </para>
    </description>

    <gui-access>
      <menu-path>/Strumenti/Test non parametrici</menu-path>
    </gui-access>

  </command>

  <command name="sampling" section="Dataset" context="gui"
    label="Impostazione del campione">

    <description>
      <para>Il menù Campione offre vari modi di selezionare un
      sotto-campione dal dataset in uso.</para>

      <para>
	Scegliendo <quote>Campione/Imposta in base a dummy...</quote>,
	viene chiesto di scegliere una variabile dummy (indicatrice),
        che può assumere solo valori 0 o 1 per ogni osservazione. Il
        campione verrà limitato alle osservazioni per cui la variabile
        dummy vale 1.</para>

      <para>Scegliendo <quote>Campione/Imposta in base a
	  condizione...</quote>, viene chiesto di inserire un'espressione
	Booleana (logica), dello stesso tipo di quella che si userebbe per
	definire una variabile dummy. Ad esempio, l'espressione
	<quote>sqft > 1400</quote> selezionerà solo le osservazioni per
	cui la variabile sqft ha un valore maggiore di 1400. Le condizioni
	possono essere concatenate con gli operatori logici
	<quote>&amp;&amp;</quote> (AND) e <quote>||</quote> (OR) e possono
	essere negate usando <quote>!</quote> (NOT).
      </para>

      <para>Il comando <quote>Campione/Scarta valori mancanti</quote>
      ridefinisce il campione in modo da escludere tutte le osservazioni
      per cui i valori di una o più variabili sono mancanti (lasciando
      nel campione solo i casi completi).</para>  

      <para>Per selezionare le osservazioni per cui solo una particolare
      variabile non ha valori mancanti, occorre usare
      <quote>Campione/Imposta in base a condizione...</quote> e inserire
      la condizione Booleana <quote>!missing(nome-variabile)</quote>
      (sostituire <quote>nome-variabile</quote> con il nome della
      variabile che si intende usare).</para>  

      <para>Se sono state associate etichette alle osservazioni, è possibile
      escludere una particolare osservazione dal campione impostando una
      condizione del tipo obs!="Francia". L'etichetta dell'osservazione deve
      essere racchiuso tra virgolette doppie.</para>

      <para>Occore tenere presente che ridefinendo il campione basandosi
      su una variabile dummy, un'espressione Booleana o sul criterio
      delle osservazioni mancanti, tutte le informazioni
      <quote>strutturali</quote> contenute nel file con la descrizione
      dei dati (riguardanti la struttura di serie storiche o di panel
      dei dati) vengono perse. È possibile reimpostare la struttura
      originale con <quote>Campione/Imposta frequenza e inizio...</quote>.</para>

      <para>Si veda la <guideref targ="sampling"/> per maggiori dettagli.</para>

    </description>
  </command>


  <command name="scatters" section="Graphs"
    label="Grafici multipli per coppie di variabili">

    <usage>
      <arguments>
        <argument>variabile-y</argument>
        <argument separated="true">lista-variabili-x</argument>
	<argument alternate="true">lista-variabili-y ; variabile-x</argument>
      </arguments>
      <options>
	<option>
	  <flag>--with-lines</flag>
	  <effect>crea grafici lineari</effect>
	</option>
      </options>
      <examples>
        <example>scatters 1 ; 2 3 4 5</example>
        <example>scatters 1 2 3 4 5 6 ; 7</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
        Produce grafici della <repl>variabile-y</repl> rispetto ad ognuna delle
        variabili nella <repl>lista-variabili-x</repl>, oppure di tutte le
        variabili nella <repl>lista-variabili-y</repl> rispetto alla
        <repl>variabile-x</repl>.  Il primo esempio visto sopra assegna
        la variabile 1 all'asse <math>y</math> e produce quattro
        grafici, il primo con la variabile 2 sull'asse
	<math>x</math>, il secondo con la variabile 3 sull'asse
	<math>x</math>, e così via. Il secondo esempio rappresenta
	ognuna delle variabili da 1 a 6 rispetto alla variabile 7
        sull'asse <math>x</math>. Questi gruppi di grafici sono
        utili nell'analisi esplorativa dei dati. È possibile creare fino
        a sei grafici alla volta, eventuali variabili in sovrappiù
        saranno ignorate.
      </para>
      <para context="cli">
        Per impostazione predefinita vengono prodotti dei classici grafici a
        dispersione, ma se si usa l'opzione <lit>--with-lines</lit> vengono
        mostrate anche le linee di collegamento tra i punti del grafico.
      </para>
      <para context="gui">
	Produce grafici a dispersione della <quote>Variabile asse
        Y</quote> selezionata rispetto ad ognuna delle <quote>Variabili
        asse X</quote> selezionate (ma è possibile fare anche viceversa). Questi
        gruppi di grafici sono utili nell'analisi esplorativa dei dati. È
        possibile creare fino a sei grafici alla volta, eventuali variabili in
        sovrappiù saranno ignorate.
      </para>
    </description>

    <gui-access>
      <menu-path>/Visualizza/Grafici multipli</menu-path>
    </gui-access>

  </command>

  <command name="sdiff" section="Transformations" label="Differenziazione stagionale" context="cli">

    <usage>
      <arguments>
        <argument>lista-variabili</argument>
      </arguments>
    </usage>

    <description>
      <para>
       Calcola la differenza stagionale di ogni variabile della
       <repl>lista-variabili</repl> e salva il risultato in una nuova variabile
       con il prefisso <lit>sd_</lit>. Il comando è disponibile solo per serie storiche stagionali.
      </para>
    </description>

    <gui-access>
      <menu-path>/Aggiungi/Differenze stagionali</menu-path>
    </gui-access>

  </command>

  <command name="set" section="Programming" label="Imposta parametri del programma" context="cli">

    <usage>
      <arguments>
        <argument>variabile</argument>
        <argument>valore</argument>
      </arguments>
      <examples>
        <example>set qr on</example>
        <example>set csv_delim tab</example>
	<example>set horizon 10</example>
      </examples>    
    </usage>

    <description>
      <para>
	Imposta i valori di vari parametri del programma. Il valore
        impostato rimane in vigore per la durata della sessione di
        gretl, a meno di non essere modificato da un ulteriore
        esecuzione del comando <cmd>set</cmd>. I parametri che possono
        essere impostati in questo modo sono elencati di seguito.
        Si noti che le impostazioni di <lit>hac_lag</lit>, <lit>hc_version</lit>
        e <lit>hac_kernel</lit> sono usate quando viene data l'opzione
        <lit>--robust</lit> a un comando di stima.
      </para>
      <para>
        Un uso speciale di questo comando è <cmd>set stopwatch</cmd>. In questo
        modo viene avviata la misurazione del tempo della CPU, che viene fermata
        la prima volta che viene usata la variabile accessoria
        <lit>$stopwatch</lit>, ad esempio assegnandola a un'altra variabile,
        oppure stampandola. <lit>$stopwatch</lit> conterrà il numero di secondi
        usati dalla CPU, dal momento in cui è stato dato il comando
        <lit>set stopwatch</lit>.
      </para>
      <para>
        Se il comando <cmd>set</cmd> è usato senza parametri, vengono
        mostrate le impostazioni attuali per tutti i parametri rilevanti.
      </para>
      <para>
	Le impostazioni disponibili sono raggruppate in sei categorie:
        interazione col programma, metodi numerici, generazione di numeri
        casuali, stima robusta, filtri e stima di modelli per serie storiche.
      </para>

      <para>
	<emphasis>Interazione con il programma</emphasis>
      </para>
      <para>
	Queste impostazioni servono per controllare vari aspetti del modo in cui
        gretl interagisce con l'utente.
      </para>
      <ilist>
	<li>
	  <para><lit>csv_delim</lit>:
	  <lit>comma</lit> (virgola, valore predefinito), <lit>space</lit>
            (spazio), o <lit>tab</lit>. Imposta il delimitatore di colonna usato nel
            salvataggio di dati su file in formato CSV.
	  </para>
	</li>
	<li>
	  <para><lit>echo</lit>:
	  <lit>off</lit> o <lit>on</lit> (valore predefinito).
	    Sopprime o ripristina l'indicazione dei comandi eseguiti nell'output
            dei risultati.</para>
	</li>
	<li>
	  <para><lit>force_decpoint</lit>: <lit>on</lit> o <lit>off</lit>
	    (valore predefinito).  Forza gretl a usare il carattere punto come
            separatore decimale, in un ambiente in cui il separatore standard è
            un'altro carattere (tipicamente la virgola).
	  </para>
	</li>
	<li>
	  <para><lit>halt_on_error</lit>: <lit>off</lit> o
	  <lit>on</lit> (valore predefinito). Quando è attivo, se si verifica un
          errore all'interno di un loop, questo si interromperà. Se si usa il
          client a riga di comando, il programma terminerà.
	  </para>
	</li>
	<li>	  
	  <para><lit>longdigits</lit>: un valore intero positivo, minore o
            uguale a 20. Determina il numero di cifre usate per mostrare i
            valori delle variabili quando viene usata l'opzione
	    <lit>--long</lit> (si veda <cmdref targ="print"/>).
	  </para>
	</li>
        <li>
          <para><lit>loop_maxiter</lit>: un valore intero positivo.
          Imposta il numero massimo di iterazioni consentite prima che un loop
          di tipo <lit>while</lit> si fermi (si veda <cmdref targ="loop"/>).
          Si noti che questa impostazione riguarda solo la variante
          <lit>while</lit>, visto che lo scopo è quello di interrompere
          possibili cicli infiniti.
         </para>
        </li>
	<li>
	  <para><lit>max_verbose</lit>: <lit>on</lit> o
	  <lit>off</lit> (valore predefinito). Attiva l'output aggiuntivo per la
          funzione <lit>BFGSmax</lit> (si veda la Guida all'uso per i dettagli).
	  </para>
	</li>
 	<li>
	  <para><lit>messages</lit>: <lit>off</lit> o <lit>on</lit> (valore
            predefinito). Sopprime o ripristina l'indicazione dei messaggi
            informativi associati a vari comandi, ad esempio quando viene
            generata una nuova variabile o viene modificato l'intervallo del
            campione.
         </para>
	</li>
 	<li>
	  <para><lit>debug</lit>: <lit>1</lit>, <lit>2</lit> o <lit>0</lit>
	    (valore predefinito). Da usare per le funzioni definite dall'utente.
	    Impostare <lit>debug</lit> a 1 equivale a impostare
	    <lit>messages</lit> in tutte queste funzioni; impostando la
            variabile a <lit>2</lit> ha l'effetto aggiuntivo di impostare
	    <lit>max_verbose</lit> in tutte le funzioni.
	  </para>
	</li>
	<li>
	  <para><lit>shell_ok</lit>: <lit>on</lit> o <lit>off</lit>
	  (valore predefinito). Abilita l'esecuzione di programmi esterni da
          gretl attraverso la shell di sistema. Per motivi di sicurezza, la
          funzione è disabilitata per impostazione predefinita; inoltre è
          possibile abilitarla solo tramite l'interfaccia grafica
          (Strumenti/Preferenze/Generali). Una volta abilitata, l'impostazione
          rimarrà attiva per le successive sessioni, fino a che non sarà
          disabilitata esplicitamente.
	  </para>
	</li>
	<li>
	  <para><lit>shelldir</lit>: <repl>percorso</repl>. Imposta la directory
           di lavoro attuale per i comandi shell.
         </para>
	</li>
	<li>
	  <para><lit>use_cwd</lit>: <lit>on</lit> o <lit>off</lit>
	  (valore predefinito). Questa impostazione modifica il comportamento
          dei comandi <cmdref targ="outfile"/> e <cmdref targ="store"/>, che
          scrivono su file esterni. Normalmente, il file verrà scritto nella
          directory dati predefinita dell'utente: se si imposta
	  <lit>use_cwd</lit> a <lit>on</lit>, al contrario, il file verrà creato
          nella directory di lavoro da cui gretl è stato eseguito.
	  </para>
	</li>
      </ilist>

      <para>
	<emphasis>Metodi numerici</emphasis>
      </para>
      <para>
	Queste impostazioni vengono usate per controllare gli algoritmi numerici
        usati da gretl per la stima.
      </para>
      <ilist>
	<li>	
	<para><lit>bhhh_maxiter</lit>: un intero. Imposta il massimo numero di
          iterazioni per la routine BHHH, che è usata dal comando
          <cmd>arma</cmd>. Se non viene raggiunta la convergenza dopo
          <lit>bhhh_maxiter</lit>, il programma segnala un errore. Il valore
          predefinito è 500.
	  </para>
	</li>	  
	<li>	  
	  <para><lit>bhhh_toler</lit>: un valore a virgola mobile, oppure la
            stringa <lit>default</lit>. Viene usato dalla routine BHHH di gretl
            per controllare se viene raggiunta la convergenza. L'algoritmo di
            calcolo ferma le iterazioni non appena l'incremento nella
            log-verosimiglianza tra le iterazioni è minore di <lit>bhhh_toler</lit>.
            Il valore predefinito è 1.0E&minus;06; questo valore può essere reimpostato
            usando la stringa <lit>default</lit> invece di un valore numerico.
	  </para>
	</li>
	<li>
	  <para><lit>bfgs_maxiter</lit>: un valore intero. Rappresenta il
            massimo numero di iterazioni per la routine BFGS di gretl,
            usata da <cmd>mle</cmd>, <cmd>gmm</cmd> e altri stimatori.
            Se non si raggiunge la convergenza nel numero specificato di
            iterazioni, il programma produce un messaggio di errore. Il valore
            predefinito dipende dal contesto, ma tipicamente è nell'ordine delle
            500 iterazioni.
	  </para>
	</li>	  
	<li>	  
	  <para><lit>bfgs_toler</lit>: un valore in virgola mobile, o la stringa
	    <lit>default</lit>. Viene usato nella routine BFGS di gretl per
            controllare se si è raggiunta la convergenza. L'algoritmo si ferma
            appena l'incremento relativo nella funzione obiettivo tra
            un'iterazione e l'altra è minore di
	    <lit>bfgs_toler</lit>.  Il valore predefinito è pari alla precisione
            della macchina elevata alla potenza 3/4; questo valore può essere
            re-impostato usando la stringa <lit>default</lit> invece di un valore numerico.
 	  </para>
	</li>	  
	<li>	  
          <para><lit>initvals</lit>: una matrice pre-specificata. Permette di
            impostare manualmente le stime dei parametri ARMA. Per i dettagli,
            si veda la <guideref targ="arma-estimation"/>.
	  </para>
	</li>
	<li>
          <para><lit>lbfgs</lit>: <lit>on</lit> o <lit>off</lit> (valore
          predefinito). Usa la versione a memoria limitata di BFGS, al posto
          dell'algoritmo standard. Può essere vantaggioso quando la funzione da
          massimizzare non è globalmente concava.
	  </para>
	</li>
        <li>
	<para>
	  <lit>nls_toler</lit>: un valore in virgola mobile (il valore
          predefinito è pari alla precisione della macchina elevata alla potenza
          3/4). Imposta la tolleranza usata per stabilire se è stata raggiunta
          la convergenza nelle procedure iterative di stima con i minimi
          quadrati non lineari usate dal comando <cmdref targ="nls"/>.
	</para>
        </li>
	<li>
	  <para><lit>qr</lit>:
	  <lit>on</lit> o <lit>off</lit> (valore predefinito).
	    Usa la decomposizione QR invece di quella di Cholesky nel
            calcolo delle stime OLS.</para>
	</li>
	<li>
          <para><lit>fcp</lit>: <lit>on</lit> o <lit>off</lit> (valore
          predefinito). Usa l'algoritmo di Fiorentini, Calzolari e Panattoni
          al posto del codice interno di gretl per  calcolare le stime GARCH.
	  </para>
	</li>
      </ilist>

      <para>
	<emphasis>Generazione di numeri casuali</emphasis>
      </para>

      <ilist>
        <li>
          <para><lit>seed</lit>: un intero senza segno. Imposta il seme per il
            generatore di numeri pseudo-casuali. Di solito il seme viene
            impostato a partire dall'ora di sistema, ma se si intende
            generare sequenze ripetibili di numeri casuali occorre impostare
            il seme manualmente.
          </para>
        </li>
      </ilist>

      <para>
	<emphasis>Stima robusta</emphasis>
      </para>

      <ilist>
	<li>
	  <para><lit>bootrep</lit>: un intero. Imposta il numero di replicazioni
          per il comando <cmdref targ="restrict"/> con l'opzione <lit>--bootstrap</lit>.
          </para>
	</li>
	<li>
	  <para><lit>garch_vcv</lit>:
	  <lit>unset</lit>, <lit>hessian</lit>,
	    <lit>im</lit> (matrice di informazione) , <lit>op</lit>
            (matrice dei prodotti esterni), <lit>qml</lit> (stimatore QML),
	    <lit>bw</lit> (Bollerslev&ndash;Wooldridge). Specifica la
            variante da usare per stimare la matrice di covarianza dei
            coefficienti nei modelli GARCH.  Se si usa <lit>unset</lit>
	    (valore predefinito), viene usata l'Hessiana, a meno di
            usare l'opzione <quote>robust</quote> col comando garch, nel
            qual caso viene usato QML.
          </para>
	</li>
	<li>
	  <para><lit>arma_vcv</lit>: <lit>hessian</lit> (predefinito) o
	    <lit>op</lit> (prodotto esterno). Specifica la variante
	    da usare per calcolare la matrice di covarianza per i modelli ARIMA.
	  </para>
 	</li>
	<li>
	  <para><lit>force_hc</lit>: <lit>off</lit> (predefinito)
	    o <lit>on</lit>. Lo stimatore HAC viene usato in modo predefinito con dati
            serie storiche e quando si usa l'opzione <lit>--robust</lit> di
            <lit>ols</lit>. Impostando invece <lit>force_hc</lit> a
            <quote>on</quote>, si forza l'uso della matrice di covarianza
	    coerente con l'eteroschedasticità (che non tiene conto dell'autocorrelazione).
	  </para>
	</li>
	<li>
	  <para><lit>hac_lag</lit>:
	  <lit>nw1</lit> (valore predefinito), <lit>nw2</lit>,
	    <lit>nw3</lit>, o un intero.  Imposta il massimo valore di
            ritardo, o la larghezza di banda, <math>p</math>, usato nel calcolo degli
            errori standard HAC (Heteroskedasticity and Autocorrelation Consistent)
	    con l'approccio Newey-West, per le serie storiche.
            <lit>nw1</lit> e <lit>nw2</lit> rappresentano due varianti
            di calcolo automatico basate sulla dimensione del campione,
	    <math>T</math>: per nw1, 
            <equation status="inline"
              tex="$p = 0.75 \times T^{1/3}$"
              ascii="p = 0.75 * T^(1/3)"
              graphic="nw1"/>,
              e per nw2, 
            <equation status="inline"
              tex="$p = 4 \times (T/100)^{2/9}$"
              ascii="p = 4 * (T/100)^(2/9)"
              graphic="nw2"/>.
            <lit>nw3</lit> permette di selezionare la larghezza di banda
            basandosi sui dati.  Si veda anche <lit>qs_bandwidth</lit> e
            <lit>hac_prewhiten</lit>.
	  </para>
	</li>
	<li>
	  <para><lit>hac_kernel</lit>: <lit>bartlett</lit> (valore predefinito),
	    <lit>parzen</lit>, o <lit>qs</lit> (Quadratic Spectral). Imposta il
            kernel, o struttura di pesi, usato nel calcolo degli errori standard
            HAC.
	  </para>
	</li>
	<li>
	  <para><lit>hac_prewhiten</lit>: <lit>on</lit> o <lit>off</lit>
	    (valore predefinito). Usa le procedure di <quote>prewhitening</quote> e
            <quote>re-coloring</quote> di Andrews-Monahan nel calcolo degli
            errori standard HAC. Questo comporta anche la selezione della
            larghezza di banda basata sui dati.
	  </para>
	</li>
	<li>
	  <para><lit>hc_version</lit>:
	  0 (valore predefinito), 1, 2 o 3. Imposta la
          variante da usare nel calcolo degli errori standard HAC
          (Heteroskedasticity and Autocorrelation Consistent) con dati
          di tipo cross section. Le opzioni corrispondono alle HC0, HC1,
          HC2 e HC3 discusse da Davidson e MacKinnon nel capitolo 5 di
          <book>Econometric Theory and Methods</book>.  HC0 produce
          quelli che di solito vengono chiamati <quote>errori standard di
          White</quote>.</para>
        </li>
	<li>
	  <para><lit>pcse</lit>: <lit>off</lit> (impostazione predefinita) o
	    <lit>on</lit>.  Di solito, quando si stima un modello con pooled OLS
            su dati panel usando l'opzione <lit>--robust</lit>, viene usato lo
            stimatore di Arellano per la matrice di covarianza. Se si imposta
            <lit>pcse</lit> a <quote>on</quote>, verranno usati i Panel
            Corrected Standard Errors (PCSE) di Beck e Katz, che non tengono
            conto dell'autocorrelazione.
	  </para>
	</li>
	<li>
	  <para><lit>qs_bandwidth</lit>: larghezza di banda per la stima HAC
            nel caso in cui si scelga il kernel "Quadratic Spectral" (a differenza
            dei kernel Bartlett e Parzen, la larghezza di banda QS non deve essere
            necessariamente un intero).
	  </para>
	</li>
      </ilist>

      <para>
	<emphasis>Filtri</emphasis>
      </para>

      <ilist>
	<li>
	  <para><lit>hp_lambda</lit>:
	  <lit>auto</lit> (valore predefinito), o un
          valore numerico. Imposta il parametro di livellamento per
          il filtro di Hodrick&ndash;Prescott (si veda la funzione
          <lit>hpfilt</lit> sotto il comando <lit>genr</lit>). Il valore
          predefinito è 100 volte il quadrato della periodicità, ossia
          100 per i dati annuali, 1600 per i dati trimestrali e così
          via.</para>
	</li>
        <li>
          <para><lit>bkbp_limits</lit>:
          due interi, il secondo maggiore del primo
           (i valori predefiniti sono 8 e 32). Imposta i limiti di
           frequenza per il filtro passa-banda di Baxter&ndash;King
           (si veda la funzione <lit>bkfilt</lit> nel comando <lit>genr</lit>).
         </para>
        </li>
        <li>
          <para><lit>bkbp_k</lit>:
          un intero (il valore predefinito è 8). Imposta
            l'ordine di approssimazione per il filtro passa-banda di
            Baxter&ndash;King.
          </para>
        </li>
      </ilist>

      <para>
	<emphasis>Serie storiche</emphasis>
      </para>
      
      <ilist>
	<li>
	  <para><lit>horizon</lit>:
	  un intero (il valore predefinito dipende dalla
          frequenza dei dati). Imposta l'orizzonte per le funzioni impulso-risposta
          e per la decomposizione della varianza nel contesto delle autoregressioni
          vettoriali.
	  </para>
	</li>
	<li>
	  <para><lit>vecm_norm</lit>: <lit>phillips</lit> (valore predefinito),
          <lit>diag</lit>, <lit>first</lit> o <lit>none</lit>. Usato nel
          contesto della stima VECM, attraverso il comando <cmdref targ="vecm"/>
          per identificare i vettori di cointegrazione. Si veda la Guida all'uso
          per i dettagli.
	  </para>
	</li>
      </ilist>

    </description>
  </command>
  
  <command name="setinfo" section="Dataset" label="Modifica degli attributi di una variabile">

    <usage>
      <arguments>
        <argument>nome-variabile</argument>
        <argument flag="-d ">descrizione</argument>
        <argument flag="-n ">nome-grafici</argument>
      </arguments>
      <options>
	<option>
	  <flag>--discrete</flag>
	  <effect>marca la variabile come discreta</effect>
	</option>
	<option>
	  <flag>--continuous</flag>
	  <effect>marca la variabile come continua</effect>
	</option>
      </options>
      <examples>
        <example>setinfo x1 -d "Descrizione di x1" -n "Nome nei grafici"</example>
	<example>setinfo z --discrete</example>
      </examples>
    </usage>

    <description context="cli">
      <para>
        Imposta fino a tre attributi di una variabile, nel modo seguente.
      </para>
      <para>
        Usando l'opzione <lit>-d</lit> seguita da una stringa tra
        virgolette doppie, la stringa verrà usata come etichetta descrittiva per
        la variabile indicata, che viene mostrata dal comando <cmdref
        targ="labels"/> e anche nella finestra principale del programma.
      </para>
      <para>
        Usando l'opzione <lit>-n</lit> seguita da una stringa tra
        virgolette doppie, la stringa verrà usata nei grafici al posto del nome
        della variabile.
      </para>
      <para>
        Usando una delle opzioni <lit>--discrete</lit> o
        <lit>--continuous</lit>, viene impostato il carattere numerico della
        variabile.  In modalità predefinita, tutte le variabili sono considerate come
        continue; marcando una variabile come discreta, essa viene trattata in
        modo speciale nei diagrammi di frequenza.
      </para>
    </description>

    <description context="gui">

      <para>
	In questa finestra di dialogo è possibile:</para>

      <para>* Rinominare una variabile.</para>

      <para>* Aggiungere o modificare una descrizione della variabile,
        che appare accanto al nome della variabile nella finestra
        principale di gretl.</para>

      <para>* Aggiungere o modificare il "nome per i grafici" della
        variabile (se la variabile è una serie e non uno scalare).
        Questa stringa (lunga al massimo 19 caratteri) viene
        usata al posto del nome della variabile quando questa compare in
        un grafico. Così, ad esempio, è possibile associare una stringa
        più comprensibile come "Tariffe telefoniche" a un nome criptico
        come "tartel".</para>

      <para>* Impostare (se i dati sono serie storiche) il
        metodo di compattamento per la variabile, che verrà usato se si
        decide di ridurre la frequenza del dataset, o se si importa la
        variabile da un dataset che ha una frequenza maggiore di quella
        del dataset in uso.
      </para>

      <para>* Marcare una variabile come discreta (per serie che contengono
        solo valori discreti). In questo modo, essa viene
        trattata in modo speciale nei diagrammi di frequenza.
      </para>

      <para>* Impostare il valore di una variabile (per variabili discrete).
      </para>


    </description>

    <gui-access>
      <menu-path>/Variabile/Modifica attributi</menu-path>
      <other-access>Menù pop-up nella finestra principale</other-access>
    </gui-access>

  </command>

  <command name="setobs" section="Dataset" context="cli"
    label="Frequenza e osservazione iniziale">

    <usage>
      <altforms>
        <altform>setobs <repl>periodicità</repl> <repl>oss-iniziale</repl></altform>
	<altform>setobs <repl>variabile-unità</repl> <repl>variabile-periodi</repl></altform>
      </altforms>
      <options>
        <option>
	  <flag>--cross-section</flag>
	  <effect>interpreta come cross section</effect>
        </option>
        <option>
	  <flag>--time-series</flag>
	  <effect>interpreta come serie storiche</effect>
        </option>
        <option>
	  <flag>--stacked-cross-section</flag>
	  <effect>interpreta come panel</effect>
        </option>
        <option>
	  <flag>--stacked-time-series</flag>
	  <effect>interpreta come panel</effect>
        </option>
        <option>
	  <flag>--panel-vars</flag>
	  <effect>usa variabili indice (si veda oltre)</effect>
        </option>
      </options>
      <examples>
        <example>setobs 4 1990:1 --time-series</example>
        <example>setobs 12 1978:03</example>
	<example>setobs 1 1 --cross-section</example>
        <example>setobs 20 1:1 --stacked-time-series</example>
	<example>setobs unita anno --panel-vars</example>
      </examples>
    </usage>

    <description>
      <para>
	Forza il programma a interpretare il dataset in uso secondo la
        struttura specificata.
      </para>
      <para>
        Nella prima forma del comando, la <repl>periodicità</repl>, che deve
        essere un valore intero, nel caso delle serie storiche rappresenta la
        frequenza delle osservazioni (1 = annuale; 4 = trimestrale; 12 =
        mensile; 52 = settimanale; 5, 6, o 7 = giornaliera; 24 = oraria). Nel
        caso di dati panel, la periodicità è il numero di righe per ogni blocco
        di dati, ossia il numero di unità cross section se i dati sono
        organizzati come pila di dati cross section, o il numero di periodi se i
        dati sono organizzati come pila di serie storiche. Nel caso di semplici
        dati cross section, la periodicità dev'essere impostata a 1.
      </para>
      <para>
	L'osservazione iniziale rappresenta la data iniziale nel caso
        delle serie storiche. Gli anni possono essere indicati con due
        o quattro cifre, mentre i sotto-periodi (ad esempio i trimestri
        o i mesi) devono essere separati dagli anni con un carattere "due punti".
	Nel caso di dati panel, l'osservazione iniziale va indicata come
	1:1, mentre nel caso di dati cross section come 1. L'osservazione
        iniziale per i dati giornalieri o settimanali va indicata nella forma
	AA/MM/GG o AAAA/MM/GG (oppure semplicemente 1 per i dati non datati).
      </para>
      <para>
        La seconda forma del comando (che richiede l'uso dell'opzione
	<lit>--panel-vars</lit>) può essere usata per imporre un'interpretazione
        panel dei dati, quando il dataset contiene variabili che identificano in
        modo univoco le unità cross section e i periodi. Il dataset verrà
        ordinato come pila di serie storiche, per valori crescenti della
        variabile che rappresenta le unità, <repl>variabile-unità</repl>.
      </para>
      <para>
	Se non viene usata nessuna opzione per indicare esplicitamente
        la struttura dei dati, il programma cercherà di riconoscerla automaticamente
        a partire dalle informazioni indicate.
      </para>
    </description>

    <gui-access>
      <menu-path>Dati/Struttura dataset</menu-path>
    </gui-access>

  </command>

  <command name="setmiss" section="Dataset"
    label="Codice dei valori mancanti">

    <usage>
      <arguments>
        <argument>valore</argument>
        <argument optional="true">lista-variabili</argument>
      </arguments>
      <examples>
        <example>setmiss -1</example>
        <example>setmiss 100 x2</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
	Imposta il programma in modo da interpretare un dato valore
        numerico (il primo parametro indicato al comando) come codice
        per i <quote>valori mancanti</quote> nei dati importati. Se
        questo valore è l'unico parametro fornito, come nel primo degli
        esempi precedenti, l'interpretazione verrà applicata a tutte le
        serie del dataset. Se <repl quote="true">valore</repl> è seguito
        da una lista di variabili, indicate per nome o numero,
        l'interpretazione è limitata solo alle variabili specificate.
        Così, nel secondo esempio, il valore 100 è interpretato come
        codice per <quote>mancante</quote>, ma solo per la variabile
        <lit>x2</lit>.
      </para>
      
      <para context="gui">
	Imposta un valore numerico che verrà interpretato come
        "mancante" o "non applicabile", per una particolare serie (sotto
        il menù Variabile) o globalmente per l'intero dataset (sotto il
        menù Campione).</para> 
      
      <para context="gui">
      Gretl ha un codice interno per i valori mancanti, che non sempre
      può coincidere con quello usato dai dati importati. Ad esempio, se
      una serie usa il valore -1 col significato di "non disponibile", è
      possibile selezionare "Imposta codice valori mancanti" nel menù
      Variabile e immettere il valore "-1" (senza le virgolette); gretl
      interpreterà quindi i valori -1 come osservazioni mancanti.</para>

    </description>

    <gui-access>
      <menu-path>/Campione/Imposta codice valori mancanti</menu-path>
    </gui-access>

  </command>

  <command name="shell" section="Utilities" label="Esegue comandi shell" context="cli">

    <usage>
      <arguments>
        <argument>comando-shell</argument>
      </arguments>
      <examples>
        <example>! ls -al</example>
	<example>! notepad</example>
	<example>launch notepad</example>
      </examples>
    </usage>

    <description>
      <para>
        Un <cmd>!</cmd>, o la parola chiave <cmd>launch</cmd>, all'inizio di una
        riga di comando è interpretato come passaggio all'interprete di comandi
        (shell) usato dall'utente nel sistema operativo. In questo modo è
        possibile eseguire comandi shell arbitrari dall'interno di
	<program>gretl</program>. Quando si usa <cmd>!</cmd>, il comando esterno
        viene eseguito in modalità sincrona, ossia <program>gretl</program> aspetta
        il termine della sua esecuzione prima di procedere. Se invece si vuole
        avviare un altro programma da dentro <program>gretl</program> senza
        aspettare che abbia completato la sua esecuzione (modalità asincrona),
        occorre usare <cmd>launch</cmd>.
      </para>
      
      <para>
        Per motivi di sicurezza, questa funzionalità è disabilitata in modalità
        predefinita. Per attivarla, occorre selezionare la casella
        <quote>Abilita comandi shell</quote> nel menù File, Preferenze. In
        questo modo si renderanno disponibili i comandi shell anche nella
        modalità a riga di comando di <program>gretl</program> (questo è l'unico
        modo per farlo).
      </para>
    </description>

  </command>

  <command name="smpl" section="Dataset" label="Imposta l'intervallo del campione" context="cli">

    <!-- don't break the lines below or the text version will get messed
    up -->

    <usage>
      <altforms>
	<altform><lit>smpl</lit> <repl>oss-iniziale oss-finale</repl></altform>
	<altform><lit>smpl</lit> <repl>+i -j</repl></altform>
	<altform><lit>smpl</lit> <repl>variabile-dummy</repl> <lit>--dummy</lit></altform>
	<altform><lit>smpl</lit> <repl>condizione</repl> <lit>--restrict</lit></altform>
	<altform><lit>smpl</lit> <lit>--no-missing [ </lit><repl>lista-variabili</repl> <lit>]</lit></altform>
 	<altform><lit>smpl</lit> <repl>n</repl> <lit>--random</lit></altform>
	<altform><lit>smpl full</lit></altform>
      </altforms>
      <examples>
        <example>smpl 3 10</example>
	<example>smpl 1960:2 1982:4</example>
	<example>smpl +1 -1</example>
	<example>smpl x > 3000 --restrict</example>
	<example>smpl y > 3000 --restrict --replace</example>
	<example>smpl 100 --random</example>
      </examples>
    </usage>

    <description>
      <para>
	Reimposta l'intervallo del campione. Il nuovo intervallo può
        essere definito in vari modi. Nel primo modo (corrispondente ai
        primi due esempi precedenti) <repl>oss-iniziale</repl> e
        <repl>oss-finale</repl> devono essere coerenti con la
        periodicità dei dati. Una delle due può essere sostituita da un
        punto e virgola per lasciare intatto il valore attuale. Nel
        secondo modo, gli interi <repl>i</repl> e <repl>j</repl> (che
        possono essere positivi o negativi e vanno indicati con il
        segno) sono presi come spostamenti relativi ai punti iniziale e
        finale del campione in uso. Nel terzo modo,
        <repl>variabile-dummy</repl> deve essere una variabile
        indicatrice che assume solo valori 0 o 1 e il campione verrà
        ristretto alle osservazioni per cui la variabile dummy vale 1.
	Il quarto modo, che usa <lit>--restrict</lit>, limita il
        campione alle osservazioni che soddisfano la condizione Booleana
	specificata secondo la sintassi del comando <cmdref
        targ="genr"/>.</para>

      <para>Con la forma <lit>--no-missing</lit>, se viene specificata
      una <repl>lista-variabili</repl>, vengono selezionate le osservazioni
      per cui tutte le variabili nella <repl>lista-variabili</repl>
      hanno valori validi in corrispondenza dell'osservazione; altrimenti, se
      non viene indicata alcuna <repl>lista-variabili</repl>, vengono
      selezionate le osservazioni per cui <emphasis>tutte</emphasis> le
      variabili hanno valori validi (non mancanti).</para>

      <para>Con la forma <lit>--random</lit>, viene estratto casualmente dal
      dataset il numero indicato di osservazioni. Per essere in grado di
      replicare questa selezione, occorre per prima cosa impostare il seme
      del generatore di numeri casuali (si veda il comando
	<cmdref targ="set"/>).</para>
 
      <para>La forma finale, <lit>smpl full</lit>, ripristina
      l'intervallo completo del campione.
      </para>
 
      <para>Si noti che i vincoli sul campione di solito sono cumulativi:
      il valore di riferimento di ogni comando <lit>smpl</lit> è il campione
      attuale. Se si vuole che il comando funzioni sostituendo i vincoli esistenti,
      così che ogni vincolo si aggiunga a quelli già impostati, occorre usare
      l'opzione <lit>--replace</lit> alla fine del comando.</para>

      <para>La variabile interna <lit>obs</lit> può essere usata con la
      forma <lit>--restrict</lit> di <lit>smpl</lit> per escludere
      particolari osservazioni dal campione. Ad esempio,</para>

      <code>
	smpl obs!=4 --restrict
      </code>
        
      <para>scarterà la quarta osservazione. Se le osservazioni sono
        identificate da etichette,</para>
        
      <code>
        smpl obs!="USA" --restrict
      </code>
        
        <para>scarterà l'osservazione a cui è associata l'etichetta <quote>USA</quote>.
        </para>

      <para>Per le forme <lit>--dummy</lit>, <lit>--restrict</lit> e
      <lit>--no-missing</lit> di <lit>smpl</lit>, occore tenere presente
      che tutte le informazioni <quote>strutturali</quote> contenute nel
      file dei dati (a proposito della struttura di serie storiche o di
      panel dei dati) vengono perse. È possibile reimpostare la
      struttura originale con il comando <cmdref targ="setobs"/>.
      </para>

      <para>Si veda la <guideref targ="sampling"/> per ulteriori dettagli.</para>
    
    </description>

    <gui-access>
      <menu-path>/Campione</menu-path>
    </gui-access>

  </command>

  <command name="spearman" section="Statistics"
    label="Correlazione di rango di Spearman">

    <usage>
      <arguments>
        <argument>x</argument>
        <argument>y</argument>
      </arguments>
      <options>
        <option>
	  <flag>--verbose</flag>
	  <effect>mostra i dati ordinati</effect>
        </option>
      </options>
    </usage>

    <description>
      <para context="cli">
	Mostra il coefficiente di correlazione di rango di Spearman per
        le variabili <math>x</math> e <math>y</math>. Le
        variabili non devono essere state ordinate manualmente in
        precedenza, se ne occupa la funzione.
      </para>

      <para context="gui">
	Mostra il coefficiente di correlazione di rango di Spearman 
        per una coppia di variabili.  Le variabili non devono essere
        state ordinate manualmente in precedenza, se ne occupa la
        funzione.</para>

      <para>
	L'ordinamento automatico è dal massimo al minimo (ossia il
        valore massimo nei dati assume il rango 1). Se occorre invertire
        l'ordinamento, creare una variabile che è il negativo della
        variabile originale, ad esempio:
      </para>

      <code>
	genr altx = -x
	spearman altx y
      </code>
    </description>

    <gui-access>
      <menu-path>/Modello/Stima robusta/SPEARMAN - Correlazione di rango</menu-path>
    </gui-access>

  </command>

  <command name="sprintf" section="Printing" 
    label="Stampa su una stringa" context="cli">

    <usage>
      <arguments>
	<argument>var-stringa</argument>
        <argument>formato</argument>
	<argpunct>, </argpunct>
        <argument>argomenti</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Questo comando funziona esattamente come il comando <cmdref targ="printf"/>,
        stampando gli argomenti nel modo controllato dalla stringa di formato,
        tranne per il fatto che il risultato è scritto nella stringa
        specificata, <repl>var-stringa</repl>.
      </para>
      <para>
	Per stampare la variabile stringa, basta usare il suo nome preceduto da
	<lit>@</lit>, come in questo esempio:
      </para>
      <code>
	sprintf variabile "%g", x
	print "variabile ha il valore @variabile"
      </code>
    </description>

  </command>

  <command name="square" section="Transformations" label="Crea quadrati delle
    variabili" context="cli">

    <usage>
      <arguments>
        <argument>lista-variabili</argument>
      </arguments>
      <options>
        <option>
	  <flag>--cross</flag>
	  <effect>genera anche i prodotti incrociati, oltre ai quadrati</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Genera nuove variabili che sono i quadrati delle variabili nella
	<repl>lista-variabili</repl> (con anche i prodotti incrociati,
        se si usa l'opzione <lit>--cross</lit>). Ad esempio, <cmd>square
          x y</cmd> genera <lit>sq_x</lit> = <lit>x</lit> al quadrato,
          <lit>sq_y</lit> = <lit>y</lit> al quadrato e (opzionalmente)
          <lit>x_y</lit> = <lit>x</lit> per <lit>y</lit>.
	Se una particolare variabile è una dummy, non ne viene fatto il
        quadrato, visto che si otterrebbe la stessa variabile.
      </para>
    </description>

    <gui-access>
      <menu-path>/Aggiungi/Quadrati delle variabili selezionate</menu-path>
    </gui-access>

  </command>

  <command name="sscanf" section="Programming" 
    label="Scansione di una stringa" context="cli">

    <usage>
      <arguments>
	<argument>stringa</argument>
	<argpunct>, </argpunct>
        <argument>formato</argument>
	<argpunct>, </argpunct>
        <argument>argomenti</argument>
      </arguments>
    </usage>

    <description>
      <para>
        Analizza una <repl>stringa</repl> seguendo il <repl>formato</repl>
        indicato, assegnando zero o più valori agli <repl>argomenti</repl>
        indicati. È una versione semplificata della funzione
	<lit>sscanf</lit> del linguaggio di programmazione C.
      </para>
      <para>
        La <repl>stringa</repl> può essere una stringa vera e propria,
	racchiusa tra virgolette doppie, o il nome di una variabile stringa
	predefinita. Il <repl>formato</repl> è definito in modo simile alla
	stringa di formato del comando <cmdref targ="printf"/> (si veda
	oltre). Gli <repl>argomenti</repl> sono una lista separata da virgole
	che contiene i nomi di variabili predefinite che verranno assegnate a
	seconda dei valori letti dalla <repl>stringa</repl>. Per chi conosce
	il C: è possibile prefissare con <lit>&amp;</lit> i nomi delle
	variabili numeriche, ma non è richiesto.
      </para>
      <para>
	Le regole specificate nel <repl>formato</repl> vengono usate per
        analizzare la <repl>stringa</repl>. Le specifiche iniziano con un
        carattere <lit>%</lit>, e comprendono
        <lit>%f</lit>, <lit>%g</lit> o <lit>%lf</lit> per i numeri in virgola
        mobile; <lit>%d</lit> per gli interi; <lit>%s</lit> per le stringhe, e
	<lit>%m</lit> per le matrici. È possibile inserire un numero intero
        positivo dopo il carattere percento, per impostare il numero massimo di
        caratteri da leggere per ogni tipo di specifica (o il massimo numero di
        righe nel caso di conversione in matrici). In alternativa è possibile
        inserire un carattere <lit>*</lit> dopo il percento per sopprimere la
        conversione di un certo numero di caratteri della stringa. Ad esempio,
	<lit>%3d</lit> converte i 3 caratteri successivi della <repl>stringa</repl>
        in un numero intero, se possibile; <lit>%*g</lit> salta tutti i caratteri
        nella <repl>stringa</repl> che potrebbero essere convertiti in un numero
        a virgola mobile.
      </para>
      <para>
	La conversione in matrici funziona nel modo seguente: viene letta ogni
        riga dell'input e vengono contati i campi numerici (separati da spazi o
        tab). In questo modo viene definito il numero di colonne della matrice.
        Vengono quindi lette tutte le righe seguenti che contengono lo stesso
        numero di colonne numeriche; è anche possibile limitare il numero
        massimo di righe da leggere.
      </para>
      <para>
        Oltre alla conversione <lit>%s</lit> per le stringhe, è disponibile
        anche una versione semplificata del formato C
        <lit>%</lit><repl>N</repl><lit>[</lit><repl>caratteri</repl><lit>]</lit>.
        In questo formato, <repl>N</repl> è il numero massimo di caratteri da
        leggere, e <repl>caratteri</repl> è un insieme di caratteri accettabili,
        racchiusi tra parentesi quadre; la lettura si ferma se si raggiunge il
        limite di <repl>N</repl> o se si incontra un carattere non compreso
        nell'insieme ammissibile. La funzione dell'insieme
	<repl>caratteri</repl> può essere invertita specificando un accento
        circonflesso <lit>^</lit> come primo carattere dell'insieme; in questo
        caso, la lettura si ferma se si incontra un carattere dell'insieme
        specificato. Al contrario del C, il carattere trattino non ha alcuna
        funzione speciale in questo contesto.
      </para>
      <para>
	Se la stringa non corrisponde esattamente al formato specificato, il
        numero di conversioni effettuate può risultare diverso dal numero di
        argomenti indicati. Per gretl questo non è necessariamente un errore,
        tuttavia può essere utile voler controllare questa corrispondenza; è
        possibile farlo usando la variabile scalare interna
	<lit>$nscan</lit>, il cui valore viene aggiornato ogni volta che si
        usa <lit>sscanf</lit>. In caso di uso interattivo viene mostrato anche
        il numero di conversioni effettuate.
      </para>
      <para>
	Ecco alcuni esempi:
      </para>
      <code>
	scalar x
	scalar y
	sscanf "123456", "%3d%3d", x, y

	sprintf S "1 2 3 4\n5 6 7 8"
	S
	matrix m
	sscanf S, "%m", m
	print m
      </code>

    </description>

  </command>

  <command name="store" section="Dataset"
    label="Salvataggio dei dati">

    <usage>
      <arguments>
        <argument>file-dati</argument>
        <argument optional="true">lista-variabili</argument>
      </arguments>
      <options>
        <option>
	  <flag>--csv</flag>
	  <effect>usa il formato CSV</effect>
        </option>
        <option>
	  <flag>--omit-obs</flag>
	  <effect>si veda oltre, a proposito del formato CSV</effect>
        </option>
        <option>
	  <flag>--gnu-octave</flag>
	  <effect>usa il formato GNU Octave</effect>
        </option>
        <option>
	  <flag>--gnu-R</flag>
	  <effect>usa il formato GNU R</effect>
        </option>
        <option>
	  <flag>--traditional</flag>
	  <effect>usa il formato tradizionale ESL</effect>
        </option>
        <option>
	  <flag>--gzipped</flag>
	  <effect>comprime con gzip</effect>
        </option>
        <option>
	  <flag>--jmulti</flag>
	  <effect>usa il formato ASCII di JMulti</effect>
        </option>
        <option>
	  <flag>--dat</flag>
	  <effect>usa il formato ASCII di PcGive</effect>
        </option>
        <option>
         <flag>--database</flag>
         <effect>usa il formato database di gretl</effect>
        </option>
        <option>
         <flag>--overwrite</flag>
         <effect>cfr oltre, a proposito del formato dei database</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Salva l'intero dataset, o un sottoinsieme delle variabili se è
        stata indicata una <repl>lista-variabili</repl>, nel file
        indicato con <repl>file-dati</repl>.</para>

      <para>
	L'impostazione predefinita è di salvare i dati nel formato
        <quote>interno</quote> di gretl, ma le opzioni del comando
        permettono di usare formati alternativi. I dati CSV
        (Comma-Separated Values, dati separati da virgole) possono
        essere letti dai programmi di foglio elettronico e possono
        essere modificati con un editor di testi. I formati
        <program>Octave</program>, <program>R</program> e
        <program>PcGive</program> sono destinati ad essere usati con i
        rispettivi programmi. La compressione con gzip può essere utile per
        grandi dataset. Si veda la <guideref targ="datafiles"/> per i dettagli sui
        vari formati.</para>

      <para>
	L'opzione <lit>--omit-obs</lit> è applicabile solo quando si salvano
        dati in formato CSV. In modalità predefinita, se i dati sono serie
        storiche o panel, o se il dataset include marcatori per osservazioni
        specifiche, il file CSV comprende una prima colonna che identifica le
        osservazioni (ad esempio per data). Se si usa <lit>--omit-obs</lit>,
        questa colonna verrà omessa e verranno salvati solo i dati effettivi.
      </para>

      <para>
	Si noti che le variabili scalari non saranno salvate
        automaticamente: per salvarle occorre includerle esplicitamente
        nella <repl>lista-variabili</repl>.
      </para>  

      <para>
        L'opzione di salvataggio in formato database di gretl è indicata se
        occorre costruire dei grandi dataset di serie, magari con frequenze
        diverse e diversi intervalli di osservazioni. Al momento questa opzione
        è disponibile solo per dati annuali, trimestrali o mensili. Salvando su
        un file che esiste già, il comportamento predefinito è quello di
        accodare le nuove serie al contenuto del database preesistente. In
        questo contesto, se una o più delle variabili da salvare hanno lo stesso
        nome di una delle variabili già presenti nel database si otterrà un
        messaggio di errore. L'opzione <lit>--overwrite</lit> permette invece di
        sovrascrivere eventuali variabili del dataset che hanno lo stesso nome
        delle nuove variabili, in modo che queste ultime rimpiazzino le
        variabili preesistenti.
      </para>

    </description>

    <gui-access>
      <menu-path>/File/Salva dati; /File/Esporta dati</menu-path>
    </gui-access>

  </command>

  <command name="summary" section="Statistics" label="Statistiche descrittive" context="cli">

    <usage>
      <arguments>
        <argument optional="true">lista-variabili</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Mostra le statistiche descrittive per le variabili nella
	<repl>lista-variabili</repl>, o per tutte le variabili nel
        dataset, se non si indica una <repl>lista-variabili</repl>.
        L'output comprende media, scarto quadratico medio, coefficiente
        di variazione (= scarto quadratico medio / media), mediana, minimo,
        massimo, coefficiente di asimmetria, curtosi.
      </para>
    </description>

    <gui-access>
      <menu-path>/Visualizza/Statistiche descrittive</menu-path>
      <other-access>Menù pop-up nella finestra principale</other-access>
    </gui-access>

  </command>

  <command name="system" section="Estimation" label="Sistemi di equazioni">

    <usage>
      <altforms>
	<altform><lit>system method=</lit><repl>stimatore</repl></altform>
	<altform><repl>nome-sistema</repl><lit> &lt;- system</lit></altform>
      </altforms>
      <examples>
	<example>"Klein Model 1" &lt;- system</example>
        <example>system method=sur</example>
	<example>system method=3sls</example>
	<demos>
	  <demo>klein.inp</demo>
	  <demo>kmenta.inp</demo>
	  <demo>greene14_2.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>

      <para context="gui">In questa finestra, è possibile stimare sistemi di
        equazioni e scegliere uno stimatore per il sistema. È possibile indicare
        i seguenti quattro tipi di comandi:
      </para>

      <para context="cli">
	Inizia un sistema di equazioni. Esistono due versioni del comando,
        a seconda che si voglia salvare il sistema per poterlo stimare in
        più modi diversi, oppure stimare il sistema una volta sola.
      </para>

      <para context="cli">
	Per salvare il sistema occorre dargli un nome, come nel primo esempio
        proposto (se il nome contiene spazi, occorre racchiuderlo tra virgolette).
        In questo caso, è possibile stimare il sistema con il comando
	<cmdref targ="estimate"/>. Una volta che il sistema è stato salvato, è
        possibile imporre dei vincoli su di esso (compresi vincoli incrociati
        tra equazioni) usando il comando <cmdref targ="restrict"/>.
      </para>

      <para context="cli">
	In alternativa, è possibile indicare uno stimatore per il sistema
	usando <lit>method=</lit> seguito da una stringa che identifica uno
        degli stimatori supportati: <cmd>ols</cmd> (ordinary least squares -
        minimi quadrati ordinari), <cmd>tsls</cmd> (two-stage least squares -
        minimi quadrati a due stadi), <cmd>sur</cmd> (seemingly unrelated
        regressions - regressioni apparentemente non collegate), <cmd>3sls</cmd>
        (three-stage least squares - minimi quadrati a tre stadi),
        <cmd>fiml</cmd> (full information maximum likelihood - massima
        verosimiglianza con informazione completa) o <cmd>liml</cmd> (limited
        information maximum likelihood - massima verosimiglianza con
        informazione limitata). In questo caso, il sistema viene stimato appena
        completata la sua definizione.
      </para>

      <para context="cli">Un sistema di equazioni termina con la riga
	<cmd>end system</cmd>.  All'interno del sistema possono essere
        definiti i quattro tipi di istruzioni seguenti.</para>

      <ilist>
	<li><para><cmdref targ="equation"/>: specifica un'equazione del sistema.
	    Occorre indicarne almeno due.</para>
	</li>
	<li><para><cmd>instr</cmd>: per i sistemi da stimare con i minimi
            quadrati a tre stadi, indica la lista degli strumenti (indicati
            dal nome o dal numero della variabile). In alternativa, è possibile
	    fornire questa informazione nella riga <cmd>equation</cmd> usando la
            stessa sintassi accettata dal comando <cmdref targ="tsls"/>.</para>
	</li>
	<li><para><cmd>endog</cmd>: per i sistemi di equazioni simultanee, indica
            la lista delle variabili endogene. È indicato principalmente per
            la stima FIML, ma può essere usato anche nella stima minimi quadrati
            a tre stadi al posto dell'istruzione <cmd>instr</cmd>: in questo modo
            tutte le variabili non identificate come endogene verranno usate come
            strumenti.</para>
	</li>
	<li><para><cmd>identity</cmd>: per la stima FIML, un'identità che collega
            due o più variabili del sistema. Questo tipo di istruzione è ignorata
            se viene usato uno stimatore diverso da FIML.
	  </para>
	</li>
      </ilist>
        
      <para context="cli">
	Dopo la stima eseguita con i comandi <cmd>system</cmd> o
	<cmd>estimate</cmd> è possibile recuperare informazioni aggiuntive dalle
        seguenti variabili accessorie:
      </para>

      <ilist context="cli">
	<li>
          <para><lit>$uhat</lit>: la matrice dei residui, una colonna per
            equazione.
	  </para>
	</li>
	<li>
          <para><lit>$yhat</lit>: la matrice dei valori stimati, una colonna
            per equazione.
	  </para>
	</li>
	<li>
          <para><lit>$coeff</lit>: il vettore colonna dei coefficienti (tutti
            i coefficienti della prima equazione, seguiti da quelli della seconda
            equazione, e così via).
	  </para>
	</li>
	<li>
          <para><lit>$vcv</lit>: la matrice di covarianza dei coefficienti.
            Se il vettore <lit>$coeff</lit> ha <math>k</math> elementi,
            questa matrice ha dimensione <math>k</math> per <math>k</math>.
	  </para>
	</li>
	<li>
          <para><lit>$sigma</lit>: la matrice di covarianza dei residui
          incrociata tra equazioni.
	  </para>
	</li>
	<li><para><lit>$sysGamma</lit>, <lit>$sysA</lit> e <lit>$sysB</lit>: 
          matrici dei coefficienti in forma strutturale (si veda oltre).
	  </para>
	</li>
      </ilist>

      <para context="cli">
        Se si vuole salvare i residui o i valori stimati per una specifica
        equazione come serie di dati, basta selezionare la colonna dalla matrice
	<lit>$uhat</lit> o <lit>$yhat</lit> e assegnarla a una serie, come in
      </para>
      <code context="cli">
	series uh1 = $uhat[,1]
      </code>

      <para context="cli">
	Le matrici in forma strutturale corrispondono alla seguente
        rappresentazione di un modello ad equazioni simultanee:
	<equation status="display"
	  tex="\[\Gamma y_t=Ay_{t-1}+Bx_t+\epsilon_t\]"
	  ascii="Gamma y(t) = A y(t-1) + B x(t) + e(t)"
	  graphic="structural"/> Se ci sono <math>n</math> variabili endogene e
          <math>k</math> variabili esogene,
	<equation status="inline"
	  tex="$\Gamma$"
	  ascii="Gamma"
	  graphic="Gamma"/> è una matrice <by r="n" c="n"/> e <math>B</math> è
	<by r="n" c="k"/>. Se il sistema non contiene ritardi delle variabili
        endogene, la matrice <math>A</math> non è presente. Se il massimo
        ritardo di un regressore endogeno è <math>p</math>, la matrice
	<math>A</math> è <by r="n" c="np"/>.
       </para>
      
    </description>
    
    <gui-access>
      <menu-path>/Modello/Equazioni simultanee</menu-path>
    </gui-access>

  </command>

  <command name="tabprint" section="Printing" label="Stampa modelli in forma
    tabulare" context="cli">

    <usage>
      <arguments>
        <argument optional="true">-f nomefile</argument>
      </arguments>
      <options>
        <option>
	  <flag>--rtf</flag>
	  <effect>Produce RTF invece di &latex;</effect>
        </option>
        <option>
	  <flag>--complete</flag>
	  <effect>Crea un documento completo</effect>
        </option>
        <option>
	  <flag>--format="f1|f2|f3|f4"</flag>
	  <effect>Specifica un formato personalizzato</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Va eseguito dopo la stima di un modello.  Stampa il modello
        stimato sotto forma di tabella, in formato &latex;, o, se viene
        usata l'opzione <lit>--rtf</lit>, in formato RTF.  Se viene specificato
        un nome di file dopo l'opzione <lit>-f</lit>, l'output viene scritto nel
        file, altrimenti viene scritto in un file col nome
        <filename>model_N.tex</filename> (o <filename>model_N.rtf</filename>),
        dove <lit>N</lit> è il numero dei modelli stimati finora nella sessione
        in corso.
      </para>
      <para>
        Le opzioni illustrate di seguito sono disponibili solo per il formato
        &latex;.
      </para>
      <para>
	Usando l'opzione <lit>--complete</lit>, il file &latex; è un
        documento completo, pronto per essere processato; altrimenti il
        file va incluso in un documento.
      </para>
      <para>
	Se si intende modificare lo stile del formato tabulare, è possibile
        specificare un formato personalizzato usando l'opzione <lit>--format</lit>,
        seguita da una stringa di formato. La stringa di formato va inclusa tra
        virgolette doppie e deve essere unita all'opzione con un segno di
        uguale. La composizione della stringa di formato è la seguente: ci sono
        quattro campi, che rappresentano il coefficiente, l'errore standard, il
        rapporto <math>t</math> e il p-value. Questi campi vanno separati
        usando barre verticali e possono contenere una specificazione di formato
        per valori numerici nello stile della funzione <lit>printf</lit>, oppure
        possono essere lasciati in bianco, in modo da sopprimere la
        visualizzazione del campo nella rispettiva colonna dela tabella (con
        l'unico vincolo che non è possibile lasciare in bianco tutti i campi).
        Ecco alcuni esempi:
      </para>
      <code>
	--format="%.4f|%.4f|%.4f|%.4f"
	--format="%.4f|%.4f|%.3f|"
	--format="%.5f|%.4f||%.4f"
	--format="%.8g|%.8g||%.4f"
      </code>
      <para>
	La prima specificazione stampa i valori di tutte le colonne usando 4
        cifre decimali. La seconda sopprime il p-value e mostra il rapporto
	<math>t</math> con 3 cifre decimali. La terza omette il rapporto
	<math>t</math>, mentre l'ultima omette il rapporto
	<math>t</math> e mostra sia il coefficiente che l'errore standard
        con 8 cifre significative.
      </para>
      <para>
	Una volta che si imposta un formato in questo modo, esso viene ricordato
        e usato per tutta la sessione di lavoro. Per tornare ad usare il formato
        predefinito, basta usare la parola chiave <lit>--format=default</lit>.
      </para>
    </description>

    <gui-access>
      <menu-path>Finestra del modello, /LaTeX</menu-path>
    </gui-access>

  </command>

  <command name="testuhat" section="Tests" context="cli"
    label="Normalità dei residui">

    <description>
      <para>
	Deve seguire un comando di stima. Mostra la distribuzione di
        frequenza dei residui del modello, insieme a un test chi-quadro
        per la normalità, basato sulla procedura suggerita da Doornik
        e Hansen (1994).
      </para>
    </description>

    <gui-access>
      <menu-path>Finestra del modello, /Test/Normalità dei residui</menu-path>
    </gui-access>

  </command>

  <command name="tobit" section="Estimation" label="Stima Tobit">

    <usage>
      <arguments>
        <argument>variabile-dipendente</argument>
        <argument>variabili-indipendenti</argument>
      </arguments>
      <options>
        <option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
        </option>
        <option>
	  <flag>--verbose</flag>
	  <effect>mostra i dettagli delle iterazioni</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>Stima un modello Tobit. Il modello può essere appropriato
      quando la variabile dipendente è <quote>censurata</quote>. Ad
      esempio, vengono osservati valori positivi o nulli della spesa dei
      consumatori per beni durevoli, ma non valori negativi; tuttavia le
      decisioni di spesa possono essere pensate come derivanti da una
      propensione al consumo, sottostante e non osservata, che può anche
      essere negativa in alcuni casi. Per i dettagli si veda il capitolo
      20 di <book>Econometric Analysis</book> di Greene.</para>
    </description>

    <gui-access>
      <menu-path>/Modello/Modelli non lineari/Tobit</menu-path>
    </gui-access>

  </command>

  <command name="transpos" section="Dataset" label="Trasposizione dei dati"
  context="gui">

    <description>
      <para>
	Traspone il dataset attuale, ossia, ogni osservazione (riga) del
        dataset attuale verrà trattata come una variabile (colonna) e
        ogni variabile come un'osservazione. Questo comando è utile se
        sono stati importati da una fonte esterna dati in cui le righe
        rappresentano variabili e le colonne osservazioni.
      </para>
      <para>
	Si veda anche <cmdref targ="dataset"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Dati/Trasponi dati</menu-path>
    </gui-access>

  </command>

  <command name="tsls" section="Estimation"
    label="Stima minimi quadrati a due stadi">

    <usage>
      <arguments>
        <argument>variabile-dipendente</argument>
        <argument>variabili-indipendenti</argument>
	<argument separated="true">strumenti</argument>
      </arguments>
      <options>
        <option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
        </option>
	<option>
	  <flag>--robust</flag>
	  <effect>errori standard robusti</effect>
        </option>
      </options>      
      <examples>
        <example>tsls y1 0 y2 y3 x1 x2 ; 0 x1 x2 x3 x4 x5 x6</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
	Calcola le stime minimi quadrati a due stadi (TSLS o IV), date
        la <repl>variabile-dipendente</repl> e la lista di
	<repl>variabili-indipendenti</repl> (incluse le variabili
        esogene) nell'equazione strutturale per cui sono richieste le
        stime TSLS; <repl>strumenti</repl> è la lista completa delle
        variabili esogene e predeterminate in tutte le equazioni. Se la
        lista degli <repl>strumenti</repl> non è lunga almeno quanto
        quella delle <repl>variabili-indipendenti</repl>, il modello non
        è identificato.</para>

      <para context="cli">
	Nell'esempio precedente, le <lit>y</lit> sono le variabili
        endogene e le <lit>x</lit> sono le variabili esogene e
        predeterminate.
      </para>

      <para context="gui">
	Questo comando richiede la scelta di due liste di variabili; le
        variabili indipendenti che appaiono nel modello e un elenco di
        "strumenti". Questi ultimi comprendono le variabili esogene e/o
        altre variabili predeterminate che possono essere usate come
        regressori per derivare valori stimati delle variabili endogene
        del modello.
      </para>

      <para context="gui">Se alcune delle variabili del modello sono
        esogene, vanno incluse in entrambe le liste.
      </para>
      
      <para>
	L'output del comando comprende il test di Hausman e, se il modello è
        sovra-identificato, il test di Sargan per la sovra-identificazione. Nel
        test di Hausman, l'ipotesi nulla è che le stime OLS siano consistenti, o
        in altre parole che non sia richiesta la stima per mezzo di variabili
        strumentali. Un modello di questo tipo è sovra-identificato se ci sono
        più strumenti di quelli strettamente necessari. Il test di Sargan è
        basato su una regressione ausiliaria dei residui del modello minimi
        quadrati a due stadi sull'intera lista degli strumenti. L'ipotesi nulla
        è che tutti gli strumenti siano validi, cosa di cui si dovrebbe dubitare
        se la regressione ausiliaria ha un significativo potere esplicativo.
	Davidson e MacKinnon (2004, capitolo 8) forniscono una buona spiegazione di
        entrambi i test.
      </para>

    </description>

    <gui-access>
      <menu-path>/Modello/TSLS - Minimi quadrati a due stadi</menu-path>
    </gui-access>

  </command>

  <command name="var" section="Estimation"
    label="Autoregressione vettoriale">

    <usage>
      <arguments>
        <argument>ordine</argument>
        <argument>lista-variabili</argument>
	<argument separated="true" optional="true">lista-esogene</argument>
      </arguments>
      <options>
        <option>
	  <flag>--nc</flag>
	  <effect>non include una costante</effect>
        </option>
	<option>
	  <flag>--trend</flag>
	  <effect>include un trend</effect>
	</option>
        <option>
	  <flag>--seasonals</flag>
	  <effect>include variabili dummy stagionali</effect>
        </option>
        <option>
	  <flag>--robust</flag>
	  <effect>errori standard robusti</effect>
        </option>
        <option>
	  <flag>--impulse-responses</flag>
	  <effect>mostra impulso-risposta</effect>
        </option>
        <option>
	  <flag>--variance-decomp</flag>
	  <effect>mostra decomposizioni della varianza della previsione</effect>
        </option>
        <option>
	  <flag>--lagselect</flag>
	  <effect>mostra i criteri di informazione per la selezione dei ritardi</effect>
        </option>
      </options>
      <examples>
        <example>var 4 x1 x2 x3 ; time mydum</example>
	<example>var 4 x1 x2 x3 --seasonals</example>
	<example>var 12 x1 x2 x3 --lagselect</example>
      </examples>
    </usage>

    <description>

      <para context="gui">
	Questo comando richiede la specificazione dei seguenti elementi:</para>

      <ilist context="gui">
	<li><para context="gui">- L'ordine di ritardi, ossia il numero
        di ritardi di ogni variabile presente nel sistema;</para>
	</li>

        <li><para context="gui">- Eventuali termini esogeni
        (ma si noti che una costante viene inclusa automaticamente, a meno che
        non si richieda altrimenti; inoltre è possibile includere variabili
        dummy stagionali con l'apposita casella); e
        </para>
	</li>

	<li><para context="gui">- Una lista di variabili esogene,
        i cui ritardi saranno inclusi a destra delle equazioni (nota:
        non includere variabili ritardate in questa lista, verranno
        aggiunte automaticamente).</para>
	</li>
      </ilist>

      <para context="gui">Viene calcolata una regressione separata per
      ogni variabile del sistema; i risultati comprendono i test F per i
      vincoli di uguaglianza a zero su tutti i ritardi della variabili e
      un test F per il ritardo massimo, oltre (opzionalmente) alla
      scomposizione della varianza della previsione e alle funzioni di
      impulso-risposta.</para>  

      <para context="cli">
	Imposta e stima (usando OLS) un'autoregressione vettoriale (VAR).
        Il primo argomento specifica l'ordine di ritardo (o il massimo ordine di
        ritardi se è stata usata l'opzione <lit>--lagselect</lit>). L'ordine può
        essere indicato numericamente o con il nome di una variabile scalare
        preesistente.  Quindi segue l'impostazione della prima equazione. Non
        occorre includere i ritardi tra gli elementi della
        <repl>lista-variabili</repl>: verranno aggiunti automaticamente. Il
        punto e virgola separa le variabili stocastiche, per cui verrà incluso
        un numero di ritardi pari a <repl>ordine</repl>, dai termini
        deterministici o esogeni presenti nella
        <repl>lista-esogene</repl>. Si noti che viene inclusa
        automaticamente una costante, a meno che non si usi l'opzione
        <lit>--nc</lit>; inoltre è possibile aggiungere un trend con l'opzione
        <lit>--trend</lit> e variabili dummy stagionali con l'opzione
        <lit>--seasonals</lit>.
      </para>

      <para context="cli">
	Viene calcolata una regressione separata per ognuna delle
        variabili nella <repl>lista-variabili</repl>. Il risultato di
        ogni equazione include i test <math>F</math> per i vincoli
        di uguaglianza a zero su tutti i ritardi delle variabili, un
        test <math>F</math> per la significatività del ritardo massimo e,
        se è stata usata l'opzione <lit>--impulse-responses</lit>, la
        scomposizione della varianza della previsione e le funzioni di
        impulso-risposta.</para>

      <para>
	Le decomposizioni della varianza della previsione e le funzioni di
        impulso-risposta sono basate sulla decomposizione di Cholesky
        della matrice di covarianza contemporanea, e in questo contesto
        l'ordine in cui vengono date le variabili stocastiche conta.
	La prima variabile nella lista viene considerata come la
	<quote>più esogena</quote> all'interno del periodo. L'orizzonte
        per le decomposizioni della varianza e le funzioni di impulso-risposta
        può essere impostato usando il comando <cmdref targ="set"/>.
      </para> 
      <para context="cli">
        Se si usa l'opzione <lit>--lagselect</lit>, il primo parametro del comando
	<lit>var</lit> viene interpretato come il massimo ordine di ritardo.
        In questo caso, il comando non produce il solito risultato della stima del VAR, ma
        una tabella che mostra i valori dei criteri di informazione di Akaike
        (AIC), Schwartz (BIC) e Hannan&ndash;Quinn (HQC) calcolati per VAR
        dall'ordine 1 fino all'ordine massimo indicato, in modo da aiutare nella
        scelta dell'ordine di ritardo ottimale.
       </para>

    </description>

    <gui-access>
      <menu-path>/Modello/Serie storiche/VAR - Autoregressione vettoriale</menu-path>
    </gui-access>

  </command>
  
  <command name="VAR-lagselect" section="Tests" context="gui"
    label="Scelta dell'ordine di ritardi in un VAR">

    <description>
      <para>
        In questa finestra di dialogo è possibile testare la stima di un VAR
        per diversi ordini di ritardi; oltre a indicare la specificazione del
        VAR è possibile selezionare il massimo ordine di ritardi da testare.
      </para>

      <para>
        Il risultato consiste in una tabella che mostra i valori dei criteri
        di informazione di Akaike (AIC), Schwartz (BIC) e Hannan&ndash;Quinn (HQC)
        calcolati per VAR dall'ordine 1 fino all'ordine massimo indicato.
      </para>
    </description>

  </command>

  <command name="VAR-omit" section="Tests" context="gui"
    label="Test per variabili esogene in un VAR">

    <description>
      <para>
        In questa finestra di dialogo è possibile testare l'omissione da un VAR
        di un gruppo di variabili esogene.
      </para>
      <para>
        Viene calcolato un test del rapporto di verosimiglianza sotto l'ipotesi
        nulla che i coefficienti delle variabili indicate valgano zero in
        tutte le equazioni del VAR. Il test si basa sulla differenza tra il
        log-determinante della matrice di varianza per il modello non vincolato
        e per il modello con il vincolo che i coefficienti delle variabili
        indicate valgano zero.
      </para>
    </description>

  </command>

  <command name="varlist" section="Dataset" label="Elenca variabili" context="cli">

    <description>
      <para>
	Mostra un elenco delle variabili disponibili.
	<cmd>list</cmd> e <cmd>ls</cmd> sono sinonimi. 
      </para>
    </description>

  </command>

  <command name="vartest" section="Tests" label="Differenza delle varianze">

    <usage>
      <arguments>
        <argument>var1</argument>
        <argument>var2</argument>
      </arguments>
    </usage>

    <description>
      <para context="cli">
	Calcola la statistica <math>F</math> per l'ipotesi nulla
        che le varianze della popolazione per le variabili
	<repl>var1</repl> e <repl>var2</repl> siano uguali e mostra il
        p-value.
      </para>
      <para context="gui">
        Calcola la statistica <math>F</math> per l'ipotesi nulla
        che le varianze della popolazione per le variabili selezionate
        siano uguali e mostra il p-value.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modello/Modelli bivariati/Differenza delle varianze</menu-path>
    </gui-access>

  </command>

  <command name="vecm" section="Estimation"
    label="Modello vettoriale a correzione d'errore">

    <usage>
      <arguments>
        <argument>ordine</argument>
	<argument>rango</argument>
        <argument>lista-y</argument>
	<argblock optional="true" separated="true">
	  <argument>lista-x</argument>
	</argblock>
	<argblock optional="true" separated="true">
	  <argument>lista-rx</argument>
	</argblock>
      </arguments>
      <options>
        <option>
	  <flag>--nc</flag>
	  <effect>senza costante</effect>
        </option>
        <option>
	  <flag>--rc</flag>
	  <effect>costante vincolata</effect>
        </option>
        <option>
	  <flag>--crt</flag>
	  <effect>costante e trend vincolato</effect>
        </option>
        <option>
	  <flag>--ct</flag>
	  <effect>costante e trend non vincolato</effect>
        </option>
        <option>
	  <flag>--seasonals</flag>
	  <effect>include dummy stagionali centrate</effect>
        </option>
        <option>
	  <flag>--impulse-responses</flag>
	  <effect>mostra impulso-risposta</effect>
        </option>
        <option>
	  <flag>--variance-decomp</flag>
	  <effect>mostra decomposizioni della varianza delle previsioni</effect>
        </option>
      </options>
      <examples>
        <example>vecm 4 1 Y1 Y2 Y3</example>
        <example>vecm 3 2 Y1 Y2 Y3 --rc</example>
	<example>vecm 3 2 Y1 Y2 Y3 ; X1 --rc</example>
	<demos>
	  <demo>denmark.inp</demo>
	  <demo>hamilton.inp</demo>
	</demos>
      </examples>
    </usage>

    <description>
      <para>
	Un VECM è un tipo di autoregressione vettoriale, o VAR (si veda <cmdref
	  targ="var"/>), applicabile quando le variabili del modello sono
        individualmente integrate di ordine 1 (ossia, sono <quote>random walk</quote>
        con o senza deriva), ma esibiscono cointegrazione. Questo comando è
        strettamente connesso al test di Johansen per la cointegrazione (si veda
	<cmdref targ="coint2"/>).
      </para>
      <para context="cli">
        Il parametro <repl>ordine</repl> rappresenta l'ordine di ritardo del
        sistema VAR. Il numero di ritardi nel VECM (dove la variabile dipendente
        è data da una differenza prima) è pari a <repl>ordine</repl> meno uno.
      </para>
      <para context="gui">
        L'ordine di ritardo selezionato nella finestra di dialogo del VECM è
        quello del sistema VAR.  Per ottenere il numero di ritardi nel VECM
        (dove la variabile dipendente è data da una differenza prima) occorre
        sottrarre uno da questo numero.
      </para>
      <para context="cli">
        Il parametro <repl>rango</repl> rappresenta il rango di cointegrazione,
        o in altre parole il numero di vettori di cointegrazione. Questo deve
        essere maggiore di zero e minore o uguale (in genere minore) al numero
        di variabili endogene contenute nella <repl>lista-y</repl>.
      </para>
      <para context="gui">
	Il <quote>rango di cointegrazione</quote> rappresenta il numero di
        vettori di cointegrazione. Questo deve essere maggiore di zero e minore
        o uguale (in genere minore) al numero di variabili endogene selezionate.
      </para>
      <para context="cli">
        La <repl>lista-y</repl> rappresenta l'elenco delle variabili
        endogene, nei livelli. L'inclusione di trend deterministici nel modello
        è controllata dalle opzioni del comando. Se non si indica alcuna
        opzione, viene inclusa una <quote>costante non vincolata</quote>, che
        permette la presenza di un'intercetta diversa da zero nelle relazioni di
        cointegrazione e di un trend nei livelli delle variabili endogene. Nella
        letteratura originata dal lavoro di Johansen (si veda ad esempio il suo
        libro del 1995), si fa riferimento a questo come al <quote>caso
        3</quote>.  Le prime quattro opzioni mostrate sopra, che sono
        mutualmente esclusive, producono rispettivamente i casi 1, 2, 4 e 5. Il
        significato di questi casi e i criteri per scegliere tra di essi sono
        spiegati nella <guideref targ="chap:vecm"/>.
      </para>
      <para context="gui">
        Nel riquadro <quote>Variabili endogene</quote>, è possibile selezionare
        il vettore delle variabili endogene, in livelli. L'inclusione di trend
        deterministici nel modello è controllata dai pulsanti opzionali.  Se non
        si seleziona alcuna opzione, viene inclusa una <quote>costante non
        vincolata</quote>, che permette la presenza di un'intercetta diversa da
        zero nelle relazioni di cointegrazione e di un trend nei livelli delle
        variabili endogene. Nella letteratura originata dal lavoro di Johansen
        (si veda ad esempio il suo libro del 1995), si fa riferimento a questo
        come al <quote>caso 3</quote>.  Le altre quattro opzioni producono
        rispettivamente i casi 1, 2, 4 e 5. Il significato di questi casi e i
        criteri per scegliere tra di essi sono spiegati nella <guideref
        targ="chap:vecm"/>.
      </para>
      <para context="gui">
        Nel riquadro <quote>Variabili esogene</quote> è possibile aggiungere
        specifiche variabili esogene. Per impostazione predefinita, le variabili
        vengono aggiunte al modello in forma non vincolata (indicata da una
        lettera <lit>N</lit> vicino al nome della variabile). Se si vuole che
        una certa variabile esogena sia vincolata allo spazio di cointegrazione,
        basta fare clic col tasto destro e selezionare <quote>Vincolata</quote>
        dal menu pop-up. Il simbolo vicino alla variabile diventerà una V.
      </para>
      <para context="cli">
	Le liste opzionali <repl>lista-x</repl> e <repl>lista-rx</repl>
        permettono di specificare insiemi di variabili esogene che entrano nel
        modello in modo non vincolato (<repl>lista-x</repl>) o in modo vincolato
        allo spazio di cointegrazione (<repl>lista-rx</repl>). Queste liste
        vanno separate dalla <repl>lista-y</repl> (e tra di loro) da caratteri
        punto e virgola.
      </para>
      <para context="cli">
        L'opzione <lit>--seasonals</lit>, che può accompagnare una qualsiasi
        delle altre opzioni, specifica l'inclusione di un gruppo di variabili
        dummy stagionali centrate. Questa opzione è disponibile solo per dati
        trimestrali o mensili.
      </para>
      <para context="gui">
	Se i dati sono trimestrali o mensili, è presente anche una casella che
        permette di includere un gruppo di variabili dummy stagionali centrate.
	In tutti i casi, la casella <quote>Mostra dettagli</quote> permette di
        vedere il risultato delle regressioni ausiliarie che sono il punto di
        partenza per la procedura di stima di massima verosimiglianza di
        Johansen.
      </para>
      <para context="cli">
        Il primo degli esempi mostrati sopra specifica un VECM con ordine di
        ritardo pari a 4 e un unico vettore di cointegrazione. Le variabili
        endogene sono <lit>Y1</lit>, <lit>Y2</lit> e <lit>Y3</lit>. Il secondo
        esempio usa le stesse variabili ma specifica un ritardo di ordine 3 e
        due vettori di cointegrazione, oltre a specificare una <quote>costante
        vincolata</quote>, che è appropriata se i vettori di cointegrazione
        possono avere un'intercetta diversa da zero, ma le variabili
        <lit>Y</lit> non hanno trend.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modello/Serie storiche/VECM</menu-path>
    </gui-access>

  </command>

  <command name="vif" section="Tests" context="cli"
    label="Fattori di inflazione della varianza">

    <description>
      <para>
	Deve seguire la stima di un modello che includa almeno due variabili
	indipendenti. Calcola e mostra i fattori di inflazione della varianza
	(Variance Inflation Factors - VIF) per i regressori.  Il VIF
	per il regressore <math>j</math> è definito come
	<equation status="display" 
	  tex="\[\frac{1}{1-R_j^2}\]"
	  ascii="1/(1 - Rj^2)"
	  graphic="vif"/> dove <math>R</math><sub>j</sub> è il
	coefficiente di correlazione multipla tra il regressore
	<math>j</math> e gli altri regressori. Il fattore ha un valore
        minimo di 1.0 quando la variabile in questione è ortogonale alle altre
        variabili indipendenti.  Neter, Wasserman e Kutner (1990) suggeriscono
        di usare il VIF maggiore come test diagnostico per la collinearità; un
        valore superiore a 10 è in genere considerato indice di un grado di
        collinearità problematico.
      </para>
    </description>

    <gui-access>
      <menu-path>Finestra del modello, /Test/collinearità</menu-path>
    </gui-access>

  </command>

  <command name="wls" section="Estimation" label="Minimi quadrati ponderati">

    <usage>
      <arguments>
        <argument>variabile-pesi</argument>
        <argument>variabile-dipendente</argument>
	<argument>variabili-indipendenti</argument>
      </arguments>
      <options>
        <option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
        </option>
	<option>
	  <flag>--robust</flag>
	  <effect>errori standard robusti</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>non mostra i risultati</effect>
        </option>
      </options> 
    </usage>

    <description>
      <para context="cli">
	Calcola stime con minimi quadrati ponderati (WLS - Weighted Least
        Squares), prendendo i pesi da <repl>variabile-pesi</repl>.
        In pratica, detta <repl>w</repl> la radice quadrata positiva della
        <lit>variabile-pesi</lit>, viene calcolata una regressione OLS di
        <repl>w</repl> <lit>*</lit> <repl>variabile-dipendente</repl> rispetto a
        <repl>w</repl> <lit>*</lit> <repl>variabili-indipendenti</repl>.
        L'<emphasis>R</emphasis>-quadro, comunque, è calcolato in un modo
        speciale, ossia come
        <equation status="display"
          tex="\[R^2 = 1 - \frac{\rm ESS}{\rm WTSS}\]"
          ascii="R^2 = 1 - ESS / WTSS"
          graphic="wlsr2"/> dove ESS è la somma dei quadrati degli errori (somma
        dei quadrati dei residui) dalla regressione ponderata, mentre WTSS
        denota la <quote>somma totale ponderata dei quadrati</quote>, che è pari 
        alla somma dei quadrati dei residui della regressione della variabile
        dipendente ponderata sulla sola costante ponderata.
      </para>
      <para>
        Se <repl>variabile-pesi</repl> è una variabile dummy, la stima WLS
        equivale a eliminare tutte le osservazioni per cui essa vale zero.
      </para>
      <para context="gui">
	Detta "variabile-pesi" la variabile scelta nel campo "Variabile
        pesi", viene stimata una regressione OLS in cui la variabile
        dipendente è il prodotto della variabile dipendente selezionata
        e della radice quadrata della variabile-pesi, e anche le variabili
        indipendenti sono moltiplicate per la radice quadrata della variabile-pesi.
        Le statistiche della regressione, come l'<emphasis>R</emphasis>-quadro
        sono basate sui dati ponderati. Se la variabile-pesi è una
        variabile dummy, ciò equivale a eliminare tutte le osservazioni
        per cui essa vale zero.</para>
    </description>

    <gui-access>
      <menu-path>/Modello/Altri modelli lineari/WLS - Minimi quadrati ponderati</menu-path>
    </gui-access>

  </command>

  <command name="working-dir" section="Utilities" label="Directory di lavoro"
    context="gui">

    <description>
      <para>
       La <quote>directory di lavoro</quote> è quella usata da gretl in modo
       predefinito nelle operazioni di letura o scrittura di file di dati o
       comandi, usando i comandi Apri e Salva.
      </para>
      <para>
       Inoltre, la directory di lavoro è usata anche per:
      </para>
      <ilist>
       <li>
         <para>
           leggere i file attraverso i comandi testuali <lit>append</lit>,
           <lit>open</lit>, <lit>run</lit> e <lit>include</lit>;
         </para>
       </li>
       <li>
         <para>
           scrivere i file attraverso i comandi <lit>eqnprint</lit>,
           <lit>tabprint</lit>, <lit>gnuplot</lit>, <lit>outfile</lit>
           e <lit>store</lit>.
         </para>
       </li>
      </ilist>
      <para>
       Se si è abituati ad avviare gretl da un terminale testuale invece che da
       un menù o icona, può essere utile l'opzione che permette di usare la
       directory attuale (determinata dalla shell) al momento dell'avvio del
       programma.
      </para>
    </description>

    <gui-access>
      <menu-path>/File/Directory di lavoro</menu-path>
    </gui-access>

  </command>

  <command name="xcorrgm" section="Statistics" label="Correlogramma incrociato">

    <usage>
      <arguments>
        <argument>var1</argument>
        <argument>var2</argument>
        <argument optional="true">maxlag</argument>
      </arguments>
      <examples>
        <example>xcorrgm x y 12</example>
      </examples>
    </usage>

    <description>
      <para>
	Mostra il correlogramma incrociato per le variabili
	<repl>var1</repl> e <repl>var2</repl>, che possono essere specificate
        per nome o per numero. I valori sono i coefficienti di correlazione
        campionari tra il valore presente di <repl>var1</repl> e i valori
        ritardati e anticipati di <repl>var2</repl>.
      </para>
      <para>
	Se si indica un valore <repl>maxlag</repl>, la lunghezza del correlogramma è
        limitata al numero di ritardi e anticipi indicati, altrimenti è
        determinata automaticamente in funzione della frequenza dei dati e del
        numero di osservazioni.
      </para>
    </description>

    <gui-access>
      <menu-path>/Visualizza/Correlogramma</menu-path>
      <other-access>Menù pop-up nella finestra principale (selezione multipla)</other-access>
    </gui-access>

  </command>
 
  <command name="xtab" section="Statistics" label="Tabulazione incrociata">

    <usage>
      <arguments>
        <argument>lista-y</argument>
        <argument optional="true" separated="true">lista-x</argument>
      </arguments>
      <options>
        <option>
	  <flag>--row</flag>
	  <effect>mostra le percentuali per riga</effect>
        </option>
        <option>
	  <flag>--column</flag>
	  <effect>mostra le percentuali per colonna</effect>
        </option>
        <option>
	  <flag>--zeros</flag>
	  <effect>mostra i valori pari a zero</effect>
        </option>
      </options>
    </usage>

    <description context="cli">
      <para>
        Mostra la tabella di contingenza, o la
        tabulazione incrociata, tra ogni combinazione delle variabili della
        <repl>lista-y</repl>; se si indica anche una seconda lista,
        <repl>lista-x</repl>, ogni variabile della <repl>lista-y</repl> viene
        tabulata (per riga) rispetto ad ogni variabile della <repl>lista-x</repl>
        (per colonna). Le variabili in queste liste possono essere referenziate per
        nome o per numero, e devono essere state marcate come discrete.
      </para>
      <para>
	Per impostazione predefinita le celle indicano la frequenza assoluta.
        Le opzioni <lit>--row</lit> e <lit>--column</lit> (che sono mutualmente
        esclusive) sostituiscono la frequenza assoluta con le frequenze in
        percentuale relativamente a ciascuna riga o colonna. Le celle con valore
        di frequenza nullo sono lasciate vuote, a meno che non venga usata l'opzione
	<lit>--zeros</lit>, che mostra esplicitamente i valori pari a zero;
        questa opzione può essere comoda se occorre importare la tabella in un
        altro programma, come un foglio di calcolo.
      </para>
      <para>
        Il test chi quadro di Pearson per l'indipendenza viene mostrato
        se la frequenza attesa nell'ipotesi di indipendenza è pari almeno a
        1.0e-7 per tutte le celle. Una regola approssimativa usata spesso nel
        giudicare la validità di questa statistica richiede che la frequenza
        attesa sia superiore a 5 per almeno l'80 per cento delle celle; se
        questa condizione non viene soddisfatta viene mostrato un messaggio di
        avvertimento.
      </para>
      <para>
	Se la tabella di contingenza è 2 x 2, viene calcolato il test esatto di
        Fisher per l'indipendenza. Si noti che questo test si basa sull'ipotesi
        che i totali per riga e colonna siano fissi; questo può essere
        appropriato o meno a seconda di come sono stati generati i dati.
	Il p-value sinistro va usato nel caso in cui l'ipotesi alternativa a
        quella di indipendenza sia quella dell'associazione negativa (ossia i
        valori tendono ad accumularsi nelle celle che non appartengono alla
        diagonale della tabella), mentre il p-value destro va usato nell'ipotesi
        alternativa di associazione positiva. Il p-value a due code di questo
        test è calcolato seguendo il metodo (b) descritto in Agresti
	(1992, capitolo 2.1): esso è la somma delle probabilità di tutte le
        possibili tabelle che hanno i totali per riga e per colonna pari a
        quelli della tabella data e che hanno una probabilità minore o uguale a
        quella della tabella data.
      </para>
    </description>

    <description context="gui">
      <para>
        Mostra la tabella di contingenza, o la tabulazione incrociata, tra ogni
        combinazione delle variabili selezionate. Si noti che tutte le variabili
        devono essere discrete.
      </para>
      <para>
	Per impostazione predefinita le celle indicano la frequenza assoluta, ma
        è possibile scegliere di avere le percentuali relative alle righe o alle
        colonne.
      </para>
      <para>
        Inoltre, le celle con un valore di frequenza nullo sono lasciate vuote,
        ma è possibile scegliere di avere i valori pari a zero esplicitamente.
      </para>
      <para>
        Il test chi quadro di Pearson per l'indipendenza viene mostrato
        se la frequenza attesa nell'ipotesi di indipendenza è pari almeno a
        1.0e-7 per tutte le celle. Una regola approssimativa usata spesso nel
        giudicare la validità di questa statistica richiede che la frequenza
        attesa sia superiore a 5 per almeno l'80 per cento delle celle; se
        questa condizione non viene soddisfatta viene mostrato un messaggio di
        avvertimento.
      </para>
      <para>
	Se la tabella di contingenza è 2 x 2, viene calcolato il test esatto di
        Fisher per l'indipendenza. Si noti che questo test si basa sull'ipotesi
        che i totali per riga e colonna siano fissi; questo può essere
        appropriato o meno a seconda di come sono stati generati i dati.
	Il p-value sinistro va usato nel caso in cui l'ipotesi alternativa a
        quella di indipendenza sia quella dell'associazione negativa (ossia i
        valori tendono ad accumularsi nelle celle che non appartengono alla
        diagonale della tabella), mentre il p-value destro va usato nell'ipotesi
        alternativa di associazione positiva. Il p-value a due code di questo
        test è calcolato seguendo il metodo (b) descritto in Agresti
	(1992, capitolo 2.1): esso è la somma delle probabilità di tutte le
        possibili tabelle che hanno i totali per riga e per colonna pari a
        quelli della tabella data e che hanno una probabilità minore o uguale a
        quella della tabella data.
      </para>
    </description>

  </command>

</commandlist>

