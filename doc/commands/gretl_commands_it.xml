<?xml version="1.0" encoding="ISO-8859-1" ?>
<!DOCTYPE commandlist SYSTEM "gretl_commands.dtd">

<commandlist language="italian">

<?PSGML NOFILL label code altforms altform menu-path other-access?>

  <command name="add" section="Tests" label="Test per le variabili aggiunte">

    <usage>
      <arguments>
        <argument>lista-variabili</argument>
      </arguments>
      <options>
	<option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>non mostra le stime del modello aumentato</effect>
	</option>
 	<option>
 	  <flag>--silent</flag>
 	  <effect>non mostra nulla</effect>
 	</option>
        <option>
          <flag>--inst</flag>
          <effect>aggiunge come strumento, solo per TSLS</effect>
        </option>
        <option>
          <flag>--both</flag>
          <effect>aggiunge come regressore e come strumento, solo per TSLS</effect>
        </option>
      </options>
      <examples>
        <example>add 5 7 9</example>
        <example>add xx yy zz --quiet</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
	Va invocato dopo un comando di stima. Aggiunge al modello precedente
        le variabili nella <repl>lista-variabili</repl> e stima il nuovo
        modello. Viene eseguito anche un test per la significatività congiunta 
        delle variabili aggiunte: nel caso di stime OLS, la statistica test è la
        <mathvar>F</mathvar>, negli altri casi è il chi-quadro asintotico di
        Wald. Un p-value inferiore a 0.05 indica che i coefficienti sono
        congiuntamente significativi al livello del 5 per cento.
      </para>
      <para context="cli">
	Se viene usata l'opzione <lit>--quiet</lit> viene mostrato solo
	il risultato del test per la significatività congiunta delle
	variabili aggiunte, altrimenti vengono mostrate anche le stime
	per il modello aumentato. Nell'ultimo caso, l'opzione
	<lit>--vcv</lit> mostra anche la matrice di covarianza dei coefficienti.
 	Usando l'opzione <lit>--silent</lit>, non viene mostrato nulla; tuttavia
        i risultati del test possono essere recuperati usando le variabili
        speciali <lit>$test</lit> e <lit>$pvalue</lit>.
      </para>
      <para context="cli">
       Se il modello originale è stato stimato con i minimi quadrati a due
       stadi, può sorgere un'ambiguità: le nuove variabili vanno aggiunte come
       regressori, come strumenti o con entrambe le funzioni? Per risolvere
       l'ambiguità, nella modalità predefinita le variabili sono aggiunte come
       regressori endogeni, se si usa l'opzione <lit>--inst</lit> sono aggiunte
       come strumenti, mentre se si usa l'opzione <lit>--both</lit> sono aggiunte
       come regressori esogeni.
      </para>
      <para context="gui">
	Aggiunge le variabili selezionate al modello precedente e stima il
        nuovo modello. Viene eseguito anche un test per la significatività congiunta 
        delle variabili aggiunte: nel caso di stime OLS, la statistica test è la
        <mathvar>F</mathvar>, negli altri casi è il chi-quadro asintotico di
        Wald. Un p-value inferiore a 0.05 indica che i coefficienti sono
        congiuntamente significativi al livello del 5 per cento.
      </para>
    </description>

    <gui-access>
      <menu-path>Finestra del modello, /Test/ADD - Aggiungi variabili</menu-path>
    </gui-access>

  </command>
  
  <command name="addobs" section="Dataset" context="cli">

    <usage>
      <arguments>
        <argument>numero_osservazioni</argument>
      </arguments>
      <examples>
        <example>addobs 10</example>
      </examples>
    </usage>

    <description>
      <para>
       Aggiunge il numero indicato di osservazioni alla fine del dataset,
       principalmente a scopo di previsione. I valori della maggior parte delle
       variabili saranno impostati a "mancante", ma alcune variabili
       deterministiche verranno riconosciute ed estese; ad esempio, un semplice
       trend lineare o delle dummy periodiche.
       </para>
       <para>
       Il comando non è disponibile se sul dataset è impostato un sotto-campione
       ottenuto con una condizione Booleana.
      </para>
    </description>
    
    <gui-access>
     <menu-path>/Data/Aggiungi osservazioni</menu-path>
    </gui-access>

  </command>

  <command name="addto" section="Tests" context="cli">

    <usage>
      <arguments>
        <argument>id-modello</argument>
	<argument>lista-variabili</argument>
      </arguments>
      <options>
	<option>
	  <flag>--quiet</flag>
	  <effect>non mostra le stime del modello aumentato</effect>
	</option>
      </options>
      <examples>
        <example>addto 2 5 7 9</example>
      </examples>
    </usage>

    <description>
      <para>
	Funziona come il comando <cmd>add</cmd>, con l'eccezione che occorre
	specificare il modello precedente (usando il suo numero identificativo,
	che è mostrato all'inizio dei risultati del modello) da prendere come
	base per l'aggiunta delle variabili. L'esempio precedente aggiunge le
	variabili numero 5, 7 e 9 al modello 2.
      </para>
    </description>

    <gui-access>
      <menu-path>Finestra del modello, /Test/ADD - Aggiungi variabili</menu-path>
    </gui-access>

  </command>

  <command name="adf" section="Tests" label="Test Dickey-Fuller aumentato">

    <usage>
      <arguments>
        <argument>ordine</argument>
        <argument>nome-variabile</argument>
      </arguments>
      <options>
	<option>
	  <flag>--nc</flag>
	  <effect>test senza costante</effect>
	</option>
	<option>
	  <flag>--c</flag>
	  <effect>solo con la costante</effect>
	</option>
	<option>
	  <flag>--ct</flag>
	  <effect>con costante e trend</effect>
	</option>
	<option>
	  <flag>--ctt</flag>
	  <effect>con costante, trend e trend al quadrato</effect>
	</option>
        <option>
	  <flag>--seasonals</flag>
	  <effect>include variabili dummy stagionali</effect>
        </option>
	<option>
	  <flag>--verbose</flag>
	  <effect>mostra i risultati della regressione</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>non mostra i risultati</effect>
	</option>
      </options>
      <examples>
	<example>adf 0 y</example>
        <example>adf 2 y --nc --c --ct</example>
      </examples>
    </usage>

    <description>
      <para context="gui">Questo comando richiede un ordine di ritardo intero;
       se si indica un ordine zero, viene eseguito un test Dickey&ndash;Fuller
       standard (non aumentato).</para>
       
      <para>
	Calcola le statistiche per un gruppo di test Dickey&ndash;Fuller sulla
        variabile specificata, assumendo come ipotesi nulla che la variabile
	abbia una radice unitaria.</para>

      <para>Per impostazione predefinita, vengono mostrate tre varianti del
        test: una basata su una regressione che contiene solo una costante,
        una che include la costante e un trend lineare, una che usa la
        costante e un trend quadratico. È possibile controllare le tre
        varianti specificando una o più opzioni.
      </para>
      
      <para>In tutti i casi, la variabile dipendente è la differenza prima
        della variabile specificata, <mathvar>y</mathvar>, e la variabile
        dipendente più importante è il ritardo (di ordine uno) di
        <mathvar>y</mathvar>. Il modello è costruito in modo che il coefficiente
        della variabile ritardata <mathvar>y</mathvar> è pari a 1 meno
        la radice. Ad esempio, il modello con una costante può essere
        scritto come <equation status="display"
	tex="\[(1-L)y_t=\beta_0+(1-\alpha)y_{t-1}+\epsilon_t\]"
	ascii="(1 - L)y(t) = b0 + (1-a)y(t-1) + e(t)"
	graphic="adf1"/></para>

      <para>Se l'ordine di ritardi, <mathvar>k</mathvar>, è maggiore di 0, ai
        regressori di ognuna delle regressioni calcolate per il test saranno
        aggiunti <mathvar>k</mathvar> ritardi della variabile dipendente.
      </para>

      <para context="cli">
        Se l'ordine di ritardi è preceduto da un segno meno, ad esempio
        &minus;<mathvar>k</mathvar>, verrà considerato come ordine massimo, e
        l'ordine da usare effettivamente sarà ricavato applicando la seguente
        procedura di test "all'indietro":
      </para>

      <para context="gui">
        Se l'ordine di ritardi, <mathvar>k</mathvar>, è maggiore di 0, ai
        regressori di ognuna delle regressioni calcolate per il test saranno
        aggiunti <mathvar>k</mathvar> ritardi della variabile dipendente, a meno
        che venga selezionata la casella <quote>test per il ritardo
        massimo</quote>; in questo caso, l'ordine selezionato verrà considerato
        come ordine massimo, e l'ordine da usare effettivamente sarà ricavato
        applicando la seguente procedura di test "all'indietro":
      </para>

      <nlist>
	<li><para>Stima la regressione Dickey&ndash;Fuller con
	    <mathvar>k</mathvar> ritardi della variabile dipendente.
	  </para>
	</li>
	<li><para>Se questo ordine di ritardi è significativo, esegue il test
        con l'ordine di ritardo <mathvar>k</mathvar>.  Altrimenti, prova il test
        con <mathvar>k</mathvar> = <mathvar>k</mathvar> &minus; 1; se
	    <mathvar>k</mathvar> = 0, esegue il test con ordine di ritardo 0,
            altrimenti va al punto 1.
	  </para>
	</li>
      </nlist>

      <para>Durante il punto 2 spiegato sopra, <quote>significativo</quote>
      significa che la statistica <mathvar>t</mathvar> per l'ultimo ritardo
      abbia un <emphasis>p</emphasis>-value asintotico a due code per la
      distribuzione normale pari a 0.10 o inferiore.</para> 

      <para>I <emphasis>p-</emphasis>value per questo test sono basati su
	MacKinnon (1996). Il codice rilevante è incluso per gentile concessione
        dell'autore.</para>
    </description>

    <gui-access>
      <menu-path>/Variabile/Test Dickey-Fuller aumentato</menu-path>
    </gui-access>

  </command>

  <command name="append" section="Dataset" context="cli">

    <usage>
      <arguments>
        <argument>file-dati</argument>
      </arguments>
    </usage>

    <description>
      <para>
       Apre un file di dati e aggiunge il suo contenuto al dataset
       corrente, se i nuovi dati sono compatibili. Il programma cerca
       di riconoscere il formato del file di dati (interno, testo semplice,
       CSV, Gnumeric, Excel, ecc.).
      </para>

    </description>

    <gui-access>
      <menu-path>/File/Aggiungi dati</menu-path>
    </gui-access>

  </command>

  <command name="ar" section="Estimation" label="Stima autoregressiva">

    <usage>
      <arguments>
        <argument>ritardi</argument>
	<argument separated="true">variabile-dipendente</argument>
        <argument>variabili-indipendenti</argument>
      </arguments>
      <options>
	<option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
	</option>
      </options>
      <examples>
        <example>ar 1 3 4 ; y 0 x1 x2 x3</example>
      </examples>
    </usage>

    <description>
      <para>
	Calcola le stime parametriche usando la procedura iterativa generalizzata
	di Cochrane&ndash;Orcutt (si veda il Capitolo 9.5 di
	Ramanathan). La procedura termina quando le somme dei quadrati degli errori
	consecutivi non differiscono per più dello 0.005 per cento, oppure dopo
	20 iterazioni.</para>

      <para context="gui">
	La <quote>lista dei ritardi AR</quote> specifica la struttura del processo
	dell'errore.  Ad esempio, l'indicazione <quote>1 3 4</quote> corrisponde
	al processo: 
	<equation status="display" 
	  tex="\[u_t = \rho_1u_{t-1} + \rho_3 u_{t-3} +
	    \rho_4 u_{t-4} + e_t\]"
	  ascii="u(t) = rho1*u(t-1) + rho3*u(t-3) + rho4*u(t-4)"
	  graphic="arlags"/>
      </para>

      <para context="cli">
	<repl quote="true">ritardi</repl> è una lista di ritardi nei residui, conclusa
	da un punto e virgola. Nell'esempio precedente, il termine di errore è
	specificato come
	<equation status="display" 
	  tex="\[u_t = \rho_1u_{t-1} + \rho_3 u_{t-3} +
	    \rho_4 u_{t-4} + e_t\]"
	  ascii="u(t) = rho(1)*u(t-1) + rho(3)*u(t-3) + rho(4)*u(t-4)"
	  graphic="arlags"/>
      </para>

    </description>

    <gui-access>
      <menu-path>/Modello/Serie storiche/AR - Stima autoregressiva</menu-path>
    </gui-access>

  </command>

  <command name="arch" section="Tests" label="Test ARCH">

    <usage>
      <arguments>
        <argument>ordine</argument>
        <argument>variabile-dipendente</argument>
	<argument>variabili-indipendenti</argument>
      </arguments>
      <examples>
        <example>arch 4 y 0 x1 x2 x3</example>
      </examples>
    </usage>

    <description>
      <para context="gui">
	Questo comando richiede un ordine di ritardo intero.
      </para>

      <para>
	Testa il modello per l'eteroschedasticità condizionale autoregressiva 
	(ARCH: Autoregressive Conditional Heteroskedasticity) dell'ordine
	specificato. Se la statistica del test LM ha un p-value inferiore a 0.10,
	viene anche effettuata la stima ARCH. Se la varianza prevista di qualche
	osservazione nella regressione ausiliaria non risulta positiva, viene usato
	il corrispondente residuo al quadrato. Viene quindi calcolata la stima con
	i minimi quadrati ponderati sul modello originale.
      </para>
      <para>
	Si veda anche <cmdref targ="garch"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>Finestra del modello, /Test/ARCH</menu-path>
    </gui-access>

  </command>

  <command name="arima" section="Estimation" label="Stima ARMA/ARIMA">

    <usage>
      <arguments>
        <argblock>
          <argument>p</argument>
          <argument>d</argument>
          <argument>q</argument>
        </argblock>
 	<argblock separated="true" optional="true">
 	  <argument>P</argument>
	  <argument>D</argument>
 	  <argument>Q</argument>
 	</argblock>
	<argument separated="true">variabile-dipendente</argument>
	<argument optional="true">variabili-indipendenti</argument>
      </arguments>
      <options>
	<option>
	  <flag>--verbose</flag>
	  <effect>mostra i dettagli delle iterazioni</effect>
        </option>
        <option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
        </option>
        <option>
         <flag>--nc</flag>
         <effect>non include l'intercetta</effect>
        </option>
        <option>
	  <flag>--x-12-arima</flag>
	  <effect>usa X-12-ARIMA per la stima</effect>
        </option>
        <option>
	  <flag>--conditional</flag>
	  <effect>X-12-ARIMA: usa la massima verosimiglianza condizionale per la stima</effect>
        </option>
      </options>
      <examples>
        <example>arima 1 0 2 ; y</example>
	<example>arima 2 0 2 ; y 0 x1 x2 --verbose</example>
	<example>arima 0 1 1 ; 0 1 1 ; y --nc</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
	Se non viene fornita una lista di <repl>variabili-indipendenti</repl>,
        stima un modello autoregressivo integrato a media mobile (ARIMA: Autoregressive,
        Integrated, Moving Average) univariato.  I valori interi <repl>p</repl>,
        <repl>d</repl> e <repl>q</repl> rappresentano rispettivamente gli ordini
        dei termini autoregressivi (AR), l'ordine di differenziazione, e quello dei termini
        a media mobile (MA).  Questi valori possono essere indicati in forma
        numerica o con i nomi di variabili scalari preesistenti. Ad esempio, un
        valore <repl>d</repl> pari a 1 significa che prima di stimare i
        parametri ARMA occorre prendere la differenza della variabile
        dipendente.
      </para>
        
      <para context="cli">
        I valori interi opzionali <repl>P</repl>, <repl>D</repl> e
        <repl>Q</repl> rappresentano rispettivamente, l'ordine dei termini AR
        stagionali, l'ordine di differenziazione stagionale e l'ordine dei
        termini MA stagionali. Essi sono rilevanti solo la frequenza dei dati è
        superiore a 1 (ad esempio, dati trimestrali o mensili). Anche questi
        valori possono essere indicati in forma numerica o con i nomi di
        variabili scalari preesistenti.
      </para>
      
      <para context="cli">
        Nel caso univariato la scelta predefinita include un'intercetta nel
        modello, ma questa può essere soppressa con l'opzione
        <lit>--nc</lit>.  Se vengono aggiunte delle
        <repl>variabili-indipendenti</repl>, il modello diventa un ARMAX: in
        questo caso occorre indicare esplicitamente la costante se si
        desidera un'intercetta (come nel secondo degli esempi proposti).
      </para>
      
      <para context="cli">
        È disponibile una sintassi alternativa per questo comando: se non si
        intende applicare alcuna operazione di differenziazione (stagionale o
        non stagionale), è possibile omettere totalmente i termini
        <repl>d</repl> e <repl>D</repl>, invece che impostarli esplicitamente
        pari a 0. Inoltre, <lit>arma</lit> è un sinonimo di <lit>arima</lit>,
        quindi ad esempio il comando seguente è un modo valido per specificare
        un modello ARMA(2,1):
      </para>
      <code context="cli">
	arma 2 1 ; y
      </code>
      
      <para context="gui">
	Stima un modello ARMA, con o senza regressori esogeni. Se l'ordine di
        differenziazione è maggiore di zero, il modello diventa un ARIMA. Se i
        dati hanno una frequenza superiore a 1, viene offerta la possibilità di
        includere termini stagionali.
      </para>

      <para>Il funzionamento predefinito utilizza la funzione ARMA 
        <quote>interna</quote> di gretl, ma è anche possibile usare
        <program>X-12-ARIMA</program> (se è stato installato il pacchetto
        <program>X-12-ARIMA</program> per gretl). In quest'ultimo caso, c'è
        l'ulteriore opzione di scegliere come metodo di stima quello della
        massima verosimiglianza esatta o condizionale. Il metodo predefinito
        usato da <program>X-12-ARIMA</program> è quello della massima
        verosimiglianza, mentre il metodo della massima verosimiglianza
        condizionale produrrà stime più vicine a quelle ottenute usando la
        funzione interna ARMA di gretl. La matrice di covarianza non è
        disponibile quando la stima utilizza <program>X-12-ARIMA</program>.
      </para>

      <para>L'algoritmo interno di gretl per ARMA utilizza una procedura di
	massima verosimiglianza condizionale, implementata attraverso la stima 
	iterata	con minimi quadrati della regressione del prodotto esterno del
	gradiente (OPG). Si veda la <guideref targ="jack-arma"/> per la logica della
	procedura. I coefficienti AR (e quelli per gli eventuali regressori 
	aggiuntivi) sono inizializzati usando una auto-regressione OLS, mentre
	i coefficienti MA sono inizializzati a zero.</para>

      <para>Il valore AIC mostrato nei modelli ARIMA è calcolato secondo la
	definizione usata in <program>X-12-ARIMA</program>, ossia
	  <equation status="display" 
	  tex="\[\mbox{AIC}=-2\ell+2k\]"
	  ascii="AIC = -2L + 2k"
	  graphic="aic"/> dove 
	<equation status="inline" 
	  tex="$\ell$" ascii="L"
	  graphic="ell"/>
        è la log-verosimiglianza e <mathvar>k</mathvar> è il numero totale di
        parametri stimati. Si noti che <program>X-12-ARIMA</program> non produce
        criteri di informazione come l'AIC quando la stima è effettuata col
        metodo della massima verosimiglianza condizionale.
      </para> 

      <para> 
	Il valore di <quote>frequenza</quote> mostrato insieme alle radici
	AR e MA è il valore di &lgr; che risolve
	  <equation status="display" 
	  tex="\[z=re^{i2\pi\lambda}\]"
	  ascii="z = r * exp(i*2*pi*lambda)"
	  graphic="lambda"/> dove <mathvar>z</mathvar> è la radice in questione
	  e <mathvar>r</mathvar> è il suo modulo.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modello/Serie Storiche/ARIMA</menu-path>
      <other-access>Menù pop-up nella finestra principale (selezione singola)</other-access>
    </gui-access>

  </command>

  <command name="boxplot" section="Graphs" label="Grafici boxplot">

    <usage>
      <arguments>
        <argument>lista-variabili</argument>
      </arguments>
      <options>
	<option>
	  <flag>--notches</flag>
	  <effect>mostra l'intervallo di confidenza al 90 per cento per la mediana</effect>
	</option>
      </options>
    </usage>

    <description>

      <para>Questo tipo di grafici (da Tukey e Chambers) mostra la distribuzione
        di una variabile. La <quote>scatola</quote> centrale (box) racchiude il
        50 per cento centrale dei dati, ossia è delimitato dal primo e terzo
        quartile. I <quote>baffi</quote> (whiskers) si estendono fino ai valori
        minimo e massimo. Una linea trasversale sulla scatola indica la mediana.
	</para> 

      <para>Nel caso dei grafici a tacca ("notches"), una tacca indica i limiti
        dell'intervallo di confidenza approssimato al 90 per cento per la
        mediana, ottenuto col metodo bootstrap.</para>

      <para context="gui">Dopo ogni variabile specificata nel comando
	boxplot, è possibile aggiungere un'espressione booleana tra
        parentesi per limitare il campione per la variabile in questione.
	Occorre inserire uno spazio tra il nome o il numero della variabile
        e l'espressione. Si supponga di avere dati sui salari di uomini e
        donne e di avere una variabile dummy <lit>GENERE</lit> che vale 1
	per gli uomini e 0 per le donne. In questo caso, è possibile generare
        dei boxplot comparativi usando la seguente riga nella finestra di
        dialogo dei boxplot:</para>

      <para context="cli">Dopo ogni variabile specificata nel comando
	boxplot, è possibile aggiungere un'espressione booleana tra
        parentesi per limitare il campione per la variabile in questione.
	Occorre inserire uno spazio tra il nome o il numero della variabile
        e l'espressione. Si supponga di avere dati sui salari di uomini e
        donne e di avere una variabile dummy <lit>GENERE</lit> che vale 1
	per gli uomini e 0 per le donne. In questo caso, è possibile generare
        dei boxplot comparativi usando la seguente <repl
	  quote="true">lista-variabili</repl>:</para>

      <code>
	salario (GENERE=1) salario (GENERE=0)
      </code>

      <para>Alcuni dettagli del funzionamento dei boxplot di gretl possono
        essere controllati attraverso un file testuale chiamato
        <filename>.boxplotrc</filename>.  Per ulteriori dettagli, si veda
	la <guideref targ="sect-boxplots"/>.</para>

    </description>

    <gui-access>
      <menu-path>/Dati/Grafico delle variabili/Boxplot</menu-path>
    </gui-access>

  </command>

  <command name="chow" section="Tests" label="Chow">

    <usage>
      <arguments>
        <argument>osservazione</argument>
      </arguments>
      <examples>
        <example>chow 25</example>
        <example>chow 1988:1</example>
      </examples>
    </usage>

    <description>
      <para context="gui">Questo comando richiede un numero di osservazione
       (o una data, se il dataset lo consente).</para>

      <para>
	Va eseguito dopo una regressione OLS. Crea una variabile
        dummy che vale 1 a partire dal punto di rottura specificato da
	<repl>osservazione</repl> fino alla fine del campione, 0 altrove; inoltre
        crea dei termini di interazione tra questa dummy e le variabili
        indipendenti originali, stima una regressione che include
        questi termini e calcola una statistica <mathvar>F</mathvar>,
        prendendo la regressione aumentata come non vincolata e la regressione
        originale come vincolata. La statistica è appropriata per testare
        l'ipotesi nulla che non esista un break strutturale in corrispondenza
        del punto di rottura specificato.
      </para>
    </description>

    <gui-access>
      <menu-path>Finestra del modello, /Test/CHOW</menu-path>
    </gui-access>

  </command>

  <command name="coeffsum" section="Tests" label="Test sulla somma dei coefficienti">

    <usage>
      <arguments>
        <argument>lista-variabili</argument>
      </arguments>
      <examples>
        <example>coeffsum xt xt_1 xr_2</example>
      </examples>
    </usage>

    <description>
      <para context="gui">Questo comando richiede una lista di variabili,
        selezionate tra le variabili indipendenti di un modello.
      </para>
      <para context="gui">
	Calcola la somma dei coefficienti delle variabili nella lista
        e mostra l'errore standard e il p-value per l'ipotesi nulla che la
        somma sia zero.
      </para>
      <para context="cli">
	Deve essere usato dopo una regressione. Calcola la somma dei 
        coefficienti delle variabili nella <repl>lista-variabili</repl>
        e ne mostra l'errore standard e il p-value per l'ipotesi nulla
        che la loro somma sia zero.
      </para>
      <para>Si noti la differenza tra questo test e <cmdref
	  targ="omit"/>, che assume come ipotesi nulla l'uguaglianza a zero
          di <emphasis>tutti</emphasis> i coefficienti di un gruppo di variabili
          indipendenti.</para>
    </description>

    <gui-access>
      <menu-path>Finestra del modello, /Test/Somma dei coefficienti</menu-path>
    </gui-access>

  </command>

  <command name="coint" section="Tests" 
    label="Test di cointegrazione di Engle-Granger">

    <usage>
      <arguments>
        <argument>ordine</argument>
        <argument>variabile-dipendente</argument>
	<argument>variabili-indipendenti</argument>
      </arguments>
      <options>
	<option>
	  <flag>--nc</flag>
	  <effect>non include la costante</effect>
	</option>
      </options>
      <examples>
	<example>coint 4 y x1 x2</example>
      </examples>
    </usage>

    <description>
      <para>
	Il test di cointegrazione di Engle&ndash;Granger svolge dei test
	Dickey&ndash;Fuller aumentati sull'ipotesi nulla che ognuna delle
        variabili elencate abbia una radice unitaria, usando l'ordine di
        ritardi specificato. Viene stimata la regressione di cointegrazione
	e viene eseguito un test ADF sui residui di questa regressione, mostrando
        anche la statistica di Durbin&ndash;Watson per la regressione
        di cointegrazione.
      </para>
      <para>I <emphasis>pvalue</emphasis> per questo test si basano su
	MacKinnon (1996). Il codice relativo è stato incluso per gentile
        concessione dell'autore.
      </para>
      <para context="cli">
	La regressione di cointegrazione di solito contiene una costante;
        se si vuole escluderla, basta usare l'opzione <lit>--nc</lit>. 
       </para>
    </description>

    <gui-access>
      <menu-path>/Modello/Serie storiche/Test di cointegrazione/Engle-Granger</menu-path>
    </gui-access>

  </command>

  <command name="coint2" section="Tests" label="Test di cointegrazione di Johansen">

    <usage>
      <arguments>
        <argument>ordine</argument>
        <argument>variabile-dipendente</argument>
	<argument>variabili-indipendenti</argument>
      </arguments>
      <options>
        <option>
	  <flag>--nc</flag>
	  <effect>senza costante</effect>
        </option>
        <option>
	  <flag>--rc</flag>
	  <effect>costante vincolata</effect>
        </option>
        <option>
	  <flag>--crt</flag>
	  <effect>costante e trend vincolato</effect>
        </option>
        <option>
	  <flag>--ct</flag>
	  <effect>costante e trend non vincolato</effect>
        </option>
        <option>
	  <flag>--seasonals</flag>
	  <effect>include dummy stagionali centrate</effect>
        </option>
        <option>
	  <flag>--verbose</flag>
	  <effect>mostra i dettagli delle regressioni ausiliarie</effect>
        </option>
      </options>
      <examples>
        <example>coint2 2 y x</example>
	<example>coint2 4 y x1 x2 --verbose</example>
	<example>coint2 3 y x1 x2 --rc</example>
      </examples>
    </usage>

    <description>
      <para>
        Esegue il test di Johansen per la cointegrazione tra le variabili
        elencate per l'ordine specificato.  I valori critici sono calcolati con
        l'approssimazione gamma di J. Doornik (Doornik, 1998). Per i dettagli su
        questo test, si veda Hamilton, <book>Time Series Analysis</book> (1994),
        Cap. 20.
      </para>
      <para context="cli">
	L'inclusione di trend deterministici nel modello è controllata dalle
        opzioni del comando. Se non si indica alcuna opzione, viene inclusa una
	<quote>costante non vincolata</quote>, che permette la presenza di
        un'intercetta diversa da zero nelle relazioni di cointegrazione e di un
        trend nei livelli delle variabili endogene. Nella letteratura originata
        dal lavoro di Johansen (si veda ad esempio il suo libro del 1995),
        si fa riferimento a questo come al <quote>caso 3</quote>.  Le prime
        quattro opzioni mostrate sopra, che sono mutualmente esclusive,
        producono rispettivamente i casi 1, 2, 4 e 5. Il significato di questi
        casi e i criteri per scegliere tra di essi sono spiegati nella
	<guideref targ="vecm-explanation"/>.
      </para>
      <para context="gui">
	L'inclusione di termini deterministici nel modello è controllata dai
        pulsanti delle opzioni. L'opzione predefinita è di includere una
	<quote>costante non vincolata</quote>, che permette la presenza di
        un'intercetta diversa da zero nelle relazioni di cointegrazione e di un
        trend nei livelli delle variabili endogene. Nella letteratura originata
        dal lavoro di Johansen (si veda ad esempio il suo libro del 1995),
        si fa riferimento a questo come al <quote>caso 3</quote>.  Le prime
        quattro opzioni mostrate sopra, che sono mutualmente esclusive,
        producono rispettivamente i casi 1, 2, 4 e 5. Il significato di questi
        casi e i criteri per scegliere tra di essi sono spiegati nella
	<guideref targ="vecm-explanation"/>.
      </para>
      <para context="cli">
        L'opzione <lit>--seasonals</lit>, che può accompagnare una qualsiasi
        delle altre opzioni, specifica l'inclusione di un gruppo di variabili
        dummy stagionali centrate. Questa opzione è disponibile solo per dati
        trimestrali o mensili.
      </para>
      <para context="gui">
	Se i dati sono trimestrali o mensili, è presente anche una casella che
        permette di includere un gruppo di variabili dummy stagionali centrate.
	In tutti i casi, la casella <quote>Mostra dettagli</quote> permette di
        vedere il risultato delle regressioni ausiliarie che sono il punto di
        partenza per la procedura di stima di massima verosimiglianza di
        Johansen.
      </para>
      <para>
	La tabella seguente fornisce un esempio di interpretazione dei
	risultati del test nel caso di 3 variabili. <lit>H0</lit> denota
        l'ipotesi nulla, <lit>H1</lit> l'ipotesi alternativa e <lit>c</lit>
        il numero delle relazioni di cointegrazione.</para>

      <code>
                 Rango    Test traccia       Test Lmax
                          H0     H1          H0     H1
                 ---------------------------------------
                  0      c = 0  c = 3       c = 0  c = 1
                  1      c = 1  c = 3       c = 1  c = 2
                  2      c = 2  c = 3       c = 2  c = 3
                 ---------------------------------------
      </code>
 
      <para>
	Si veda anche il comando <cmdref targ="vecm"/>.
      </para>

    </description>

    <gui-access>
      <menu-path>/Modello/Serie storiche/Test do cointegrazione/Johansen</menu-path>
    </gui-access>

  </command>

  <command name="compact" section="Dataset" context="gui"
    label="Compattamento dei dati">

    <description>

      <para>Quando viene aggiunta a un dataset una serie di frequenza
        maggiore, occorre <quote>compattare</quote> la nuova serie.
	Ad esempio, una serie mensile deve essere compattata per
        adattarsi a un dataset trimestrale.</para>  

      <para>Inoltre, a volte può essere necessario compattare un intero
	dataset abbassandone la frequenza (ad esempio, prima di aggiungere
	al dataset una variabile a frequenza minore).</para>

      <para>Ci sono quattro opzioni per il compattamento:</para>

      <ilist>
	<li><para>Media: i nuovi valori saranno la media aritmetica
	    dei corrispondenti valori della serie a frequenza maggiore.
            Ad esempio, il valore per il primo trimestre del 1990 sarà la
            media dei valori di gennaio, febbraio e marzo del 1990.</para>
	</li>

	<li><para>Somma: i nuovi valori saranno la somma dei 
            corrispondenti valori della serie a frequenza maggiore.
            Ad esempio, il valore per il primo trimestre sarà la somma dei
            valori di gennaio, febbraio e marzo.</para>
	</li>

	<li><para>Valori di fine periodo: il nuovo valore è l'ultimo
            valore corrispondente nella serie a frequenza maggiore.
	    Ad esempio, il valore del primo trimestre del 1990 sarà quello
            del marzo 1990.</para>
	</li>

	<li><para>Valori di inizio periodo: il nuovo valore è il primo
            valore corrispondente nella serie a frequenza maggiore.
            Ad esempio, il valore del primo trimestre del 1990 sarà quello
            del gennaio 1990.</para>
	</li>
      </ilist>

      <para>Se si compatta un intero dataset, il metodo di compattamento
        scelto diventa quello predefinito, ma se si è scelto un metodo di
        compattamento per una certa variabile (nel menù <quote>Variabile/Modifica
        attributi</quote>) viene usato quel metodo al posto di quello predefinito.
        Se il metodo di compattamento è già stato scelto per tutte le variabili, non
        viene presentata la scelta per il metodo di compattamento predefinito.
	</para>

    </description>
  </command>

  <command name="copy-formats" section="Utilities" context="gui"
    label="Formati di copia">

    <description>
      <para>
	Per copiare i dati da questa finestra, è possibile scegliere il formato
        testo semplice o altri tre formati.
      </para>

      <para>
	RTF: il formato <quote>Rich Text Format</quote> di Microsoft. In questo
        caso, la rappresentazione RTF dei dati è costituita da una tabella che
        usa un carattere a spazio uniforme (stile macchina da scrivere). I dati
        appariranno incolonnati, ma sarà difficile convertire questa
        rappresentazione tabulare in una <quote>vera</quote> tabella in MS Word,
        visto che il numero di spazi tra le colonne di dati è variabile.
      </para>

      <para>
	Testo separato da tab (o <quote>Tabella (MS Word)</quote>): i dati sono
        copiati sotto forma di testo semplice usando caratteri tab per separare
        le colonne. Incollando i dati in MS Word e utilizzando il comando di
        <quote>Formattazione automatica</quote> delle tabelle è possibile
        produrre una vera e propria tabella.
      </para>

      <para>
	CSV (Comma Separated Values): i valori dei dati sono separati da
        virgole, in modo da poter essere incollati in un foglio elettronico.
      </para>

    </description>

  </command>

  <command name="corc" section="Estimation" label="Stima Cochrane-Orcutt">

    <usage>
      <arguments>
        <argument>variabile-dipendente</argument>
        <argument>variabili-indipendenti</argument>
      </arguments>
      <options>
	<option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
	</option>
      </options>
      <examples>
        <example>corc 1 0 2 4 6 7</example>
      </examples>
    </usage>

    <description>
      <para>
	Calcola le stime dei parametri usando la procedura iterativa di
        Cochrane&ndash;Orcutt (si veda il Capitolo 9.4 di Ramanathan).
        La procedura si ferma quando le stime consecutive del coefficiente
        di autocorrelazione differiscono per meno di 0.001, oppure dopo
        20 iterazioni.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modello/Serie storiche/Cochrane-Orcutt</menu-path>
    </gui-access>

  </command>

  <command name="corr" section="Statistics" context="cli">

    <usage>
      <arguments>
        <argument optional="true">lista-variabili</argument>
      </arguments>
      <examples>
        <example>corr y x1 x2 x3</example>
      </examples>
    </usage>

    <description>
      <para>
	Mostra le coppie di coefficienti di correlazione per la variabili date
	nella <repl>lista-variabili</repl>, o per tutte le variabili del dataset
	se non viene specificata alcuna <repl>lista-variabili</repl>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Dati/Matrice di correlazione</menu-path>
      <other-access>Menù pop-up nella finestra principale (selezione multipla)</other-access>
    </gui-access>

  </command>

  <command name="corrgm" section="Statistics" label="Correlogramma">

    <usage>
      <arguments>
        <argument>variabile</argument>
        <argument optional="true">max-ritardo</argument>
      </arguments>
      <examples>
        <example>corrgm x 12</example>
      </examples>
    </usage>

    <description>
      <para>
	Mostra i valori della funzione di autocorrelazione per la
	<repl>variabile</repl> specificata (dal nome o dal numero).
        I valori sono definiti come
	<equation status="inline" 
	  tex="$\hat{\rho}(u_t, u_{t-s})$"
	  ascii="rho(u(t), u(t-s))"
	  graphic="autocorr"/> dove <mathvar>u<sub>t</sub></mathvar>
	è la <mathvar>t</mathvar>-esima osservazione della variabile
	<mathvar>u</mathvar> e <mathvar>s</mathvar> è il numero dei
	ritardi.
      </para>

      <para>
	Vengono mostrate anche le autocorrelazioni parziali (calcolate con
        l'algoritmo di Durbin&ndash;Levinson), ossia al
	netto dell'effetto dei ritardi intermedi. Il comando produce anche
        un grafico del correlogramma e mostra la statistica
        <mathvar>Q</mathvar> di Box&ndash;Pierce per testare l'ipotesi nulla
        che la serie sia <quote>white noise</quote> (priva di
        autocorrelazione). La statistica si distribuisce asintoticamente come
        chi-quadro con gradi di libertà pari al numero di ritardi specificati.
      </para>

      <para>
	Se viene specificato un valore <repl>max-ritardo</repl>, la lunghezza
        del correlogramma viene limitata al numero di ritardi specificato, altrimenti
        viene scelta automaticamente in funzione della frequenza dei dati e del
        numero di osservazioni.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variabile/Correlogramma</menu-path>
      <other-access>Menù pop-up nella finestra principale (selezione singola)</other-access>
    </gui-access>

  </command>

  <command name="criteria" section="Utilities" context="cli">

    <usage>
      <arguments>
        <argument>ess</argument>
        <argument>T</argument>
        <argument>k</argument>
      </arguments>
      <examples>
        <example>criteria 23.45 45 8</example>
      </examples>
    </usage>

    <description>
      <para>
	Calcola il criterio di informazione di Akaike (AIC) e il criterio
        di informazione bayesiana di Schwarz (BIC), dati <repl>ess</repl> (somma
        dei quadrati degli errori), il numero delle osservazioni
	(<mathvar>T</mathvar>) e quello dei coefficienti (<mathvar>k</mathvar>).
	<mathvar>T</mathvar>, <mathvar>k</mathvar> e
	<repl>ess</repl> possono essere valori numerici o nomi di
        variabili definite in precedenza.
      </para>
      <para>
	L'AIC è calcolato come nella formulazione originale di Akaike (1974),
        ossia
	<equation status="display"
	  tex="\[{\rm AIC} = -2 \ell + 2k\]"
	  ascii="AIC = -2L + 2k"
          graphic="aic"/>
	dove <equation status="inline" 
	  tex="$\ell$" ascii="L"
	  graphic="ell"/> denota la log-verosimiglianza massimizzata.
	Il BIC è calcolato come
	<equation status="display"
	  tex="\[{\rm BIC} = -2 \ell + k \log T\]"
	  ascii="BIC = -2L + k log T"
          graphic="bic_orig"/>
	Si vada la <guideref targ="select-criteria"/> per ulteriori dettagli.
      </para>
    </description>

  </command>

  <command name="critical" section="Utilities" context="cli">

    <usage>
      <arguments>
        <argument>distribuzione</argument>
        <argument>param1</argument>
	<argument optional="true">param2</argument>
      </arguments>
      <examples>
        <example>critical t 20</example>
        <example>critical X 5</example>
        <example>critical F 3 37</example>
        <example>critical d 50</example>
      </examples>
    </usage>

    <description>
      <para>Se la <repl>distribuzione</repl> è <lit>t</lit>, <lit>X</lit> o
	<lit>F</lit>, mostra i valori critici per le distribuzioni
        <mathvar>t</mathvar> di Student, chi-quadro o <mathvar>F</mathvar>,
	per i valori di significatività usuali, con i gradi di libertà
	specificati, dati da <repl>param1</repl> per la t e la chi-quadro,
        o <repl>param1</repl> e <repl>param2</repl> per la
	<mathvar>F</mathvar>. Se la <repl>distribuzione</repl> è <lit>d</lit>,
	mostra i valori superiore e inferiore della statistica di 
        Durbin&ndash;Watson al livello di significatività del 5 per cento, per
        il dato numero di osservazioni <repl>param1</repl>, e per l'intervallo
        da 1 a 5 variabili esplicative.
      </para>
    </description>

    <gui-access>
      <menu-path>/Utilità/Tavole statistiche</menu-path>
    </gui-access>

  </command>

  <command name="cusum" section="Tests" label="Test CUSUM">

    <description>
      <para>
	Va eseguito dopo la stima di un modello OLS. Esegue il test
	CUSUM per la stabilità dei parametri. Viene calcolata una 
        serie di errori di previsione (scalati) per il periodo successivo,
        attraverso una serie di regressioni: la prima usa le prime
	<mathvar>k</mathvar> osservazioni e viene usata per generare
        la previsione della variabile dipendente per l'osservazione 
	<mathvar>k</mathvar> + 1; la seconda usa le prime
        <mathvar>k</mathvar> + 1 osservazioni per generare una previsione
        per l'osservazione <mathvar>k</mathvar> + 2 e così via (dove
	<mathvar>k</mathvar> è il numero dei parametri nel modello originale).
      </para>
      <para>
	Viene mostrata, anche graficamente, la somma cumulata degli errori 
        scalati di previsione. L'ipotesi nulla della stabilità dei parametri
        è rifiutata al livello di significatività del 5 per cento se la somma
        cumulata va al di fuori delle bande di confidenza al 95 per cento.
      </para>

      <para>
	Viene mostrata anche la statistica <mathvar>t</mathvar> di
        Harvey&ndash;Collier per testare l'ipotesi nulla della stabilità dei
        parametri. Si veda il Capitolo 7 di <book>Econometric Analysis</book>
        di Greene, per i dettagli.
      </para>
    </description>

    <gui-access>
      <menu-path>Finestra del modello, /Test/CUSUM</menu-path>
    </gui-access>

  </command>

  <command name="data" section="Dataset" context="cli">

    <usage>
      <arguments>
        <argument>lista-variabili</argument>
      </arguments>
    </usage>

    <description>
      <para>Legge le variabili nella <repl>lista-variabili</repl> da un
	database (gretl o RATS 4.0), che deve essere stato precedentemente
        aperto con il comando <cmdref targ="open"/>. Inoltre, prima di eseguire
        questo comando, va impostata una frequenza dei dati e un intervallo del
        campione, usando i comandi <cmdref targ="setobs"/> e <cmdref
	  targ="smpl"/>. Ecco un esempio completo:</para>

      <code>
	open macrodat.rat
	setobs 4 1959:1
	smpl ; 1999:4
	data GDP_JP GDP_UK</code>

      <para>Questi comandi aprono un database chiamato
	<filename>macrodat.rat</filename>, impostano un dataset trimestrale
	che inizia nel primo trimestre del 1959 e finisce nel quarto trimestre
	del 1999 e infine importano le serie <lit>GDP_JP</lit> e <lit>GDP_UK</lit>.
        </para>

      <para>Se le serie da leggere hanno frequenza maggiore di quella impostata
        nel dataset, occorre specificare un metodo di compattamento, come mostrato
        di seguito</para>

      <code>
	data (compact=average) LHUR PUNEW</code>

      <para>I quattro metodi di compattamento disponibili sono
	<quote>average</quote> (usa la media delle osservazioni ad alta
	frequenza), <quote>last</quote> (usa l'ultima osservazione),
	<quote>first</quote> e <quote>sum</quote>.
      </para> 

    </description>

    <gui-access>
      <menu-path>/File/Consulta database</menu-path>
    </gui-access>

  </command>

  <command name="delete" section="Dataset" context="cli">

    <usage>
      <arguments>
        <argument optional="true">lista-variabili</argument>
      </arguments>
    </usage>

    <description>
      <para>Rimuove dal dataset le variabili elencate (specificate tramite il
      nome o il numero). <emphasis>Usare con cautela</emphasis>: non viene
      chiesta conferma dell'operazione e le variabili con numeri identificativi
      più alti vengono ri-numerate.</para>

      <para>Se non viene specificata alcuna <repl>lista-variabili</repl>
        viene eliminata dal dataset l'ultima variabile (quella col numero
        identificativo più alto).</para>
    </description>

    <gui-access>
      <menu-path>Pop-up nella finestra principale (selezione singola)</menu-path>
    </gui-access>

  </command>

  <command name="density" section="Statistics" context="gui"
    label="Stima kernel di densità">

    <description>

      <para>La stima kernel di densità avviene definendo un insieme di punti di
      riferimento distanziati in modo uniforme su un appropriato intervallo dei
      dati, e attribuendo ad ognuno di essi un valore di densità
      basato sui valori delle osservazioni circostanti.</para>
      
      <para>
        La formula usata per calcolare la densità stimata in ognuno dei punti di
        riferimento <mathvar>x</mathvar> è
      <equation status="display"
	tex="\[f(x)=(1/nh) \sum_{t-1}^{n} k\left((x-x_t)/h\right)\]"
	ascii="f(x) = (1/nh) sum(t=1 to n) k((x - x(t)) / h)"
	graphic="kernel1"/>
      dove <mathvar>n</mathvar> denota il numero delle osservazioni,
      <mathvar>h</mathvar> è un parametro di "larghezza di banda" e
      <mathvar>k</mathvar>() è la funzione kernel. All'aumentare del parametro
      di banda, aumenta il livellamento della densità stimata.
      </para>

      <para>È possibile usare un kernel Gaussiano (la densità normale
        standard) o il kernel di Epanechnikov, mentre la larghezza di banda
        predefinita è quella suggerita da Silverman (1986), ossia
	<equation status="display"
	  tex="\[h=0.9 {\rm min}(s, {\rm IQR}/1.349) n^{1/5}\]"
	  ascii="h = 0.9 min(s, IQR/1.349) n^{1/5}"
	  graphic="kernel2"/>

      dove <mathvar>s</mathvar> denota la deviazione standard dei dati e IQR
      denota il range interquartile. È possibile allargare o restringere la
      banda usando il <quote>fattore di aggiustamento della banda</quote>: la
      banda effettivamente utilizzata si ottiene moltiplicando il valore di
      Silverman per il fattore di aggiustamento.
      </para>

      <para>Per una buona discussione introduttiva della stima kernel, si veda
      il capitolo 15 di <book>Econometric Theory and Methods</book> di Davidson
      e MacKinnon.
      </para>

    </description>

  </command>  

  

  <command name="dialog" section="Estimation" context="gui"
    label="Finestra di dialogo Modello">

    <description>
      <para>Per selezionare la variabile dipendente, fare clic su una variabile
        nella lista di sinistra e premere il pulsante <quote>Scegli</quote>
	con la freccia che punta verso il riquadro della variabile dipendente.
	Selezionando la casella <quote>Imposta come predefinito</quote>, la
        variabile scelta verrà sempre pre-selezionata come variabile dipendente
        durante le prossime aperture della finestra di dialogo.
        Trucco: facendo doppio clic su una variabile sulla sinistra, viene
        selezionata come variabile dipendente e impostata come scelta predefinita.
	</para>

      <para>Per selezionare le variabili indipendenti, fare clic su di esse nella
        lista di sinistra e premere il pulsante <quote>Aggiungi</quote> (o fare clic
        col pulsante destro del mouse). È possibile selezionare più variabili
        contigue trascinando il mouse; se le variabili da selezionare non sono
        contigue, occorre fare clic tenendo premuto il tasto <lit>Ctrl</lit>.</para>

    </description>

  </command>

  <command name="diff" section="Transformations" context="cli">

    <usage>
      <arguments>
        <argument>lista-variabili</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Calcola la differenza prima di ogni variabile nella <repl>lista-variabili</repl>
	e la salva in una nuova variabile il cui nome è prefissato con
	<lit>d_</lit>.  Quindi <cmd>diff x y</cmd> crea le nuove variabili
      </para>
      <code>
	d_x = x(t) - x(t-1)
        d_y = y(t) - y(t-1)
      </code>
    </description>

    <gui-access>
      <menu-path>/Dati/Aggiungi variabili/Differenze</menu-path>
    </gui-access>

  </command>
  
  <command name="discrete" section="Transformations" context="cli">

    <usage>
      <arguments>
        <argument>lista-variabili</argument>
      </arguments>
      <options>
	<option>
	  <flag>--reverse</flag>
	  <effect>marca le variabili come continue</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
        Marca ogni variabile della <repl>lista-variabili</repl> come discreta.
        In modalità predefinita, tutte le variabili sono considerate come
        continue; marcando una variabile come discreta, essa viene trattata in
        modo speciale nei diagrammi di frequenza, e può esere usata con i
        comandi <cmdref targ="xtab"/> (cross-tabulazione) e <cmdref targ="dummify"/>.
      </para>
      <para>
        Usando l'opzione <lit>--reverse</lit>, l'operazione viene invertita,
        ossia, le variabili nella <repl>lista-variabili</repl> sono marcate come
        continue.
      </para>
    </description>

  </command>

  <command name="dummify" section="Transformations" context="cli">

    <usage>
      <arguments>
        <argument>lista-variabili</argument>
      </arguments>
    </usage>

    <description>
      <para>
        Per ogni variabile della <repl>lista-variabili</repl>, che sia stata
        marcata come discreta in precedenza, crea un insieme di variabili dummy
        che codificano i valori distinti di quella variabile. Così, ad esempio,
        se una variabile discreta <lit>x</lit> ha 5 valori distinti, verranno
        create 5 variabili dummy, di nome <lit>Dx_1</lit>, <lit>Dx_2</lit> e
        così via. La prima variabile dummy avrà valore 1 per le osservazioni in
        cui <lit>x</lit> assume il suo valore minimo, e 0 altrove; la successiva
        variabile dummy avrà valore 1 dove <lit>x</lit> assume il secondo tra i
        suoi valori, e così via.
      </para>
      <para>
	Questo comando può anche essere usato nel contesto di una regressione.
        Ad esempio, la riga seguente specifica un modello in cui
	<lit>y</lit> viene regredita sull'insieme di variabili dummy che
        codificano <lit>x</lit>.
      </para>
      <code>
	ols y dummify(x)</code>
    </description>

  </command>

  <command name="else" section="Programming" context="cli">

    <description><para>Si veda <cmdref targ="if"/>.</para>
    </description>

  </command>

  <command name="end" section="Programming" context="cli">

    <description>
      <para>
	Termina un blocco di comandi di qualsiasi tipo.
        Ad esempio, <cmd>end system</cmd> termina un <cmdref targ="system"/>
        (sistema di equazioni).
      </para>
    </description>

  </command>

  <command name="endif" section="Programming" context="cli">

    <description><para>Si veda <cmdref targ="if"/>.</para>
    </description>

  </command>

  <command name="endloop" section="Programming" context="cli">

    <description>
      <para>
	Indica la fine di un ciclo (loop) di comandi.  Si veda <cmdref targ="loop"/>.
      </para>
    </description>

  </command>

  <command name="eqnprint" section="Printing" context="cli">

    <usage>
      <arguments>
        <argument optional="true">-f nomefile</argument>
      </arguments>
      <options>
        <option>
	  <flag>--complete</flag>
	  <effect>crea un documento completo</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Va eseguito dopo la stima di un modello. Stampa il modello
        stimato sotto forma di equazione &latex;. Se viene specificato
        un nome di file usando l'opzione <lit>-f</lit>, il risultato
        viene scritto in quel file, altrimenti viene scritto in un file
        il cui nome ha la forma <filename>equation_N.tex</filename>, dove
        <lit>N</lit> è il numero di modelli stimati finora nella sessione
        in corso. Si veda anche <cmdref targ="tabprint"/>.
      </para>

      <para>
	Usando l'opzione <lit>--complete</lit>, il file &latex; è un
        documento completo, pronto per essere processato; altrimenti il
        file va incluso in un documento.
      </para>
    </description>

    <gui-access>
      <menu-path>Finestra del modello, /LaTeX</menu-path>
    </gui-access>

  </command>

  <command name="equation" section="Estimation" context="cli">

    <usage>
      <arguments>
        <argument>variabile-dipendente</argument>
        <argument>variabili-indipendenti</argument>
      </arguments>
      <examples>
        <example>equation y x1 x2 x3 const</example>
      </examples>
    </usage>

    <description>
      <para>
	Specifica un'equazione all'interno di un sistema di equazioni
        (si veda <cmdref targ="system"/>). La sintassi per specificare
        un'equazione in un sistema SUR è la stessa usata ad esempio in <cmdref
        targ="ols"/>. Per un'equazione in un sistema con minimi quadrati 
        a tre stadi, invece è possibile usare una specificazione simile a quella
        usata per OLS e indicare una lista di strumenti comuni usando l'istruzione
        <cmd>instr</cmd> (si veda ancora <cmdref targ="system"/>), oppure si può
        usare la stessa sintassi di <cmdref targ="tsls"/>.
      </para>
    </description>

  </command>

  <command name="estimate" section="Estimation" context="cli">

    <usage>
      <arguments>
        <argument>nome_sistema</argument>
        <argument>stimatore</argument>
      </arguments>
      <options>
       <option>
         <flag>--iterate</flag>
         <effect>itera fino alla convergenza</effect>
       </option>
       <option>
         <flag>--no-df-corr</flag>
         <effect>nessuna correzione per i gradi di libertà</effect>
       </option>
       <option>
         <flag>--geomean</flag>
         <effect>si veda oltre</effect>
       </option>
      </options>
      <examples>
        <example>estimate "Klein Model 1" method=fiml</example>
	<example>estimate Sys1 method=sur</example>
        <example>estimate Sys1 method=sur --iterate</example>
      </examples>
    </usage>

    <description>
      <para>
	Esegue la stima di un sistema di equazioni, che deve essere stato
        definito in precedenza usando il comando <cmdref targ="system"/>.
        Per prima cosa va indicato il nome del sistema, racchiuso tra
        virgolette se contiene spazi, quindi il tipo di stimatore, preceduto
        dalla stringa <lit>method=</lit>. Gli stimatori disponibili sono:
        <cmd>ols</cmd>, <cmd>tsls</cmd>, <cmd>sur</cmd>, <cmd>3sls</cmd>,
        <cmd>fiml</cmd> o <cmd>liml</cmd>.
      </para>
      <para>Se al sistema in questione sono stati imposti dei vincoli (si veda
       il comando <cmdref targ="restrict"/>), la stima sarà soggetta a tali
       vincoli.
      </para>
      <para>
       Se il metodo di stima è <cmd>sur</cmd> o <cmd>3sls</cmd>
       e viene usata l'opzione <lit>--iterate</lit>, lo stimatore verrà
       iterato. Nel caso di SUR, se la procedura converge, i risultati
       saranno stime di massima verosimiglianza. Invece l'iterazione della
       procedura dei minimi quadrati a tre stadi non produce in genere
       risultati di massima verosimiglianza a informazione completa.
       L'opzione <lit>--iterate</lit> viene ignorata con gli altri metodi di
       stima.
      </para>
      <para>Se vengono scelti gli stimatori "equazione per equazione"
      <cmd>ols</cmd> o <cmd>tsls</cmd>, nel calcolo degli errori standard viene
      applicata in modo predefinito una correzione per i gradi di libertà, che
      può essere disabilitata usando l'opzione <lit>--no-df-corr</lit>. Questa
      opzione non ha effetti nel caso vengano usati altri stimatori, che non
      prevedono correzioni per i gradi di libertà.
      </para>
      <para>La formula usata in modo predefinito per calcolare gli elementi della matrice
       di covarianza tra equazioni è
       <equation status="display"
       tex="\[\hat{\sigma}_{i,j}=\frac{\hat{u}_i' \hat{u}_j}{T}\]"
       ascii="sigma(i,j) = u(i)' * u(j) / T"
       graphic="syssigma1"/>
       Se viene usata l'opzione <lit>--geomean</lit>, viene applicata una correzione
       per i gradi di libertà secondo la formula
       <equation status="display"
       tex="\[\hat{\sigma}_{i,j}=\frac{\hat{u}_i' \hat{u}_j}{\sqrt{(T-k_i)(T-k_j)}}\]"
       ascii="sigma(i,j) = u(i)' * u(j) / sqrt((T - ki) * (T - kj))"
       graphic="syssigma2"/>
       dove i <mathvar>k</mathvar> indicano il numero di parametri indipendenti in
       ogni equazione.
      </para>
    </description>

  </command>

  <command name="expand" section="Dataset" context="gui"
    label="Espansione dei dati">

    <description>

      <para>
	Se si vuole aggiungere a un dataset una serie di frequenza inferiore, è
        necessario <quote>espandere</quote> la nuova serie. Ad esempio, una serie
        trimestrale dovrà essere espansa per essere aggiunta a un dataset
        mensile. Altre volte occorrerà espandere un intero dataset a una
        frequenza superiore prima di aggiungervi una serie che ha una frequenza
        superiore.
      </para>

      <para>
        L'operazione di espansione dei dati è riservata gli utenti
        <quote>esperti</quote>: occorre sapere bene cosa si sta facendo. In
        pratica, gretl replica i valori della serie a minore frequenza tante
        volte quanto è richiesto dai dati. Ad esempio, se si ha una
        serie trimestrale con il valore 35.5 per l'osservazione 1990:1 (il primo
        trimestre del 1990), espandendo la serie, il valore 35.5 verrà assegnato
        alle osservazioni per gennaio, febbraio e marzo del 1990. La variabile
        espansa non potrà quindi essere utilizzata per analisi temporali
        "a grana fine", tranne nel caso si abbia ragione di ritenere che la
        variabile in questione rimanga costante nei vari sotto-periodi.
      </para>

      <para>
	È utile tenere presenti due altri comandi. Per prima cosa, se si
        combinano serie di diversa frequenza in un dataset, è opportuno
        considerare la possibilità di compattare i dati a frequenza più alta,
        invece che espandere quelli a frequenza più bassa, utilizzando il
        comando presente nel menù Campione. In secondo luogo, se si sceglie di
        espandere una serie, può essere utile applicare un'operazione di
        smorzamento (smoothing) ai dati, fra quelle disponibili utilizzando il
        comando <cmd>genr</cmd>.
      </para>

    </description>
  </command>

  <command name="export" section="Dataset" context="gui"
    label="Esportazione dei dati">

    <description>
      <para>È possibile esportare dati in formato separato da virgole
        (CSV: Comma-Separated Values), in modo che possano essere aperti
        con fogli elettronici e molti altri programmi applicativi.
	</para>

      <para>È anche possibile esportare i dati nei formati specifici di
        GNU R o GNU octave.  Per ulteriori informazioni in questi programmi
        (entrambi utili per l'analisi statistica avanzata) si vedano i 
        rispettivi siti web: http://www.r-project.org/ e http://www.octave.org/
      </para>
    </description>
  </command>

  <command name="factorized" section="Graphs" context="gui"
    label="Grafici X-Y con fattore">

    <description>
      <para>Questo comando richiede che si selezionino tre variabili,
        l'ultima delle quali deve essere una variabile dummy (con valori
        1 o 0). La variabile Y è rappresentata rispetto alla variabile X,
        con i punti colorati diversamente a seconda del valore della terza
        variabile.</para>

      <para>Esempio: si hanno dati sui salari e il livello di scolarità
        per un campione di persone; si dispone anche di una variabile
        dummy che vale 1 per gli uomini e 2 per le donne (come nel file
	<filename>data7-2</filename> di Ramanathan).  Un <quote>Grafico
        X-Y con fattore</quote> di <lit>WAGE</lit> rispetto a <lit>EDUC</lit>
	usando la dummy <lit>GENDER</lit> mostrerà le osservazioni che si
        riferiscono agli uomini in un colore e quelle delle donne in un altro
        (insieme a una legenda per identificarli).</para>

    </description>

  </command>
  

  <command name="fcast" section="Prediction" context="cli">

    <usage>
      <arguments>
        <argument optional="true" >oss-iniziale oss-finale</argument>
	<argument>var-stima</argument>
      </arguments>
      <options>
        <option>
	  <flag>--dynamic</flag>
	  <effect>crea previsioni dinamiche</effect>
        </option>
        <option>
	  <flag>--static</flag>
	  <effect>crea previsioni statiche</effect>
        </option>
      </options>
      <examples>
        <example>fcast 1997:1 2001:4 f1</example>
	<example>fcast fit2</example>
      </examples>
    </usage>

    <description>
      <para>
	Deve seguire un comando di stima.  Calcola previsioni
        per l'intervallo specificato (o per il più lungo intervallo
        possibile, se non viene specificata alcuna <repl>oss-iniziale</repl>
        e <repl>oss-finale</repl>) e salva i valori nella variabile
	<repl>var-stima</repl>, che può essere stampata e rappresentata
        graficamente o con un diagramma ASCII. Le variabili indipendenti
        sono quelle del modello originale, non è possibile introdurre altre
        variabili. Se viene specificato un processo di errore autoregressivo,
	la previsione incorpora la frazione prevedibile del processo di errore.
      </para>
      <para>
	La scelta tra previsione statica e dinamica è rilevante solo nel caso di
        modelli dinamici, che comprendono un processo di errore autoregressivo,
        o che comprendono uno o più valori ritardati della variabile dipendente
        come regressori. Si veda <cmdref targ="fcasterr"/> per maggiori
        dettagli.
      </para>
    </description>

    <gui-access>
      <menu-path>Finestra del modello, /Dati modello/Previsioni</menu-path>
    </gui-access>

  </command>

  <command name="fcasterr" section="Prediction"
    label="Previsioni con errori standard">

    <usage>
      <arguments>
        <argument>oss-iniziale</argument>
        <argument>oss-finale</argument>
      </arguments>
      <options>
        <option>
	  <flag>--plot</flag>
	  <effect>mostra il grafico</effect>
        </option>
        <option>
	  <flag>--dynamic</flag>
	  <effect>crea previsioni dinamiche</effect>
        </option>
        <option>
	  <flag>--static</flag>
	  <effect>crea previsioni statiche</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Dopo aver stimato un modello è possibile usare questo comando
        per rappresentare i valori stimati su un intervallo di osservazioni
	specificato, insieme agli errori standard stimati per queste previsioni
        (a seconda del tipo di modello e dei dati disponibili)
        e agli intervalli di confidenza al 95 per cento.</para>

       <para>
	La scelta tra previsione statica e dinamica è rilevante solo nel caso di
        modelli dinamici, che comprendono un processo di errore autoregressivo,
        o che comprendono uno o più valori ritardati della variabile dipendente
        come regressori. Le previsioni statiche sono per il periodo successivo,
        basate sui valori effettivi nel periodo precedente, mentre quelle
        dinamiche usano la regola della previsione a catena.
        Ad esempio, se la previsione per <mathvar>y</mathvar> nel 2008
 	richiede come input il valore di <mathvar>y</mathvar> nel 2007,
        non è possibile calcolare una previsione statica se non si hanno dati
        per il 2007. È possibile calcolare una previsione dinamica per il 2008
        se si dispone di una precedente previsione per
 	<mathvar>y</mathvar> nel 2007.
       </para>
 
       <para>
 	La scelta predefinita consiste nel fornire una previsione statica per
        ogni porzione dell'intervallo di previsione che fa parte dell'intervallo
        del campione su cui il modello è stato stimato, e una previsione
        dinamica (se rilevante) fuori dal campione. L'opzione
 	<lit>dynamic</lit> richiede di produrre previsioni dinamiche a partire
        dalla prima data possibile, mentre l'opzione <lit>static</lit>
        richiede di produrre previsioni statiche anche fuori dal campione.
       </para>
 
       <para>
 	La natura degli errori standard della previsione (se disponibili)
        dipende dalla natura del modello e della previsione. Per i modelli
        lineari statici, gli errori standard sono calcolati seguendo il metodo
        delineato in Davidson and MacKinnon (2004); essi incorporano sia
        l'incertezza dovuta al processo d'errore, sia l'incertezza dei parametri
        (sintetizzata dalla matrice di covarianza delle stime dei parametri).
        Per modelli dinamici, gli errori standard della previsione sono
        calcolati solo nel caso di previsione dinamica, e non incorporano
        incertezza dei parametri. Per modelli non lineari, al momento non sono
        disponibili errori standard della previsione.
       </para>

    </description>

    <gui-access>
      <menu-path>Finestra del modello, /Dati modello/Previsioni con errori standard</menu-path>
    </gui-access>

  </command>

  <command name="fit" section="Prediction" context="cli">

    <description>
      <para>
	Una scorciatoia per <cmdref targ="fcast"/>. Deve seguire un comando
        di stima. Genera valori stimati per il campione corrente basati
        sull'ultima regressione e li salva nella serie <lit>autofit</lit>.
	Nel caso di modelli di serie storiche, mostra anche un grafico dei
        valori stimati e di quelli effettivi della variabile dipendente
        rispetto al tempo.
      </para>
    </description>

  </command>

  <command name="freq" section="Statistics" context="cli">

    <usage>
      <arguments>
        <argument>variabile</argument>
      </arguments>
      <options>
        <option>
         <flag>--quiet</flag>
         <effect>non mostra l'istogramma</effect>
        </option>
        <option>
         <flag>--gamma</flag>
         <effect>test per la distribuzione gamma</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
        Se non vengono indicate opzioni, mostra la distribuzione di frequenza
        per la <repl>variabile</repl> (indicata con il nome o il numero) e i
        risultati del test chi-quadro di Doornik&ndash;Hansen per la normalità.
      </para>
      <para>
       Se si usa l'opzione <lit>--quiet</lit>, l'istogramma non viene mostrato.
       Usando l'opzione <lit>--gamma</lit>, al posto del test di normalità
       viene eseguito il test non parametrico di Locke per l'ipotesi nulla che la
       variabile segua la distribuzione gamma; si veda Locke (1976), Shapiro e
       Chen (2001).
      </para>
      <para>
        In modalità interattiva viene mostrato anche un grafico della distribuzione.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variabile/Distribuzione di frequenza</menu-path>
    </gui-access>

  </command>

  <command name="function" section="Programming" context="cli">

    <usage>
      <arguments>
        <argument>nome_funzione</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Apre un blocco di istruzioni che definiscono una funzione. Il blocco va
        chiuso con <lit>end function</lit>. Per i dettagli, si veda
        la <guideref targ="functions"/>.
      </para>
    </description>

  </command>  

  <command name="garch" section="Estimation" label="Stima GARCH">

    <usage>
      <arguments>
        <argument>p</argument>
	<argument>q</argument>
	<argument separated="true">variabile-dipendente</argument>
	<argument optional="true">variabili-indipendenti</argument>
      </arguments>
      <options>
	<option>
	  <flag>--robust</flag>
	  <effect>errori standard robusti</effect>
        </option>
	<option>
	  <flag>--verbose</flag>
	  <effect>mostra i dettagli delle iterazioni</effect>
        </option>
        <option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
        </option>
        <option>
	  <flag>--arma-init</flag>
	  <effect>parametri di varianza iniziale da ARMA</effect>
        </option>
      </options>
      <examples>
        <example>garch 1 1 ; y</example>
	<example>garch 1 1 ; y 0 x1 x2 --robust</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
	Stima un modello GARCH (Generalized Autoregressive
	Conditional Heteroskedasticity) univariato, o, se sono specificate delle
	<repl>variabili-indipendenti</repl>, includendo delle variabili esogene.
	I valori interi <repl>p</repl> e <repl>q</repl> (che possono essere
        indicati in forma numerica o col nome di variabili scalari preesistenti)
        rappresentano gli ordini di ritardo nell'equazione della varianza
        condizionale.
	<equation status="display"
	  tex="\[h_t = \alpha_0 + \sum_{i=1}^q \alpha_i \varepsilon^2_{t-i} +
	  \sum_{j=1}^p \beta_i h_{t-j}\]"
	  ascii="h(t) = a(0) + somma(per i da 1 a q) a(i)*u(t-i)^2 + somma( per j da 1 a p) b(j)*h(t-j)"
	  graphic="garch_h"/>
      </para>

      <para context="gui">
        Stima un modello GARCH (Generalized Autoregressive Conditional
        Heteroskedasticity) univariato, o, se sono specificate delle
        variabili-indipendenti, includendo delle variabili esogene.
	L'equazione della varianza condizionale è la seguente:
	<equation status="display" tex="\[h_t = \alpha_0 + 
	\sum_{i=1}^q \alpha_i \varepsilon^2_{t-i} + \sum_{j=1}^p
	\beta_i h_{t-j}\]" ascii="h(t) = a(0) + somma (i da 1 a q) a(i)*u(t-i) +
	somma(j da 1 a p) b(j)*h(t-j)" graphic="garch_h"/>
      </para>

      <para>L'algoritmo GARCH usato da gretl è in pratica quello di
        Fiorentini, Calzolari e Panattoni (1996), usato per gentile
        concessione del Professor Fiorentini.</para>

      <para context="cli">Sono disponibili varie stime della
	matrice di covarianza dei coefficienti. Il metodo predefinito
        è quello dell'Hessiana; se si indica l'opzione <lit>--robust</lit>
	viene usata la matrice di covarianza QML (White).
	Altre possibilità (ad es. la matrice di informazione, o lo
        stimatore di Bollerslev&ndash;Wooldridge) possono essere specificate
        con il comando <cmdref targ="set"/>.
      </para>

      <para context="gui">Sono disponibili varie stime della matrice di
        covarianza dei coefficienti. Il metodo predefinito è quello
        dell'Hessiana, a meno di non selezionare la casella <quote>Errori
        standard robusti</quote>, nel qual caso viene usata la matrice di 
        covarianza QML (White). Altre possibilità (ad es. la matrice di
        informazione, o lo stimatore di Bollerslev&ndash;Wooldridge) possono
        essere specificate con il comando <cmdref targ="set"/>.
      </para>

      <para context="gui">La varianza condizionale stimata, insieme ai residui e
        ad altre statistiche del modello, può essere richiamata ed aggiunta al
        dataset usando il menù <quote>Dati modello</quote> presente nella
        finestra del modello.
      </para>

      
      <para context="cli">
	In modalità predefinita, le stime dei parametri di varianza sono
	inizializzate usando la varianza dell'errore non condizionale, ottenuta
        dalla stima OLS iniziale, per la costante, e piccoli valori positivi
        per i coefficienti dei valori passati dell'errore al quadrato e
        per la varianza dell'errore. L'opzione <lit>--arma-init</lit>
	fa in modo che i valori iniziali per questi parametri siano ricavati da
        un modello ARMA iniziale, sfruttando la relazione tra GARCH
        e ARMA mostrata nel capitolo 21 di <book>Time Series Analysis</book> di Hamilton.
        In alcuni casi, questo metodo può aumentare le probabilità di convergenza.
      </para>

      <para context="cli">
        I residui GARCH e la varianza condizionale stimata sono memorizzate
        rispettivamente nelle variabili <lit>$uhat</lit> e <lit>$h</lit>. Ad
        esempio, per ottenere la varianza condizionale è possibile scrivere: 
        </para>
      <code context="cli">
        genr ht = $h
      </code>

    </description>

    <gui-access>
      <menu-path>/Modello/Serie storiche/GARCH</menu-path>
    </gui-access>

  </command>

  <command name="genr" section="Dataset"
    label="Generazione di una nuova variabile">

    <usage>
      <arguments>
        <argument>nuova-variabile</argument>
        <argument>= formula</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Crea nuove variabili, di solito per mezzo di trasformazioni
        di variabili esistenti. Si veda anche <cmdref targ="diff"/>,
        <cmdref targ="logs"/>, <cmdref targ="lags"/>, <cmdref targ="ldiff"/>,
        <cmdref targ="multiply"/> e <cmdref targ="square"/> per le
        scorciatoie. Nel contesto di una formula <lit>genr</lit>, le variabili esistenti
        devono essere referenziate per nome, non per numero identificativo.
        La formula dev'essere una combinazione ben definita di nomi di
        variabile, costanti, operatori e funzioni (descritte oltre). Ulteriori
        dettagli su alcuni aspetti di questo comando si possono trovare nella
        <guideref targ="chap-genr"/>.
      </para>

      <para>
	Questo comando può produrre come risultato una serie o uno scalare. Ad
        esempio, la formula <lit>x2 = x * 2</lit> produce una serie se la variabile
	<lit>x</lit> è una serie e uno scalare se <lit>x</lit> è uno scalare.
        Le formule <lit>x = 0</lit> e <lit>mx = mean(x)</lit> producono degli
        scalari. In alcune circostanze, può essere utile che un risultato
        scalare sia espanso in una serie o in un vettore: è possibile ottenere
        questo risultato usando <lit>series</lit> come <quote>alias</quote> per il comando
	<lit>genr</lit>. Ad esempio, <lit>series x = 0</lit> produce una
	serie con tutti i valori pari a 0. Allo stesso modo, è possibile usare
        <lit>scalar</lit> come alias per <lit>genr</lit>, ma non è possibile
        forzare un risultato vettoriale in uno scalare: con questa parola chiave
        si indica che il risultato <emphasis>dovrebbe essere</emphasis> uno scalare;
        se non lo è, viene emesso un messaggio di errore.
      </para>

      <para>
        Quando una formula produce una serie o un vettore come risultato,
        l'intervallo su cui essi sono definiti dipende dall'impostazione attuale
        del campione. È quindi possibile definire una serie a pezzi, alternando
        l'uso dei comandi <lit>smpl</lit> e <lit>genr</lit>.
      </para>

      <para>
        Gli <emphasis>operatori aritmetici</emphasis> supportati sono, in
        ordine di precedenza: <lit>^</lit> (esponenziale); <lit>*</lit>,
        <lit>/</lit> e <lit>%</lit> (modulo o resto); <lit>+</lit> e
        <lit>-</lit>. 
      </para>

      <para>
	Gli <emphasis>operatori Booleani</emphasis> disponibili sono
	(ancora in ordine di precedenza): <lit>!</lit> (negazione),
	<lit>&amp;</lit> (AND logico), <lit>|</lit> (OR logico),
	<lit>&gt;</lit>, <lit>&lt;</lit>, <lit>=</lit>,
	<lit>&gt;=</lit> (maggiore o uguale), <lit>&lt;=</lit>
	(minore o uguale) e <lit>!=</lit> (disuguale).  Gli operatori
	Booleani possono essere usati per costuire variabili dummy:
	ad esempio <lit>(x > 10)</lit> produce 1 se <lit>x</lit>
	&gt; 10, 0 altrimenti.</para>
 
       <para>Le costanti predefinite sono <lit>pi</lit> e <lit>NA</lit>. L'ultima
       rappresenta il codice per i valori mancanti: è possibile inizializzare
       una variabile con valori mancanti usando <lit>scalar x = NA</lit>.
       </para>

      <para>Le <emphasis>funzioni</emphasis> supportate appartengono
        ai gruppi seguenti:
      </para>

      <ilist>
	<li><para>Funzioni matematiche standard: <func>abs</func>,
	    <func>cos</func>, <func>exp</func>, <func>int</func>
	    (parte intera), <func>ln</func> (logaritmo naturale:
	    <func>log</func> è un sinonimo), <func>sin</func>,
	    <func>sqrt</func> (radice quadrata). Tutte queste accettano un solo
            argomento, che può essere una serie o uno scalare.</para>
	</li>
	<li><para>Funzioni statistiche standard, che possono accettare un solo
            argomento e producono un risultato scalare: <func>max</func> (valore
            massimo in una serie), <func>min</func> (minimo),
	    <func>mean</func> (media aritmetica), <func>median</func> (mediana),
	    <func>var</func> (varianza) <func>sd</func> (deviazione
            standard), <func>sst</func> (somma dei quadrati delle
            deviazioni dalla media), <func>sum</func> (somma),
            <func>gini</func> (coefficiente di Gini).</para>
        </li>
        <li>
          <para>Funzioni statistiche che accettano una serie con argomento e
          producono una serie o un vettore: <func>sort</func> (ordina una serie
          in ordine ascendente di grandezza), <func>dsort</func> (ordina una serie
          in ordine discendente di grandezza), <func>cum</func> (somma cumulata).
          </para>
        </li>
	<li>
          <para>Funzioni statistiche che accettano due serie come argomenti e
          producono uno scalare: <func>cov</func> (covarianza), <func>corr</func>
          (coefficiente di correlazione).
          </para>
        </li>
        <li>
          <para>Funzioni statistiche speciali: <func>pvalue</func> e
          <func>critical</func> (si veda oltre), <func>cnorm</func> (funzione di
          ripartizione normale standard), <func>dnorm</func> (funzione di
          densità normale standard), <func>qnorm</func> (quantili della
          normale standard, o inversa della funzione di densità normale standard),
          <func>resample</func> (ricampiona una serie
          con rimpiazzo, utile per il bootstrap), <func>hpfilt</func>
          (componente di <quote>ciclo</quote> della serie), <func>bkfilt</func>
          (filtro passa-banda di Baxter&ndash;King).</para>
	</li>
	<li><para>Funzioni per serie storiche: <func>diff</func>
            (differenza prima), <func>ldiff</func> (log-differenza,
            ossia la differenza prima dei logaritmi naturali),
            <func>sdiff</func> (differenza stagionale),
            <func>fracdiff</func> (differenza frazionale).
	    Per generare ritardi della variabile <lit>x</lit>, si può usare
            la sintassi <cmd>x(-N)</cmd>, dove <lit>N</lit> rappresenta
            la lunghezza del ritardo desiderato; per generare anticipi
	    si usi <cmd>x(+N)</cmd>.</para>
	</li>
        <li><para>Funzioni dataset, che producono una serie:
          <func>misszero</func> (sostituisce con zero il codice delle
          osservazioni mancanti in una serie); <func>zeromiss</func>
          (l'operazione inversa di <func>misszero</func>); 
          <func>missing</func> (per ogni osservazione, vale 1 se l'argomento ha
          un valore mancante, 0 altrimenti); <func>ok</func> (l'opposto di
          <func>missing</func>).</para>
	</li>
        <li><para>Funzioni dataset, che producono uno scalare:
          <func>nobs</func> (riporta il numero di osservazioni valide in una
          serie), <func>firstobs</func> (riporta il numero della prima osservazione
          non mancante in una serie) <func>lastobs</func> (numero dell'ultima osservazione
          non mancante in una serie).
 	  </para>
 	</li>
        
	<li><para>
	    Numeri pseudo-casuali: <func>uniform</func> e <func>normal</func>.
	    Queste funzioni non accettano argomenti e vanno scritte con
            parentesi vuote: <lit>uniform()</lit>, <lit>normal()</lit>. Esse
            creano serie pseudo-casuali estraendo i valori dalle distribuzioni
            uniforme (0&ndash;1) e normale standard. Si veda anche l'opzione
            <lit>seed</lit> del comando <cmdref targ="set"/>.
            Le serie dalla distribuzione uniforme sono generate usando il Mersenne Twister
            <footnote><para>Si veda Matsumoto e Nishimura
            (1998). L'implementazione è fornita da <program>glib</program>, se è
            disponibile, o dal codice C scritto da Nishimura e Matsumoto.</para>
            </footnote>; per le serie dalla distribuzione normale, viene usato il
            metodo di Box e Muller (1958), prendendo l'input dal Mersenne Twister.
	  </para>
	</li>
      </ilist> 

      <para>
        Tutte le funzioni viste sopra, con l'eccezione di <func>cov</func>,
        <func>corr</func>, <func>pvalue</func>, <func>critical</func>,
        <func>fracdiff</func>, <func>uniform</func> e <func>normal</func> hanno
        come unico argomento il nome di una variabile o un'espressione che si
        risolve in una variabile (ad es. <lit>ln((x1+x2)/2)</lit>).
      </para>
      <para>
	La funzione <func>pvalue</func> richiede gli stessi argomenti del
	comando <cmdref targ="pvalue"/>, ma in questo caso occorre separare
	gli argomenti con delle virgole. Questa funzione produce un p-value
        a una coda, che nel caso delle distribuzioni normale e
        <emphasis>t</emphasis> è la <quote>coda corta</quote>. Con la normale,
        ad esempio, sia 1.96 sia -1.96 daranno un risultato di circa 0.025.
      </para>

      <para>
	La funzione <func>critical</func> produce il valore critico per una
        certa distribuzione di probabilità, data la proporzione sulla coda di
        destra (e dati i gradi di libertà, in alcuni casi). L'argomento che
        indica la distribuzione deve essere il primo e può valere <cmd>z</cmd> o
        <cmd>N</cmd> per la distribuzione normale, <cmd>t</cmd> per la
        <emphasis>t</emphasis> di Student, <cmd>X</cmd> per la chi-quadro, o
        <cmd>F</cmd>. L'ultimo argomento è la proporzione sulla coda di destra.
        Se il primo argomento è <cmd>t</cmd> o <cmd>X</cmd>, occorre specificare
        un secondo argomento per i gradi di libertà, mentre per la distribuzione
        <emphasis>F</emphasis>, occorre indicare i gradi di libertà del
        numeratore e quelli del denominatore, rispettivamente come secondo e
        terzo argomento.
      </para>

      <para>
	Ecco alcuni esempi di uso delle funzioni <func>pvalue</func> e
	<func>critical</func> (gli spazi tra gli argomenti sono opzionali):
      </para>
      <code>
	genr p1 = pvalue(z, 2.2)
	genr p2 = pvalue(X, 3, 5.67)
	genr c1 = critical(t, 20, 0.025)
	genr c2 = critical(F, 4, 48, 0.05)
      </code>

      <para>
	Le funzioni relative alla densità normale standard funzionano nel modo
        seguente, dato un argomento <mathvar>x</mathvar>: <func>cnorm</func> restituisce
        l'area al di sotto della funzione di densità normale standard, integrata
        da meno infinito a <mathvar>x</mathvar>; <func>dnorm</func> restituisce
        la densità normale standard valutata in <mathvar>x</mathvar>, mentre
        <func>qnorm</func> restituisce il valore <mathvar>z</mathvar> tale che
        l'area al di sotto della funzione di densità normale standard, integrata
        da meno infinito a <mathvar>z</mathvar> valga <mathvar>x</mathvar>.
      </para>
      
      <para>
        La funzione <func>fracdiff</func> richiede due argomenti: il nome della
        serie e una frazione nell'intervallo da &minus;1 a 1.
      </para>
      
      <para>Oltre agli operatori e alle funzioni mostrati, ci sono alcuni
        usi speciali del comando <cmd>genr</cmd>:
      </para>

      <ilist>
	<li><para><cmd>genr time</cmd> crea una variabile trend temporale
	    (1,2,3,&hellip;) chiamata <cmd>time</cmd>.
            <cmd>genr index</cmd> fa la stessa cosa, ma chiamando la variabile
	    <lit>index</lit>.</para>
	</li>
	<li><para><cmd>genr dummy</cmd> crea una serie di variabili dummy a seconda
            della periodicità dei dati. Ad esempio, nel caso di dati trimestrali
            (periodicità 4) il programma crea <lit>dummy_1</lit>, che vale 1 
            nel primo trimestre e 0 altrove, <lit>dummy_2</lit> che vale 1
            nel secondo trimestre e 0 altrove, e così via.</para>
	</li>
	<li><para><cmd>genr paneldum</cmd> crea una serie di variabili dummy
            da usare in un dataset di tipo panel.
	    </para>
	</li>
      </ilist>

      <para>Alcune variabili interne che vengono generate durante
	il calcolo di una regressione possono essere recuperate usando
	<cmd>genr</cmd>, nel modo seguente:</para>

      <ilist>
	<li>
	  <para>
	   <lit>$ess</lit>: somma dei quadrati degli errori
	  </para>
	</li>
	<li>
	  <para>
	   <lit>$rsq</lit>: <emphasis>R</emphasis>-quadro
	  </para>
	</li>	
	<li>
	  <para>
	   <lit>$T</lit>: numero delle osservazioni usate
	  </para>
	</li>
	<li>
	  <para>
	   <lit>$df</lit>: gradi di libertà
	  </para>
	</li>
	<li>
	  <para>
	   <lit>$ncoeff</lit>: numero dei coefficienti stimati
	  </para>
	</li>
	<li>
	  <para>
	    <lit>$trsq</lit>: <emphasis>TR</emphasis>-quadro (ampiezza del
	    campione moltiplicata per <emphasis>R</emphasis>-quadro)
	  </para>
	</li>
	<li>
	  <para>
	   <lit>$sigma</lit>: errore standard dei residui
	  </para>
	</li>
	<li>
	  <para>
	   <lit>$aic</lit>: criterio di informazione di Akaike
	  </para>
	</li>
	<li>
	  <para>
	   <lit>$bic</lit>: criterio di informazione bayesiana di Schwarz
	  </para>
	</li>
	<li>
	  <para>
	   <lit>$lnl</lit>: log-verosimiglianza (dove è applicabile)
	  </para>
	</li>
	<li>
	  <para>
	    <lit>$coeff</lit>(<repl>variabile</repl>): coefficiente stimato per
	    la <repl>variabile</repl>
	  </para>
	</li>
	<li>
	  <para>
	    <lit>$stderr</lit>(<repl>variabile</repl>): errore standard stimato
	    per la <repl>variabile</repl>
	  </para>
	</li>
	<li>
	  <para>
	    <lit>$rho</lit>(<repl>i</repl>): coefficiente di autoregressione
	    dei residui di ordine <repl>i</repl>-esimo
	  </para>
	</li>
	<li>
	  <para>
	    <lit>$vcv</lit>(<repl>x1</repl>,<repl>x2</repl>): covarianza
	    stimata tra i coefficienti delle variabili <repl>x1</repl> e
	    <repl>x2</repl> 
	  </para>
	</li>
      </ilist> 

      <para>
	<emphasis>Nota</emphasis>: nella versione a riga di comando del programma,
        i comandi <cmd>genr</cmd> che estraggono dati relativi al modello
	si riferiscono sempre al modello stimato per ultimo. Questo vale anche
        per la versione grafica del programma se si usa <cmd>genr</cmd> nel
        <quote>terminale di gretl</quote> o si immette una formula usando
        l'opzione <quote>Definisci nuova variabile</quote> nel menù Variabile
        della finestra principale. Usando la versione grafica, però, è
        possibile anche estrarre i dati da qualunque modello mostrato in una
        finestra (anche se non è il modello più recente) usando il menù
        <quote>Dati modello</quote> nella finestra del modello.</para>

      <para>Le serie interne <lit>uhat</lit> e <lit>yhat</lit>
	contengono rispettivamente i residui e i valori stimati dell'ultima
        regressione. Per i modelli GARCH, la varianza condizionale è memorizzata
        nella variabile interna <lit>$h</lit>.
      </para>

      <para>
	Sono disponibili tre variabili dataset <quote>interne</quote>:
	<lit>$nobs</lit>, che contiene il numero di osservazioni nell'intervallo
        del campione attuale (che non è necessariamente uguale al valore di
	<lit>$T</lit>, il numero delle osservazioni usate per stimare l'ultimo
        modello), <lit>$nvars</lit>, che contiene il numero di variabili nel
        dataset (inclusa la costante), e <lit>$pd</lit>, che contiene la
        frequenza o la periodicità dei dati (ad esempio 4 per dati
        trimestrali).</para>

      <para>Due scalari speciali interni, <lit>$test</lit> e
       <lit>$pvalue</lit>, contengono rispettivamente il valore e il
       p-value della statistica test che è stata generata dall'ultimo
       comando di test eseguito esplicitamente (ad es. <lit>chow</lit>).
       Si veda la <guideref targ="chap-genr"/> per i dettagli.
      </para>

      <para>La variabile <lit>t</lit> serve da indice per le osservazioni.
	Ad esempio, <lit>genr dum = (t=15)</lit> crea una variabile dummy
	che vale 1 per l'osservazione 15 e 0 altrove. La variabile
        <lit>obs</lit> è simile ma più flessibile: è possibile usarla per
        isolare alcune osservazioni indicandole con una data o un nome.
        Ad esempio, <lit>genr d = (obs&gt;1986:4)</lit> o 
        <lit>genr d = (obs="CA")</lit>. L'ultima forma richiede che
        siano definite delle etichette, da usare tra virgolette doppie,
        per le osservazioni.</para>

      <para>È possibile estrarre dei valori scalari da una serie usando
        una formula <lit>genr</lit> con la sintassi
	<repl>nome-variabile</repl><lit>[</lit><repl>osservazione</repl><lit>]</lit>.
	Il valore di <repl>osservazione</repl> può essere specificato con
        un numero o una data.
	Esempi: <lit>x[5]</lit>, <lit>CPI[1996:01]</lit>.  Per i dati
        giornalieri occorre usare la forma <repl>AAAA/MM/GG</repl>, ad esempio
	<lit>ibm[1970/01/23]</lit>.
      </para>

      <para>È possibile modificare una singola osservazione in una serie
         usando <lit>genr</lit>. Per farlo, occorre aggiungere un numero
         di osservazione o una data valida tra parentesi quadre al nome
	 della variabile nel lato sinistro della formula. Ad esempio:
	<lit>genr x[3] = 30</lit> o <lit>genr x[1950:04] =
	  303.7</lit>.
      </para>

      <para>
	Ecco qualche esempio di utilizzo delle variabili dummy:
      </para>

      <ilist>
	<li><para>Si supponga che <lit>x</lit> abbia valori 1, 2, o 3
	    e si desiderino tre variabili dummy, <lit>d1</lit> = 1 se
	    <lit>x</lit> = 1, e 0 altrove, <lit>d2</lit> = 1 se
	    <lit>x</lit> = 2 e così via. Per crearle, basta usare i comandi:
	    </para>

	  <code>
	    genr d1 = (x=1)
	    genr d2 = (x=2)
	    genr d3 = (x=3)</code>
	</li>

	<li><para>Per creare <lit>z</lit> = <lit>max(x,y)</lit>
	    usare</para>

	  <code>
	    genr d = x&gt;y
	    genr z = (x*d)+(y*(1-d))</code>
	</li>
      </ilist>

      <table id="tab-genr" title="Esempi di utilizzo del comando genr"
	lhead="Formula" rhead="Commento"
	lwidth="100pt" rwidth="300pt" 
	style="rpara">
	<row>
	  <cell><lit>y = x1^3</lit></cell>
	  <cell><lit>x1</lit> al cubo</cell>
	</row>          
	<row>
	  <cell><lit>y = ln((x1+x2)/x3)</lit></cell>
	  <cell></cell>
	</row>
	<row>
	  <cell><lit>z = x&gt;y</lit></cell>
	  <cell><lit>z(t)</lit> = 1 se <lit>x(t) &gt; y(t)</lit>,
	    0 altrove</cell>
	</row> 
	<row>
	  <cell><lit>y = x(-2)</lit></cell>
	  <cell><lit>x</lit> ritardata di 2 periodi</cell>
	</row>     
	<row>
	  <cell><lit>y = x(+2)</lit></cell>
	  <cell><lit>x</lit> anticipata di 2 periodi</cell>
	</row>
	<row>
	  <cell><lit>y = diff(x)</lit></cell>
	  <cell><lit>y(t) = x(t) - x(t-1)</lit></cell>
	</row>
	<row>
	  <cell><lit>y = ldiff(x)</lit></cell>
	  <cell><lit>y(t) = log x(t) - log x(t-1)</lit>, il
            tasso di crescita istantaneo di <lit>x</lit></cell>
	</row>
	<row>
	  <cell><lit>y = sort(x)</lit></cell>
	  <cell>ordina <lit>x</lit> in senso crescente e la salva in
	    <lit>y</lit></cell>
	</row>
	<row>
	  <cell><lit>y = dsort(x)</lit></cell>
	  <cell>ordina <lit>x</lit> in senso decrescente</cell>
	</row>
	<row>
	  <cell><lit>y = int(x)</lit></cell>
	  <cell>tronca <lit>x</lit> e salva il valore intero in
	    <lit>y</lit></cell>
	</row>
	<row>
	  <cell><lit>y = abs(x)</lit></cell>
	  <cell>salva il valore assoluto di <lit>x</lit></cell>
	</row>
	<row>
	  <cell><lit>y = sum(x)</lit></cell>
	  <cell>somma i valori di <lit>x</lit> escludendo i valori mancanti &minus;999</cell>
	</row>
	<row>
	  <cell><lit>y = cum(x)</lit></cell>
	  <cell>cumulativa: 
		<equation status="inline"
		  tex="$y_t = \sum_{\tau=1}^t x_{\tau}$"
		  ascii="y(t) = somma di x(s) per s da 1 a t"
		  graphic="cumulate"/>
	  </cell>
	</row>
	<row>
	  <cell><lit>aa = $ess</lit></cell>
	  <cell>imposta <lit>aa</lit> uguale alla somma dei quadrati degli errori
            dell'ultima regressione</cell>
	</row>
	<row>
	  <cell><lit>x = $coeff(sqft)</lit></cell>
	  <cell>estrae il coefficiente stimato per la variabile
	    <lit>sqft</lit> nell'ultima regressione</cell>
	</row>
	<row>
	  <cell><lit>rho4 = $rho(4)</lit></cell>
	  <cell>estrae il coefficiente di autoregressione del quarto
            ordine dall'ultimo modello (presume un modello
            <lit>ar</lit> model)</cell>
	</row>
	<row>
	  <cell><lit>cvx1x2 = $vcv(x1, x2)</lit></cell>
	  <cell>estrae il coefficiente di covarianza stimato tra le
            variabili <lit>x1</lit> e <lit>x2</lit> dall'ultimo modello</cell>
	</row>
	<row>
	  <cell><lit>foo = uniform()</lit></cell>
	  <cell>variabile pseudo-casuale uniforme nell'intervallo
	    0&ndash;1</cell>
	</row>
	<row>
	  <cell><lit>bar = 3 * normal()</lit></cell>
	  <cell>variabile pseudo-casuale normale con &mu; = 0, &sigma; =
	    3</cell>
	</row>
	<row>
	  <cell><lit>samp = ok(x)</lit></cell>
	  <cell>vale 1 per le osservazioni dove il valore di <lit>x</lit>
            non è mancante.</cell>
	</row>
      </table>

    </description>

    <gui-access>
      <menu-path>/Variabile/Definisci nuova variabile</menu-path>
      <other-access>Menù pop-up nella finestra principale</other-access>
    </gui-access>

  </command>

  <command name="gnuplot" section="Graphs" context="cli">

    <usage>
      <arguments>
        <argument>variabili-y</argument>
        <argument>variabile-x</argument>
	<argument optional="true">variabile-dummy</argument>
      </arguments>
      <options>
        <option>
	  <flag>--with-lines</flag>
	  <effect>usa linee invece che punti</effect>
        </option>
        <option>
	  <flag>--with-impulses</flag>
	  <effect>usa linee verticali</effect>
        </option>
        <option>
	  <flag>--suppress-fitted</flag>
	  <effect>non mostra le stime minimi quadrati</effect>
        </option>
        <option>
	  <flag>--dummy</flag>
	  <effect>si veda sotto</effect>
        </option>
      </options>
      <examples>
        <example>gnuplot y1 y2 x</example>
        <example>gnuplot x time --with-lines</example>
	<example>gnuplot wages educ gender --dummy</example>
      </examples>
    </usage>

    <description>
      <para>Senza l'opzione <lit>--dummy</lit> mostra un grafico delle
	<repl>variabili-y</repl> rispetto alla <repl>variabile-x</repl>.
        Con <lit>--dummy</lit>, la <repl>variabile-y</repl> è rappresentata
        rispetto alla <repl>variabile-x</repl> con i punti colorati diversamente
        a seconda del valore della <repl>variabile-dummy</repl> (1 o 0).</para>

      <para>
	La variabile <lit>time</lit> si comporta in modo speciale: se non esiste
        già, verrà generata automaticamente.
      </para>

      <para>
	In modalità interattiva il risultato è mostrato immediatamente.
        In modalità <quote>batch</quote>, viene scritto un file di comandi
        gnuplot, chiamato <filename>gpttmpN.plt</filename>, a partire da N
	= <lit>01</lit>; il grafico vero e proprio può essere generato
        usando il programma <program>gnuplot</program> (su MS Windows:
	<program>wgnuplot</program>).
      </para>

      <para>È disponibile un'ulteriore opzione per questo comando: dopo la
        specificazione delle variabili e le eventuali opzioni, è possibile
        aggiungere direttamente dei comandi gnuplot per modificare l'aspetto
        visivo del grafico (ad esempio, impostando il titolo e o gli intervalli
        degli assi). Questi comandi aggiuntivi vanno inclusi tra parentesi
        graffe e ogni comando va separato con un punto e virgola; è possibile
        usare una barra rovesciata (<lit>\</lit>) per continuare un gruppo di
        comandi gnuplot sulla riga successiva. Ecco un esempio della sintassi:
      </para>

      <para>
	<lit>{ set title 'Il mio titolo'; set yrange [0:1000]; }</lit>
      </para>

    </description>

    <gui-access>
      <menu-path>/Dati/Grafico delle variabili</menu-path>
      <other-access>Menù pop-up nella finestra principale, pulsante grafico sulla barra degli strumenti</other-access>
    </gui-access>

  </command>

  <command name="graph" section="Graphs" context="cli">

    <usage>
      <arguments>
        <argument>variabili-y</argument>
        <argument>variabile-x</argument>
      </arguments>
      <options>
        <option>
	  <flag>--tall</flag>
	  <effect>usa 40 righe</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Grafici ASCII.  Le <repl>variabili-y</repl> (che possono essere
        definite per nome o numero) sono rappresentate rispetto alla
        <repl>variabile-x</repl> usando simboli ASCII. L'opzione
        <lit>--tall</lit> produce un grafico di 40 righe per 60 colonne,
        altrimenti il grafico sarà di 20 righe per 60 colonne (per la
        visualizzazione a schermo). Si veda anche <cmdref targ="gnuplot"/>.
      </para>
    </description>

  </command>

  <command name="graphing" section="Graphs" context="gui"
    label="Grafici">

    <description>

      <para>Gretl richiama un programma separato, gnuplot, per generare
	i grafici. Gnuplot è un programma di grafica molto completo, con
        una miriade di opzioni; gretl fornisce l'accesso, attraverso
        un'interfaccia grafica, a una parte di queste opzioni, cercando
        di scegliere dei valori, ma è possibile anche controllare
        l'aspetto di un grafico in tutti i suoi dettagli, se si vuole.
	</para>

      <para>Mentre un grafico viene visualizzato, facendo clic sulla
      finestra del grafico si aprirà un menù pop-up con le seguenti
      opzioni:</para>

      <ilist>
	<li><para>Salva come postscript: salva il grafico in formato encapsulated
	    postscript (EPS)</para>
	</li>
	<li><para>Salva come PNG: salva in formato Portable Network Graphics</para>
	</li>
	<li><para>Salva alla sessione come icona: il grafico apparirà
        sotto forma di icona quando si seleziona <quote>Visualizza
        Icone</quote> dal menù Sessione</para>
	</li>
	<li><para>Ingrandisci: permette di selezionare un'area
        all'interno del grafico per visualizzarla da vicino</para>
	</li>
        <li><para>Stampa: permette di stampare il grafico direttamente
        (disponibile solo in Gnome e MS Windows)</para>
	</li>
	<li><para>Copia negli appunti: permette di copiare il grafico
        per poi incollarlo in altri programmi Windows, come ad esempio
        MS Word (disponibile solo in MS Windows)</para>
	</li>
	<li><para>Modifica: apre una finestra che permette di modificare
        vari dettagli dell'aspetto del grafico</para>
	</li>
	<li><para>Chiudi: chiude la finestra del grafico</para>
	</li>
      </ilist>

      <para>
	Se si conosce gnuplot e si desidera un controllo sull'aspetto
        del grafico più preciso di quello fornito dalla finestra di
        modifica del grafico (opzione <quote>Modifica</quote>), ci sono
        due possibilità:</para>

      <ilist>
	<li><para>Una volta salvato il grafico come icona di sessione,
        facendo clic col tasto destro sull'icona si apre un altro menù
        pop-up. Una delle opzioni disponibili è <quote>Comandi per
        modificare il grafico</quote>, che apre una finestra di modifica
        con i comandi di gnuplot. È possibile modificare questi comandi
        e salvarli per il futuro, oppure inviarli direttamente a
        gnuplot (con il comando <quote>File/Invia a gnuplot</quote> del
        menù della finestra di modifica dei comandi).</para>
	</li>
	<li><para>Un altro modo per salvare i comandi del grafico (o per
        salvare il grafico in formati diversi da EPS o PNG) è quello di
        usare il comando <quote>Modifica</quote> nel menù pop-up del
        grafico per aprire la finestra di modifica del grafico, quindi
        fare clic su <quote>File</quote>: verrà visualizzato un menù a
        discesa con i formati in cui è possibile salvare il grafico.
	</para>
	</li>
      </ilist>

      <para>
	Per saperne di più su gnuplot, si veda
	http://ricardo.ecn.wfu.edu/gnuplot.html oppure
	http://www.gnuplot.info</para>

    </description>

  </command>

  <command name="graphpag" section="Graphs" context="gui"
    label="Pagina dei grafici">

    <description>

      <para>La <quote>pagina dei grafici</quote> funzionerà solo se
        si è installato il sistema di composizione &latex; e si è
        in grado di generare e visualizzare file in formato postscript.
	</para>

      <para>Nella finestra della sessione, è possibile trascinare fino
	a otto grafici sull'icona della pagina dei grafici. Facendo doppio
	clic sull'icona della pagina dei grafici (o facendo clic col tasto
        destro e selezionando <quote>Mostra</quote>), la pagina contenente
        i grafici selezionati verrà composta e aperta con il proprio
        visualizzatore di file postscript, da cui sarà possibile stamparla.
      </para>

      <para>Per pulire la pagina dei grafici, fare clic col tasto destro
        sull'icona e selezionare <quote>Pulisci</quote>.</para> 

      <para>Su sistemi diversi da MS Windows, può essere necessario modificare
        l'impostazione del programma per visualizzare il postscript, che si
        trova nella sezione <quote>Programmi</quote> della finestra di dialogo
        delle Preferenze di gretl (nel menù File della finestra principale).
        </para>

    </description>

  </command>

  <command name="3-D" section="Graphs" context="gui"
    label="Grafici tridimensionali">

    <description>
      <para>Questa funzionalità migliora se è stata installata una
        versione di gnuplot pari o superiore alla 3.8, che consente
        di manipolare il grafico 3D con il mouse (ruotandolo ed
        allungando o riducendo gli assi).</para>

      <para>Nella composizione di un grafico 3D, si noti che l'asse Z
        sarà l'asse verticale, quindi se si ha una variabile dipendente
        che si pensa possa essere influenzata da due variabili indipendenti,
        è meglio mettere la variabile dipendente sull'asse Z e le altre
        due variabili sugli assi X e Y.
	</para>  

      <para>A differenza di molti altri grafici di gretl, i grafici 3D
        sono controllati da gnuplot invece che da gretl, quindi il menù
        di modifica dei grafici in questo caso non è disponibile.
	</para>

    </description>
  </command>

  <command name="gui-htest" section="Tests" context="gui"
    label="Calcolatore per le statistiche test">

    <description>
      <para>
	Il calcolatore dei test di Gretl calcola statistiche test e p-value
        per molti tipi di test di ipotesi su una o più popolazioni.
        Per utilizzarlo, occorre indicare le statistiche campionarie derivate
        da uno o due campioni, a seconda del test scelto. Queste possono essere
        indicate esplicitamente in forma numerica, oppure, se si ha un file di
        dati aperto, è possibile far calcolare a gretl le statistiche test per
        una o più variabili selezionate dal dataset (nel caso delle medie e
        varianze, ma non nel caso delle proporzioni).
      </para>

      <para>
	Per eseguire un test indicando una variabile del dataset, occorre per
        prima cosa attivare questa opzione selezionando la casella "Usa
        variabile dal dataset", e poi scegliere la variabile nella lista.
        Appena si sceglie una variabile, i valori della statistica rilevante
        sono automaticamente inseriti nelle caselle sottostanti.
      </para>

      <para>
	Oltre che selezionare semplicemente una variabile, è possibile
        specificare un sotto-campione. Ad esempio, si ipotizzi di avere dei dati
        sui salari in una variabile chiamata "salari" e una variabile dummy
        chiamata "genere", pari a 1 per gli uomini e 0 per le donne (o
        viceversa). Quindi, nel test per la differenza fra le medie, è possibile
        selezionare "salari" in entrambi i campi, ma aggiungendo nel campo
        superiore "(genere=0)" e nel campo inferiore "(genere=1)" si otterrà
        un test per la differenza tra il reddito medio degli uomini e delle
        donne. Quando si specifica un vincolo che identifica un sotto-campione,
        occorre premere il tasto Invio perché le statistiche campionarie siano
        calcolate.
      </para>

      <para>
	Il vincolo che definisce il sotto-campione deve essere indicato tra
        parentesi e in generale prende la forma "variabile operatore valore",
        dove "variabile" è il nome di una variabile nel dataset attuale,
        "valore" è un valore numerico e "operatore" è un operatore di confronto,
        da scegliere tra =, !=, &lt;, &gt;, &lt;= or &gt;= (rispettivamente uguale
        diverso, minore, maggiore, minore o uguale, maggiore o uguale). Gli
        spazi prima e dopo l'operatore sono opzionali.
      </para>

    </description>
  </command>
    
  <command name="hausman" section="Tests"
    label="Test di Hausman (diagnosi panel)">

    <description>
      <para>
        Questo test è disponibile solo dopo aver stimato un modello OLS
        <quote>pooled</quote> (si veda anche <cmd>setobs</cmd>). Testa il
        semplice modello pooled (con tutte le osservazioni considerate
        indistintamente) contro le principali alternative: il modello a effetti
        fissi e quello a effetti casuali.</para>

      <para>
	Il modello a effetti fissi aggiunge una variabile dummy per
        tutte le unità cross section tranne una, permettendo così
        all'intercetta della regressione di variare per ogni unità.
	Viene poi eseguito un test <mathvar>F</mathvar> per la
        significatività congiunta di queste dummy. Il modello a effetti
        casuali scompone la varianza dei residui in due parti: una
        specifica all'unità cross section e una specifica all'osservazione
        particolare (la stima può essere eseguita solo se il numero
        delle unità cross section nel dataset è maggiore del numero dei
        parametri da stimare). La statistica LM di Breusch&ndash;Pagan
	testa l'ipotesi nulla (che il modello pooled OLS sia adeguato)
        contro l'alternativa a effetti casuali.</para>

      <para>
	Può accadere che il modello pooled OLS sia rifiutato nei confronti
        di entrambe le alternative, a effetti fissi o casuali. A patto
        che gli errori specifici di unità o di gruppo siano non
        correlati con le variabili indipendenti, lo stimatore a effetti
        casuali è più efficiente dello stimatore a effetti fissi; nel
        caso contrario lo stimatore a effetti casuali non è consistente
	e deve essergli preferito lo stimatore a effetti fissi. L'ipotesi
        nulla per il test di Hausman è che l'errore specifico di gruppo non
        sia correlato con le variabili indipendenti (e quindi che il
        modello a effetti casuali sia preferibile). Un basso p-value per
        questo test suggerisce di rifiutare il modello a effetti casuali
        in favore del modello a effetti fissi.
      </para>
    </description>

    <gui-access>
      <menu-path>Finestra del modello, /Test/HAUSMAN - Diagnosi panel</menu-path>
    </gui-access>

  </command>

  <command name="hccm" section="Estimation" context="cli" label="Stima HCCM">

    <usage>
      <arguments>
        <argument>variabile-dipendente</argument>
        <argument>variabili-indipendenti</argument>
      </arguments>
      <options>
	<option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
        Matrice di covarianza coerente con l'eteroschedasticità (HCCM:
        Heteroskedasticity-Consistent Covariance Matrix); questo comando
        esegue una regressione dove i coefficienti sono stimati con la
        procedura OLS standard, ma gli errori standard delle stime dei
	coefficienti sono calcolati in modo da essere robusti rispetto
        all'eteroschedasticità, ossia usando la procedura <quote>jackknife</quote>
        di MacKinnon&ndash;White.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modello/HCCM</menu-path>
    </gui-access>

  </command>

  <command name="hccme" section="Estimation" context="gui"
    label="Errori standard robusti">

    <description>
      <para>
	Sono disponibili vari modi di calcolare gli errori standard
        robusti in presenza di eteroschedasticità (e, nel caso dello
        stimatore HAC, di autocorrelazione).
      </para>

      <para>HC0 produce gli <quote>errori standard originali di White</quote>;
        HC1, HC2, HC3 e HC3a sono varianti che si ritiene producano risultati
        migliori (più affidabili). Per i dettagli sugli stimatori, si veda
	MacKinnon e White (Journal of Econometrics, 1985) o
	Davidson e MacKinnon, Econometric Theory and Methods
	(Oxford, 2004). Le sigle usate sono quelle proposte da
	Davidson e MacKinnon. La variante <quote>HC3a</quote> è il
	<quote>jackknife</quote> descritto da MacKinnon e White (1985); HC3 è
        una sua vicina approssimazione.
      </para>

      <para>Se si usa lo stimatore HAC per serie storiche, è possibile calibrare
        la lunghezza dei ritardi usando il comando <cmd>set</cmd>. Si veda il
        manuale di gretl o i file di aiuto per i dettagli.</para>

      <para>Per i modelli GARCH sono disponibili due stimatori robusti della
        matrice di covarianza: QML è lo stimatore di quasi massima verosimiglianza,
        e BW è lo stimatore di Bollerslev-Wooldridge.
      </para>

    </description>

  </command>

  <command name="help" section="Utilities" context="cli">

    <description>
      <para>
	Mostra un elenco dei comandi disponibili, <cmd>help</cmd>
	<repl>comando</repl> descrive il <repl>comando</repl> (ad es.
	<cmd>help smpl</cmd>).  Al posto di <cmd>help</cmd> si può usare
	<cmd>man</cmd> se si preferisce.
      </para> 
    </description>

    <gui-access>
      <menu-path>/Aiuto</menu-path>
    </gui-access>

  </command>

  <command name="hilu" section="Estimation" label="Stima Hildreth-Lu">

    <usage>
      <arguments>
        <argument>variabile-dipendente</argument>
        <argument>variabili-indipendenti</argument>
      </arguments>
      <options>
	<option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
	</option>
        <option>
          <flag>--no-corc</flag>
          <effect>non affina i risultati con Cochrane-Orcutt</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>Calcola le stime dei parametri per il modello specificato
	usando la procedura di ricerca di Hildreth&ndash;Lu. I risultati sono
        ottimizzati con la procedura iterativa di Cochrane&ndash;Orcutt, a meno
        che non si usi l'opzione <lit>--no-corc</lit>.
      </para>
      <para>
        Questa procedura è progettata per correggere l'effetto
        della correlazione seriale nel termine di errore. Viene mostrato
        un grafico della somma dei quadrati degli errori per il modello
        trasformato rispetto ai valori di rho da &minus;0.99 a 0.99.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modello/Serie storiche/Hildreth-Lu</menu-path>
    </gui-access>

  </command>

  <command name="hsk" section="Estimation"
    label="Stime corrette per l'eteroschedasticità">

    <usage>
      <arguments>
        <argument>variabile-dipendente</argument>
        <argument>variabili-indipendenti</argument>
      </arguments>
      <options>
	<option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Stima una regressione OLS e ne salva i residui. I logaritmi
        dei quadrati di questi residui diventano la variabile dipendente
        di una regressione ausiliaria che ha come regressori le
        variabili indipendenti originali e i loro quadrati. I valori
        stimati dalla regressione ausiliaria sono quindi usati per
        costruire una serie di pesi, usati per ri-stimare il modello
        originale con la procedura dei minimi quadrati ponderati.
        Viene riportato il risultato finale.</para>

      <para>La serie dei pesi è composta da
	<equation status="inline"
	  tex="$1/\sqrt{e^{y^*}}$"
	  ascii="1/sqrt(exp(y*))"
	  graphic="hsk"/>, dove <mathvar>y<super>*</super></mathvar>
	denota i valori stimati dalla regressione ausiliaria.</para>
    </description>

    <gui-access>
      <menu-path>/Modello/WLS corretti per eteroschedasticità</menu-path>
    </gui-access>

  </command>

  <command name="hurst" section="Statistics"
    label="Esponente di Hurst">
  
    <usage>
      <arguments>
        <argument>nome-variabile</argument>
      </arguments>
    </usage>
  
    <description>
      <para>
       Calcolate l'esponente di Hurst (una misura di persistenza, o di memoria
       lunga) per una serie storica con almeno 128 osservazioni.
      </para>
  
      <para>
       L'esponente di Hurst è discusso da Mandelbrot. In termini teorici è
       l'esponente <mathvar>H</mathvar> nella relazione
       <equation status="display"
         tex="\[\mathrm{RS}(x) = an^H\]"
         ascii="RS(x) = an^H"
         graphic="hurst"/>dove RS è l'<quote>intervallo riscalato</quote>
         della variabile <mathvar>x</mathvar> in un campione dell'ampiezza
       <mathvar>n</mathvar>, mentre <mathvar>a</mathvar> è una
       costante. L'intervallo riscalato è l'intervallo (valore massimo
       meno valore minimo) del valore cumulato, o somma parziale, di
       <mathvar>x</mathvar> sul periodo del campione (dopo aver sottratto la
       media campionaria), diviso per la deviazione standard campionaria.
      </para>
  
      <para>
       Come punto di riferimento, se <mathvar>x</mathvar> è un rumore bianco
       (media zero, persistenza zero) l'intervallo dei suoi valori cumulati
       (che forma una passeggiata casuale), scalato per la deviazione standard,
       cresce come la radice quadrata dell'ampiezza campionaria, ossia ha un
       esponente di Hurst atteso pari a 0.5. Valori dell'esponente sensibilmente
       maggiori di 0.5 indicano persistenza della serie, mentre valori minori di
       0.5 indicano anti-persistenza (autocorrelazione negativa). In teoria
       l'esponente deve essere compreso tra 0 e 1, ma in campioni finiti è
       possibile ottenere delle stime per l'esponente maggiorni di 1.
      </para>

      <para>
       In gretl, l'esponente è stimato usando il sotto-campionamento binario:
       si inizia dall'intero intervallo dei dati, quindi si usano le due metà
       dell'intervallo, poi i quattro quarti, e così via. Il valore RS è la
       media presa sui vari campioni. L'esponente è quindi stimato come il
       coefficiente di pendenza della regressione del logaritmo di RS sul
       logaritmo dell'ampiezza del campione.
      </para>

    </description>

    <gui-access>
      <menu-path>/Variable/Esponente di Hurst</menu-path>
    </gui-access>

  </command>


  <command name="if" section="Programming" context="cli">

    <description>
      <para>Controllo di flusso per l'esecuzione dei comandi. La sintassi è:</para>

      <pre>
	<lit>if</lit> <repl>condizione</repl>&par;
	<lit>  </lit> <repl>comandi1</repl>&par;
	<lit>else</lit>&par;
	<lit>  </lit> <repl>comandi2</repl>&par;
	<lit>endif</lit>
      </pre>      

      <para>La <repl quote="true">condizione</repl> deve essere un'espressione
      Booleana, per la cui sintassi si veda <cmdref targ="genr"/>.
      Il blocco <cmd>else</cmd> è opzionale; i blocchi <lit>if</lit> &hellip;
	<lit>endif</lit> possono essere nidificati.</para>
    </description>

  </command>

  <command name="import" section="Dataset" context="cli">

    <usage>
      <arguments>
        <argument>nomefile</argument>
      </arguments>
      <options>
        <option>
	  <flag>--octave</flag>
	  <effect>dati GNU octave</effect>
        </option>
        <option>
	  <flag>--box1</flag>
	  <effect>dati BOX1</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
        Se non si specifica alcuna opzione, importa dati da un file in formato
        valori separati da virgole (CSV: comma-separated values), che può essere
        facilmente prodotto da un foglio elettronico. Il file deve contenere i
        nomi delle variabili sulla prima riga e una matrice rettangolare di dati
        nelle righe rimanenti. Le variabili devono essere disposte <quote>per
          osservazione</quote> (una colonna per variabile, ogni riga rappresenta
        un'osservazione).  Si veda la <guideref targ="datafiles"/> per i
        dettagli.
      </para>
      <para>
	Con l'opzione <lit>--octave</lit> viene letto un file nel formato di
        GNU octave.
      </para>

      <para>
	Con l'opzione <lit>--box1</lit> viene letto un file in formato
        BOX1, che un tempo poteva essere ottenuto usando il Servizio di Estrazione
        Dati del Bureau of the Census degli USA.
      </para>
    </description>

    <gui-access>
      <menu-path>/File/Apri dati/importa</menu-path>
    </gui-access>

  </command>

  <command name="include" section="Programming" context="cli">

    <usage>
      <arguments>
        <argument>file</argument>
      </arguments>
    </usage>

    <description>
      <para>
        Da usare in uno script di comandi, principalmente per includere
        definizioni di funzioni. Esegue i comandi nel <repl>file</repl>
        e ripassa il controllo allo script principale.
      </para>
    </description>

  </command>


  <command name="info" section="Dataset" context="cli">

    <description>
      <para>
	Mostra le informazioni aggiuntive contenute nel file di dati
        attuale.
      </para>
    </description>

    <gui-access>
      <menu-path>/Dati/Visualizza descrizione</menu-path>
      <other-access>Finestre di esplorazione dei dati</other-access>
    </gui-access>

  </command>

  <command name="irfboot" section="Graphs" context="gui"
    label="Bootstrap impulso-risposta">

    <description>
      <para>Se si sceglie l'intervallo di confidenza bootstrap nella
      visualizzazione delle funzioni di impulso-risposta, gretl calcola un
      intervallo di confidenza al 95 per cento per le risposte usando il metodo
      bootstrap. Si effettua un campionamento (con reimmissione) dai residui del
      VAR (o VECM) originale, viene costruito un dataset artificiale usando le
      stime originali dei parametri e i residui ri-campionati, viene ri-stimato
      il sistema e vengono ri-calcolate le funzioni di impulso-risposta.  Questa
      procedura viene ripetuta 999 volte e vengono mostrati i quantili 0.025 e
      0.975 per le risposte, insieme alle stime puntuali.
      </para>

    </description>

  </command>


  <command name="kpss" section="Tests" label="Test KPSS">

    <usage>
      <arguments>
        <argument>ordine</argument>
        <argument>nome-variabile</argument>
      </arguments>
      <options>
	<option>
	  <flag>--trend</flag>
	  <effect>include un trend</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>mostra i risultati della regressione</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>non mostra i risultati</effect>
	</option>
      </options>
      <examples>
	<example>kpss 8 y</example>
        <example>kpss 4 x1 --trend</example>
      </examples>
    </usage>

    <description>
      <para context="gui">
	Calcola il test KPSS (Kwiatkowski, Phillips, Schmidt e
	Shin, 1992) per la stazionarietà di una variabile. L'ipotesi
        nulla è che la variabile in questione sia stazionaria, attorno
        a un valore fisso o, se è stata selezionata l'opzione <lit>includi un trend</lit>,
        attorno a un trend deterministico lineare.
      </para>
      <para context="cli">
	Calcola il test KPSS (Kwiatkowski, Phillips, Schmidt e
	Shin, 1992) per la stazionarietà di una variabile. L'ipotesi
        nulla è che la variabile in questione sia stazionaria, attorno
        a un valore fisso o, se è stata usata l'opzione <lit>--trend</lit>,
        attorno a un trend deterministico lineare.
      </para>
      <para context="gui">
	L'argomento ordine determina la dimensione della finestra usata per
        il livellamento di Bartlett.  Se si usa l'opzione <lit>Mostra i risultati
        della regressione</lit>, vengono mostrati anche i risultati della
        regressione ausiliaria, insieme alla varianza stimata della componente
        random walk della variabile.
      </para>
      <para context="cli">
	L'argomento ordine determina la dimensione della finestra usata per
        il livellamento di Bartlett.  Se si usa l'opzione <lit>--verbose</lit>,
        vengono mostrati anche i risultati della regressione ausiliaria, insieme
        alla varianza stimata della componente random walk della variabile.
      </para>

    </description>

    <gui-access>
      <menu-path>/Variabile/Test KPSS</menu-path>
    </gui-access>

  </command>
  <command name="labels" section="Dataset" context="cli">

    <description>
      <para>
	Mostra le etichette informative per le variabili generate con il comando
        <cmd>genr</cmd> e quelle aggiunte al dataset attraverso
        l'interfaccia grafica.
      </para>
    </description>

  </command>

  <command name="lad" section="Estimation"
    label="Stima con minime deviazioni assolute">

    <usage>
      <arguments>
        <argument>variabile-dipendente</argument>
        <argument>variabili-indipendenti</argument>
      </arguments>
      <options>
        <option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Calcola una regressione che minimizza la somma delle deviazioni
        assolute dei valori stimati dai valori effettivi della variabile
        dipendente. Le stime dei coefficienti sono derivate usando
        l'algoritmo del simplesso di Barrodale&ndash;Roberts; viene
        mostrato un messaggio di avvertimento se la soluzione non è
        unica.
      </para>
      <para>
	Gli errori standard sono derivati usando la procedura bootstrap
        con 500 estrazioni. La matrice di covarianza per le stime dei
        parametri, mostrata se si usa l'opzione <lit>--vcv</lit>, si basa
        sulla stessa procedura.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modello/LAD - Minime deviazioni assolute</menu-path>
    </gui-access>

  </command>

  <command name="lags" section="Transformations" context="cli">

    <usage>
      <altforms>
        <altform><lit>lags</lit> <repl>lista-variabili</repl></altform>
       <altform><lit>lags</lit> <repl>ordine</repl> <lit>;</lit> <repl>lista-variabili</repl></altform>
      </altforms>
      <examples>
       <example>lags x y</example>
       <example>lags 12 ; x y</example>
      </examples>
    </usage>

    <description>
      <para>
	Crea delle nuove variabili come valori ritardati di ognuna delle
	variabili nella <repl>lista-variabili</repl>. Il numero dei ritardi può
        essere indicato dal primo parametro opzionale, altrimenti sarà pari
        alla periodicità del dataset.  Ad esempio, se la periodicità è 4
        (trimestrale), il comando <cmd>lags x y</cmd> crea
      </para>
      <code>
       x_1 = x(t-1)
       x_2 = x(t-2)
       x_3 = x(t-3)
       x_4 = x(t-4)</code>
      <para>
        Il numero dei ritardi creati può essere indicato come primo parametro
        opzionale.
      </para>
    </description>

    <gui-access>
      <menu-path>/Dati/Aggiungi variabili/Ritardi delle variabili selezionate</menu-path>
    </gui-access>

  </command>

  <command name="lags-dialog" section="Estimation" context="gui"
    label="Finestra di selezione dei ritardi">

    <description>
      <para>
	In questa finestra di dialogo è possibile selezionare l'ordine dei
        ritardi per le variabili indipendenti in un modello di serie storiche, e
        in alcuni casi anche per la variabile dipendente (ma si noti che
        l'ordine di ritardi comune per modelli vettoriali come i VAR e i VECM è
        gestito separatamente attraverso un selettore nella finestra di dialogo
        principale del modello).
      </para>

      <para>
	I selettori sulla sinistra permettono di selezionare un intervallo di
        ritardi consecutivi per ogni variabile. Per specificare ritardi non
        consecutivi, occorre selezionare la casella vicino al campo intitolato
	<quote>ritardi specifici</quote>. In questo modo si attiva il campo,
        all'interno del quale è possibile inserire una lista di ritardi separati
        da spazi.
      </para>

      <para>
        La riga denominata <quote>predefinito</quote> offre un modo veloce per
        impostare una specificazione di ritardi comune a tutte le variabili
        indipendenti: i valori inseriti in questa riga vengono copiati in tutte
        le righe successive (tranne quella della variabile dipendente, se
        esiste).
      </para>

      <para>
        La variabile dipendente è trattata in modo speciale: il ritardo di
        ordine zero indica che la variabile apparirà nel modello a sinistra del
        segno uguale, mentre ulteriori ordini di ritardo saranno aggiunti a
        destra dell'uguale, insieme alle variabili indipendenti.
      </para>

      <para>
	I valori selezionati in questa finestra di dialogo vengono ricordati per
        l'intera durata della sessione di lavoro con un certo dataset.
      </para>

    </description>

  </command>

  <command name="ldiff" section="Transformations" context="cli">

    <usage>
      <arguments>
        <argument>lista-variabili</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Calcola la differenza prima del logaritmo naturale di ogni
        variabile della <repl>lista-variabili</repl> e la salva in una
        nuova variabile con il prefisso <lit>ld_</lit>.  Così, <cmd>ldiff
	x y</cmd> crea le nuove variabili 
      </para>
      <code>
	ld_x = log(x) - log(x(-1))
	ld_y = log(y) - log(y(-1))
      </code>
    </description>

    <gui-access>
      <menu-path>/Dati/Aggiungi variabili/Differenze logaritmiche</menu-path>
    </gui-access>

  </command>

  <command name="leverage" section="Tests"
    label="Test per le osservazioni influenti">

    <usage>
      <options>
        <option>
	  <flag>--save</flag>
	  <effect>salva le variabili</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
	Deve seguire immediatamente un comando <cmd>ols</cmd>. Calcola
        il <quote>leverage</quote> (<mathvar>h</mathvar>, compreso tra 0
        e 1) di ogni osservazione nel campione su cui è stato stimato il
        precedente modello. Mostra il residuo (<mathvar>u</mathvar>) per
        ogni osservazione assieme al leverage corrispondente e a una
        misura della sua influenza sulla stima:
	  <equation status="inline" 
	  tex="$uh/(1 - h)$"
	  ascii="u*h/(1-h)"
	  graphic="influence"/>. I <quote>punti di leverage</quote> per
        cui il valore di <mathvar>h</mathvar> supera
	2<mathvar>k</mathvar>/<mathvar>n</mathvar> (dove
	<mathvar>k</mathvar> è il numero dei parametri stimati e
        <mathvar>n</mathvar> è l'ampiezza del campione) sono indicati
        con un asterisco. Per i dettagli sui concetti di leverage e
        influenza, si veda Davidson e MacKinnon (1993, capitolo 2).
      </para>

      <para>
	Vengono mostrati anche i valori DFFITS: questi sono
        <quote>residui studentizzati</quote> (ossia i residui previsti,
        divisi per i propri errori standard) moltiplicati per
	  <equation status="inline" 
	  tex="$\sqrt{h/(1 - h)}$"
	  ascii="sqrt[h/(1 - h)]"
	  graphic="dffit"/>. Per una discussione dei residui
          studentizzati e dei valori DFFITS si veda G. S. Maddala,
        <book>Introduction to Econometrics</book>, capitolo 12 e anche
        Belsley, Kuh e Welsch (1980).
        </para>
        <para>
        In breve, i <quote>residui previsti</quote>
	sono la differenza tra il valore osservato e il valore stimato 
        della variabile dipendente all'osservazione
        <mathvar>t</mathvar>, ottenuti da una regressione in cui
        quell'osservazione è stata omessa (oppure in cui è stata
        aggiunta una variabile dummy che vale 1 solo per l'osservazione
	<mathvar>t</mathvar>); il residuo studentizzato si ottiene
        dividendo il residuo previsto per il proprio errore standard.
      </para>

      <para context="cli">Se si usa l'opzione <lit>--save</lit>, il
      leverage, il valore di influenza e il valore DFFITS vengono aggiunti
      al dataset in uso.</para>

      <para context="gui">
	L'icona "+" in cima alla finestra del test di leverage apre una
        finestra di dialogo che permette di salvare nel dataset in uso
        una o più delle variabili del test.</para>

    </description>

    <gui-access>
      <menu-path>Finestra del modello, /Test/LEVERAGE - Osservazioni influenti</menu-path>
    </gui-access>

  </command>

  <command name="lmtest" section="Tests" label="Test LM">

    <usage>
      <options>
        <option>
	  <flag>--logs</flag>
	  <effect>non-linearità, logaritmi</effect>
        </option>
        <option>
	  <flag>--autocorr</flag>
	  <effect>correlazione seriale</effect>
        </option>
        <option>
	  <flag>--squares</flag>
	  <effect>non-linearità, quadrati</effect>
        </option>
        <option>
	  <flag>--white</flag>
	  <effect>eteroschedasticità (test di White)</effect>
        </option>
      </options>
    </usage>

    <description context="gui">
      <para>
	Questo comando racchiude vari test di ipotesi. La caratteristica
        comune è che tutti i test prevedono la stima di una regressione
        ausiliaria in cui la variabile dipendente è il residuo di una
        regressione <quote>originale</quote>. Le variabili indipendenti
        della regressione ausiliaria comprendono quelle della
        regressione originale e alcuni termini aggiuntivi. La statistica
        test è calcolata come (ampiezza campionaria * R-quadro) della 
        regressione ausiliaria: si distribuisce come chi-quadro con
        gradi di libertà pari al numero dei termini aggiuntivi, sotto
        l'ipotesi nulla che essi non abbiano potere esplicativo sui
        residui. Un valore <quote>elevato</quote> del chi-quadro (ossia
        un basso p-value) suggerisce di rifiutare questa ipotesi nulla.
      </para>
    </description>

    <description context="cli">
      <para>
	Deve seguire immediatamente un comando <cmd>ols</cmd>. A seconda delle
        opzioni usate, il comando esegue una combinazione dei test seguenti:
        test dei moltiplicatori di Lagrange per la non-linearità (logaritmi e
        quadrati), test di White per l'eteroschedasticità e test LMF per la
        correlazione seriale di ordine pari alla periodicità (si veda Kiviet,
        1986), mostrando anche i coefficienti delle corrispondenti regressioni
        ausiliarie. Si veda Ramanathan, capitoli 7, 8 e 9 per i dettagli.
      </para>
    </description>

    <gui-access>
      <menu-path>Finestra del modello, /Test</menu-path>
    </gui-access>

  </command>

  <command name="logistic" section="Estimation"
    label="Stima logistica">

    <usage>
      <arguments>
        <argument>variabile-dipendente</argument>
        <argument>variabili-indipendenti</argument>
	<argument optional="true" flag="ymax=">valore</argument>
      </arguments>
      <options>
	<option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
	</option>
      </options>
      <examples>
        <example>logistic y const x</example>
        <example>logistic y const x ymax=50</example>
      </examples>
    </usage>

    <description>
      <para>
	Regressione logistica: esegue una regressione OLS usando la
        trasformazione logistica sulla variabile dipendente:
	<equation status="display" 
	  tex="\[\log\left(\frac{y}{y^*-y}\right)\]"
	  ascii="log(y/(y* - y))"
	  graphic="logistic1"/>
      </para>

      <para context="cli">La variabile dipendente dev'essere
        strettamente positiva. Se è una frazione decimale, compresa tra
        0 e 1, il valore predefinito per <mathvar>y<super>*</super></mathvar>
        (il massimo asintotico della variabile dipendente) è 1.
        Se la variabile dipendente è una percentuale, compresa tra 0 e
        100, il valore predefinito di <mathvar>y<super>*</super></mathvar>
        è 100.
      </para>
        
      <para context="cli">
        È possibile indicare un valore diverso per il massimo,
        usando la sintassi opzionale <lit>ymax=</lit><repl>valore</repl>,
        che segue la lista dei regressori. Il valore fornito deve essere
        maggiore di tutti i valori osservati della variabile dipendente.
      </para>
        
      <para context="gui">
        Nella finestra di dialogo del comando, è possibile specificare
        un valore diverso per il massimo. Il valore fornito
        <mathvar>y<super>*</super></mathvar> deve essere
        maggiore di tutti i valori osservati della variabile dipendente.
      </para>

      <para>I valori stimati e i residui della regressione sono
        trasformati automaticamente usando 	  
	<equation status="display" 
	  tex="\[y=\frac{y^*}{1+e^{-x}}\]"
	  ascii="y = y* / (1 + exp(-x))"
	  graphic="logistic2"/> dove <mathvar>x</mathvar> rappresenta
	un valore stimato oppure un residuo della regressione OLS,
        usando la variabile dipendente trasformata. I valori riportati
        sono dunque confrontabili con la variabile dipendente originale.
	</para>

      <para>Si noti che se la variabile dipendente è binaria, occorre
        usare il comando <cmdref targ="logit"/> invece di questo comando.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modello/Logistico</menu-path>
    </gui-access>

  </command>

  <command name="logit" section="Estimation"
    label="Stima logit">

    <usage>
      <arguments>
        <argument>variabile-dipendente</argument>
        <argument>variabili-indipendenti</argument>
      </arguments>
      <options>
	<option>
	  <flag>--robust</flag>
	  <effect>errori standard robusti</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
        Regressione binomiale logit. La variabile dipendente deve essere
        binaria. Le stime di massima verosimiglianza dei coefficienti
        per le <repl>variabili-indipendenti</repl> sono ottenute con il
        metodo BRMR (<quote>binary response model regression</quote>) descritto
        in Davidson e MacKinnon (2004). Visto che il modello è nonlineare, le pendenze
        dipendono dai valori delle variabili indipendenti: le pendenze
        riportate sono valutate nelle medie di queste variabili. La
        statistica chi-quadro testa l'ipotesi nulla che tutti i
        coefficienti tranne la costante siano pari a zero.
      </para>
      <para context="cli">
        In modalità predefinita, gli errori standard sono calcolati con
        l'inversa negativa dell'Hessiana.  Se si usa l'opzione
        <lit>--robust</lit>, verranno calcolati gli errori standard QML o quelli
        di Huber&ndash;White. In questo caso, la matrice di covarianza stimata è
        un <quote>sandwich</quote> dell'inversa dell'Hessiana stimata e del
        prodotto esterno del gradiente. Per i dettagli, si veda Davidson e
        MacKinnon 2004, cap. 10.
      </para>
      <para context="gui">
        In modalità predefinita, gli errori standard sono calcolati con
        l'inversa negativa dell'Hessiana.  Se si seleziona la casella "Errori
        standard robusti", verranno calcolati gli errori standard QML o quelli
        di Huber&ndash;White. In questo caso, la matrice di covarianza stimata è
        un <quote>sandwich</quote> dell'inversa dell'Hessiana stimata e del
        prodotto esterno del gradiente. Per i dettagli, si veda Davidson e
        MacKinnon 2004, cap. 10.
      </para>
      <para>
	Per condurre un'analisi delle proporzioni (dove la variabile
	dipendente è la proporzione dei casi che hanno una certa
        caratteristica in ogni osservazione, invece che una variabile
        binaria che indica se la caratteristica è presente o no), non
        bisogna usare il comando <cmd>logit</cmd>, ma occorre costruire
        la variabile logit come
      </para>
      <code>
	genr lgt_p = log(p/(1 - p))
      </code>
      <para>
        e usare questa come variabile dipendente in una regressione OLS.
        Si veda Ramanathan, capitolo 12.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modello/Logit</menu-path>
    </gui-access>

  </command>

  <command name="logs" section="Transformations" context="cli">

    <usage>
      <arguments>
        <argument>lista-variabili</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Calcola il logaritmo naturale di ognuna delle variabili
        della <repl>lista-variabili</repl> e lo salva in una nuova
        variabile col prefisso <lit>l_</lit>, ossia una
        <quote>elle</quote> seguita da un trattino basso.
        <cmd>logs x y</cmd> crea le nuove variabili <lit>l_x</lit> =
        ln(<lit>x</lit>) e <lit>l_y</lit> = ln(<lit>y</lit>).
      </para>
    </description>

    <gui-access>
      <menu-path>/Dati/Aggiungi variabili/Logaritmi delle variabili selezionate</menu-path>
    </gui-access>

  </command>

  <command name="loop" section="Programming" context="cli">

    <usage>
      <arguments>
        <argument>controllo</argument>
      </arguments>
      <options>
	<option>
	  <flag>--progressive</flag>
	  <effect>abilita modalità speciali di alcuni comandi</effect>
	</option>
        <option>
          <flag>--verbose</flag>
          <effect>mostra i dettagli dei comandi genr</effect>
        </option>
        <option>
          <flag>--quiet</flag>
          <effect>non mostra il numero di iterazioni eseguite</effect>
        </option>
      </options>
      <examples>
        <example>loop 1000</example>
	<example>loop 1000 --progressive</example>
        <example>loop while essdiff > .00001</example>
        <example>loop for i=1991..2000</example>
        <example>loop for (r=-.99; r&lt;=.99; r+=.01)</example>
      </examples>
    </usage>

    <description>
      <para>Il parametro <repl quote="true">controllo</repl> deve
        assumere uno dei quattro valori mostrati negli esempi: un numero di
        volte per cui ripetere i comandi all'interno del loop, oppure
	<quote><lit>while</lit></quote> seguito da una condizione
        numerica, oppure <quote><lit>for</lit></quote> seguito da un
        intervallo di valori per la variabile interna <lit>i</lit> che
        funge da indice, o ancora <quote><lit>for</lit></quote> seguito
        da tre espressioni tra parentesi separate da punti e virgola.
        Nell'ultima forma, l'espressione a sinistra inizializza una
        variabile, quella centrale imposta la condizione perché l'iterazione
        continui, e l'ultima espressione imposta un incremento o un decremento
        da applicare all'inizio della seconda iterazione e di quelle successive
 	(si tratta di una forma ristretta dell'istruzione <lit>for</lit> nel
        linguaggio di programmazione C).
      </para>

      <para>Questo comando apre una modalità speciale, in cui il
        programma accetta comandi da eseguire più volte. All'interno di
        un loop possono essere usati solo alcuni tipi di comandi:
        <cmd>genr</cmd>, <cmd>ols</cmd>, <cmd>print</cmd>, <cmd>printf</cmd>
        <cmd>pvalue</cmd>, <cmd>sim</cmd>, <cmd>smpl</cmd>, <cmd>store</cmd> e
        <cmd>summary</cmd>, <cmd>if</cmd>, <cmd>else</cmd> e <cmd>endif</cmd>.
        Si esce dalla modalità loop con l'istruzione <cmd>endloop</cmd>: solo a
        questo punto i comandi indicati vengono eseguiti.
      </para>

      <para>Si veda la <guideref targ="looping"/> per ulteriori dettagli,
      esempi e per la spiegazione dell'opzione <lit>--progressive</lit> (che è destinata
      ad essere usata nelle simulazioni Monte Carlo).</para>
    </description>

  </command>
  
  <command name="mahal" section="Statistics"
    label="Distanze di Mahalanobis">

    <usage>
      <arguments>
        <argument>lista-variabili</argument>
      </arguments>
      <options>
       <option>
         <flag>--save</flag>
         <effect>salva le distanze nel dataset</effect>
       </option>
       <option>
         <flag>--vcv</flag>
         <effect>mostra la matrice di covarianza</effect>
       </option>
      </options>
    </usage>

    <description>
      <para>
       La distanza di Mahalanobis è la distanza tra due punti in uno spazio
       <mathvar>k</mathvar>-dimensionale, scalata rispetto alla variazione
       statistica in ogni dimensione dello spazio. Ad esempio, se
       <mathvar>p</mathvar> e <mathvar>q</mathvar> sono due osservazioni su
       un insieme di <mathvar>k</mathvar> variabili con matrice di covarianza
       <mathvar>C</mathvar>, la distanza di Mahalanobis tra le due osservazioni
       è data da
       <equation status="display"
        tex="\[\sqrt{(p-q)^{\prime}C^{-1}(p-q)}\]"
        ascii="sqrt((p - q)' * C-inversa * (p - q))"
          graphic="mahal"/> dove
       <equation status="inline" tex="$(p-q)$" ascii="(p - q)" graphic="mahal2"/> è un
       vettore a <mathvar>k</mathvar> dimensioni. Se la matrice di covarianza è
       la matrice identità, la distanza di Mahalanobis corrisponde alla distanza
       Euclidea.
      </para>

      <para>Lo spazio in cui vengono calcolate le distanze è definito dalle
      variabili selezionate; per ogni osservazione nell'intervallo attuale
      viene calcolata la distanza tra l'osservazione e il centroide delle
      variabili selezionate. La distanza è la controparte multidimensionale di uno
      <mathvar>z</mathvar>-score standard e può essere usata per giudicare se una certa
      osservazione <quote>appartiene</quote> a un gruppo di altre osservazioni.
      </para>

      <para context="cli">Se si usa l'opzione <lit>--vcv</lit>, vengono mostrate
      la matrice di covarianza e la sua inversa. Se si usa l'opzione
      <lit>--save</lit>, le distanze vengono salvate nel dataset con il nome
      <lit>mdist</lit> (o <lit>mdist1</lit>, <lit>mdist2</lit> e così via, se
      esiste già una variabile con quel nome).
      </para>

      <para context="gui">Se il numero delle variabili selezionate è minore o
       uguale a 4, vengono mostrate la matrice di covarianza e la sua inversa.
       Facendo clic sul pulsante "+" in cima alla finestra che mostra le
       distanze è possibile aggiungerle al dataset come nuova variabile.
      </para>

    </description>

    <gui-access>
      <menu-path>/Dati/Distanze di Mahalanobis</menu-path>
    </gui-access>

  </command>

  <command name="markers" section="Dataset" context="gui"
    label="Aggiunta di marcatori">

    <description>
      <para>
	Questo comando richiede il nome di un file che contiene
        <quote>marcatori</quote> per le osservazioni, ossia brevi stringhe
        identificative per singole osservazioni del dataset (ad esempio
        nomi di paesi o città, o altri codici), che possono essere
        lunghe fino a 8 caratteri. Il file deve contenere un marcatore
        per riga e devono esserci tanti marcatori quante sono le
        osservazioni nel dataset corrente. Se queste condizioni sono
        rispettate e se il file specificato esiste, i marcatori verranno
        aggiunti al dataset e saranno visibili scegliendo <quote>Mostra valori</quote>
        dal menù Dati di gretl.</para>
    </description>
  </command>
 
  <command name="matrix" section="Programming" context="cli">

    <description>
      <para>
	La parola chiave <lit>matrix</lit> deve precedere tutti i comandi che
        creano, manipolano o mostrano matrici. Si veda il
	<guideref targ="chap-matrices"/> per i dettagli.
      </para>
    </description>

  </command>

  <command name="meantest" section="Tests"
    label="Test per la differenza delle medie">

    <usage>
      <arguments>
        <argument>var1</argument>
        <argument>var2</argument>
      </arguments>
      <options>
        <option>
	  <flag>--unequal-vars</flag>
	  <effect>assume varianze diverse</effect>
        </option>
      </options>
    </usage>

    <description>
      <para context="cli">
	Calcola la statistica <mathvar>t</mathvar> per l'ipotesi
	nulla che le medie della popolazione siano uguali per le
        variabili <repl>var1</repl> e <repl>var2</repl>, mostrando il
        suo p-value.
      </para>
      <para>
        L'impostazione predefinita prevede di assumere che
        le varianze delle due variabili siano uguali, mentre usando
        l'opzione <lit>--unequal-vars</lit>, si assume che esse siano
        diverse. Questo è rilevante per la statistica test solo se le
        due variabili contengono un diverso numero di osservazioni
        valide (non mancanti).
      </para>
      <para context="gui">
        Calcola la statistica t per l'ipotesi nulla che le medie della
        popolazione siano uguali per due variabili selezionate,
        mostrando il suo p-value. Il comando può essere eseguito con o
        senza l'ipotesi che le varianze delle due variabili siano uguali
        (anche se questo è rilevante per la statistica test solo se le
        due variabili contengono un diverso numero di osservazioni
        valide).</para>
    </description>

    <gui-access>
      <menu-path>/Dati/Differenza delle medie</menu-path>
    </gui-access>

  </command>

  <command name="missing" section="Dataset" context="gui"
    label="Valori dati mancanti">

    <description>
      <para>Imposta un valore numerico che sarà interpretato come
	<quote>mancante</quote> o <quote>non disponibile</quote>, per
        una serie particolare (nel menù Variabile) o globalmente per
        l'intero dataset (nel menù Campione).</para> 

      <para>Gretl ha un codice interno per i valori mancanti, che non
      sempre può coincidere con quello usato dai dati importati. Ad
      esempio, se una serie usa il valore -1 col significato di
      <quote>non disponibile</quote>, è possibile selezionare
      <quote>Imposta codice valori mancanti</quote> nel menù
      Variabile e immettere il valore <quote>-1</quote> (senza le
      virgolette); gretl interpreterà quindi i valori -1 come osservazioni
      mancanti.</para>
    </description>
  </command>

  <command name="mle" section="Estimation"
    label="Stima di massima verosimiglianza">

    <usage>
      <arguments>
        <argument>funzione di log-verosimiglianza</argument>
        <argument>derivate</argument>
      </arguments>
      <options>
	<option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>mostra i dettagli delle iterazioni</effect>
	</option>
      </options>
    </usage>

    <description context="gui">

      <para>Esegue la stima di massima verosimiglianza (ML, Maximum
        Likelihood) usando l'algoritmo BFGS (Broyden, Fletcher, Goldfarb, Shanno).
        Occorre specificare la funzione di log-verosimiglianza, e se possibile è
        consigliabile indicare anche espressioni per le derivate di questa
        funzione, rispetto ad ognuno dei parametri.
      </para>

      <para>
        Esempio: si supponga di avere una serie <lit>X</lit> con valori 0 o 1 e di
        voler ottenere la stima di massima verosimiglianza della probabilità <lit>p</lit> 
        che <lit>X</lit> valga 1 (è semplice intuire che la stima ML di <lit>p</lit>
        corrisponderà alla proporzione dei valori 1 nel campione).
      </para>

      <para>Occorre per prima cosa aggiungere <lit>p</lit> al dataset e assegnargli un
        valore iniziale, attraverso il comando genr o i comandi del menù.
	È possibile scrivere delle istruzioni <quote>genr</quote> appropriate
        nella finestra di specificazione del comando di stima, prima di indicare
        la specificazione della funzione di log-verosimiglianza.
      </para>

      <para>Si scrivano i seguenti comandi nella finestra del comando:</para>

      <code>
	loglik = X*log(p) + (1-X)*log(1-p)
	deriv p = X/p - (1-X)/(1-p)
      </code>

      <para>
	La prima riga specifica la funzione di log-verosimiglianza, mentre
        la seconda indica la derivata della funzione rispetto a p. Se non si
        indicanto righe "deriv", viene calcolata un'approssimazione numerica
        delle derivate.
      </para>

      <para>
	Se non si era dichiarato in precedenza il parametro p, sarebbe stato
        necessario premettere alle righe precedenti la riga:
      </para>

      <code>
	genr p = 0.5
      </code>

    </description>

    <description context="cli">

      <para>Esegue la stima di massima verosimiglianza (ML, Maximum
        Likelihood) usando l'algoritmo BFGS (Broyden, Fletcher, Goldfarb, Shanno).
        Occorre specificare la funzione di log-verosimiglianza e indicare dei
        valori iniziali per i parametri della funzione (utilizzando il comando
        <cmd>genr</cmd>.  Se possibile è consigliabile indicare anche
        espressioni per le derivate di questa funzione, rispetto ad ognuno dei
        parametri; se non si indicano le derivate analitiche, verrà calcolata
        un'approssimazione numerica.
      </para>

      <para>
        Esempio: si supponga di avere una serie <lit>X</lit> con valori 0 o 1 e di
        voler ottenere la stima di massima verosimiglianza della probabilità <lit>p</lit> 
        che <lit>X</lit> valga 1 (è semplice intuire che la stima ML di <lit>p</lit>
        corrisponderà alla proporzione dei valori 1 nel campione).
      </para>

      <para>Occorre per prima cosa aggiungere <lit>p</lit> al dataset e assegnargli un
        valore iniziale; è possibile farlo nel modo seguente con il comando genr:
      <lit>genr p = 0.5</lit>.
	</para>

      <para>Quindi costruiamo il blocco di comandi per la stima di massima
      verosimiglianza:</para>

      <code>
       mle loglik = X*log(p) + (1-X)*log(1-p)
       deriv p = X/p - (1-X)/(1-p)
       end mle
      </code>

      <para>
        La prima riga specifica la funzione di log-verosimiglianza: inizia con
        la parola chiave <lit>mle</lit>, quindi contiene la variabile
        dipendente e una specificazione per la log-verosimiglianza usando la
        stessa sintassi del comando <cmd>genr</cmd>. La riga seguente (che è
        opzionale), inizia con la parola chiave <lit>deriv</lit> e fornisce
        la derivata della funzione di log-verosimiglianza rispetto al parametro
        <lit>p</lit>. Se non vengono indicate derivate, occorre includere una
        dichiarazione che identifica i parametri liberi (separati da spazi)
        utilizzando la parola chiave <lit>params</lit>. Ad esempio si
        sarebbe potuto scrivere:
      </para>
      <code>
       mle loglik = X*log(p) + (1-X)*log(1-p)
       params p
       end mle
      </code>
      <para>
       e in questo caso la derivata verrebbe calcolata numericamente.
      </para>
      <para>
       Eventuali opzioni <lit>--vcv</lit> o <lit>--verbose</lit> vanno indicate
       nella riga finale del blocco MLE.
      </para>

    </description>

    <gui-access>
      <menu-path>/Modello/Massima verosimiglianza</menu-path>
    </gui-access>

  </command>

  <command name="modeltab" section="Utilities"
    label="Tabella modelli">

    <usage>
      <arguments>
        <argument>add</argument>
        <argument alternate="true">show</argument>
        <argument alternate="true">free</argument>
      </arguments>
    </usage>

    <description context="gui"> 
      <para>
	Nella ricerca econometrica si è soliti stimare vari modelli con una
        variabile dipendente comune, che differiscono tra loro per le variabili
        indipendenti o per lo stimatore usato.  In questa situazione è comodo
        poter rappresentare i risultati delle regressioni sotto forma di una
        tabella dove ogni colonna contiene i risultati (stime dei coefficienti
        e errori standard) per un dato modello e ogni riga contiene le stime
        per una certa variabile nei differenti modelli.</para>

      <para>Gretl dà la possibilità di costruire una tabella simile (e
      di esportarla in testo semplice, &latex; o RTF - Rich Text Format).
      Ecco come fare:</para>

      <nlist>
	<li><para>1. Stimare un modello che si vuole includere nella
            tabella e selezionare, nel menù File della finestra di
            visualizzazione del modello, <quote>Salva alla sessione come
            icona</quote> o <quote>Salva come icona e chiudi</quote>.</para>
	</li>

	<li><para>2. Ripetere il punto 1 per gli alri modelli da
        includere nella tabella (fino a un massimo di sei modelli).</para>
	</li>

	<li><para>3. Completata la stima dei modelli, aprire l'icona
        della sessione di gretl (selezionando <quote>Visualizza Icone</quote>
        nel menù Sessione della finestra principale di gretl, o facendo
        clic su <quote>Icone di sessione</quote> sulla barra degli
        strumenti di gretl).</para>
	</li>

        <li><para>4. La finestra delle icone di sessione contiene
        un'icona chiamata <quote>Tabella Modelli</quote>. Per aggiungere
        alla tabella modelli il modello che deve apparire nella colonna
        più a sinistra della tabella, basta trascinare l'icona del
        modello sull'icona della Tabella Modelli, oppure fare clic col
        tasto destro sull'icona del modello e selezionare
        <quote>Aggiungi alla tabella modelli</quote> dal menù
        pop-up.</para>
	</li>

	<li><para>5. Ripetere il punto 4 per gli altri modelli da
        aggiungere alla tabella. Il secondo modello scelto apparirà
        nella seconda colonna da sinistra della tabella, e così via.
	</para>
	</li>

	<li><para>6. Ultimata la composizione della tabella, è possibile
        visualizzarla facendo doppio clic sulla sua icona. Per copiare
        la tabella negli appunti in uno dei formati supportati, basta
        fare clic sul menù Modifica della finestra in cui appare la
        tabella.</para>
	</li>

	<li><para>7. Se l'ordinamento dei modelli nella tabella non è
        quello voluto, fare clic col tasto destro sull'icona della
        tabella modelli e selezionare <quote>Pulisci</quote>, quindi
        tornare al punto 4.</para>
	</li>
      </nlist>
    </description>

    <description context="cli">
      <para>Manipola la <quote>tabella modelli</quote> di gretl. Si veda la
      	<guideref targ="modes"/> per i dettagli. Le opzioni hanno i
        seguenti effetti: <cmd>add</cmd> aggiunge l'ultimo modello
        stimato alla tabella modelli, se possibile; <cmd>show</cmd>
	mostra la tabella modelli in una finestra; <cmd>free</cmd>
	pulisce la tabella.</para>
    </description>

    <gui-access>
      <menu-path>Finestra di sessione, Icona Tabella Modelli</menu-path>
    </gui-access>

  </command>

  <command name="mpols" section="Estimation"
    label="Stima OLS a precisione multipla">

    <usage>
      <arguments>
        <argument>variabile-dipendente</argument>
        <argument>variabili-indipendenti</argument>
      </arguments>
      <options>
	<option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
        </option>
	<option>
	  <flag>--simple-print</flag>
	  <effect>non mostra le statistiche ausiliarie</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>non mostra i risultati</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Calcola le stime OLS per il modello indicato usando aritmetica
        in virgola mobile a precisione multipla. Questo comando è
        disponibile solo se <program>gretl</program> è compilato con il
        supporto per la libreria Gnu Multiple Precision (GMP).
      </para>

      <para context="cli">
        È possibile recuperare diverse variabili interne con il comando
        <cmdref targ="genr"/>, a condizione che <cmd>genr</cmd> venga invocato
        immediatamente dopo questo comando.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modello/MPOLS - Minimi quadrati in alta precisione</menu-path>
    </gui-access>

  </command>

  <command name="multiply" section="Transformations" context="cli">

    <usage>
      <arguments>
        <argument>x</argument>
        <argument>suffisso</argument>
        <argument>lista-variabili</argument>
      </arguments>
      <examples>
        <example>multiply invpop pc 3 4 5 6</example>
        <example>multiply 1000 big x1 x2 x3</example>
      </examples>
    </usage>

    <description>
      <para>
	Le variabili nella <repl>lista-variabili</repl> (indicate per
        nome o numero) sono moltiplicate per <repl>x</repl>, che può
        essere un valore numerico o il nome di una variabile già
        definita. I prodotti verranno chiamati con il
        <repl>suffisso</repl> specificato (massimo 3 caratteri),
        troncando i nomi delle variabili originali se ce n'è bisogno per motivi
        di spazio. Ad esempio, si supponga di voler creare la versione
        procapite di una serie di variabili, usando la variabile <lit>pop</lit>
        (popolazione).  Lo si può fare con i comandi seguenti:</para>
      
      <code>
	genr invpop = 1/pop
	multiply invpop pc income</code>

      <para>che creeranno <lit>incomepc</lit> come prodotto di
	<lit>income</lit> e <lit>invpop</lit>, e
	<lit>expendpc</lit> come <lit>expend</lit> per
	<lit>invpop</lit>.
      </para>
    </description>

  </command>

  <command name="nls" section="Estimation"
    label="Stima minimi quadrati non-lineari">

    <usage>
      <arguments>
        <argument>funzione</argument>
        <argument>derivate</argument>
      </arguments>
      <options>
	<option>
	  <flag>--robust</flag>
	  <effect>errori standard robusti</effect>
        </option>
	<option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
	</option>
	<option>
	  <flag>--verbose</flag>
	  <effect>mostra i dettagli delle iterazioni</effect>
	</option>
      </options>
    </usage>

    <description context="gui">

      <para>Esegue una stima con minimi quadrati non-lineari (NLS:
      Nonlinear Least Squares) usando una versione modificata
      dell'algoritmo di Levenberg&ndash;Marquandt. Occorre fornire una
      specificazione di funzione e si raccomanda di specificare anche le
      espressioni per le derivate di questa funzione rispetto a ognuno
      dei parametri, se possibile.</para>

      <para>Esempio: si supponga di avere un dataset con le variabili
	C e Y (ad es. greene11_3.gdt) e di voler stimare una funzione di
        consumo non-lineare del tipo:
	<equation status="display"
	  tex="\[C = \alpha + \beta Y^{\gamma}\]"
	  ascii="C = alfa + beta * Y^gamma"
	  graphic="greene_Cfunc"/></para>

      <para>I parametri alfa, beta e gamma devono per prima cosa essere
      aggiunti al dataset, indicando un valore iniziale; è possibile
      farlo usando il comando genr o attraverso i menù. È possibile
      inserire i comandi <quote>genr</quote> appropriati nella finestra
      di dialogo della specificazione NLS prima di specificare la
      funzione.</para>

      <para>Nella finestra NLS si inseriranno le righe seguenti:</para>

      <code>
	C = alfa + beta * Y^gamma
	deriv alfa = 1
	deriv beta = Y^gamma
	deriv gamma = beta * Y^gamma * log(Y)
      </code>

      <para>La prima riga indica la specificazione della funzione, mentre
      le righe successive forniscono le derivate della funzione rispetto
      ad ognuno dei tre parametri. Se non vengono fornite le righe
      "deriv", viene calcolata un'approssimazione numerica del
      Jacobiano.</para>

      <para>Se i parametri alfa, beta e gamma non sono stati
      dichiarati in precedenza, è possibile premettere alle righe viste
      sopra le seguenti:</para>

      <code>
	genr alpha = 1
	genr beta = 1
	genr gamma = 1
      </code>

      <para>Per ulteriori dettagli sulla stima NLS si veda la
	<guideref targ="chap-nls"/>.</para>

    </description>

    <description context="cli">

      <para>Esegue una stima con minimi quadrati non-lineari (NLS:
      Nonlinear Least Squares) usando una versione modificata
      dell'algoritmo di Levenberg&ndash;Marquandt. Occorre fornire una
      specificazione di funzione e dichiarare i parametri della funzione
      (usando il comando <cmd>genr</cmd>) prima della stima.
      Opzionalmente, è anche possibile specificare le espressioni per le
      derivate della funzione rispetto a ognuno dei parametri; in caso
      contrario, viene calcolata un'approssimazione numerica del
      Jacobiano.</para>

      <para>
	È più semplice mostrare il funzionamento con un esempio. Quello
        che segue è uno script completo per stimare la funzione di
        consumo non-lineare presentata in <book>Econometric
        Analysis</book> di William Greene (capitolo 11 della quarta
        edizione, o capitolo 9 della quinta). I numeri alla sinistra
        delle righe sono dei punti di riferimento e non fanno parte dei
        comandi. Si noti che le opzioni, come ad esempio <lit>--vcv</lit> per mostrare la
	matrice di covarianza delle stime dei parametri, vanno aggiunte al
        comando finale <lit>end nls</lit>.</para>

      <code>
	1   open greene11_3.gdt
	2   ols C 0 Y
	3   genr alfa = $coeff(0)
	4   genr beta = $coeff(Y)
	5   genr gamma = 1.0
	6   nls C = alfa + beta * Y^gamma
	7   deriv alfa = 1
	8   deriv beta = Y^gamma
	9   deriv gamma = beta * Y^gamma * log(Y)
	10  end nls --vcv
      </code>

      <para>
	Spesso è comodo inizializzare i parametri con riferimento a un
        modello lineare collegato, come è mostrato nelle righe da 2 a 5.
	I parametri alfa, beta e gamma possono essere impostati a
        qualunque valore iniziale (non necessariamente sulla base di un
        modello stimato con OLS), ma la convergenza della procedura NLS
        non è garantita per qualunque punto di partenza.</para>

      <para>
	I veri comandi NLS occupano le righe da 6 a 10. Sulla riga 6
        viene dato il comando <cmd>nls</cmd>: viene specificata una
        variabile dipendente, seguita dal segno uguale, seguito da una
        specificazione di funzione. La sintassi per l'espressione a
        destra è la stessa usata per il comando <cmd>genr</cmd>. Le tre
        righe successive specificano le derivate della funzione di
        regressione rispetto a ognuno dei parametri. Ogni riga inizia
        con il comando <cmd>deriv</cmd>, indica il nome di un parametro,
        il segno di uguale e un'espressione che indica come calcolare la
        derivata (anche qui la sintassi è la stessa di <cmd>genr</cmd>).
        Queste righe <cmd>deriv</cmd> sono opzionali, ma si raccomanda
        di inserirle se possibile. La riga 10, <cmd>end nls</cmd>,
        completa il comando ed esegue la stima.</para>

      <para>Per ulteriori dettagli sulla stima NLS si veda la
	<guideref targ="chap-nls"/>.</para>

    </description>

    <gui-access>
      <menu-path>/Modello/Minimi quadrati non lineari</menu-path>
    </gui-access>

  </command>

  <command name="nulldata" section="Dataset"
    label="Creazione di un dataset vuoto">

    <usage>
      <arguments>
        <argument>lunghezza_serie</argument>
      </arguments>
      <examples>
        <example>nulldata 500</example>
      </examples>
    </usage>

    <description>
      <para>
	Crea un dataset <quote>vuoto</quote>, che contiene solo una
        costante e una variabile indice, con periodicità 1 e il numero
        indicato di osservazioni. Ad esempio, è possibile creare un dataset
        a scopo di simulazione usando alcuni comandi <cmd>genr</cmd> (come
        <cmd>genr uniform()</cmd> e <cmd>genr normal()</cmd>) per generare
        dati di prova. Questo comando può essere usato insieme a
        <cmd>loop</cmd>.  Si veda anche l'opzione <quote>seed</quote> del
        comando <cmdref targ="set"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>/File/Crea dataset</menu-path>
    </gui-access>

  </command>

  <command name="ols" section="Estimation"
    label="Stima minimi quadrati ordinari">

    <usage>
      <arguments>
        <argument>variabile-dipendente</argument>
        <argument>variabili-indipendenti</argument>
      </arguments>
      <options>
        <option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
        </option>
        <option>
	  <flag>--robust</flag>
	  <effect>errori standard robusti</effect>
        </option>
        <option>
	  <flag>--simple-print</flag>
	  <effect>non mostra le statistiche ausiliarie</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>non mostra i risultati</effect>
        </option>
        <option>
	  <flag>--no-df-corr</flag>
	  <effect>sopprime la correzione per i gradi di libertà</effect>
        </option>
        <option>
	  <flag>--print-final</flag>
	  <effect>si veda sotto</effect>
        </option>
      </options>
      <examples>
        <example>ols 1 0 2 4 6 7</example>
	<example>ols y 0 x1 x2 x3 --vcv</example>
	<example>ols y 0 x1 x2 x3 --quiet</example>
      </examples>
    </usage>

    <description>
      <para context="gui">
        Calcola le stime minimi quadrati ordinari (OLS: Ordinary Least
        Squares) per il modello specificato.
      </para>

      <para context="cli">
        Calcola le stime minimi quadrati ordinari (OLS: Ordinary Least
        Squares) usando la <repl>variabile-dipendente</repl> e la lista
        di <repl>variabili-indipendenti</repl>, che possono essere 
        specificate per nome o numero. Il termine costante può essere
        indicato usando il numero 0.
      </para>

      <para>Oltre alle stime dei coefficienti e agli errori standard, il
        programma mostra i p-value per le statistiche <mathvar>t</mathvar>
	(a due code) e <mathvar>F</mathvar>.  Un p-value inferiore a
	0.01 indica significatività al livello dell'1 per cento ed è
        denotato con <lit>***</lit>. <lit>**</lit> indica invece la
        significatività tra l'1 e il 5 per cento, mentre <lit>*</lit>
	indica un livello di significatività tra il 5 e il 10 per cento.
	Vengono mostrate anche le statistiche di selezione del modello
        (il criterio di informazione di Akaike, AIC, e il criterio di
        informazione bayesiana di Schwarz, BIC). La formula usata per AIC
        è descritta in Akaike (1974), ossia meno due volte la log-verosimiglianza
        massimizzata più il doppio del numero di parametri stimati.</para>

      <para context="cli">Usando l'opzione <lit>--no-df-corr</lit> la correzione per i
	gradi di libertà non viene applicata nel calcolo della varianza
        stimata dell'errore (e quindi anche dell'errore standard delle
        stime dei parametri).</para>

      <para context="cli">L'opzione <lit>--print-final</lit> è utilizzabile solo nel contesto
	di un <cmdref targ="loop"/>. L'effetto è quello di eseguire la
        regressione in modo silenzioso per tutte le iterazioni del loop
        tranne l'ultima. Si veda la <guideref targ="loop-examples"/> per i dettagli.
      </para>

      <para context="cli">È possibile salvare alcune variabili
      interne generate durante la stima, usando il comando <cmdref
      targ="genr"/> subito dopo questo comando.
      </para>

      <para context="cli">La formula usata per generare gli errori
      standard robusti (quando viene usata l'opzione
      <lit>--robust</lit>) può essere modificata con il comando <cmdref
      targ="set"/>.  </para>
    </description>

    <gui-access>
      <menu-path>/Modello/OLS - Minimi quadrati ordinari</menu-path>
      <other-access>Pulsante Beta-hat sulla barra degli strumenti</other-access>
    </gui-access>

  </command>

  <command name="omit" section="Tests" label="Test per le variabili omesse">

    <usage>
      <arguments>
        <argument>lista-variabili</argument>
      </arguments>
      <options>
	<option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>non mostra le stime per il modello ridotto</effect>
	</option>
 	<option>
 	  <flag>--silent</flag>
 	  <effect>non mostra nulla</effect>
 	</option>
        <option>
          <flag>--inst</flag>
          <effect>omette come strumento, solo per TSLS</effect>
        </option>
        <option>
          <flag>--both</flag>
          <effect>omette come regressore e come strumento, solo per TSLS</effect>
        </option>
      </options>
      <examples>
        <example>omit 5 7 9</example>
        <example>omit seasonals --quiet</example>
      </examples>
    </usage>

    <description>
      <para>
	Questo comando deve seguire un comando di stima. Omette le
        variabili indicate dal modello precedente e stima il nuovo
        modello. Viene eseguito un test per la significatività congiunta
        delle variabili omesse; la statistica test è la <mathvar>F</mathvar>
        nel caso della stima OLS, altrimenti è un chi-quadro asintotico di Wald.
        Un p-value inferiore a 0.05 indica che i coefficienti sono
        congiuntamente significativi al livello del 5 per cento.
      </para>
      <para context="cli">
	Se viene usata l'opzione <lit>--quiet</lit>, i risultati
        mostrati comprendono solo il test per la significatività
        congiunta delle variabili omesse, altrimenti vengono mostrate
        anche le stime del modello ridotto. In quest'ultimo caso,
        l'opzione <lit>--vcv</lit> mostra anche la matrice di covarianza
        dei coefficienti.
 	Usando l'opzione <lit>--silent</lit>, non viene mostrato nulla; tuttavia
        i risultati del test possono essere recuperati usando le variabili
        speciali <lit>$test</lit> e <lit>$pvalue</lit>.
      </para>
      <para context="cli">
       Se il modello originale è stato stimato con i minimi quadrati a due
       stadi, può sorgere un'ambiguità: le nuove variabili vanno omesse come
       regressori, come strumenti o con entrambe le funzioni? Per risolvere
       l'ambiguità, nella modalità predefinita le variabili sono omesse
       dall'elenco dei regressori, se si usa l'opzione <lit>--inst</lit> sono
       omesse dall'elenco degli strumenti, mentre se si usa l'opzione
       <lit>--both</lit> sono rimosse totalmente dal modello.
      </para>
    </description>

    <gui-access>
      <menu-path>Finestra del modello, /Test/OMIT - Ometti variabili</menu-path>
    </gui-access>

  </command>

  <command name="omitfrom" section="Tests" context="cli">

    <usage>
      <arguments>
        <argument>id-modello</argument>
        <argument>lista-variabili</argument>
      </arguments>
      <options>
	<option>
	  <flag>--quiet</flag>
	  <effect>non mostra le stime per il modello ridotto</effect>
	</option>
      </options>
      <examples>
        <example>omitfrom 2 5 7 9</example>
      </examples>
    </usage>

    <description>
      <para>Funziona come <cmdref targ="omit"/>, tranne per il fatto che
      è possibile indicare un modello precedentemente stimato,
      attraverso il suo numero identificativo (che è mostrato all'inizio
      dei risultati del modello). L'esempio precedente omette le
      variabili numero 5, 7 e 9 dal modello 2.
      </para>
    </description>

    <gui-access>
      <menu-path>Finestra del modello, /Test/OMIT - Ometti variabili</menu-path>
    </gui-access>

  </command>

  <command name="online" section="Dataset" context="gui"
    label="Accesso ai database online">

    <description>
      <para>
	Gretl può accedere ai database della Wake Forest University
	(se il proprio computer è connesso a internet).</para>

      <para>Dal menù <quote>File, Consulta database</quote>, selezionare
	<quote>Sul server di database</quote>: apparirà una finestra che
        mostra i database disponibili alla Wake Forest (a seconda della
        località e della velocità della connessione internet,
        l'operazione può richiedere alcuni secondi). Oltre al nome del
        database e a una breve descrizione, apparirà un campo
        <quote>Stato</quote>, che mostra se il database è stato
        installato localmente (sul disco del computer), e, in caso
        positivo, se la versione installata è aggiornata a quella
        disponibile sul server.</para>

      <para>Se un database è stato installato localmente ed è
      aggiornato, non c'è nessun vantaggio nell'accedervi attraverso il
      server, mentre per un database non installato o non aggiornato, può essere
      utile scaricare un elenco delle serie di dati, facendo clic su
      <quote>Scarica l'elenco delle serie</quote>. Apparirà una nuova
      finestra da cui è possibile visualizzare i valori di una serie
      scelta, vederne il grafico o importarle in gretl. È possibile
      effettuare queste operazioni usando il menù <quote>Serie</quote>,
      o attraverso il menù pop-up che appare facendo clic col tasto
      destro su una serie. È anche possibile cercare nell'elenco una
      variabile in particolare, usando il comando <quote>Trova</quote>
      del menù.</para>

      <para>Per poter accedere a un database anche offline, basta selezionare la
      riga del database desiderato nella prima finestra e premere il pulsante 
      <quote>Installa</quote>. Il database verrà scaricato in formato
      compresso, verrà decompresso e installato sul proprio disco fisso,
      in modo da poter essere caricato usando il menù <quote>File,
      Consulta database, gretl</quote>.</para>

    </description>
  </command>

  <command name="open" section="Dataset" context="cli">

    <usage>
      <arguments>
        <argument>file-dati</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Apre un file di dati. Se è già stato aperto un file di dati,
        esso viene sostituito da quello selezionato. Il programma cerca
        di determinare il formato del file di dati (gretl, testo
        semplice, CSV o	BOX1).
      </para>

      <para>
	Questo comando può essere usato anche per aprire un database (gretl o
	RATS 4.0) per la lettura. In questo caso, dev'essere seguito dal comando
	<cmdref targ="data"/> per estrarre una particolare serie dal
        database.
      </para>
    </description>

    <gui-access>
      <menu-path>/File/Apri dati</menu-path>
      <other-access>Trascinare un file di dati in gretl (MS Windows o Gnome)</other-access>
    </gui-access>

  </command>

  <command name="outfile" section="Printing" context="cli">

    <usage>
      <arguments>
        <argument>file-output</argument>
        <argument>opzione</argument>
      </arguments>
      <options>
        <option>
	  <flag>--append</flag>
	  <effect>aggiunge al file</effect>
        </option>
        <option>
	  <flag>--close</flag>
	  <effect>chiude il file</effect>
        </option>
        <option>
	  <flag>--write</flag>
	  <effect>sovrascrive il file</effect>
        </option>
      </options>
      <examples>
        <example>outfile --write regress.txt</example>
        <example>outfile --close</example>
      </examples>
    </usage>

    <description>
      <para>Scrive i risultati sul <repl>file-output</repl>, fino a nuovo
        ordine. Usando l'opzione <lit>--append</lit>, i risultati
        vengono aggiunti a un file esistente, mentre <lit>--write</lit>
        apre un nuovo file (o ne sovrascrive uno esistente). Può essere
        aperto solo un file alla volta.</para>

      <para>L'opzione <lit>--close</lit> può essere usata per chiudere
      un file di output aperto in precedenza, tornando a scrivere i
      risultati sul canale predefinito.</para>

      <para>Nel primo degli esempi precedenti viene aperto il file
	<filename>regress.txt</filename>, mentre nel secondo viene
        chiuso. Se prima del comando <lit>--close</lit> fosse
        eseguito un comando <cmd>ols</cmd>, i risultati della
        regressione verrebbero scritti su
        <filename>regress.txt</filename> invece che sullo schermo.</para>
    </description>

  </command>

  <command name="panel" section="Estimation" context="cli"
    label="Modelli panel">

    <usage>
      <options>
 	<option>
	  <flag>--random-effects</flag>
	  <effect>effetti casuali invece che fissi</effect>
	</option>
	<option>
	  <flag>--unit-weights</flag>
	  <effect>minimi quadrati ponderati</effect>
	</option>
	<option>
	  <flag>--iterate</flag>
	  <effect>stima iterativa</effect>
	</option>
	<option>
	  <flag>--quiet</flag>
	  <effect>mostra meno risultati</effect>
        </option>
        <option>
	  <flag>--verbose</flag>
	  <effect>mostra più risultati</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
        Stima un modello panel, usando gli effetti fissi o, se si usa l'opzione
        <lit>--random-effects</lit>, gli effetti casuali.
      </para>
      <para>
        In alternativa, con l'opzione <lit>--unit-weights</lit>, il modello viene
        stimato con i minimi quadrati ponderati, con i pesi costruiti a partire
        dalla varianza residua per le rispettive unità cross section nel
        campione. Solo in questo caso, è possibile usare l'opzione
        <lit>--iterate</lit> per produrre stime iterative: nel caso di
        convergenza, le stime sono di massima verosimiglianza.
      </para>
      <para>
	FIXME add more detail here.
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Panel</menu-path>
    </gui-access>

  </command>
  
  <command name="panel-mode" section="Dataset" context="gui"
    label="Organizzazione dei dati panel">

    <description>
      <para>
	Questa finestra di dialogo offre tre opzioni per definire un dataset
        come panel. Le prime due opzioni richiedono che il dataset sia già
        organizzato in un formato panel (anche se gretl può non essersi accorto
        di ciò). La terza opzione richiede che il dataset contenga variabili che
        rappresentano la struttura panel.
      </para>
      <para>
        Pila di serie storiche: date N unità cross section nel dataset e T
        osservazioni temporali per ogni unità, selezionando questa opzione si
        dice a gretl che il dataset attuale è composto da N blocchi consecutivi
        di T osservazioni ciascuno. Il passo successivo consiste nello
        specificare il valore di N.
      </para>
      <para>
        Pila di dati cross section: si indica a gretl che il dataset è composto
        da T blocchi consecutivi di N osservazioni cross section ciascuno.
        observations, one for each time period.  Il passo successivo consiste
        nello specificare il valore di N.
      </para>
      <para>
	Usa variabili indice: si indica che il dataset è organizzato in modo
        qualsiasi, ma contiene due variabili che indicizzano le unità cross
        section e quelle temporali. Il passo successivo consiste nell'indicare
        queste due variabili, che devono essere strettamente positive.
       </para>
     </description>
 
   </command>


  <command name="pca" section="Statistics"
    label="Analisi delle componenti principali">

    <usage>
      <arguments>
        <argument>lista-variabili</argument>
      </arguments>
      <options>
        <option>
	  <flag>--save</flag>
	  <effect>salva le componenti principali</effect>
        </option>
        <option>
	  <flag>--save-all</flag>
	  <effect>salva tutte le componenti</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>Analisi delle componenti principali. Mostra gli autovalori
      della matrice di correlazione per le variabili nella
	<repl>lista-variabili</repl>, insieme alla proporzione della
        varianza comune spiegata da ogni componente. Mostra anche i
        corrispondenti autovettori (o <quote>pesi della componente</quote>).</para>  

      <para>Usando l'opzione <lit>--save</lit>, le componenti con autovalori
      maggiori di 1.0 vengono salvati nel dataset come variabili, con i nomi
      <lit>PC1</lit>, <lit>PC2</lit> e così via.  Queste variabili artificiali
      sono definite come la somma del peso della componente moltiplicato per
      <lit>Xi</lit> standardizzato, dove <lit>Xi</lit> denota la
      <mathvar>i</mathvar>-esima variabile nella
      <repl>lista-variabili</repl>.</para>

      <para>Usando l'opzione <lit>--save-all</lit>, vengono salvate
      tutte le componenti, come descritto sopra.</para> 
    </description>

    <gui-access>
      <menu-path>Pop-up nella finestra principale (selezione multipla)</menu-path>
    </gui-access>

  </command>

  <command name="pergm" section="Statistics"
    label="Periodogramma">

    <usage>
      <arguments>
        <argument>nome-variabile</argument>
      </arguments>
      <options>
        <option>
	  <flag>--bartlett</flag>
	  <effect>usa la finestra di Bartlett</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Calcola e mostra (graficamente se non si è in modalità batch)
        lo spettro della variabile specificata. Senza l'opzione
	<lit>--bartlett</lit>, viene mostrato il periodogramma nel
        campione; usando l'opzione, lo spettro viene stimato usando una
        finestra di Bartlett per i ritardi di lunghezza pari al doppio della
        radice quadrata dell'ampiezza campionaria (si veda il capitolo 18 di
        <book>Econometric Analysis</book> di Greene).
       </para>
       <para>
        Se viene mostrato il periodogramma
        del campione, viene mostrato anche il test <mathvar>t</mathvar>
        per l'integrazione frazionale della serie (<quote>memoria
        lunga</quote>): l'ipotesi nulla è che l'ordine di integrazione
        sia zero.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variabile/Spettro</menu-path>
      <other-access>Menù pop-up nella finestra principale (selezione singola)</other-access>
    </gui-access>

  </command>

  <command name="poisson" section="Estimation" label="Poisson">

    <usage>
      <arguments>
        <argument>variabile-dipendente</argument>
        <argument>variabili-indipendenti</argument>
        <argument separated="true" optional="true">offset</argument>
      </arguments>
      <options>
        <option>
          <flag>--vcv</flag>
          <effect>mostra la matrice di covarianza</effect>
        </option>
        <option>
          <flag>--verbose</flag>
          <effect>mostra i dettagli delle iterazioni</effect>
        </option>
      </options>
      <examples>
        <example>poisson y 0 x1 x2</example>
       <example>poisson y 0 x1 x2 ; S</example>
      </examples>
    </usage>

    <description>
      <para>Stima una regressione di Poisson, in cui la variabile dipendente
      rappresenta le occorrenze di un qualche tipo di evento e può assumere solo
      valori interi non negativi.
      </para>

      <para>Se una variabile casuale discreta <mathvar>Y</mathvar> segue la
      distribuzione di Poisson, 
        <equation status="display"
          tex="\[\mathrm{Pr}(Y = y) = \frac{e^{-v} v^y}{y!}\]"
          ascii="Pr(Y = y) = exp(-v) * v^y / y!"
          graphic="poisson1"/>
      per <mathvar>y</mathvar> = 0, 1,
      2,&hellip;.  La media e la varianza della distribuzione sono entrambe uguali a
      <mathvar>v</mathvar>. Nel modello di regressione di Poisson, il parametro
      <mathvar>v</mathvar> è rappresentato da una funzione di una o più varabili
      indipendenti. La versione più comune del modello (e l'unica supportata da
      gretl) ha
        <equation status="display"
          tex="\[v = \mathrm{exp}(\beta_0+\beta_1 x_1+\beta_2 x_2 + \cdots)\]"
          ascii="v = exp(b0 + b1*x1 + b2*x2 + ...)"
          graphic="poisson2"/>,
      ossia il logaritmo di
      <mathvar>v</mathvar> è una funzione lineare delle variabili indipendenti.
      </para>

      <para>Opzionalmente è possibile aggiungere una variabile
      <quote>offset</quote> alla specificazione, ossia una variabile di scala,
       il cui logaritmo viene aggiunto alla funzione di regressione lineare
       (con un coefficiente implicito di 1.0). Ciò ha senso se si ipotizza che
       il numero di occorrenze dell'evento in questione sia proporzionale a
       qualche fattore noto, a parità di altre condizioni. Ad esempio, il numero
       di incidenti stradali può essere ipotizzato proporzionale al volume del
       traffico, che potrebbe essere specificato come una variabile di
       <quote>offset</quote> in un modello di Poisson per il tasso di incidenti.
       La variabile di offset dev'essere strettamente positiva.
      </para>

    </description>

    <gui-access>
      <menu-path>/Modello/Poisson</menu-path>
    </gui-access>

  </command>

  <command name="plot" section="Graphs" context="cli">

    <usage>
      <arguments>
        <argument>lista-variabili</argument>
      </arguments>
      <options>
        <option>
	  <flag>--one-scale</flag>
	  <effect>forza una scala sola</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Disegna i valori delle variabili indicate per l'intervallo di
        osservazioni attuale, usando simboli ASCII. Ogni riga
        rappresenta un'osservazione e i valori sono disegnati
        orizzontalmente. Il comportamento predefinito è di scalare la
        variabili in modo appropriato. Si veda anche <cmdref targ="gnuplot"/>.
      </para>
    </description>

  </command>

  <command name="print" section="Printing" context="cli">

    <usage>
      <arguments>
	<argument>lista-variabili</argument>
	<argument alternate="true">stringa-letterale</argument>
      </arguments>
      <options>
	<option>
	  <flag>--byobs</flag>
	  <effect>per osservazione</effect>
	</option>
	<option>
	  <flag>--ten</flag>
	  <effect>usa 10 cifre significative</effect>
	</option>
 	<option>
 	  <flag>--no-dates</flag>
 	  <effect>usa i numeri delle osservazioni</effect>
 	</option>
      </options>
      <examples>
	<example>print x1 x2 --byobs</example>
	<example>print "Questa è una stringa"</example>
      </examples>
    </usage>

    <description>
      <para>
	Se viene indicata una <repl>lista-variabili</repl>, stampa i
        valori delle variabili specificate, altrimenti stampa i valori
        di tutte le variabili nel dataset in uso. Usando l'opzione
	<lit>--byobs</lit> i dati vengono stampati per osservazione,
        altrimenti sono stampati per variabile. Usando l'opzione
	<lit>--ten</lit> i dati vengono stampati per variabile con 10
        cifre significative.
      </para>

      <para>
 	Se si usa l'opzione <lit>--byobs</lit> e i dati sono mostrati per
        osservazione, il comportamento predefinito è quello di mostrare la data
        (per serie storiche) o il marcatore (se esiste) all'inizio di ogni riga.
 	L'opzione <lit>--no-dates</lit> sopprime la visualizzazione delle date o
        dei marcatori: viene mostrato solo un semplice numero di osservazione.
       </para>
 
       <para>
	Se l'argomento di <cmd>print</cmd> è una stringa letterale (che
        deve iniziare con le virgolette doppie <lit>"</lit>), la stringa
        viene stampata così come è stata indicata. Si veda anche <cmdref
	  targ="printf"/>.</para>
    </description>

    <gui-access>
      <menu-path>/Dati/Mostra valori</menu-path>
    </gui-access>

  </command>

  <command name="printf" section="Printing" context="cli">

    <usage>
      <arguments>
        <argument>formato</argument>
        <argument>argomenti</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Stampa valori scalari nel formato indicato da una stringa di
        formato (che supporta un piccolo sottoinsieme del comando
        <lit>printf()</lit> del linguaggio di programmazione C). I
        formati riconosciuti sono <lit>%g</lit> e <lit>%f</lit>, con i
        vari modificatori disponibili in C. Esempi: la stringa <lit>%.10g</lit>
        stampa un valore con 10 cifre significative; <lit>%12.6f</lit>
        stampa un valore con 6 cifre decimali e una larghezza di 12
        caratteri.</para>  

      <para>La stringa di formato deve essere racchiusa tra virgolette
        doppie, i valori da stampare devono seguire la stringa di
        formato, separati da virgole. I valori possono avere tre forme:
	a) i nomi di variabili nel dataset; b) espressioni valide per
        il comando <cmd>genr</cmd>; c) le funzioni speciali <lit>varname()</lit>
        o <lit>date()</lit>. L'esempio seguente stampa i valori
        di due variabili e quello di un'espressione calcolata:</para>

      <code>
	ols 1 0 2 3
	genr b = $coeff(2)
	genr se_b = $stderr(2)
	printf "b = %.8g, standard error %.8g, t = %.4f\n", b, se_b, b/se_b
      </code>

      <para>
 	Le prossime righe mostrano l'uso delle funzioni varname e date, che
        rispettivamente mostrano il nome di una variabile dato il suo numero
        identificativo, e una stringa data, dato un numero di osservazione.
      </para>
 
       <code>
 	printf "Il nome della variabile %d è %s\n", i, varname(i)
 	printf "La data dell'osservazione %d è %s\n", j, date(j)
       </code>
 
       <para>
	La lunghezza massima di una stringa di formato è di 127
        caratteri. Vengono riconosciute le sequenze di escape
	<lit>\n</lit> (newline), <lit>\t</lit> (tab),
	<lit>\v</lit> (tab verticale) e <lit>\\</lit> (barra inversa).
        Per stampare un segno di percentuale, si usi <lit>%%</lit>.</para>
    </description>

  </command>

  <command name="probit" section="Estimation"
    label="Stima probit">

    <usage>
      <arguments>
        <argument>variabile-dipendente</argument>
        <argument>variabili-indipendenti</argument>
      </arguments>
      <options>
	<option>
	  <flag>--robust</flag>
	  <effect>errori standard robusti</effect>
	</option>
	<option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
	</option>
      </options>
    </usage>

    <description>
      <para>
        Stima un modello probit, per variabili dipendenti binarie.
        Le stime di massima verosimiglianza dei coefficienti delle
        <repl>variabili-indipendenti</repl> sono ottenute con il metodo
        <quote>binary response model regression</quote> (BRMR) descritto in
        Davidson e MacKinnon (2004). Visto che il modello è nonlineare, le
        pendenze dipendono dai valori delle variabili indipendenti: le pendenze
        riportate sono valutate nelle medie di queste variabili. La
        statistica chi-quadro testa l'ipotesi nulla che tutti i
        coefficienti tranne la costante siano pari a zero.
      </para>
      <para>
        In modalità predefinita, gli errori standard sono calcolati con
        l'inversa negativa dell'Hessiana.  Se si usa l'opzione
        <lit>--robust</lit>, verranno calcolati gli errori standard QML o quelli
        di Huber&ndash;White. In questo caso, la matrice di covarianza stimata è
        un <quote>sandwich</quote> dell'inversa dell'Hessiana stimata e del
        prodotto esterno del gradiente. Per i dettagli, si veda Davidson e
        MacKinnon 2004, cap. 10.
      </para>
      <para>
	Il probit per l'analisi delle proporzioni non è ancora stato
        implementato in	<program>gretl</program>.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modello/Probit</menu-path>
    </gui-access>

  </command>

  <command name="pvalue" section="Utilities" context="cli">

    <usage>
      <arguments>
        <argument>distribuzione</argument>
        <argument optional="true">parametri</argument>
	<argument>valore-x</argument>
      </arguments>
      <examples>
        <example>pvalue z zscore</example>
	<example>pvalue t 25 3.0</example>
	<example>pvalue X 3 5.6</example>
	<example>pvalue F 4 58 fval</example>
	<example>pvalue G xbar varx x</example>
        <example>pvalue B bprob 10 6</example>
      </examples>
    </usage>

    <description>
      <para>
	Calcola l'area alla destra del <repl>valore-x</repl> nella
        distribuzione indicata (<lit>z</lit> per la Gaussiana,
	<lit>t</lit> per la <mathvar>t</mathvar> di Student, <lit>X</lit>
	per la chi-quadro, <lit>F</lit> per la <mathvar>F</mathvar>,
	<lit>G</lit> per la gamma e <lit>B</lit> per la binomiale).
      </para>
      <para>
        Per le distribuzioni <mathvar>t</mathvar> e chi-quadro vanno indicati i
        gradi di libertà; per la <mathvar>F</mathvar> sono richiesti i gradi di
        libertà al numeratore e al denominatore; per la gamma sono richieste la
        media e la varianza; per la binomiale sono richieste la probabilità di
        <quote>successo</quote> e il numero di tentativi. In ogni caso questi
        argomenti aggiuntivi vanno specificati prima del <repl>valore-x</repl>.
      </para>
      <para>
        Come si nota dagli esempi, gli argomenti numerici possono essere
        indicati sotto forma di numero o come nomi di variabili.
      </para>
    </description>

    <gui-access>
      <menu-path>/Utilità/Calcola p-value</menu-path>
    </gui-access>

  </command>

  <command name="pwe" section="Estimation" label="Stimatore di Prais-Winsten">

    <usage>
      <arguments>
        <argument>variabile-dipendente</argument>
        <argument>variabili-indipendenti</argument>
      </arguments>
      <options>
	<option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
	</option>
      </options>
      <examples>
        <example>pwe 1 0 2 4 6 7</example>
      </examples>
    </usage>

    <description>
      <para>
	Calcola le stime dei parametri usando la procedura
        Prais&ndash;Winsten, un'implementazione GLS sviluppata per
        gestire l'autocorrelazione del primo ordine nel termine di
        errore. La procedura viene iterata, così come in <cmdref
        targ="corc"/>; la differenza è che mentre Cochrane&ndash;Orcutt
        tralascia la prima osservazione, Prais&ndash;Winsten ne fa uso.
        Per i dettagli, si veda per esempio il capitolo 13 di
        <book>Econometric Analysis</book> (2000) di Greene.
      </para>
    </description>

    <gui-access>
      <menu-path>/Modello/Serie storiche/PWE - Prais-Winsten</menu-path>
    </gui-access>

  </command>

  <command name="quit" section="Utilities" context="cli">

    <description>
      <para>
	Esce dal programma, dando la possibilità di salvare i
        risultati della sessione.
      </para>
    </description>

    <gui-access>
      <menu-path>/File/Esci</menu-path>
    </gui-access>

  </command>

  <command name="rename" section="Dataset" context="cli">

    <usage>
      <altforms>
	<altform><lit>rename</lit> <repl>numero-var</repl> <repl>nuovo-nome</repl></altform>
	<altform><lit>rename</lit> <repl>nome-var</repl> <repl>nuovo-nome</repl></altform>
      </altforms>
    </usage>

    <description>
      <para>Modifica il nome di una variabile con numero identificativo
        <repl>numero-var</repl> o nome <repl>nome-var</repl> in
        <repl>nuovo-nome</repl>. Il <repl>numero-var</repl> deve essere compreso
        tra 1 e il numero di variabili nel dataset. Il nuovo nome deve essere
        lungo al massimo 15 caratteri, deve iniziare con una lettera e deve
        essere composto di sole lettere, numeri e il carattere trattino basso.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variabile/Modifica attributi</menu-path>
      <other-access>Menù pop-up nella finestra principale (selezione singola)</other-access>
    </gui-access>

  </command>

  <command name="reset" section="Tests" label="Test RESET di Ramsey">

    <description>
      <para>
	Va eseguito dopo la stima di un modello via OLS. Esegue il test
	RESET di Ramsey per la specificazione del modello
        (non-linearità), aggiungendo alla regressione il quadrato e il
        cubo dei valori stimati e calcolando la statistica
        <mathvar>F</mathvar> per l'ipotesi nulla che i coefficienti dei due
        termini aggiunti siano pari a zero.
      </para>
    </description>

    <gui-access>
      <menu-path>Finestra del modello, /Test/RESET - Ramsey</menu-path>
    </gui-access>

  </command>

  <command name="restrict" section="Tests" context="cli" label="Test per vincoli lineari">

    <description>
      <para>
	Impone un insieme di vincoli lineari sull'ultimo modello
        stimato o su un sistema di equazioni definito in precedenza.
        La sintassi del comando è leggermente diversa in ognuno dei due casi.
      </para>
        
      <para>
        In entrambi i casi, l'insieme di vincoli deve essere racchiuso tra i
        comandi <quote>restrict</quote> e <quote>end restrict</quote>. Nel caso
        della singola equazione, i vincoli sono applicati implicitamente
        all'ultimo modello e vengono valutati appena viene terminato il comando
        <quote>restrict</quote>. Nel caso del sistema, il comando iniziale
        <quote>restrict</quote> deve essere seguito immediatamente dal nome di
        un sistema di equazioni definito in precedenza (si veda <cmdref targ="system"/>).
        I vincoli vengono valutati nella successiva stima del sistema effettuata
        con il comando <cmdref targ="estimate"/>.
      </para>

      <para>Ogni vincolo nell'insieme va indicato sotto forma di equazione
	con una combinazione lineare dei parametri al primo membro e un
        valore numerico al secondo. Nel caso della singola equazione, i
        parametri sono indicati con la sintassi b<repl>N</repl>, dove
        <repl>N</repl> rappresenta la posizione nella lista dei regressori, a
        partire da zero. Ad esempio, <lit>b1</lit> indica il secondo parametro
        della regressione. Nel caso del sistema, i parametri vengono indicati
        con la sintassi <lit>b</lit> seguita da due numeri tra parentesi quadre.
        Il primo numero rappresenta la posizione dell'equazione all'interno del
        sistema a partire da 1, mentre il secondo indica la posizione nella
        lista dei regressori, a partire da zero. Ad esempio <lit>b[2,0]</lit>
        indica il primo parametro della seconda equazione, mentre
	<lit>b[3,1]</lit> il secondo parametro della terza equazione.
      </para>

      <para>I termini <lit>b</lit> nell'equazione che rappresenta un vincolo
      possono essere prefissati da un moltiplicatore numerico, usando il segno
      <lit>*</lit> per indicare la moltiplicazione, ad esempio
      <lit>3.5*b4</lit>.
      </para>

      <para>Ecco un esempio di un insieme di vincoli per un modello stimato in
      precedenza:</para>

      <code>
	restrict
	 b1 = 0
	 b2 - b3 = 0
	 b4 + 2*b5 = 1
	end restrict</code>

      <para>Ed ecco un esempio di un insieme di vincoli da applicare a un
      sistema (se il nome del sistema non contiene spazi, è possibile
      tralasciare le virgolette).
      </para>

      <code>
	restrict "Sistema 1"
	 b[1,1] = 0
	 b[1,2] - b[2,2] = 0
	 b[3,4] + 2*b[3,5] = 1
	end restrict</code>

      <para>
        Nel caso dell'equazione singola, i vincoli sono valutati attraverso un
        test <mathvar>F</mathvar> di Wald, usando la matrice di covarianza dei
        coefficienti del modello in questione. In modalità predefinita vengono
        mostrate le stime dei coefficienti vincolati; se si desidera solo la
        statistica test, basta aggiungere l'opzione <lit>--quiet</lit> al
        comando <lit>restrict</lit> iniziale.
      </para>
      <para>
        Nel caso del sistema, la statistica test dipende dallo stimatore scelto:
        un test del rapporto di verosimiglianza nel caso di un sistema stimato
        con un metodo di massima verosimiglianza, o un test
        <mathvar>F</mathvar> asintotico negli altri casi.
      </para>

    </description>

    <gui-access>
      <menu-path>Modello, /Test/Vincoli lineari</menu-path>
    </gui-access>

  </command>
  
  <command name="restrict-model" section="Tests" context="gui"
    label="Vincoli su un modello">

    <description>

      <para>Ognuno dei vincoli da imporre a un modello deve essere espresso
        sotto forma di equazione con una combinazione lineare dei parametri al
        primo membro e un valore numerico al secondo. Nel caso della singola
        equazione, i parametri sono indicati con la sintassi b<repl>N</repl>,
        dove <repl>N</repl> rappresenta la posizione nella lista dei regressori,
        a partire da zero. Ad esempio, <lit>b1</lit> indica il secondo parametro
        della regressione.
      </para>

      <para>I termini <lit>b</lit> nell'equazione che rappresenta un vincolo
        possono essere prefissati con un moltiplicatore numerico usando il
        carattere <lit>*</lit> per indicare la moltiplicazione, ad esempio
        <lit>3.5*b4</lit>.
      </para>

      <para>Ecco ad esempio un insieme di vincoli:</para>

      <code>
	b1 = 0
	b2 - b3 = 0
	b4 + 2*b5 = 1</code>

    </description>

  </command>

  <command name="restrict-system" section="Tests" context="gui"
    label="Vincoli su un sistema di equazioni">

    <description>

      <para>Ognuno dei vincoli da imporre a un sistema deve essere espresso
        sotto forma di equazione con una combinazione lineare dei parametri al
        primo membro e un valore numerico al secondo. 
        I parametri vengono indicati con la sintassi <lit>b</lit> seguita da due
        numeri tra parentesi quadre.  Il primo numero rappresenta la posizione
        dell'equazione all'interno del sistema a partire da 1, mentre il secondo
        indica la posizione nella lista dei regressori, a partire da zero. Ad
        esempio <lit>b[2,0]</lit> indica il primo parametro della seconda
        equazione, mentre <lit>b[3,1]</lit> il secondo parametro della terza
        equazione.
      </para>

      <para>I termini <lit>b</lit> nell'equazione che rappresenta un vincolo
        possono essere prefissati con un moltiplicatore numerico usando il
        carattere <lit>*</lit> per indicare la moltiplicazione, ad esempio
        <lit>3.5*b4</lit>.
      </para>

      <para>Ecco ad esempio un insieme di vincoli:</para>

      <code>
	b[1,1] = 0
	b[1,2] - b[2,2] = 0
	b[3,4] + 2*b[3,5] = 1</code>

    </description>

  </command>

  <command name="restrict-vecm" section="Tests" context="gui"
    label="Vincoli su un VECM">

    <description>

      <para>
	Questo comando impone restrizioni lineari omogenee sulle relazioni
        di cointegrazione in un modello vettoriale a correzione d'errore (VECM).
      </para>

      <para>Ognuno dei vincoli deve essere espresso sotto forma di equazione,
        con una combinazione lineare dei parametri al primo membro e il valore
        zero al secondo membro (al momento gretl supporta solo vincoli omogenei
        in un contesto VECM).
      </para>

      <para>Se il VECM è di rango 1, è possibile esprimere i parametri nella
        forma b<repl>N</repl>, dove <repl>N</repl> rappresenta la posizione nel
        vettore di correzione dell'errore, a partire da zero. Ad esempio,
        <lit>b1</lit> indica il secondo parametro di correzione dell'errore.
      </para>

      <para>Se il rango è maggiore di 1, è possibile esprimere i parametri
        usando <lit>b</lit> seguito da due numeri tra parentesi quadre.
      </para>

      <para>I termini <lit>b</lit> nell'equazione che rappresenta un vincolo
        possono essere prefissati con un moltiplicatore numerico usando il
        carattere <lit>*</lit> per indicare la moltiplicazione, ad esempio
        <lit>3.5*b4</lit>.
      </para>

      <para>Ecco ad esempio un insieme di vincoli su un VECM di rango 1.
      </para>

      <code>
	b0 + b1 = 0
	b0 + b2 = 0</code>

    </description>

  </command>

  <command name="rhodiff" section="Transformations" context="cli">

    <usage>
      <arguments>
        <argument>lista-rho</argument>
        <argument separated="true">lista-variabili</argument>
      </arguments>
      <examples>
        <example>rhodiff .65 ; 2 3 4</example>
        <example>rhodiff r1 r2 ; x1 x2 x3</example>	
      </examples>
    </usage>

    <description>
      <para>
	Crea delle versioni rho-differenziate delle variabili indicate
        (con numero o con nome) nella <repl>lista-variabili</repl> e le
        aggiunge al dataset, usando il suffisso <lit>#</lit> per le
        nuove variabili. Ad esempio, data la variabile <lit>v1</lit> nella
	<repl>lista-variabili</repl> e i valori <lit>r1</lit> e
	<lit>r2</lit> nella <repl>lista-rho</repl>, viene creata
      </para>
      <code>
        v1# = v1 - r1*v1(-1) - r2*v1(-2)</code>
      <para>
	I valori nella <repl>lista-rho</repl> possono essere specificati sotto
	forma di valori numerici o di nomi di variabili definite in precedenza.
      </para>
    </description>

  </command>

  <command name="rmplot" section="Graphs"
    label="Grafici range-mean">

    <usage>
      <arguments>
        <argument>nome-variabile</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Grafici Range&ndash;mean: questo comando crea un semplice
        grafico che aiuta a capire se una serie storica
	<mathvar>y</mathvar>(t) ha varianza costante o no. L'intero
        campione t=1,...,T viene diviso in piccoli sotto-campioni di
        dimensione arbitraria <mathvar>k</mathvar>. Il primo
        sotto-campione è formato da
        <mathvar>y</mathvar>(1), ... ,<mathvar>y</mathvar>(k), il secondo
        da <mathvar>y</mathvar>(k+1), ... , <mathvar>y</mathvar>(2k), e
        così via.  Per ogni sotto-campione, vengono calcolati la media e
        il campo di variazione (range: il valore massimo meno quello
        minimo) e viene costruito un grafico con le medie sull'asse
        orizzontale e i campi di variazione su quello verticale, in modo
        che ogni sotto-campione sia rappresentato da un punto sul piano.
	Se la varianza della serie è costante, ci si aspetta che il
        campo di variazione del sotto-campione sia indipendente dalla
        media del sotto-campione; se i punti si dispongono su una linea
        crescente, la varianza della serie cresce al crescere della
        media, viceversa se i punti si dispongono su una linea
        decrescente.</para>

      <para>Oltre al grafico, gretl mostra anche le medie e i campi di
      variazione per ogni sotto-campione, insieme al coefficiente di
      pendenza della regressione OLS del campo di variazione sulla media
      e il p-value per l'ipotesi nulla che la pendenza sia zero.
      Se il coefficiente di pendenza è significativo al livello del 10
      per cento, viene mostrata sul grafico la linea stimata della
      regressione del campo di variazione sulla media.
      </para>
    </description>

    <gui-access>
      <menu-path>/Variabile/Grafico range-mean</menu-path>
    </gui-access>

  </command>

  <command name="run" section="Programming" context="cli">

    <usage>
      <arguments>
        <argument>file-input</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Esegue i comandi nel <repl>file-input</repl> e restituisce il
        controllo al prompt interattivo. Questo comando si intende usato con il
        programma a riga di comando gretlcli, o con il <quote>terminale di gretl</quote>
        nel programma con interfaccia grafica.
      </para>
      <para>
	Si veda anche <cmdref targ="include"/>.
      </para>
    </description>

    <gui-access>
      <menu-path>Icona Esegui nella finestra comandi</menu-path>
    </gui-access>

  </command>

  <command name="runs" section="Tests" label="Test delle successioni">

    <usage>
      <arguments>
        <argument>nome-variabile</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Esegue il test non parametrico <quote>delle successioni</quote>
        per la casualità della variabile specificata. Ad esempio, per 
        testare la casualità delle deviazioni dalla mediana per una
        variabile chiamata <lit>x1</lit>, con una mediana diversa da
        zero, eseguire i comandi seguenti:</para>

      <code>
	genr signx1 = x1 - median(x1)
	runs signx1
      </code>
    </description>

    <gui-access>
      <menu-path>/Variabile/Test delle successioni</menu-path>
    </gui-access>

  </command>

  <command name="sampling" section="Dataset" context="gui"
    label="Impostazione del campione">

    <description>
      <para>Il menù Campione offre vari modi di selezionare un
      sotto-campione dal dataset in uso.</para>

      <para>
	Scegliendo <quote>Campione/Imposta in base a dummy...</quote>,
	viene chiesto di scegliere una variabile dummy (indicatrice),
        che può assumere solo valori 0 o 1 per ogni osservazione. Il
        campione verrà limitato alle osservazioni per cui la variabile
        dummy vale 1.</para>

      <para>Scegliendo <quote>Campione/Imposta in base a
      condizione...</quote>, viene chiesto di inserire un'espressione
      Booleana (logica), dello stesso tipo di quella che si userebbe per
      definire una variabile dummy. Ad esempio, l'espressione
      <quote>sqft > 1400</quote> selezionerà solo le osservazioni per
      cui la variabile sqft ha un valore maggiore di 1400. Le condizioni
      possono essere concatenate con gli operatori logici <quote>&amp;</quote>
	(AND) e <quote>|</quote> (OR) e possono essere negate usando
	<quote>!</quote> (NOT).</para>

      <para>Il comando <quote>Campione/Scarta valori mancanti</quote>
      ridefinisce il campione in modo da escludere tutte le osservazioni
      per cui i valori di una o più variabili sono mancanti (lasciando
      nel campione solo i casi completi).</para>  

      <para>Per selezionare le osservazioni per cui solo una particolare
      variabile non ha valori mancanti, occorre usare
      <quote>Campione/Imposta in base a condizione...</quote> e inserire
      la condizione Booleana <quote>!missing(nome-variabile)</quote>
      (sostituire <quote>nome-variabile</quote> con il nome della
      variabile che si intende usare).</para>  

      <para>Se sono state associate etichette alle osservazioni, è possibile
      escludere una particolare osservazione dal campione impostando una
      condizione del tipo obs!="Francia". L'etichetta dell'osservazione deve
      essere racchiuso tra virgolette doppie.</para>

      <para>Occore tenere presente che ridefinendo il campione basandosi
      su una variabile dummy, un'espressione Booleana o sul criterio
      delle osservazioni mancanti, tutte le informazioni
      <quote>strutturali</quote> contenute nel file con la descrizione
      dei dati (riguardanti la struttura di serie storiche o di panel
      dei dati) vengono perse. È possibile reimpostare la struttura
      originale con <quote>Campione/Imposta frequenza e inizio...</quote>.</para>

      <para>Si veda la <guideref targ="sampling"/> per maggiori dettagli.</para>

    </description>
  </command>


  <command name="scatters" section="Graphs"
    label="Grafici a dispersione multipli">

    <usage>
      <arguments>
        <argument>variabile-y</argument>
        <argument separated="true">lista-variabili-x</argument>
	<argument alternate="true">lista-variabili-y ; variabile-x</argument>
      </arguments>
      <examples>
        <example>scatters 1 ; 2 3 4 5</example>
        <example>scatters 1 2 3 4 5 6 ; 7</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
	Produce grafici a dispersione della <repl>variabile-y</repl>
        rispetto ad ognuna delle variabili nella
        <repl>lista-variabili-x</repl>, oppure di tutte le variabili
        nella <repl>lista-variabili-y</repl> rispetto alla
        <repl>variabile-x</repl>.  Il primo esempio visto sopra assegna
        la variabile 1 all'asse <mathvar>y</mathvar> e produce quattro
        grafici, il primo con la variabile 2 sull'asse
	<mathvar>x</mathvar>, il secondo con la variabile 3 sull'asse
	<mathvar>x</mathvar>, e così via. Il secondo esempio rappresenta
	ognuna delle variabili da 1 a 6 rispetto alla variabile 7
        sull'asse <mathvar>x</mathvar>. Questi gruppi di grafici sono
        utili nell'analisi esplorativa dei dati. È possibile creare fino
        a sei grafici alla volta, eventuali variabili in sovrappiù
        saranno ignorate.
      </para>
      <para context="gui">
	Produce grafici a dispersione della <quote>Variabile asse
        Y</quote> selezionata rispetto ad ognuna delle <quote>Variabili
        asse X</quote> selezionate. Questi gruppi di grafici sono utili
        nell'analisi esplorativa dei dati. È possibile creare fino a sei
        grafici alla volta, eventuali variabili in sovrappiù saranno
        ignorate.
      </para>
    </description>

    <gui-access>
      <menu-path>/Dati/Grafici multipli a dispersione</menu-path>
    </gui-access>

  </command>

  <command name="sdiff" section="Transformations" context="cli">

    <usage>
      <arguments>
        <argument>lista-variabili</argument>
      </arguments>
    </usage>

    <description>
      <para>
       Calcola la differenza stagionale di ogni variabile della
       <repl>lista-variabili</repl> e salva il risultato in una nuova variabile
       con il prefisso <lit>sd_</lit>. Il comando è disponibile solo per serie storiche stagionali.
      </para>
    </description>

    <gui-access>
      <menu-path>/Dati/Aggiungi variabili/Differenze stagionali</menu-path>
    </gui-access>

  </command>

  <command name="seed" section="Programming" context="gui"
    label="Seme dei numeri casuali">

    <description>
      <para>Richiede un argomento intero. Imposta il seme del generatore
      di numeri pseudo-casuali usato dalle opzioni Variabile casuale
      uniforme e normale nel menù Dati, Aggiungi variabili.
      </para>
      <para>
      Di solito il seme è impostato al momento dell'avvio del programma usando
      l'orologio di sistema, ma per ottenere sequenze ripetibili di numeri
      pseudo-casuali occorre impostarlo manualmente.
      </para>
    </description>
  </command>

  <command name="set" section="Programming" context="cli">

    <usage>
      <arguments>
        <argument>variabile</argument>
        <argument>valore</argument>
      </arguments>
      <examples>
        <example>set qr on</example>
        <example>set csv_delim tab</example>
	<example>set horizon 10</example>
      </examples>    
    </usage>

    <description>
      <para>
	Imposta i valori di vari parametri del programma. Il valore
        impostato rimane in vigore per la durata della sessione di
        gretl, a meno di non essere modificato da un ulteriore
        esecuzione del comando <cmd>set</cmd>. I parametri che possono
        essere impostati in questo modo sono elencati di seguito.
	Si noti che le impostazioni di <lit>hac_lag</lit> e
	<lit>hc_version</lit> sono usate quando viene data l'opzione
        <lit>--robust</lit> al comando <cmd>ols</cmd>. 
      </para>
      <para>
        Se il comando <cmd>set</cmd> è usato senza parametri, vengono
        mostrate le impostazioni attuali per tutti i parametri rilevanti.
      </para>

      <ilist>
	<li>
	  <para><lit>echo</lit>:
	  <lit>off</lit> o <lit>on</lit> (valore predefinito).
	    Sopprime o ripristina l'indicazione dei comandi eseguiti nell'output
            dei risultati.</para>
	</li>
 	<li>
	  <para><lit>messages</lit>: <lit>off</lit> o <lit>on</lit> (valore
            predefinito). Sopprime o ripristina l'indicazione dei messaggi
            informativi associati a vari comandi, ad esempio quando viene
            generata una nuova variabile o viene modificato l'intervallo del
            campione.
         </para>
	</li>
        <li>
	<para>
	  <lit>nls_toler</lit>: un valore in virgola mobile (il valore
          predefinito è pari alla precisione della macchina elevata alla potenza
          3/4). Imposta la tolleranza usata per stabilire se è stata raggiunta
          la convergenza nelle procedure iterative di stima con i minimi
          quadrati non lineari usate dal comando <cmdref targ="nls"/>.
	</para>
        </li>
	<li>
	  <para><lit>qr</lit>:
	  <lit>on</lit> o <lit>off</lit> (valore predefinito).
	    Usa la decomposizione QR invece di quella di Cholesky nel
            calcolo delle stime OLS.</para>
	</li>
        <li>
          <para><lit>seed</lit>:
          un intero senza segno. Imposta il seme per il
            generatore di numeri pseudo-casuali. Di solito il seme viene
            impostato a partire dall'ora di sistema, ma se si intende
            generare sequenze ripetibili di numeri casuali occorre impostare
            il seme manualmente.
          </para>
        </li>
	<li>
	  <para><lit>hac_lag</lit>:
	  <lit>nw1</lit> (valore predefinito) o
	    <lit>nw2</lit>, o un intero.  Imposta il massimo valore di
            ritardo, <mathvar>p</mathvar>, usato nel calcolo degli
            errori standard HAC (Heteroskedasticity and Autocorrelation Consistent)
	    con l'approccio Newey-West, per le serie storiche.
            <lit>nw1</lit> e <lit>nw2</lit> rappresentano due varianti
            di calcolo automatico basate sulla dimensione del campione,
	    <mathvar>T</mathvar>: per nw1, 
	  <equation status="inline"
	    tex="$p = 0.75 \times T^{1/3}$"
	    ascii="p = 0.75 * T^(1/3)"
	    graphic="nw1"/>,
	    e per nw2, 
	  <equation status="inline"
	    tex="$p = 4 \times (T/100)^{2/9}$"
	    ascii="p = 4 * (T/100)^(2/9)"
	    graphic="nw2"/>.	  
	  </para>
	</li>
	<li>
	  <para><lit>hc_version</lit>:
	  0 (valore predefinito), 1, 2 o 3. Imposta la
          variante da usare nel calcolo degli errori standard HAC
          (Heteroskedasticity and Autocorrelation Consistent) con dati
          di tipo cross section. Le opzioni corrispondono alle HC0, HC1,
          HC2 e HC3 discusse da Davidson e MacKinnon nel capitolo 5 di
          <book>Econometric Theory and Methods</book>.  HC0 produce
          quelli che di solito vengono chiamati <quote>errori standard di
          White</quote>.</para> </li>
	<li>
	  <para><lit>force_hc</lit>: <lit>off</lit> (predefinito)
	    o <lit>on</lit>. Lo stimatore HAC viene usato in modo predefinito con dati
            serie storiche e quando si usa l'opzione <lit>--robust</lit> di
            <lit>ols</lit>. Impostando invece <lit>force_hc</lit> a
            <quote>on</quote>, si forza l'uso della matrice di covarianza
	    coerente con l'eteroschedasticità (che non tiene conto dell'autocorrelazione).
	  </para>
	</li>
	<li>
	  <para><lit>garch_vcv</lit>:
	  <lit>unset</lit>, <lit>hessian</lit>,
	    <lit>im</lit> (matrice di informazione) , <lit>op</lit>
            (matrice dei prodotti esterni), <lit>qml</lit> (stimatore QML),
	    <lit>bw</lit> (Bollerslev&ndash;Wooldridge). Specifica la
            variante da usare per stimare la matrice di covarianza dei
            coefficienti nei modelli GARCH.  Se si usa <lit>unset</lit>
	    (valore predefinito), viene usata l'Hessiana, a meno di
            usare l'opzione <quote>robust</quote> col comando garch, nel
            qual caso viene usato QML.</para>
	</li>
	<li>
	  <para><lit>hp_lambda</lit>:
	  <lit>auto</lit> (valore predefinito), o un
          valore numerico. Imposta il parametro di livellamento per
          il filtro di Hodrick&ndash;Prescott (si veda la funzione
          <lit>hpfilt</lit> sotto il comando <lit>genr</lit>). Il valore
          predefinito è 100 volte il quadrato della periodicità, ossia
          100 per i dati annuali, 1600 per i dati trimestrali e così
          via.</para>
	</li>
        <li>
          <para><lit>bkbp_limits</lit>:
          due interi, il secondo maggiore del primo
           (i valori predefiniti sono 8 e 32). Imposta i limiti di
           frequenza per il filtro passa-banda di Baxter&ndash;King
           (si veda la funzione <lit>bkfilt</lit> nel comando <lit>genr</lit>).
         </para>
        </li>
        <li>
          <para><lit>bkbp_k</lit>:
          un intero (il valore predefinito è 8). Imposta
            l'ordine di approssimazione per il filtro passa-banda di
            Baxter&ndash;King.
          </para>
        </li>
	<li>
	  <para><lit>horizon</lit>:
	  un intero (il valore predefinito dipende dalla
          frequenza dei dati). Imposta l'orizzonte per le funzioni impulso-risposta
          e per la decomposizione della varianza nel contesto delle autoregressioni
          vettoriali.
	  </para>
	</li>
	<li>
	  <para><lit>csv_delim</lit>:
	  <lit>comma</lit> (virgola, valore predefinito), <lit>space</lit>
            (spazio), o <lit>tab</lit>. Imposta il delimitatore di colonna usato nel
            salvataggio di dati su file in formato CSV.
	  </para>
	</li>
	<li>	
	<para><lit>bhhh_maxiter</lit>: un intero. Imposta il massimo numero di
          iterazioni per la routine BHHH, che è usata dai comandi
	    <cmd>arma</cmd> e <cmd>tobit</cmd>. Se non viene raggiunta la
            convergenza dopo <lit>bhhh_maxiter</lit>, il programma segnala un
            errore. Il valore predefinito è 500.
	  </para>
	  </li>	  
	<li>	  
	  <para><lit>bhhh_toler</lit>: un valore a virgola mobile, oppure la
            stringa <lit>default</lit>. Viene usato dalla routine BHHH di gretl
            per controllare se viene raggiunta la convergenza. L'algoritmo di
            calcolo ferma le iterazioni non appena l'incremento nella
            log-verosimiglianza tra le iterazioni è minore di <lit>bhhh_toler</lit>.
            I valori predefiniti sono 1.0E&minus;06 per il comando <cmd>arma</cmd>
            e 1.0E&minus;10 per <cmd>tobit</cmd>; questi valori possono essere reimpostati
            usando la stringa <lit>default</lit> invece di un valore numerico.
	    </para>
	    </li>
      </ilist>

    </description>
  </command>
  
  <command name="setinfo" section="Dataset" label="Modifica degli attributi di una variabile">

    <usage>
      <arguments>
        <argument>nome-variabile</argument>
        <argument flag="-d ">descrizione</argument>
        <argument flag="-n ">nome-grafici</argument>
      </arguments>
      <options>
	<option>
	  <flag>--discrete</flag>
	  <effect>marca la variabile come discreta</effect>
	</option>
	<option>
	  <flag>--continuous</flag>
	  <effect>marca la variabile come continua</effect>
	</option>
      </options>
      <examples>
        <example>setinfo x1 -d "Descrizione di x1" -n "Nome nei grafici"</example>
	<example>setinfo z --discrete</example>
      </examples>
    </usage>

    <description context="cli">
      <para>
        Imposta fino a tre attributi di una variabile, nel modo seguente.
      </para>
      <para>
        Usando l'opzione <lit>-d</lit> seguita da una stringa tra
        virgolette doppie, la stringa verrà usata come etichetta descrittiva per
        la variabile indicata, che viene mostrata dal comando <cmdref
        targ="labels"/> e anche nella finestra principale del programma.
      </para>
      <para>
        Usando l'opzione <lit>-n</lit> seguita da una stringa tra
        virgolette doppie, la stringa verrà usata nei grafici al posto del nome
        della variabile.
      </para>
      <para>
        Usando una delle opzioni <lit>--discrete</lit> o
        <lit>--continuous</lit>, viene impostato il carattere numerico della
        variabile.  In modalità predefinita, tutte le variabili sono considerate come
        continue; marcando una variabile come discreta, essa viene trattata in
        modo speciale nei diagrammi di frequenza, e può esere usata con i
        comandi <cmdref targ="xtab"/> (cross-tabulazione) e <cmdref targ="dummify"/>.
      </para>
    </description>

    <description context="gui">

      <para>
	In questa finestra di dialogo è possibile:</para>

      <para>* Rinominare una variabile.</para>

      <para>* Aggiungere o modificare una descrizione della variabile,
        che appare accanto al nome della variabile nella finestra
        principale di gretl.</para>

      <para>* Aggiungere o modificare il "nome per i grafici" della
        variabile. Questa stringa (lunga al massimo 19 caratteri) viene
        usata al posto del nome della variabile quando questa compare in
        un grafico. Così, ad esempio, è possibile associare una stringa
        più comprensibile come "Tariffe telefoniche" a un nome criptico
        come "tartel".</para>

      <para>* Impostare (nel caso di un dataset di serie storiche) il
        metodo di compattamento per la variabile, che verrà usato se si
        decide di ridurre la frequenza del dataset, o se si importa la
        variabile da un dataset che ha una frequenza maggiore di quella
        del dataset in uso.
      </para>

      <para>* Marca una variabile come discreta. In questo modo, essa viene
        trattata in modo speciale nei diagrammi di frequenza, e può esere usata
        con i comandi <cmdref targ="xtab"/> (cross-tabulazione) e <cmdref
        targ="dummify"/>.
      </para>

    </description>

    <gui-access>
      <menu-path>/Variabile/Modifica attributi</menu-path>
      <other-access>Menù pop-up nella finestra principale</other-access>
    </gui-access>

  </command>

  <command name="setobs" section="Dataset" context="cli"
    label="Frequenza e osservazione iniziale">

    <usage>
      <altforms>
        <altform><repl>periodicità</repl> <repl>oss-iniziale</repl></altform>
	<altform><repl>variabile-unità</repl> <repl>variabile-periodi</repl></altform>
      </altforms>
      <options>
        <option>
	  <flag>--cross-section</flag>
	  <effect>interpreta come cross section</effect>
        </option>
        <option>
	  <flag>--time-series</flag>
	  <effect>interpreta come serie storiche</effect>
        </option>
        <option>
	  <flag>--stacked-cross-section</flag>
	  <effect>interpreta come panel</effect>
        </option>
        <option>
	  <flag>--stacked-time-series</flag>
	  <effect>interpreta come panel</effect>
        </option>
        <option>
	  <flag>--panel-vars</flag>
	  <effect>usa variabili indice (si veda oltre)</effect>
        </option>
      </options>
      <examples>
        <example>setobs 4 1990:1 --time-series</example>
        <example>setobs 12 1978:03</example>
	<example>setobs 1 1 --cross-section</example>
        <example>setobs 20 1:1 --stacked-time-series</example>
	<example>setobs unita anno --panel-vars</example>
      </examples>
    </usage>

    <description>
      <para>
	Forza il programma a interpretare il dataset in uso secondo la
        struttura specificata.
      </para>
      <para>
        Nella prima forma del comando, la <repl>periodicità</repl>, che deve
        essere un valore intero, nel caso delle serie storiche rappresenta la
        frequenza delle osservazioni (1 = annuale; 4 = trimestrale; 12 =
        mensile; 52 = settimanale; 5, 6, o 7 = giornaliera; 24 = oraria). Nel
        caso di dati panel, la periodicità è il numero di righe per ogni blocco
        di dati, ossia il numero di unità cross section se i dati sono
        organizzati come pila di dati cross section, o il numero di periodi se i
        dati sono organizzati come pila di serie storiche. Nel caso di semplici
        dati cross section, la periodicità dev'essere impostata a 1.
      </para>
      <para>
	L'osservazione iniziale rappresenta la data iniziale nel caso
        delle serie storiche. Gli anni possono essere indicati con due
        o quattro cifre, mentre i sotto-periodi (ad esempio i trimestri
        o i mesi) devono essere separati dagli anni con un carattere "due punti".
	Nel caso di dati panel, l'osservazione iniziale va indicata come
	1:1, mentre nel caso di dati cross section come 1. L'osservazione
        iniziale per i dati giornalieri o settimanali va indicata nella forma
	AA/MM/GG o AAAA/MM/GG (oppure semplicemente 1 per i dati non datati).
      </para>
      <para>
        La seconda forma del comando (che richiede l'uso dell'opzione
	<lit>--panel-vars</lit>) può essere usata per imporre un'interpretazione
        panel dei dati, quando il dataset contiene variabili che identificano in
        modo univoco le unità cross section e i periodi. Il dataset verrà
        ordinato come pila di serie storiche, per valori crescenti della
        variabile che rappresenta le unità, <repl>variabile-unità</repl>.
      </para>
      <para>
	Se non viene usata nessuna opzione per indicare esplicitamente
        la struttura dei dati, il programma cercherà di riconoscerla automaticamente
        a partire dalle informazioni indicate.
      </para>
    </description>

    <gui-access>
      <menu-path>Campione/Struttura dataset</menu-path>
    </gui-access>

  </command>

  <command name="setmiss" section="Dataset"
    label="Codice dei valori mancanti">

    <usage>
      <arguments>
        <argument>valore</argument>
        <argument optional="true">lista-variabili</argument>
      </arguments>
      <examples>
        <example>setmiss -1</example>
        <example>setmiss 100 x2</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
	Imposta il programma in modo da interpretare un dato valore
        numerico (il primo parametro indicato al comando) come codice
        per i <quote>valori mancanti</quote> nei dati importati. Se
        questo valore è l'unico parametro fornito, come nel primo degli
        esempi precedenti, l'interpretazione verrà applicata a tutte le
        serie del dataset. Se <repl quote="true">valore</repl> è seguito
        da una lista di variabili, indicate per nome o numero,
        l'interpretazione è limitata solo alle variabili specificate.
        Così, nel secondo esempio, il valore 100 è interpretato come
        codice per <quote>mancante</quote>, ma solo per la variabile
        <lit>x2</lit>.
      </para>
      
      <para context="gui">
	Imposta un valore numerico che verrà interpretato come
        "mancante" o "non applicabile", per una particolare serie (sotto
        il menù Variabile) o globalmente per l'intero dataset (sotto il
        menù Campione).</para> 
      
      <para context="gui">
      Gretl ha un codice interno per i valori mancanti, che non sempre
      può coincidere con quello usato dai dati importati. Ad esempio, se
      una serie usa il valore -1 col significato di "non disponibile", è
      possibile selezionare "Imposta codice valori mancanti" nel menù
      Variabile e immettere il valore "-1" (senza le virgolette); gretl
      interpreterà quindi i valori -1 come osservazioni mancanti.</para>

    </description>

    <gui-access>
      <menu-path>/Campione/Imposta codice valori mancanti</menu-path>
    </gui-access>

  </command>

  <command name="shell" section="Utilities" context="cli">

    <usage>
      <arguments>
        <argument>comando-shell</argument>
      </arguments>
      <examples>
        <example>! ls -al</example>
	<example>! notepad</example>
      </examples>
    </usage>

    <description>
      <para>
	Un <cmd>!</cmd> all'inizio di una riga di comando è
        interpretato come passaggio all'interprete di comandi (shell)
        usato dall'utente nel sistema operativo. In questo modo è
        possibile eseguire comandi shell arbitrari dall'interno di
	<program>gretl</program>.
      </para>
      
      <para>
        Per motivi di sicurezza, questa funzionalità è disabilitata in modalità
        predefinita. Per attivarla, occorre selezionare la casella
        <quote>Abilita comandi shell</quote> nel menù File, Preferenze.
      </para>
    </description>

  </command>

  <command name="smpl" section="Dataset" context="cli">

    <!-- don't break the lines below or the text version will get messed
    up -->

    <usage>
      <altforms>
	<altform><lit>smpl</lit> <repl>oss-iniziale oss-finale</repl></altform>
	<altform><lit>smpl</lit> <repl>+i -j</repl></altform>
	<altform><lit>smpl</lit> <repl>variabile-dummy</repl> <lit>--dummy</lit></altform>
	<altform><lit>smpl</lit> <repl>condizione</repl> <lit>--restrict</lit></altform>
	<altform><lit>smpl</lit> <lit>--no-missing [ </lit><repl>lista-variabili</repl> <lit>]</lit></altform>
 	<altform><lit>smpl</lit> <repl>n</repl> <lit>--random</lit></altform>
	<altform><lit>smpl full</lit></altform>
      </altforms>
      <examples>
        <example>smpl 3 10</example>
	<example>smpl 1960:2 1982:4</example>
	<example>smpl +1 -1</example>
	<example>smpl x > 3000 --restrict</example>
	<example>smpl y > 3000 --restrict --replace</example>
	<example>smpl 100 --random</example>
      </examples>
    </usage>

    <description>
      <para>
	Reimposta l'intervallo del campione. Il nuovo intervallo può
        essere definito in vari modi. Nel primo modo (corrispondente ai
        primi due esempi precedenti) <repl>oss-iniziale</repl> e
        <repl>oss-finale</repl> devono essere coerenti con la
        periodicità dei dati. Una delle due può essere sostituita da un
        punto e virgola per lasciare intatto il valore attuale. Nel
        secondo modo, gli interi <repl>i</repl> e <repl>j</repl> (che
        possono essere positivi o negativi e vanno indicati con il
        segno) sono presi come spostamenti relativi ai punti iniziale e
        finale del campione in uso. Nel terzo modo,
        <repl>variabile-dummy</repl> deve essere una variabile
        indicatrice che assume solo valori 0 o 1 e il campione verrà
        ristretto alle osservazioni per cui la variabile dummy vale 1.
	Il quarto modo, che usa <lit>--restrict</lit>, limita il
        campione alle osservazioni che soddisfano la condizione Booleana
	specificata secondo la sintassi del comando <cmdref
        targ="genr"/>.</para>

      <para>Con la forma <lit>--no-missing</lit>, se viene specificata
      una <repl>lista-variabili</repl>, vengono selezionate le osservazioni
      per cui tutte le variabili nella <repl>lista-variabili</repl>
      hanno valori validi in corrispondenza dell'osservazione; altrimenti, se
      non viene indicata alcuna <repl>lista-variabili</repl>, vengono
      selezionate le osservazioni per cui <emphasis>tutte</emphasis> le
      variabili hanno valori validi (non mancanti).</para>

      <para>Con la forma <lit>--random</lit>, viene estratto casualmente dal
      dataset il numero indicato di osservazioni. Per essere in grado di
      replicare questa selezione, occorre per prima cosa impostare il seme
      del generatore di numeri casuali (si veda il comando
	<cmdref targ="set"/>).</para>
 
      <para>La forma finale, <lit>smpl full</lit>, ripristina
      l'intervallo completo del campione.
      </para>
 
      <para>Si noti che i vincoli sul campione di solito sono cumulativi:
      il valore di riferimento di ogni comando <lit>smpl</lit> è il campione
      attuale. Se si vuole che il comando funzioni sostituendo i vincoli esistenti,
      così che ogni vincolo si aggiunga a quelli già impostati, occorre usare
      l'opzione <lit>--replace</lit> alla fine del comando.</para>

      <para>La variabile interna <lit>obs</lit> può essere usata con la
      forma <lit>--restrict</lit> di <lit>smpl</lit> per escludere
      particolari osservazioni dal campione. Ad esempio,</para>

        <code>
	smpl obs!=4 --restrict</code>
        
        <para>scarterà la quarta osservazione. Se le osservazioni sono
        identificate da etichette,</para>
        
	<code>
        smpl obs!="USA" --restrict</code>
        
        <para>scarterà l'osservazione a cui è associata l'etichetta <quote>USA</quote>.
        </para>

      <para>Per le forme <lit>--dummy</lit>, <lit>--restrict</lit> e
      <lit>--no-missing</lit> di <lit>smpl</lit>, occore tenere presente
      che tutte le informazioni <quote>strutturali</quote> contenute nel
      file dei dati (a proposito della struttura di serie storiche o di
      panel dei dati) vengono perse. È possibile reimpostare la
      struttura originale con il comando <cmdref targ="setobs"/>.
      </para>

      <para>Si veda la <guideref targ="sampling"/> per ulteriori dettagli.</para>
    
    </description>

    <gui-access>
      <menu-path>/Campione</menu-path>
    </gui-access>

  </command>

  <command name="spearman" section="Statistics"
    label="Correlazione di rango di Spearman">

    <usage>
      <arguments>
        <argument>x</argument>
        <argument>y</argument>
      </arguments>
      <options>
        <option>
	  <flag>--verbose</flag>
	  <effect>mostra i dati ordinati</effect>
        </option>
      </options>
    </usage>

    <description>
      <para context="cli">
	Mostra il coefficiente di correlazione di rango di Spearman per
        le variabili <mathvar>x</mathvar> e <mathvar>y</mathvar>. Le
        variabili non devono essere state ordinate manualmente in
        precedenza, se ne occupa la funzione.
      </para>

      <para context="gui">
	Mostra il coefficiente di correlazione di rango di Spearman 
        per una coppia di variabili.  Le variabili non devono essere
        state ordinate manualmente in precedenza, se ne occupa la
        funzione.</para>

      <para>
	L'ordinamento automatico è dal massimo al minimo (ossia il
        valore massimo nei dati assume il rango 1). Se occorre invertire
        l'ordinamento, creare una variabile che è il negativo della
        variabile originale, ad esempio:
      </para>

      <code>
	genr altx = -x
	spearman altx y</code>
    </description>

    <gui-access>
      <menu-path>/Modello/SPEARMAN - Correlazione di rango</menu-path>
    </gui-access>

  </command>

  <command name="square" section="Transformations" context="cli">

    <usage>
      <arguments>
        <argument>lista-variabili</argument>
      </arguments>
      <options>
        <option>
	  <flag>--cross</flag>
	  <effect>genera anche i prodotti incrociati, oltre ai quadrati</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Genera nuove variabili che sono i quadrati delle variabili nella
	<repl>lista-variabili</repl> (con anche i prodotti incrociati,
        se si usa l'opzione <lit>--cross</lit>). Ad esempio, <cmd>square
          x y</cmd> genera <lit>sq_x</lit> = <lit>x</lit> al quadrato,
          <lit>sq_y</lit> = <lit>y</lit> al quadrato e (opzionalmente)
          <lit>x_y</lit> = <lit>x</lit> per <lit>y</lit>.
	Se una particolare variabile è una dummy, non ne viene fatto il
        quadrato, visto che si otterrebbe la stessa variabile.
      </para>
    </description>

    <gui-access>
      <menu-path>/Dati/Aggiungi variabili/Quadrati delle variabili selezionate</menu-path>
    </gui-access>

  </command>

  <command name="store" section="Dataset"
    label="Salvataggio dei dati">

    <usage>
      <arguments>
        <argument>file-dati</argument>
        <argument optional="true">lista-variabili</argument>
      </arguments>
      <options>
        <option>
	  <flag>--csv</flag>
	  <effect>usa il formato CSV</effect>
        </option>
        <option>
	  <flag>--omit-obs</flag>
	  <effect>si veda oltre, a proposito del formato CSV</effect>
        </option>
        <option>
	  <flag>--gnu-octave</flag>
	  <effect>usa il formato GNU Octave</effect>
        </option>
        <option>
	  <flag>--gnu-R</flag>
	  <effect>usa il formato GNU R</effect>
        </option>
        <option>
	  <flag>--traditional</flag>
	  <effect>usa il formato tradizionale ESL</effect>
        </option>
        <option>
	  <flag>--gzipped</flag>
	  <effect>comprime con gzip</effect>
        </option>
        <option>
	  <flag>--dat</flag>
	  <effect>usa il formato ASCII di PcGive</effect>
        </option>
        <option>
         <flag>--database</flag>
         <effect>usa il formato database di gretl</effect>
        </option>
        <option>
         <flag>--overwrite</flag>
         <effect>cfr oltre, a proposito del formato dei database</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Salva l'intero dataset, o un sottoinsieme delle variabili se è
        stata indicata una <repl>lista-variabili</repl>, nel file
        indicato con <repl>file-dati</repl>.</para>

      <para>
	L'impostazione predefinita è di salvare i dati nel formato
        <quote>interno</quote> di gretl, ma le opzioni del comando
        permettono di usare formati alternativi. I dati CSV
        (Comma-Separated Values, dati separati da virgole) possono
        essere letti dai programmi di foglio elettronico e possono
        essere modificati con un editor di testi. I formati
        <program>Octave</program>, <program>R</program> e
        <program>PcGive</program> sono destinati ad essere usati con i
        rispettivi programmi. La compressione con gzip può essere utile per
        grandi dataset. Si veda la <guideref targ="datafiles"/> per i dettagli sui
        vari formati.</para>

      <para>
	L'opzione <lit>--omit-obs</lit> è applicabile solo quando si salvano
        dati in formato CSV. In modalità predefinita, se i dati sono serie
        storiche o panel, o se il dataset include marcatori per osservazioni
        specifiche, il file CSV comprende una prima colonna che identifica le
        osservazioni (ad esempio per data). Se si usa <lit>--omit-obs</lit>,
        questa colonna verrà omessa e verranno salvati solo i dati effettivi.
      </para>

      <para>
	Si noti che le variabili scalari non saranno salvate
        automaticamente: per salvarle occorre includerle esplicitamente
        nella <repl>lista-variabili</repl>.
      </para>  

      <para>
        L'opzione di salvataggio in formato database di gretl è indicata se
        occorre costruire dei grandi dataset di serie, magari con frequenze
        diverse e diversi intervalli di osservazioni. Al momento questa opzione
        è disponibile solo per dati annuali, trimestrali o mensili. Salvando su
        un file che esiste già, il comportamento predefinito è quello di
        accodare le nuove serie al contenuto del database preesistente. In
        questo contesto, se una o più delle variabili da salvare hanno lo stesso
        nome di una delle variabili già presenti nel database si otterrà un
        messaggio di errore. L'opzione <lit>--overwrite</lit> permette invece di
        sovrascrivere eventuali variabili del dataset che hanno lo stesso nome
        delle nuove variabili, in modo che queste ultime rimpiazzino le
        variabili preesistenti.
      </para>

    </description>

    <gui-access>
      <menu-path>/File/Salva dati; /File/Esporta dati</menu-path>
    </gui-access>

  </command>

  <command name="summary" section="Statistics" context="cli">

    <usage>
      <arguments>
        <argument optional="true">lista-variabili</argument>
      </arguments>
    </usage>

    <description>
      <para>
	Mostra le statistiche descrittive per le variabili nella
	<repl>lista-variabili</repl>, o per tutte le variabili nel
        dataset, se non si indica una <repl>lista-variabili</repl>.
        L'output comprende media, deviazione standard, coefficiente
        di variazione (= deviazione standard / media), mediana, minimo,
        massimo, coefficiente di asimmetria, curtosi.
      </para>
    </description>

    <gui-access>
      <menu-path>/Dati/Statistiche descrittive</menu-path>
      <other-access>Menù pop-up nella finestra principale</other-access>
    </gui-access>

  </command>

  <command name="system" section="Estimation" label="Sistemi di equazioni">

    <usage>
      <altforms>
	<altform><lit>system method=</lit><repl>stimatore</repl></altform>
	<altform><lit>system name=</lit><repl>nome_sistema</repl></altform>
      </altforms>
      <arguments>
        <argument>variabili-salvate</argument>
      </arguments>
      <examples>
	<example>system name="Klein Model 1"</example>
        <example>system method=sur</example>
	<example>system method=sur save=resids</example>
	<example>system method=3sls save=resids,fitted</example>
      </examples>
    </usage>

    <description>

      <para context="gui">In questa finestra, è possibile stimare sistemi di
        equazioni e scegliere uno stimatore per il sistema. È possibile indicare
        i seguenti quattro tipi di comandi:
      </para>

      <para context="cli">
	Inizia un sistema di equazioni. Esistono due versioni del comando,
        a seconda che si voglia salvare il sistema per poterlo stimare in
        più modi diversi, oppure stimare il sistema una volta sola.
      </para>

      <para context="cli">
	Per salvare il sistema occorre dargli un nome, come nel primo esempio
        proposto (se il nome contiene spazi, occorre racchiuderlo tra virgolette).
        In questo caso, è possibile stimare il sistema con il comando
	<cmdref targ="estimate"/>. Una volta che il sistema è stato salvato, è
        possibile imporre dei vincoli su di esso (compresi vincoli incrociati
        tra equazioni) usando il comando <cmdref targ="restrict"/>.
      </para>

      <para context="cli">
	In alternativa, è possibile indicare uno stimatore per il sistema
	usando <lit>method=</lit> seguito da una stringa che identifica uno
        degli stimatori supportati: <cmd>ols</cmd> (ordinary least squares -
        minimi quadrati ordinari), <cmd>tsls</cmd> (two-stage least squares -
        minimi quadrati a due stadi), <cmd>sur</cmd> (seemingly unrelated
        regressions - regressioni apparentemente non collegate), <cmd>3sls</cmd>
        (three-stage least squares - minimi quadrati a tre stadi),
        <cmd>fiml</cmd> (full information maximum likelihood - massima
        verosimiglianza con informazione completa) o <cmd>liml</cmd> (limited
        information maximum likelihood - massima verosimiglianza con
        informazione limitata). In questo caso, il sistema viene stimato appena
        completata la sua definizione.
      </para>

      <para context="cli">Un sistema di equazioni termina con la riga
	<cmd>end system</cmd>.  All'interno del sistema possono essere
        definiti i quattro tipi di istruzioni seguenti.</para>

      <ilist>
	<li><para><cmdref targ="equation"/>: specifica un'equazione del sistema.
	    Occorre indicarne almeno due.</para>
	</li>
	<li><para><cmd>instr</cmd>: per i sistemi da stimare con i minimi
            quadrati a tre stadi, indica la lista degli strumenti (indicati
            dal nome o dal numero della variabile). In alternativa, è possibile
	    fornire questa informazione nella riga <cmd>equation</cmd> usando la
            stessa sintassi accettata dal comando <cmdref targ="tsls"/>.</para>
	</li>
	<li><para><cmd>endog</cmd>: per i sistemi di equazioni simultanee, indica
            la lista delle variabili endogene. È indicato principalmente per
            la stima FIML, ma può essere usato anche nella stima minimi quadrati
            a tre stadi al posto dell'istruzione <cmd>instr</cmd>: in questo modo
            tutte le variabili non identificate come endogene verranno usate come
            strumenti.</para>
	</li>
	<li><para><cmd>identity</cmd>: per la stima FIML, un'identità che collega
            due o più variabili del sistema. Questo tipo di istruzione è ignorata
            se viene usato uno stimatore diverso da FIML.
	  </para>
	</li>
      </ilist>
        
      <para context="cli">
        Nel campo opzionale <cmd>save=</cmd> del comando è possibile
        specificare se salvare i residui (<cmd>resids</cmd>) e/o
	i valori stimati (<cmd>fitted</cmd>).
      </para>
      
      <para>Per esempi completi di specificazione e stima di un
	sistema di equazioni, si vedano gli script
	<filename>klein.inp</filename>,
	<filename>kmenta.inp</filename> e
	<filename>greene14_2.inp</filename> forniti con la
	distribuzione di gretl.
       </para>

    </description>
    
    <gui-access>
      <menu-path>/Modello/Equazioni simultanee</menu-path>
    </gui-access>

  </command>

  <command name="tabprint" section="Printing" context="cli">

    <usage>
      <arguments>
        <argument optional="true">-f nomefile</argument>
      </arguments>
      <options>
        <option>
	  <flag>--complete</flag>
	  <effect>crea un documento completo</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
	Va eseguito dopo la stima di un modello.  Stampa il modello
        stimato sotto forma di tabella &latex;.  Se viene specificato un
        nome di file dopo l'opzione <lit>-f</lit>, l'output viene
        scritto nel file, altrimenti viene scritto in un file col nome
	<filename>model_N.tex</filename>, dove <lit>N</lit> è il numero
        dei modelli stimati finora nella sessione in corso.
	Si veda anche <cmdref targ="eqnprint"/>.
      </para>

      <para>
	Usando l'opzione <lit>--complete</lit>, il file &latex; è un
        documento completo, pronto per essere processato; altrimenti il
        file va incluso in un documento.
      </para>
    </description>

    <gui-access>
      <menu-path>Finestra del modello, /LaTeX</menu-path>
    </gui-access>

  </command>

  <command name="testuhat" section="Tests" context="cli"
    label="Normalità dei residui">

    <description>
      <para>
	Deve seguire un comando di stima. Mostra la distribuzione di
        frequenza dei residui del modello, insieme a un test chi-quadro
        per la normalità, basato sulla procedura suggerita da Doornik
        e Hansen (1984).
      </para>
    </description>

    <gui-access>
      <menu-path>Finestra del modello, /Test/Normalità dei residui</menu-path>
    </gui-access>

  </command>

  <command name="tobit" section="Estimation" label="Stima Tobit">

    <usage>
      <arguments>
        <argument>variabile-dipendente</argument>
        <argument>variabili-indipendenti</argument>
      </arguments>
      <options>
        <option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
        </option>
        <option>
	  <flag>--verbose</flag>
	  <effect>mostra i dettagli delle iterazioni</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>Stima un modello Tobit. Il modello può essere appropriato
      quando la variabile dipendente è <quote>troncata</quote>. Ad
      esempio, vengono osservati valori positivi o nulli della spesa dei
      consumatori per beni durevoli, ma non valori negativi; tuttavia le
      decisioni di spesa possono essere pensate come derivanti da una
      propensione al consumo, sottostante e non osservata, che può anche
      essere negativa in alcuni casi. Per i dettagli si veda il capitolo
      20 di <book>Econometric Analysis</book> di Greene.</para>
    </description>

    <gui-access>
      <menu-path>/Modello/Tobit</menu-path>
    </gui-access>

  </command>

  <command name="transpos" section="Dataset" label="Trasposizione dei dati">

    <description>
      <para>
	Traspone il dataset attuale, ossia, ogni osservazione (riga) del
        dataset attuale verrà trattata come una variabile (colonna) e
        ogni variabile come un'osservazione. Questo comando è utile se
        sono stati importati da una fonte esterna dati in cui le righe
        rappresentano variabili e le colonne osservazioni.
      </para>
    </description>

    <gui-access>
      <menu-path>/Campione/Trasponi dati</menu-path>
    </gui-access>

  </command>

  <command name="tsls" section="Estimation"
    label="Stima minimi quadrati a due stadi">

    <usage>
      <arguments>
        <argument>variabile-dipendente</argument>
        <argument>variabili-indipendenti</argument>
	<argument separated="true">strumenti</argument>
      </arguments>
      <options>
        <option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
        </option>
	<option>
	  <flag>--robust</flag>
	  <effect>errori standard robusti</effect>
        </option>
      </options>      
      <examples>
        <example>tsls y1 0 y2 y3 x1 x2 ; 0 x1 x2 x3 x4 x5 x6</example>
      </examples>
    </usage>

    <description>
      <para context="cli">
	Calcola le stime minimi quadrati a due stadi (TSLS o IV), date
        la <repl>variabile-dipendente</repl> e la lista di
	<repl>variabili-indipendenti</repl> (incluse le variabili
        esogene) nell'equazione strutturale per cui sono richieste le
        stime TSLS; <repl>strumenti</repl> è la lista completa delle
        variabili esogene e predeterminate in tutte le equazioni. Se la
        lista degli <repl>strumenti</repl> non è lunga almeno quanto
        quella delle <repl>variabili-indipendenti</repl>, il modello non
        è identificato.</para>

      <para context="cli">
	Nell'esempio precedente, le <lit>y</lit> sono le variabili
        endogene e le <lit>x</lit> sono le variabili esogene e
        predeterminate.
      </para>

      <para context="gui">
	Questo comando richiede la scelta di due liste di variabili; le
        variabili indipendenti che appaiono nel modello e un elenco di
        "strumenti". Questi ultimi comprendono le variabili esogene e/o
        altre variabili predeterminate che possono essere usate come
        regressori per derivare valori stimati delle variabili endogene
        del modello.
      </para>

      <para context="gui">Se alcune delle variabili del modello sono
        esogene, vanno incluse in entrambe le liste.
      </para>
      
      <para>
	L'output del comando comprende il test di Hausman e, se il modello è
        sovra-identificato, il test di Sargan per la sovra-identificazione. Nel
        test di Hausman, l'ipotesi nulla è che le stime OLS siano consistenti, o
        in altre parole che non sia richiesta la stima per mezzo di variabili
        strumentali. Un modello di questo tipo è sovra-identificato se ci sono
        più strumenti di quelli strettamente necessari. Il test di Sargan è
        basato su una regressione ausiliaria dei residui del modello minimi
        quadrati a due stadi sull'intera lista degli strumenti. L'ipotesi nulla
        è che tutti gli strumenti siano validi, cosa di cui si dovrebbe dubitare
        se la regressione ausiliaria ha un significativo potere esplicativo.
	Davidson e MacKinnon (2004, capitolo 8) forniscono una buona spiegazione di
        entrambi i test.
      </para>

    </description>

    <gui-access>
      <menu-path>/Modello/TSLS - Minimi quadrati a due stadi</menu-path>
    </gui-access>

  </command>

  <command name="var" section="Estimation"
    label="Stima autoregressione vettoriale">

    <usage>
      <arguments>
        <argument>ordine</argument>
        <argument>lista-variabili</argument>
	<argument separated="true">lista-esogene</argument>
      </arguments>
      <options>
        <option>
	  <flag>--nc</flag>
	  <effect>non include una costante</effect>
        </option>
        <option>
	  <flag>--seasonals</flag>
	  <effect>include variabili dummy stagionali</effect>
        </option>
        <option>
	  <flag>--robust</flag>
	  <effect>errori standard robusti</effect>
        </option>
        <option>
	  <flag>--impulse-responses</flag>
	  <effect>mostra impulso-risposta</effect>
        </option>
        <option>
	  <flag>--variance-decomp</flag>
	  <effect>mostra decomposizioni della varianza della previsione</effect>
        </option>
        <option>
	  <flag>--lagselect</flag>
	  <effect>mostra i criteri di informazione per la selezione dei ritardi</effect>
        </option>
      </options>
      <examples>
        <example>var 4 x1 x2 x3 ; time mydum</example>
	<example>var 4 x1 x2 x3 --seasonals</example>
	<example>var 12 x1 x2 x3 --lagselect</example>
      </examples>
    </usage>

    <description>

      <para context="gui">
	Questo comando richiede la specificazione dei seguenti elementi:</para>

      <ilist context="gui">
	<li><para context="gui">- L'ordine di ritardi, ossia il numero
        di ritardi di ogni variabile presente nel sistema;</para>
	</li>

        <li><para context="gui">- Eventuali termini esogeni
        (ma si noti che una costante viene inclusa automaticamente, a meno che
        non si richieda altrimenti; inoltre è possibile includere variabili
        dummy stagionali con l'apposita casella); e
        </para>
	</li>

	<li><para context="gui">- Una lista di variabili esogene,
        i cui ritardi saranno inclusi a destra delle equazioni (nota:
        non includere variabili ritardate in questa lista, verranno
        aggiunte automaticamente).</para>
	</li>
      </ilist>

      <para context="gui">Viene calcolata una regressione separata per
      ogni variabile del sistema; i risultati comprendono i test F per i
      vincoli di uguaglianza a zero su tutti i ritardi della variabili e
      un test F per il ritardo massimo, oltre (opzionalmente) alla
      scomposizione della varianza della previsione e alle funzioni di
      impulso-risposta.</para>  

      <para context="cli">
	Imposta e stima (usando OLS) un'autoregressione vettoriale (VAR).
        Il primo argomento specifica l'ordine di ritardo (o il massimo ordine di
        ritardi se è stata usata l'opzione <lit>--lagselect</lit>). L'ordine può
        essere indicato numericamente o con il nome di una variabile scalare
        preesistente.  Quindi segue l'impostazione della prima equazione. Non
        occorre includere i ritardi tra gli elementi della
        <repl>lista-variabili</repl>: verranno aggiunti automaticamente. Il
        punto e virgola separa le variabili stocastiche, per cui verrà incluso
        un numero di ritardi pari a <repl>ordine</repl>, dai termini
        deterministici o esogeni presenti nella
        <repl>lista-esogene</repl>.</para>

      <para context="cli">
	gretl è in grado di riconoscere le più comuni variabili
        deterministiche (trend temporale, variabili dummy con
        valori 0 o 1), quindi queste non devono necessariamente essere
        elencate dopo il punto e virgola. Variabili deterministiche più
        complesse (ad es. un trend temporale moltiplicato per una
        variabile dummy) devono invece essere indicate esplicitamente.
        Si noti che viene inclusa automaticamente una costante, a meno che
        non si usi l'opzione <lit>--nc</lit>; inoltre è possibile aggiungere
        un trend con l'opzione <lit>--trend</lit> e variabili dummy stagionali
        con l'opzione <lit>--seasonals</lit>.</para>

      <para context="cli">
	Viene calcolata una regressione separata per ognuna delle
        variabili nella <repl>lista-variabili</repl>. Il risultato di
        ogni equazione include i test <mathvar>F</mathvar> per i vincoli
        di uguaglianza a zero su tutti i ritardi delle variabili, un
        test <mathvar>F</mathvar> per la significatività del ritardo massimo e,
        se è stata usata l'opzione <lit>--impulse-responses</lit>, la
        scomposizione della varianza della previsione e le funzioni di
        impulso-risposta.</para>

      <para>
	Le decomposizioni della varianza della previsione e le funzioni di
        impulso-risposta sono basate sulla decomposizione di Cholesky
        della matrice di covarianza contemporanea, e in questo contesto
        l'ordine in cui vengono date le variabili stocastiche conta.
	La prima variabile nella lista viene considerata come la
	<quote>più esogena</quote> all'interno del periodo. L'orizzonte
        per le decomposizioni della varianza e le funzioni di impulso-risposta
        può essere impostato usando il comando <cmdref targ="set"/>.
      </para> 
      <para context="cli">
        Se si usa l'opzione <lit>--lagselect</lit>, il primo parametro del comando
	<lit>var</lit> viene interpretato come il massimo ordine di ritardo.
        In questo caso, il comando non produce il solito risultato della stima del VAR, ma
        una tabella che mostra i valori dei criteri di informazione di Akaike
        (AIC), Schwartz (BIC) e Hannan&ndash;Quinn (HQC) calcolati per VAR
        dall'ordine 1 fino all'ordine massimo indicato, in modo da aiutare nella
        scelta dell'ordine di ritardo ottimale.
       </para>

    </description>

    <gui-access>
      <menu-path>/Modello/Serie storiche/VAR - Autoregressione vettoriale</menu-path>
    </gui-access>

  </command>
  
  <command name="VAR-lagselect" section="Tests" context="gui"
    label="Scelta dell'ordine di ritardi in un VAR">

    <description>
      <para>
        In questa finestra di dialogo è possibile testare la stima di un VAR
        per diversi ordini di ritardi; oltre a indicare la specificazione del
        VAR è possibile selezionare il massimo ordine di ritardi da testare.
      </para>

      <para>
        Il risultato consiste in una tabella che mostra i valori dei criteri
        di informazione di Akaike (AIC), Schwartz (BIC) e Hannan&ndash;Quinn (HQC)
        calcolati per VAR dall'ordine 1 fino all'ordine massimo indicato.
      </para>
    </description>

  </command>

  <command name="VAR-omit" section="Tests" context="gui"
    label="Test per variabili esogene in un VAR">

    <description>
      <para>
        In questa finestra di dialogo è possibile testare l'omissione da un VAR
        di un gruppo di variabili esogene.
      </para>
      <para>
        Viene calcolato un test del rapporto di verosimiglianza sotto l'ipotesi
        nulla che i coefficienti delle variabili indicate valgano zero in
        tutte le equazioni del VAR. Il test si basa sulla differenza tra il
        log-determinante della matrice di varianza per il modello non vincolato
        e per il modello con il vincolo che i coefficienti delle variabili
        indicate valgano zero.
      </para>
    </description>

  </command>

  <command name="varlist" section="Dataset" context="cli">

    <description>
      <para>
	Mostra un elenco delle variabili disponibili.
	<cmd>list</cmd> e <cmd>ls</cmd> sono sinonimi. 
      </para>
    </description>

  </command>

  <command name="vartest" section="Tests"
    label="Test per la differenza delle varianze">

    <usage>
      <arguments>
        <argument>var1</argument>
        <argument>var2</argument>
      </arguments>
    </usage>

    <description>
      <para context="cli">
	Calcola la statistica <mathvar>F</mathvar> per l'ipotesi nulla
        che le varianze della popolazione per le variabili
	<repl>var1</repl> e <repl>var2</repl> siano uguali e mostra il
        p-value.
      </para>
      <para context="gui">
        Calcola la statistica <mathvar>F</mathvar> per l'ipotesi nulla
        che le varianze della popolazione per le variabili selezionate
        siano uguali e mostra il p-value.
      </para>
    </description>

    <gui-access>
      <menu-path>/Dati/Differenza delle varianze</menu-path>
    </gui-access>

  </command>

  <command name="vecm" section="Estimation"
    label="Vector Error Correction Model">

    <usage>
      <arguments>
        <argument>ordine</argument>
	<argument>rango</argument>
        <argument>lista-variabili</argument>
      </arguments>
      <options>
        <option>
	  <flag>--nc</flag>
	  <effect>senza costante</effect>
        </option>
        <option>
	  <flag>--rc</flag>
	  <effect>costante vincolata</effect>
        </option>
        <option>
	  <flag>--crt</flag>
	  <effect>costante e trend vincolato</effect>
        </option>
        <option>
	  <flag>--ct</flag>
	  <effect>costante e trend non vincolato</effect>
        </option>
        <option>
	  <flag>--seasonals</flag>
	  <effect>include dummy stagionali centrate</effect>
        </option>
        <option>
	  <flag>--impulse-responses</flag>
	  <effect>mostra impulso-risposta</effect>
        </option>
        <option>
	  <flag>--variance-decomp</flag>
	  <effect>mostra decomposizioni della varianza delle previsioni</effect>
        </option>
      </options>
      <examples>
        <example>vecm 4 1 Y1 Y2 Y3</example>
        <example>vecm 3 2 Y1 Y2 Y3 --rc</example>
      </examples>
    </usage>

    <description>
      <para>
	Un VECM è un tipo di autoregressione vettoriale, o VAR (si veda <cmdref
	  targ="var"/>), applicabile quando le variabili del modello sono
        individualmente integrate di ordine 1 (ossia, sono <quote>random walk</quote>
        con o senza deriva), ma esibiscono cointegrazione. Questo comando è
        strettamente connesso al test di Johansen per la cointegrazione (si veda
	<cmdref targ="coint2"/>).
      </para>
      <para context="cli">
        Il parametro <repl>ordine</repl> rappresenta l'ordine di ritardo del
        sistema VAR. Il numero di ritardi nel VECM (dove la variabile dipendente
        è data da una differenza prima) è pari a <repl>ordine</repl> meno uno.
      </para>
      <para context="gui">
        L'ordine di ritardo selezionato nella finestra di dialogo del VECM è
        quello del sistema VAR.  Per ottenere il numero di ritardi nel VECM
        (dove la variabile dipendente è data da una differenza prima) occorre
        sottrarre uno da questo numero.
      </para>
      <para context="cli">
        Il parametro <repl>rango</repl> rappresenta il rango di cointegrazione,
        o in altre parole il numero di vettori di cointegrazione. Questo deve
        essere maggiore di zero e minore o uguale (in genere minore) al numero
        di variabili endogene contenute nella <repl>lista variabili</repl>.
      </para>
      <para context="gui">
	Il <quote>rango di cointegrazione</quote> rappresenta il numero di
        vettori di cointegrazione. Questo deve essere maggiore di zero e minore
        o uguale (in genere minore) al numero di variabili endogene selezionate.
      </para>
      <para context="cli">
        La <repl>lista-variabili</repl> rappresenta l'elenco delle variabili
        endogene, nei livelli. L'inclusione di trend deterministici nel modello
        è controllata dalle opzioni del comando. Se non si indica alcuna
        opzione, viene inclusa una <quote>costante non vincolata</quote>, che
        permette la presenza di un'intercetta diversa da zero nelle relazioni di
        cointegrazione e di un trend nei livelli delle variabili endogene. Nella
        letteratura originata dal lavoro di Johansen (si veda ad esempio il suo
        libro del 1995), si fa riferimento a questo come al <quote>caso
        3</quote>.  Le prime quattro opzioni mostrate sopra, che sono
        mutualmente esclusive, producono rispettivamente i casi 1, 2, 4 e 5. Il
        significato di questi casi e i criteri per scegliere tra di essi sono
        spiegati nella <guideref targ="vecm-explanation"/>.
      </para>
      <para context="gui">
        Nel riquadro <quote>Variabili endogene</quote>, è possibile selezionare
        il vettore delle variabili endogene, in livelli. L'inclusione di trend
        deterministici nel modello è controllata dai pulsanti opzionali.  Se non
        si seleziona alcuna opzione, viene inclusa una <quote>costante non
        vincolata</quote>, che permette la presenza di un'intercetta diversa da
        zero nelle relazioni di cointegrazione e di un trend nei livelli delle
        variabili endogene. Nella letteratura originata dal lavoro di Johansen
        (si veda ad esempio il suo libro del 1995), si fa riferimento a questo
        come al <quote>caso 3</quote>.  Le prime quattro opzioni mostrate sopra,
        che sono mutualmente esclusive, producono rispettivamente i casi 1, 2, 4
        e 5. Il significato di questi casi e i criteri per scegliere tra di essi
        sono spiegati nella <guideref targ="vecm-explanation"/>.
      </para>
      <para context="cli">
        L'opzione <lit>--seasonals</lit>, che può accompagnare una qualsiasi
        delle altre opzioni, specifica l'inclusione di un gruppo di variabili
        dummy stagionali centrate. Questa opzione è disponibile solo per dati
        trimestrali o mensili.
      </para>
      <para context="gui">
	Se i dati sono trimestrali o mensili, è presente anche una casella che
        permette di includere un gruppo di variabili dummy stagionali centrate.
	In tutti i casi, la casella <quote>Mostra dettagli</quote> permette di
        vedere il risultato delle regressioni ausiliarie che sono il punto di
        partenza per la procedura di stima di massima verosimiglianza di
        Johansen.
      </para>
      <para context="cli">
        Il primo degli esempi mostrati sopra specifica un VECM con ordine di
        ritardo pari a 4 e un unico vettore di cointegrazione. Le variabili
        endogene sono <lit>Y1</lit>, <lit>Y2</lit> e <lit>Y3</lit>. Il secondo
        esempio usa le stesse variabili ma specifica un ritardo di ordine 3 e
        due vettori di cointegrazione, oltre a specificare una <quote>costante
        vincolata</quote>, che è appropriata se i vettori di cointegrazione
        possono avere un'intercetta diversa da zero, ma le variabili
        <lit>Y</lit> non hanno trend.
      </para>
    </description>

    <gui-access>
      <menu-path>/Model/Time series/VECM</menu-path>
    </gui-access>

  </command>

  <command name="vif" section="Tests" context="cli"
    label="Fattori di inflazione della varianza">

    <description>
      <para>
	Deve seguire la stima di un modello che includa almeno due variabili
	indipendenti. Calcola e mostra i fattori di inflazione della varianza
	(Variance Inflation Factors - VIF) per i regressori.  Il VIF
	per il regressore <mathvar>j</mathvar> è definito come
	<equation status="display" 
	  tex="\[\frac{1}{1-R_j^2}\]"
	  ascii="1/(1 - Rj^2)"
	  graphic="vif"/> dove <mathvar>R<sub>j</sub></mathvar> è il
	coefficiente di correlazione multipla tra il regressore
	<mathvar>j</mathvar> e gli altri regressori. Il fattore ha un valore
        minimo di 1.0 quando la variabile in questione è ortogonale alle altre
        variabili indipendenti.  Neter, Wasserman e Kutner (1990) suggeriscono
        di usare il VIF maggiore come test diagnostico per la collinearità; un
        valore superiore a 10 è in genere considerato indice di un grado di
        collinearità problematico.
      </para>
    </description>

    <gui-access>
      <menu-path>Finestra del modello, /Test/collinearità</menu-path>
    </gui-access>

  </command>

  <command name="wls" section="Estimation"
    label="Stima minimi quadrati ponderati">

    <usage>
      <arguments>
        <argument>variabile-pesi</argument>
        <argument>variabile-dipendente</argument>
	<argument>variabili-indipendenti</argument>
      </arguments>
      <options>
        <option>
	  <flag>--vcv</flag>
	  <effect>mostra la matrice di covarianza</effect>
        </option>
	<option>
	  <flag>--robust</flag>
	  <effect>errori standard robusti</effect>
        </option>
        <option>
	  <flag>--quiet</flag>
	  <effect>non mostra i risultati</effect>
        </option>
      </options> 
    </usage>

    <description>
      <para context="cli">
	Calcola stime con minimi quadrati ponderati (WLS - Weighted Least
        Squares), prendendo i pesi da <repl>variabile-pesi</repl>.
        In pratica, detta <repl>w</repl> la radice quadrata positiva della
        <lit>variabile-pesi</lit>, viene calcolata una regressione OLS di
        <repl>w</repl> <lit>*</lit> <repl>variabile-dipendente</repl> rispetto a
        <repl>w</repl> <lit>*</lit> <repl>variabili-indipendenti</repl>.
        L'<emphasis>R</emphasis>-quadro, comunque, è calcolato in un modo
        speciale, ossia come
        <equation status="display"
          tex="\[R^2 = 1 - \frac{\rm ESS}{\rm WTSS}\]"
          ascii="R^2 = 1 - ESS / WTSS"
          graphic="wlsr2"/> dove ESS è la somma dei quadrati degli errori (somma
        dei quadrati dei residui) dalla regressione ponderata, mentre WTSS
        denota la <quote>somma totale ponderata dei quadrati</quote>, che è pari 
        alla somma dei quadrati dei residui della regressione della variabile
        dipendente ponderata sulla sola costante ponderata.
      </para>
      <para>
        <repl>variabile-pesi</repl> è una variabile dummy, la stima WLS
        equivale a eliminare tutte le osservazioni per cui essa vale zero.
      </para>
      <para context="gui">
	Detta "variabile-pesi" la variabile scelta nel campo "Variabile
        pesi", viene stimata una regressione OLS in cui la variabile
        dipendente è il prodotto della variabile dipendente selezionata
        e della radice quadrata della variabile-pesi, e anche le variabili
        indipendenti sono moltiplicate per la radice quadrata della variabile-pesi.
        Le statistiche della regressione, come l'<emphasis>R</emphasis>-quadro
        sono basate sui dati ponderati. Se la variabile-pesi è una
        variabile dummy, ciò equivale a eliminare tutte le osservazioni
        per cui essa vale zero.</para>
    </description>

    <gui-access>
      <menu-path>/Modello/WLS - Minimi quadrati ponderati</menu-path>
    </gui-access>

  </command>
 
  <command name="xtab" section="Statistics" context="cli">

    <usage>
      <arguments>
        <argument>variabile1 variabile2</argument>
      </arguments>
      <options>
	<option>
	  <flag>--chi-square</flag>
	  <effect>mostra i risultati del test chi-quadro</effect>
        </option>
        <option>
	  <flag>--row</flag>
	  <effect>mostra le percentuali per riga</effect>
        </option>
        <option>
	  <flag>--column</flag>
	  <effect>mostra le percentuali per colonna</effect>
        </option>
        <option>
	  <flag>--zeros</flag>
	  <effect>mostra i valori pari a zero</effect>
        </option>
      </options>
    </usage>

    <description>
      <para>
        Se non vengono usate opzioni, mostra la tabella di contingenza tra
        la <repl>variabile1</repl> per riga e la <repl>variabile2</repl> per
        colonna; ognuna di esse può essere referenziata per nome o per numero.
        Si noti che entrambe le variabili devono essere marcate come discrete.
      </para>
      <para>
	Le opzioni <lit>--row</lit> e <lit>--column</lit> sono mutualmente
        esclusive; al posto del conteggio delle frequenze, mostrano le
        percentuali, rispettivamente per ogni riga e ogni colonna. L'opzione
	<lit>--zeros</lit> può essere utile per importare la tabella in un altro
        programma, ad esempio un foglio elettronico.
      </para>
      <para>
        Il test chi quadro di Pearson per l'indipendenza viene mostrato
        automaticamente se la frequenza attesa nell'ipotesi di indipendenza è
        superiore a 5 per almeno l'80 per cento delle celle. L'opzione
	<lit>--chi-square</lit> fa in modo che il test sia mostrato in tutti i
        casi.
      </para>

    </description>

  </command>

</commandlist>

