  <?PSGML NOFILL programlisting example informalequation?>

  <chapter id="c-cmdref">
    <title>Guía de Instrucciones</title>

    <sect1 id="cmd-intro">
      <title>Introducción</title>

      <para>Las instrucciones definidas en esta sección pueden ejecutarse en el
      programa cliente de línea de instrucciones. También pueden incluirse en un
      archivo o <quote>lote de instrucciones</quote> (script) y así ejecutarse en el
      GUI, o teclearse mediante el modo consola de este último. En la mayoría
      de los casos la sintaxis que se menciona es también aplicable para
      rellenar una línea en el correspondiente cuadro de diálogo del GUI (véase también la
      ayuda <emphasis>en línea</emphasis> de <application>gretl</application>),
      excepto que <emphasis>no</emphasis> es preciso teclear la palabra
      inicial de la instrucción - está implícita por el contexto. Una diferencia
      adicional es que no se puede insertar la marca <command>-o</command>
      para las instrucciones de regresión en los cuadros de diálogo del GUI: hay
      una opción de menú para mostrar la matriz formada por las varianzas y
      covarianzas de los coeficientes (que es el efecto de
      <command>-o</command> en las instrucciones de las regresiones).</para>

      <para>A lo largo de este capítulo se utilizan las siguientes convenciones:</para>

      <itemizedlist>
        <listitem>
          <para>La fuente <literal>typewriter</literal> se utiliza en lo
          que tecleamos directamente, y también para los nombres internos de
          las variables.</para>
        </listitem>

        <listitem>
          <para>Los términos en <replaceable>cursiva</replaceable> son
          marcadores de ubicación: es posible sustituirlos por algo más
          específico, por ejemplo, se puede escribir <varname>renta</varname>
          en lugar del genérico <replaceable>varx</replaceable>.</para>
        </listitem>

        <listitem>
          <para><literal>[ -o ]</literal> significa que la marca
          <command>-o</command> es opcional: puede ser añadida o no (pero en
          todo caso sin los paréntesis).</para>
        </listitem>

        <listitem>
          <para>La frase <quote>instrucción de estimación</quote>
          puede significar cualquiera de las siguientes <command>ols</command>,
          <command>hilu</command>, <command>corc</command>,
          <command>ar</command>, <command>arch</command>, <command>hsk</command>,
          <command>tsls</command>, <command>wls</command>, <command>hccm</command>,
          <command>add</command> y <command>omit</command>.</para>
        </listitem>
      </itemizedlist>

      <para>Las referencias a secciones y capítulos en lo que sigue se
      refieren al libro de Ramanathan (2002).</para>
    </sect1>

    <sect1 id="cmd-cmd">
      <title>Instrucciones de <application>gretl</application></title>

      <sect2 id="add">
        <title>add</title>
	<para>(añadir)</para>
        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumento:</entry>

                <entry><replaceable>lista_var</replaceable> <literal>[ -o ]</literal></entry>
              </row>

              <row>
                <entry>Ejemplos:</entry>

                <entry><command>add 5 7 9</command></entry>
              </row>

              <row>
                <entry></entry>

                <entry><command>add xx yy zz -o</command></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Debe de invocarse después de la instrucción de estimación. Las
        variables en <replaceable>lista_var</replaceable> se añaden al modelo
        que había previamente y se estima el nuevo modelo. Si se añade más de
        una variable, se mostrará el estadístico <emphasis>F</emphasis> para
        las variables añadidas (sólo para el método MCO) junto con
        su valor p. Un valor p de menos de 0.05 significa
        que los coeficientes son conjuntamente significativos al nivel del 5
        por ciento. Podemos recuperar algunas variables internas a través
        de la instrucción <command>genr</command>, invocando
        <command>genr</command> directamente después de esta instrucción. La marca
        <literal>-o</literal> hace que se muestre la matriz de varianzas y
        covarianzas.</para>
      </sect2>

      <sect2 id="addto">
        <title>addto</title>
	<para>(añadir a)</para>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumentos:</entry>

                <entry><replaceable>ID_de_modelo lista_var</replaceable></entry>
              </row>

              <row>
                <entry>Ejemplo:</entry>

                <entry><command>addto 2 5 7 9</command></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Funciona como la instrucción <command>add</command>, con la
        diferencia de que hay que indicar un modelo previo (utilizando su
        número de identificación, que se muestra al principio de los resultados del
        modelo) que se toma como base para añadir las variables. En el ejemplo de
        arriba se añaden las variables con números 5, 7 y 9 al modelo 2.</para>
      </sect2>

      <sect2 id="adf">
        <title>adf </title>
	<para>(Dickey-Fuller)</para>
        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumentos:</entry>

                <entry><replaceable>orden nombre_var</replaceable></entry>
              </row>

              <row>
                <entry>Ejemplo:</entry>

                <entry><command>adf 2 x1</command></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Calcula los estadísticos para dos contrastes de Dickey-Fuller.
        En ambos casos, la hipótesis nula es que la variable en cuestión presenta
        una raiz unitaria. El primero es un contraste <emphasis>t</emphasis>
        basado en el modelo <informalequation><alt role="tex">\[(1-L)x_t=m+gx_{t-1}+\epsilon_t\]</alt><graphic
        fileref="figures/adf1" /></informalequation> La hipótesis nula es que
        <emphasis>g</emphasis> = 0. El segundo contraste (aumentado) se hace
        estimando una regresión sin restricciones (con una constante,
        tendencia, el primer retardo de la variable, y un número igual a
        <replaceable>orden</replaceable> de retardos de la primera diferencia
        como los regresores), y una versión restringida (omitiendo la
        tendencia y el primer retardo). El estadístico de contraste es
        <informalequation><alt role="tex">\[F_{2,T-k}=\frac{(ESS_r-ESS_u)/2}{ESS_u/(T-k)}\]</alt><graphic
        fileref="figures/adf2" /></informalequation>donde
        <emphasis>T</emphasis> es el tamaño de la muestra,
        <emphasis>k</emphasis> el número de parámetros en el modelo sin
        restricciones, y los subíndices <emphasis>u</emphasis> y
        <emphasis>r</emphasis> significan los modelos sin restricciones y
        restringido respectivamente. Nótese que los valores
        críticos para estos estadísticos no son los habituales; se muestra un
        rango para el valor p, cuando puede determinarse.</para>
      </sect2>

      <sect2 id="ar">
        <title>ar</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumentos:</entry>

                <entry><replaceable>retardos</replaceable> <literal>;</literal>
                <replaceable>vardep varindeps</replaceable>
                <literal>[ -o ]</literal></entry>
              </row>

              <row>
                <entry>Ejemplo:</entry>

                <entry><command>ar 1 3 4 ; y 0 x1 x2 x3</command></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Calcula las estimaciones de los parámetros utilizando el
        procedimiento iterativo generalizado de Cochrane-Orcutt (véase Sección
        9.5 del libro de Ramanathan). Las iteraciones se dan por finalizadas cuando las
        sucesivas sumas de cuadrados de los errores no difieren en más de un 0.005
        por ciento, o después de 20 iteraciones. <replaceable>retardos</replaceable>
        es una lista de retardos de los residuos, y termina con un punto y
        coma. En el ejemplo de arriba, el término de error se especifica
        como <informalequation><alt role="tex">\[u_t = \rho_1u_{t-1} + \rho_3
        u_{t-3} + \rho_4 u_{t-4} + e_t\]</alt><graphic fileref="figures/corc" /></informalequation>
        <replaceable>vardep</replaceable> es la variable dependiente y
        <replaceable>varindeps</replaceable> es la lista de las variables
        independientes. Poner la marca <literal>-o</literal> hace que se
        muestre la matriz de covarianzas de los coeficientes de la regresión.
        Los residuos de la regresión transformada se guardan con el nombre de
        <varname>uhat</varname>, y se pueden recuperar mediante <command>genr</command>.
        Otras variables internas pueden recuperarse utilizando la instrucción
        <command>genr</command>, invocando
        <command>genr</command> después de esta instrucción.</para>
      </sect2>

      <sect2 id="arch">
        <title>arch</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumentos:</entry>

                <entry><replaceable>orden vardep varindep</replaceable>
                <literal>[ -o ]</literal></entry>
              </row>

              <row>
                <entry>Ejemplo:</entry>

                <entry><command>arch 4 y 0 x1 x2 x3</command></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Esta instrucción contrasta la posibilidad de ARCH (Autoregressive Conditional
        Heteroskedasticity - Heterocedasticidad Condicional Autorregresiva) en el modelo,
        del orden de retardos especificado en <replaceable>orden</replaceable>,
        que tiene que ser un número entero. Si el estadístico de contraste
        LM tiene un valor p menor que 0.10, entonces
        también se lleva a cabo la estimación ARCH. Si la varianza estimada de
        alguna observación en la regresión auxiliar no es positiva, entonces
        se utiliza el cuadrado del residuo correspondiente en su lugar. En
        este caso, se hace la estimación mínimo-cuadrática ponderada sobre el
        modelo original. La marca <literal>-o</literal> muestra la matriz de
        covarianzas de los coeficientes.</para>
      </sect2>

      <sect2 id="chow">
        <title>chow</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumento:</entry>

                <entry><replaceable>observación</replaceable></entry>
              </row>

              <row>
                <entry>Ejemplo:</entry>

                <entry><command>chow 25</command></entry>
              </row>

              <row>
                <entry></entry>

                <entry><command>chow 1988.1</command></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Tiene que ejecutarse después de una regresión MCO. Crea una variable
        ficticia que es igual a 1 desde el punto de corte especificado por
        <replaceable>observación</replaceable> hasta el final de la muestra, y 0 en el resto.
	También crea los términos de interacción entre esta
        variable ficticia y las variables independientes originales. Se
        ejecuta una regresión aumentada incluyendo estos términos y se calcula
        un estadístico <emphasis>F</emphasis>, tomando la regresión aumentada
        como la no restringida y la original como la restringida. Este
        estadístico es apropiado para hacer un contraste de la hipótesis nula
        de que no existe cambio estructural en el punto de ruptura
        especificado.</para>
      </sect2>

      <sect2 id="coint">
        <title>coint</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumentos:</entry>

                <entry><replaceable>orden vardep varindeps</replaceable></entry>
              </row>

              <row>
                <entry>Ejemplos:</entry>

                <entry><command>coint 2 y x</command></entry>
              </row>

              <row>
                <entry></entry>

                <entry><command>coint 4 y x1 x2</command></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Lleva a cabo los contrastes de Dickey-Fuller Aumentados de la
        hipótesis nula de que cada una de las variables incluidas en
        la lista tiene una raíz unitaria, utilizando el orden de retardos
        especificado. Se estima la regresión cointegrante y se hace un
        contraste ADF sobre los residuos que resultan de esta regresión.
        También se proporciona el estadístico de Durbin-Watson para la regresión
        cointegrante. Téngase en cuenta que ninguno de estos estadísticos de
        contraste pueden compararse con las tablas estadísticas habituales.</para>
      </sect2>

      <sect2 id="corc">
        <title>corc</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumentos:</entry>

                <entry><replaceable>vardep varindeps</replaceable>
                <literal>[ -o ]</literal></entry>
              </row>

              <row>
                <entry>Ejemplos:</entry>

                <entry><command>corc 1 0 2 4 6 7</command></entry>
              </row>

              <row>
                <entry></entry>

                <entry><command>corc -o 1 0 2 4 6 7</command></entry>
              </row>

              <row>
                <entry></entry>

                <entry><command>corc y 0 x1 x2 x3</command></entry>
              </row>

              <row>
                <entry></entry>

                <entry><command>corc -o y 0 x1 x2 x3</command></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Calcula las estimaciones de los parámetros utilizando el
        procedimiento iterativo de Cochrane-Orcutt (véase Sección 9.4 en el libro de
        Ramanathan) con <replaceable>depvar</replaceable> como variable
        dependiente y <replaceable>varindeps</replaceable> como lista de
        variables independientes. Las iteraciones se dan por terminadas cuando
        estimaciones sucesivas de los coeficientes de autocorrelación muestran
        diferencias menores que 0.001, o después de 20 iteraciones. Si
        se indica la marca <literal>-o</literal>, se muestra la matriz de
        covarianzas de los coeficientes de la regresión. Los residuos de esta
        regresión transformada se guardan con el nombre de <varname>uhat</varname>.
        Se pueden recuperar varias variables internas utilizando la instrucción
        <command>genr</command>, siempre que invoquemos <command>genr</command>
        inmediatamente después de esta instrucción.</para>
      </sect2>

      <sect2 id="corr">
        <title>corr</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumento:</entry>

                <entry>[ <replaceable>lista_var</replaceable> ]</entry>
              </row>

              <row>
                <entry>Ejemplos:</entry>

                <entry><command>corr 1 3 5</command></entry>
              </row>

              <row>
                <entry></entry>

                <entry><command>corr y x1 x2 x3</command></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Muestra los coeficientes de correlación de las variables de la lista
        <replaceable>lista_var</replaceable>, o de todas las variables en el
        conjunto de datos si no se especifica <replaceable>lista_var</replaceable>.</para>
      </sect2>

      <sect2 id="corrgm">
        <title>corrgm</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumentos:</entry>

                <entry><replaceable>variable</replaceable> [
                <replaceable>maxret</replaceable> ]</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Muestra los valores de la función de autocorrelación de la
        <replaceable>variable</replaceable> especificada (bien por su nombre o
        por su número). Véase Ramanathan, Sección 11.7. Calcula, por lo tanto,
        <inlineequation><alt role="tex">$\rho(u_t, u_{t-s})$</alt><inlinemediaobject><imageobject><imagedata
        align="center" fileref="figures/autocorr" /></imageobject></inlinemediaobject></inlineequation>
        donde <emphasis>u</emphasis><subscript><emphasis>t</emphasis></subscript>
        es la <emphasis>t</emphasis>-ésima observación de la variable
        <emphasis>u</emphasis> y <emphasis>s</emphasis> es el número de
        retardos.</para>

        <para>También se muestran las correlaciones parciales: estas son el
        resultado neto después de descontar los efectos de los retardos
        intermedios. La instrucción también dibuja el gráfico del correlograma y
        proporciona el estadístico <emphasis>Q</emphasis> de Ljung-Box para
        contrastar la hipótesis nula de que la serie es
        <quote>ruido blanco</quote>. Este estadístico se distribuye
        asintóticamente como una chi-cuadrado con los grados de libertad
        iguales al número de retardos utilizados.</para>

        <para>Si se aporta el valor <replaceable>maxret</replaceable> en forma
        de un número entero (opcional), la longitud del correlograma se
        limita, como máximo, a este número de retardos, de otro modo, la
        longitud se determinará de manera automática.</para>
      </sect2>

      <sect2 id="criteria">
        <title>criteria</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumentos:</entry>

                <entry><replaceable>scr T k</replaceable></entry>
              </row>

              <row>
                <entry>Ejemplo:</entry>

                <entry><command>criteria 23.45 45 8</command></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Calcula los estadísticos de selección de modelos (véase
        Ramanathan, Sección 4.3), dada la <replaceable>scr</replaceable> (suma
        de cuadrados residual), el número de observaciones (<emphasis>T</emphasis>),
        y el número de coeficientes (<emphasis>k</emphasis>).
        <emphasis>T</emphasis>, <emphasis>k</emphasis>, y
        <replaceable>scr</replaceable> pueden ser nombres o valores numéricos
        de las variables definidas previamente.</para>
      </sect2>

      <sect2 id="cusum">
        <title>cusum</title>

        <para>Debe ejecutarse despues de la estimación de un modelo mediante MCO.
        Realiza el contraste CUSUM de estabilidad de los parámetros. Se
        obtiene una serie de errores de predicción un-paso-adelante
        (tipificados) mediante la ejecución de una serie de regresiones: la
        primera regresión utiliza las primeras <emphasis>k</emphasis>
        observaciones para generar una predicción de la variable dependiente
        en la observación <emphasis>k</emphasis> + 1; la segunda utiliza las
        primeras <emphasis>k</emphasis> + 1 observaciones y genera una
        predicción para la observación <emphasis>k</emphasis> + 2, y así
        sucesivamente (donde <emphasis>k</emphasis> es el número de parámetros
        del modelo original). Se realiza el gráfico y se muestra la suma
        acumulada de los errores de predicción tipificados. La hipótesis nula
        de estabilidad de los parámetros se rechaza al nivel de significación
        del 5 por ciento si la suma acumulada sale fuera de la banda de
        confianza del 95 por ciento.</para>

        <para>Además, esta instrucción muestra el estadístico
        <emphasis>t</emphasis> de Harvey-Collier para comprobar la hipótesis
        nula de estabilidad de parámetros. Para más detalles, consultar el
        capítulo 7 del libro <citetitle>Econometric Analysis</citetitle> de Greene.</para>
      </sect2>

      <sect2 id="delete">
        <title>delete</title>
	<para>(borrar)</para>

        <para>Elimina la última variable (de número más alto) en el
        conjunto de datos actual. <emphasis>Utilizar con cuidado</emphasis>:
        no se pide ninguna confirmación. Puede ser útil para quitar variables
        ficticias temporales. No hay posibilidad de eliminar otra variable que
        no sea la última.</para>
      </sect2>

      <sect2 id="diff">
        <title>diff</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumento:</entry>

                <entry><replaceable>lista_var</replaceable></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Se obtiene la primera diferencia de cada variable de la lista
        <replaceable>lista_var</replaceable> y el resultado se guarda en una
        nueva variable con el prefijo <varname>d_</varname>. De este modo
        <command>diff x y</command> crea las variables nuevas
        <varname>d_x = x(t) - x(t-1)</varname> y <varname>d_y = y(t) - y(t-1)</varname>.</para>
      </sect2>

      <sect2 id="endloop">
        <title>endloop</title>
	<para>(fin de bucle)</para>

        <para>Da por finalizadas las iteraciones de un bucle. Véase
        <command>loop</command>.</para>
      </sect2>

      <sect2 id="eqnprint">
        <title>eqnprint</title>

        <para>Debe ejecutarse despues de la estimación de un modelo mediante MCO.
        Se guardan las estimaciones en formato de ecuación LaTeX, en un
        archivo cuyo nombre tiene la estructura
        <filename>equation_N.tex</filename>, donde <varname>N</varname> es el
        número de modelos estimados hasta el momento en la sesión actual. Dicho
        archivo puede incorporarse en un documento LaTeX. Para información
        adicional, véase <command>tabprint</command>.</para>
      </sect2>

      <sect2 id="fcast">
        <title>fcast</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumentos:</entry>

                <entry>[ <replaceable>primobs ultobs</replaceable> ]
                <replaceable>nuevo_nombre_var</replaceable></entry>
              </row>

              <row>
                <entry>Ejemplos:</entry>

                <entry><command>fcast 1997.1 1999.4 f1</command></entry>
              </row>

              <row>
                <entry></entry>

                <entry><command>fcast f2</command></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Debe de ejecutarse despues de una instrucción de estimación. Las predicciones se
        generan para el rango especificado (o el rango más grande posible si
        no hemos puesto los argumentos <replaceable> primobs</replaceable> y
        <replaceable>ultobs</replaceable>) y los valores se guardan como
        <replaceable>nuevo_nombre_var</replaceable>, que así pueden mostrarse
        o representarse en un gráfico. Las variables del lado derecho de la
        ecuación son las del modelo original. No hay posibilidad de
        sustituirlas por otras variables. Si se ha especificado un término de
        error autorregresivo (en <command>hilu</command>,
        <command>corc</command>, y <command>ar</command>) la predicción es
        condicional un-paso-adelante, e incorpora el proceso de error.</para>
      </sect2>

      <sect2 id="fcasterr">
        <title>fcasterr</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumentos:</entry>

                <entry><replaceable>primobs ultobs</replaceable>
                <literal>[ -o ]</literal></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Después de estimar un modelo mediante MCO que incluya
        una constante y al menos una variable independiente (estas
        restricciones pueden relajarse en un algún punto), se puede
        utilizar esta instrucción para mostrar los valores ajustados sobre el rango de
        observación especificado, junto con las desviaciones típicas estimadas de
        estas predicciones y los intervalos de 95 por ciento de confianza .
        Además, si se utiliza la opción <literal>-o</literal>, los resultados también se
        mostrarán en un gráfico gnuplot. Se utiliza el método de regresión
        aumentada de Salkever (1976) para generar los errores de predicción
        estándar.</para>
      </sect2>

      <sect2 id="fit">
        <title>fit</title>
	<para>(ajuste)</para>

        <para>Esta orden <command>fit</command> (que debe seguir a una instrucción
        de estimación) es un atajo a la instrucción <command>fcast</command>. Esta
        instrucción genera los valores ajustados, para la muestra actual, basándose en la
        última regresión y los guarda en una serie denominada <quote>autofit</quote>.
         En el caso de los modelos de series temporales,
        <command>fit</command> también muestra un gráfico gnuplot de los
        valores actuales y estimados de la variable dependiente a lo largo del
        tiempo.</para>
      </sect2>

      <sect2 id="freq">
        <title>freq</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumento:</entry>

                <entry><replaceable>freq nombre_var (o numero_var)</replaceable></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Muestra la distribución de frecuencias de
        <replaceable>nombre_var</replaceable> o <replaceable>numero_var</replaceable> junto con
        un contraste chi-cuadrado de normalidad. En el modo interactivo, se
        muestra un gráfico gnuplot de la distribución.</para>

        <para role="bodge">&nbsp;</para>

        <para role="bodge">&nbsp;</para>

        <!-- BODGE to make genr section title not an orphan -->
      </sect2>

      <sect2 id="genr">
        <title>genr</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumento:</entry>

                <entry><replaceable>nueva_var</replaceable> =
                <replaceable>formula</replaceable></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Crea variables nuevas, normalmente mediante transformaciones de
        variables ya existentes. Para más información sobre los posibles
        atajos, véase, <command>diff</command>, <command>logs</command>,
        <command>lags</command>, <command>ldiff</command>, <command>multiply</command>
        y <command>square</command>.</para>

        <para>El programa admite los siguientes <emphasis>operadores
        aritméticos</emphasis>, en orden de precendencia: <literal>^</literal>
        (exponenciación); <literal>*</literal>, <literal>/</literal> y
        <literal>%</literal> (módulo o resto); <literal>+</literal> y
        <literal>-</literal>.</para>

        <para>Los <emphasis>operadores Booleanos</emphasis> son (de nuevo 
        en orden de precedencia): <literal>!</literal> (negación),
        <literal>&amp;</literal> (Y lógica), <literal>|</literal> (O lógica),
        <literal>&gt;</literal>,
    <literal>&lt;</literal>, <literal>=</literal>,
    <literal>&gt;=</literal> (mayor o igual a),
        <literal>&lt;=</literal> (menor oigual a) y <literal>!=</literal>
        (no igual a). Es posible utilizar los operadores Booleanos para
        definir variables ficticias: por ejemplo, <literal>(x > 10)</literal>
        produce 1 si <literal>x</literal> > 10, y 0 en los demás casos. Las
        <emphasis>funciones</emphasis> permitidas pertenecen a los
        siguientes grupos:</para>

        <itemizedlist>
          <listitem>
            <para>Funciones matemáticas típicas: <function>abs</function>,
            <function>cos</function>, <function>exp</function>,
            <function>int</function> (parte entera del número),
            <function>ln</function> (logaritmo natural: <function>log</function>
            es un sinónimo), <function>sin</function> (seno), <function>sqrt</function>
            (raíz cuadrada)</para>
          </listitem>

          <listitem>
            <para>Funciones estadísticas: <function>max</function> (valor
            máximo de una serie), <function>min</function> (mínimo),
            <function>mean</function> (media aritmética),
            <function>median</function> (mediana), <function>var</function>
            (varianza), <function>sd</function> (desviación típica),
            <function>sum</function> (suma), <function>cov</function> (covarianza),
            <function>corr</function> (coeficiente de correlación),
            <function>pvalue</function> (valor p).</para>
          </listitem>

          <listitem>
            <para>Funciones de series temporales: <function>lag</function>
            (retardo), <function>lead</function> (avance),
            <function>diff</function> (primera diferencia),
            <function>ldiff</function> (diferencia logarítmica, o primera
            diferencia de los logaritmos naturales).</para>
          </listitem>

          <listitem>
            <para>Otros: <function>cum</function> (acumulación),
            <function>sort</function> (ordenar), <function>uniform</function> (distribución uniforme),
            <function>normal</function> (distribución normal), <function>misszero</function>
            (reemplazar el código de observación ausente en una serie con
            ceros), <command>zeromiss</command> (la operación inversa de
            <command>misszero</command>).</para>
          </listitem>
        </itemizedlist>

        <para>Todas las funciones citadas arriba a excepción de
        <function>cov</function>, <function>corr</function>,
        <function>pvalue</function>, <function>uniform</function> y
        <function>normal</function> toman como único argumento, o bien el
        nombre de la variable (nótese que, en una instrucción<command> genr</command>, no es posible referirse a las variables por su número de identificación )
        o bien una expresión compuesta que se evalúa como una variable (por
        ejemplo, <literal>ln((x1+x2)/2)</literal>). Tanto
        <function>cov</function> como <function>corr</function> requieren dos
        argumentos, y dan respectivamente la covarianza y el coeficiente de
        correlación de las dos variables nombradas. La función
        <function>pvalue</function> toma los mismos argumentos que la instrucción
        <command>pvalue</command> (véase abajo), pero en este contexto hay que
        poner comas entre los argumentos. <function>uniform()</function> y
        <function>normal()</function>, que no toman argumentos, devuelven
        series pseudoaleatorias extraídas respectivamente de las
        distribuciones uniforme (0-100) [Nota del traductor: (0-1) a partir de gretl-1.0.9] y normal reducida (véase también la
        instrucción <command>seed</command>). Las series uniformes se generan
        utilizando la función de biblioteca C <function>rand()</function>;
        para las series normales se emplea el método de Box y Muller (1958).</para>

        <para>Además de los operadores y funciones comentados aquí, hay
        algunos usos especiales de <command>genr</command>:</para>

        <itemizedlist>
          <listitem>
            <para><command>genr time</command> crea una variable de tendencia
            temporal (1,2,3,...) denominada <command>time</command>.</para>
	    <para>
            <command>genr; index</command> hace lo mismo excepto que la
            variable se denomina <varname>index</varname>.</para>
          </listitem>

          <listitem>
            <para><command>genr dummy</command> crea variables ficticias hasta
            la periodicidad de los datos. Por ejemplo, en el caso de datos
            trimestrales, (periodicidad 4), el programa crea
            <varname>dummy_1</varname> = 1 para el primer trimestre y 0 en los
            demás trimestres, <varname>dummy_2</varname> = 1 para el segundo
            trimestre y 0 en los otros trimestres, y así sucesivamente.</para>
          </listitem>

          <listitem>
            <para><command>genr paneldum</command> crea un conjunto de
            variables ficticias especiales para usar con datos de panel -
            véase el <xref linkend="c-panel" /> arriba.</para>
          </listitem>

          <listitem>
            <para>Es posible recuperar varias de las variables internas
            definidas mientras se ejecuta una regresión, utilizando
            <command>genr</command> como se describe a continuación:</para>

            <informaltable role="cmd" frame="none">
              <tgroup cols="2">
                <colspec colwidth="100pt" />

                <colspec colwidth="300pt" />

                <tbody>
                  <row>
                    <entry><varname>$ess</varname></entry>

                    <entry>suma de cuadrados de los residuos</entry>
                  </row>

                  <row>
                    <entry><varname>$rsq</varname></entry>

                    <entry><emphasis>R</emphasis>-cuadrado no ajustado</entry>
                  </row>

                  <row>
                    <entry><varname>$T</varname></entry>

                    <entry>número de observaciones utilizadas en el modelo</entry>
                  </row>

                  <row>
                    <entry><varname>$df</varname></entry>

                    <entry>grados de libertad</entry>
                  </row>

                  <row>
                    <entry><varname>$trsq</varname></entry>

                    <entry><emphasis>TR</emphasis>-cuadrado (tamaño muestral
                    multiplicado por <emphasis>R</emphasis>-cuadrado)</entry>
                  </row>

                  <row>
                    <entry><varname>$sigma</varname></entry>

                    <entry>desviación típica de los residuos</entry>
                  </row>

                  <row>
                    <entry><varname>$lnl</varname></entry>

                    <entry>log de la verosimilitud (en modelos logit y probit)</entry>
                  </row>

                  
                  <row>
                    <entry>coeff(<replaceable>var</replaceable>)</entry>

                    <entry>coeficiente estimado para la variable
                    <replaceable>var</replaceable></entry>
                  </row>

                  <row>
                    <entry>stderr(<replaceable>var</replaceable>)</entry>

                    <entry>desviación típica estimada para la variable
                    <replaceable>var</replaceable></entry>
                  </row>

                  <row>
                    <entry>rho(<replaceable>i</replaceable>)</entry>

                    <entry>coeficiente autoregresivo de orden
                    <replaceable>i</replaceable>-ésimo de los residuos</entry>
                  </row>

                  <row>
                    <entry>vcv(<replaceable>xi</replaceable>,<replaceable>xj</replaceable>)</entry>

                    <entry>covarianza entre los coeficientes de las variables
                    <replaceable>xi</replaceable> y
                    <replaceable>xj</replaceable></entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
          </listitem>
        </itemizedlist>

        <para><emphasis>Nota</emphasis>: En el programa cliente de línea de instrucciones,
        las instrucciones <command>genr</command> que recuperan datos relacionados
        con los modelos siempre se refieren al modelo estimado más
        recientemente. Esto mismo ocurre en el cliente GUI, si se utiliza
        <command>genr</command> en la <quote>consola de <application>gretl</application></quote> o se
        proporciona una formula a través de la opción <quote>Definir nueva variable</quote> en el menú Variable en la
        ventana principal. Sin embargo, con el GUI existe la opción de recuperar
        los datos de cualquier modelo que actualmente esté mostrándose en la
        ventana (independientemente de que sea el modelo más reciente o no).
        Esto se consigue desde el menú <quote>Datos del modelo</quote>
        en la ventana del modelo.</para>

        <para>Hay, además, otras tres variables <quote>internas</quote>
        disponibles: <varname>$nobs</varname> contiene el número de
        observaciones del rango de muestra actual (nótese que este puede o no
        ser equivalente al valor de <varname>$T</varname>, el cual se refiere
        al número de observaciones utilizadas en la estimación del modelo más
        reciente). La variable <varname>t</varname> sirve como un índice de
        las observaciones. Así por ejemplo,
        <literal>genr dum = (t=15)</literal> generará una variable ficticia
        que tiene el valor 1 para la observación número 15 y 0 en el resto.
        La variable <varname>$pd</varname> contiene la frecuencia o la
        periodicidad de los datos (por ejemplo, 4 para datos trimestrales).</para>

        <para>La <xref linkend="tab-genr" />ofrece varios ejemplos de los
        diferentes usos de <command>genr</command> con comentarios de explicación;
	a continuación hay un par de sugerencias a tener en
        cuenta sobre el uso de variables ficticias:</para>

        <itemizedlist>
          <listitem>
            <para>Supongamos que <varname>x</varname> se codifica con los
            valores 1, 2, ó 3 y Vd desea tres variables ficticias,
            <varname>d1</varname> = 1 si <varname>x</varname> = 1, 0 si no,
            <varname>d2</varname> = 1 si <varname>x</varname> = 2, y así
            sucesivamente. Para crear estas variables, utilize las
            siguientes instrucciones:
                    <programlisting>
          genr d1 = (x=1)
          genr d2 = (x=2)
          genr d3 = (x=3)</programlisting>
          </para>
          </listitem>

          <listitem>
            <para>Para obtener la serie <varname>z</varname> = <literal>max(x,y)</literal>
            haga 
            <programlisting>
          genr d = x&gt;y
          genr z = (x*d)+(y*(1-d))</programlisting>
          </para>
          </listitem>
        </itemizedlist>

        <table id="tab-genr" frame="none">
          <title>Ejemplos de uso de la instrucción genr</title>

          <tgroup cols="2">
            <thead>
              <row>
                <entry>Instrucción</entry>

                <entry>Comentario</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><command>genr y = x1^3</command></entry>

                <entry><command>x1</command> elevado al cubo</entry>
              </row>

              <row>
                <entry><command>genr y = ln((x1+x2)/x3)</command></entry>

                <entry></entry>
              </row>

              <row>
                <entry><command>genr z = x&gt;y</command></entry>

                <entry>asigna a <command>z(t)</command> el valor 1 si
                <command>x(t) &gt; y(t)</command> y 0 en caso contrario</entry>
              </row>

              <row>
                <entry><command>genr y = x(-2)</command></entry>

                <entry><varname>x</varname> retardada 2 periodos</entry>
              </row>

              <row>
                <entry><command>genr y = x(2)</command></entry>

                <entry><varname>x</varname> adelantada 2 periodos</entry>
              </row>

              <row>
                <entry><command>genr y = diff(x)</command></entry>

                <entry><command>y(t) = x(t) - x(t-1)</command></entry>
              </row>

              <row>
                <entry><command>genr y = ldiff(x)</command></entry>

                <entry><command>y(t) = log x(t) - log x(t-1)</command>, la
                tasa de crecimiento instantánea de <varname>x</varname></entry>
              </row>

              <row>
                <entry><command>genr y = sort(x)</command></entry>

                <entry>ordena <varname>x</varname> en orden creciente y lo
                guarda en <varname>y</varname></entry>
              </row>

              <row>
                <entry><command>genr y = -sort(-x)</command></entry>

                <entry>ordena <varname>x</varname> en orden decreciente</entry>
              </row>

              <row>
                <entry><command>genr y = int(x)</command></entry>

                <entry>trunca <varname>x</varname> y guarda su valor entero en
                <varname>y</varname></entry>
              </row>

              <row>
                <entry><command>genr y = abs(x)</command></entry>

                <entry>guarda los valores absolutos de <command>x</command></entry>
              </row>

              <row>
                <entry><command>genr y = sum(x)</command></entry>

                <entry>suma los valores de <varname>x</varname> excluyendo los
                valores perdidos -999</entry>
              </row>

              <row>
                <entry><command>genr y = cum(x)</command></entry>

                <entry>acumula: <inlineequation><alt role="tex">$y_t =
                \sum_{\tau=1}^t x_{\tau}$</alt><inlinemediaobject><imageobject><imagedata
                align="center" fileref="figures/cumulate" /></imageobject></inlinemediaobject></inlineequation></entry>
              </row>

              <row>
                <entry><command>genr aa = $ess</command></entry>

                <entry>define <varname>aa</varname> como la suma de
                cuadrados de los residuos de la última regresión</entry>
              </row>

              <row>
                <entry><command>genr x = coeff(sqft)</command></entry>

                <entry>guarda en <varname>x</varname> el coeficiente estimado de la variable
                <varname>sqft</varname> obtenido en el último modelo</entry>
              </row>

              <row>
                <entry><command>genr rho4 = rho(4)</command></entry>

                <entry>guarda en <varname>rho4</varname> el coeficiente autorregresivo de cuarto orden obtenido del último
                modelo (supone un modelo <command>ar</command>)</entry>
              </row>

              <row>
                <entry><command>genr cvx1x2 = vcv(x1, x2)</command></entry>

                <entry>guarda la covarianza de los coeficientes estimados de
                las vars <varname>x1</varname> y <varname>x2</varname> en el
                último modelo</entry>
              </row>

              <row>
                <entry><command>genr foo = uniform()/100</command></entry>

                <entry>variable pseudoaleatoria uniforme, de rango 0 a 1</entry>
              </row>

              <row>
                <entry><command>genr bar = 3 * normal()</command></entry>

                <entry>variable pseudoaleatoria normal , &mu = 0, &sigma =
                3</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>&nbsp;</para>
      </sect2>

      <sect2 id="gnuplot">
        <title>gnuplot</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumentos:</entry>

                <entry><replaceable>vars_y vars_x</replaceable>
                <literal>[ -o | -m ]</literal></entry>
              </row>

              <row>
                <entry></entry>

                <entry><command>gnuplot -z</command>
                <replaceable>var_y var_x ficticia</replaceable></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>En el primer caso, se representan las variables <replaceable>vars_y</replaceable>
        con respecto a las variables <replaceable>vars_x</replaceable>. Con la opción
        <literal>-o</literal>, el gráfico utilizará lineas; con la opción
        <literal>-m</literal>, el gráfico utilizará impulsos (lineas
        verticales); en los demás casos, se trazará con puntos.</para>

        <para>En el segundo caso, se representa <replaceable>var_y</replaceable> con
	respecto a <replaceable>var_x</replaceable> con los puntos en diferentes
        colores dependiendo de si el valor de la variable
        <replaceable>ficticia</replaceable> es 1 ó 0.</para>

        <para>Para realizar un gráfico de series temporales, se puede pedir
        <command>gnuplot</command> <replaceable>vars_y</replaceable>
        <varname>time</varname>. Si no existe previamente ninguna variable
        llamada <varname>time</varname>, entonces ésta se generará de forma
        automática. Se crearán variables ficticias especiales para
        representar datos mensuales y trimestrales.</para>

        <para>En modo interactivo, el resultado se pasa a gnuplot para que
        lo muestre en pantalla. En el modo de proceso por lotes, se escribe un
        archivo de gráfico llamado <filename>gpttmp01.plt</filename>. (Se
        crean archivos similares con el uso posterior de <command>gnuplot</command>,
        y se incrementa el número en el nombre del archivo para reflejar
        esto.) Se pueden volver a generar los gráficos más adelante utilizando la
        instrucción <command>gnuplot gpttmp.plt</command>. (En MS Windows, invocar
        <application>wgnuplot</application> y abrir el archivo
        <filename>gpttmp01.plt</filename>.) Si se quieren controlar los
        detalles del gráfico, se puede editar el archivo <filename>.plt</filename>.</para>
      </sect2>

      <sect2 id="graph">
        <title>graph</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumentos:</entry>

                <entry><replaceable>var1 var2</replaceable>
                <literal>[ -o ]</literal></entry>
              </row>

              <row>
                <entry></entry>

                <entry><command>graph</command> <replaceable>var1 var2 var3</replaceable></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Gráficos ASCII. En los dos primeros ejemplos, se representa la variable
        <replaceable>var1</replaceable> (que puede darse mediante un nombre o un número)
        contra la variable <replaceable>var2</replaceable>
        (eje x) utilizando símbolos ASCII. La opción <literal>-o</literal>
        trazará el gráfico con 40 filas y 60 columnas, sin ella el
        gráfico será de 20 por 60 (para ver los resultados en pantalla). En el
        tercer ejemplo, ambas variables<replaceable>
        var1</replaceable> y <replaceable>var2</replaceable> se representarán (sobre el eje y)
        contra <replaceable>var3</replaceable>. Esto es especialmente útil para representar los valores
        observados y predichos contra el tiempo. Véase también la instrucción
        <command>gnuplot</command>.</para>
      </sect2>

      <sect2 id="hausman">
        <title>hausman</title>

        <para>Este contraste sólo está disponible después de haber estimado
        un modelo mediante la instrucción <command>pooled</command> (véanse
        también <command>panel</command> y <command>setobs</command>). Se
        contrasta el modelo combinado simple contra las principales
        alternativas, es decir, contra los modelos de efectos fijos o de
        efectos aleatorios.</para>

        <para>En el modelo de efectos fijos se añade una variable ficticia para
        todas menos una de las unidades de sección cruzada, permitiendo de
        esta manera que el intercepto de la regresión varíe a través de las
        unidades. Se presenta un contraste <emphasis>F</emphasis> de significación
	conjunta de estas variables ficticias. En el modelo de
        efectos aleatorios se descompone la varianza residual en dos partes, una
        parte específica de la unidad de sección cruzada y la otra específica de
        la observación particular. (Sólo se puede calcular este estimador si
        el número de las unidades de sección cruzada en el conjunto de datos
        excede el número de parámetros a estimar). El estadístico de LM
        de Breusch-Pagan sirve para contrastar la hipótesis nula (de que el
        estimador MCO de datos combinados es adecuado) contra la
        alternativa del modelo de efectos aleatorios.</para>

        <para>El modelo de MCO combinados  puede ser
        rechazado contra ambas alternativas, es decir, la de efectos fijos y la de
        efectos aleatorios. Si el error específico de grupo o de unidad
        no está correlacionado con las variables independientes, el
        estimador de efectos aleatorios es más eficiente que el estimador de
        efectos fijos; en caso contrario, el estimador de efectos aleatorios resulta ser
        inconsistente, y es preferible el estimador de efectos fijos. La
        hipótesis nula para el contraste de Hausman indica que el error
        específico al grupo no esta correlacionado (y por lo tanto es
        preferible el modelo de efectos aleatorios). Un valor p bajo
        para este contraste lleva a rechazar el modelo de efectos
        aleatorios en favor del modelo de efectos fijos.</para>
      </sect2>

      <sect2 id="hccm">
        <title>hccm</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumentos:</entry>

                <entry><replaceable>vardep varindeps</replaceable>
                <literal>[ -o ]</literal></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Presenta las estimaciones de MCO junto con las desviaciones típicas
        de los coeficientes obtenidas por medio de una estimación consistente ante heterocedasticidad de
        la matriz de varianzas y covarianzas. Utiliza para ello el método <quote>jackknife</quote> de MacKinnon y White 	(1985) (véase Ramanathan, Sección 8.3). Si ponemos la marca <literal>-o</literal> se muestra la matriz de 		covarianzas de los coeficientes.</para>
      </sect2>

      <sect2 id="help">
        <title>help</title>

        <para>Proporciona una lista de las instrucciones disponibles en <application>gretl</application>.
        <command>Help instrucción</command> describe la <replaceable>instrucción</replaceable> (por ejemplo <command>help 	smpl</command>). Se puede teclear <command>man</command> en lugar de
        <command>help</command> si así se desea.</para>
      </sect2>

      <sect2 id="hilu">
        <title>hilu</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumentos:</entry>

                <entry><replaceable>vardep varindeps</replaceable>
                <literal>[ -o ]</literal></entry>
              </row>

              <row>
                <entry>Ejemplos:</entry>

                <entry><command>hilu 1 0 2 4 6 7</command></entry>
              </row>

              <row>
                <entry></entry>

                <entry><command>hilu -o y 0 x1 x2 x3</command></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Calcula las estimaciones de un modelo utilizando el
        procedimiento de red de búsqueda de Hildreth-Lu (se hace el ajuste fino con el procedimiento
        Cochrane-Orcutt) siendo <replaceable>vardep</replaceable> la variable
        dependiente y <replaceable>varindeps</replaceable> una lista con
        las variables independientes separadas por espacios. Se representa graficamente la suma de
        cuadrados de los residuos del modelo transformado contra los valores de
        rho desde -0.99 hasta 0.99. Si se utiliza la opción
        <literal>-o</literal>, también se mostrará la matriz de varianzas y covarianzas de los
        coeficientes de las regresiones . Los residuos de esta regresión
        transformada se guardan bajo el nombre de <varname>uhat</varname>.</para>

        <para role="bodge">&nbsp;</para>
      </sect2>

      <sect2 id="hsk">
        <title>hsk</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumentos:</entry>

                <entry><replaceable>vardep varindeps</replaceable>
                <literal>[ -o ]</literal></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Calcula las estimaciones corregidas de heterocedasticidad (véase
        Ramanathan, cap. 8) y sus estadísticos asociados. Se ajusta una regresión auxiliar
        para el logaritmo de los cuadrados de los residuos (utilizando los
        cuadrados de las variables independientes pero no sus productos
        cruzados), a partir de la cual se obtienen los estimadores
        de mínimos cuadrados ponderados del modelo inicial. Si se usa la opción
        <literal>-o</literal>, se mostrará también la matriz de varianzas y covarianzas estimada de los
        coeficientes de la regresión. Es posible recuperar varias de las
        variables internas mediante la instrucción <command>genr</command>, para ello
        ha de invocarse <command>genr</command> inmediatamente después
        de esta instrucción.</para>
      </sect2>

      <sect2 id="if">
        <title>if</title>

        <para>Control de flujo para la ejecución de instrucciones. La sintaxis es</para>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry><command>if</command> <replaceable>condición</replaceable></entry>
              </row>
              <row>
                <entry>&nbsp;<replaceable>instrucciones</replaceable></entry>
              </row>
              <row>
                <entry><command>else</command></entry>
              </row>
              <row>
                <entry>&nbsp;<replaceable>instrucciones</replaceable></entry>
              </row>
              <row>
                <entry><command>endif</command></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para><replaceable>condición</replaceable> tiene que ser una expresión
        Booleana; para ver su sintaxis, véase <xref linkend="genr" />. El
        bloque <command>else</command> es opcional; los bloques
        <literal>if ... endif </literal>pueden estar
        anidados.</para>
      </sect2>

      <sect2 id="import">
        <title>import</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumento:</entry>

                <entry><replaceable>nombre_de_archivo</replaceable> <literal>[ -o ]</literal></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Sin la opción <literal>-o</literal>, importa datos desde un
        archivo con formato CSV (comma-separated values - valores
        separados por comas), como por ejemplo los que se pueden escribir fácilmente
        desde cualquier programa de hoja de cálculo. Este archivo debe de tener los nombres de las
        variables en la primera linea, y una matriz de datos rectangular en
        las líneas restantes. Las variables deben de estar alineadas
        <quote>por observación</quote> (una columna por cada variable; cada
        fila representa una observación). Véase el <xref linkend="c-datafiles" /> para
        más detalles.</para>

        <para>Con la opción <literal>-o</literal>, lee archivos de datos en
        formato BOX1, como los que se obtienen utilizando el servicio de
        extracción de datos de la Oficina del Censo
        de los Estados Unidos (US Bureau of the Census).</para>
      </sect2>

      <sect2 id="info">
        <title>info</title>

        <para><command>info</command> muestra cualquier información contenida
        en el archivo de cabecera que corresponda al archivo de datos actual.
        (Esta información debe estar limitada entre <literal>(*</literal> y
        <literal>*)</literal>, estando situados estos marcadores
        en líneas separadas.)</para>
      </sect2>

      <sect2 id="labels">
        <title>labels</title>

        <para>Muestra las etiquetas informativas de cualquiera de las variables
        generadas utilizando <command>genr</command>, así como de cualquier
        etiqueta añadida al conjunto de datos mediante el GUI.</para>
      </sect2>

      <sect2 id="lad">
        <title>lad</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumentos:</entry>

                <entry><replaceable>vardep varindeps</replaceable></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Calcula una regresión que minimiza la suma de las desviaciones
        absolutas entre los valores observados y ajustados de la variable dependiente.
        Las estimaciones de los coeficientes
        se obtienen utilizando el algoritmo simplex de Barrodale-Roberts; si la solución obtenida no es única
	aparece un mensaje de aviso . Las desviaciones
        típicas se obtienen mediante el procedimiento <quote>bootstrap</quote> con 500
        extracciones.</para>
      </sect2>

      <sect2 id="lags">
        <title>lags</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumento:</entry>

                <entry><replaceable>lista_var</replaceable></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Crea variables nuevas que son los valores retardados de cada una de
        las variables en <quote>lista_var</quote>. El número de variables retardadas
	que se crean es igual a la periodicidad. Por ejemplo, si la periodicidad fuera 4 (datos trimestrales), la
        instrucción <command>lags x y</command> creará <varname>x_1</varname> =
        <varname>x(t-1)</varname>, <varname>x_2</varname> =
        <varname>x(t-2)</varname>, <varname>x_3</varname> =
        <varname>x(t-3)</varname> y <varname>x_4</varname> <varname>x(t-4);
        </varname> y de forma similar para <varname>y</varname>. Estas variables
        deben referenciarse de forma exacta, esto es, con el carácter de
        subrayado.</para>
      </sect2>

      <sect2 id="ldiff">
        <title>ldiff</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumento:</entry>

                <entry><replaceable>lista_var</replaceable></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Se obtiene la primera diferencia del logaritmo natural de cada
        variable de <quote>lista_var</quote> y el resultado se guarda en una variable nueva con
        el prefijo <varname>ld_</varname>. Por lo tanto <command>ldiff x y</command>
        crea las nuevas variables <varname>ld_x</varname> =
        <inlineequation><alt role="tex">$\ln(x_t) - \ln(x_{t-1})$</alt><inlinemediaobject><imageobject><imagedata
        align="center" fileref="figures/ldx" /></imageobject></inlinemediaobject></inlineequation>
        y <varname>ld_y</varname> = <inlineequation><alt role="tex">$\ln(y_t)
        - \ln(y_{t-1})$</alt><inlinemediaobject><imageobject><imagedata
        align="center" fileref="figures/ldy" /></imageobject></inlinemediaobject></inlineequation>.</para>
      </sect2>

      <sect2 id="lmtest">
        <title>lmtest</title>

        <para>Debe utilizarse justo despues de una instrucción <command>ols</command>. Calcula el
        estadístico de contraste del multiplicador de Lagrange (LM) (y los
        valores p asociados) para los contrastes de no linealidad y de
        heterocedasticidad (contraste de White) o, si se utiliza la opción
        <literal>-o</literal>, el estadístico de contraste LMF para
        correlación serial hasta la periodicidad (véase Kiviet, 1986). También
        se muestran los coeficientes de las regresiones auxiliares
        correspondientes. Véanse los Capítulos 7, 8, y 9 del libro de Ramanathan para más
        detalles. Solamente se utilizan los cuadrados de las variables
        independientes, y no sus productos cruzados. (No se obtienen los
        estadísticos de contraste LM si al crearse internamente los cuadrados de las variables
        independientes se aprecia multicolinealidad exacta.)</para>
      </sect2>

      <sect2 id="logit">
        <title>logit</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumentos:</entry>

                <entry><replaceable>vardep varindeps</replaceable></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Regresión logit binomial. La variable dependiente ha de ser una
        variable binaria. Se calculan las estimaciones máximo-verosímiles de los
        coeficientes para las <replaceable>varindeps</replaceable>
        mediante el método EM (Expectation-Maximization method) (véase Ruud,
        2000, ch. 27). Como el modelo no es lineal, las pendientes dependen de
        los valores de las variables independientes: las pendientes
        mencionadas se evalúan en las medias de estas variables. El
        estadístico de contraste chi-cuadrado contrasta la hipótesis nula de
        que todos los coeficientes son cero a excepción de la constante.</para>

        <para>Si queremos utilizar logit para llevar a cabo un análisis de
        proporciones (donde la variable dependiente es la proporción de casos
        con alguna característica en particular, en cada observación, en lugar
        de una variable 1 o 0 indicando si la característica esta presente o
        ausente) no debemos utilizar la instrucción <command>logit</command>, sino
	construir la variable logit (por ejemplo, mediante
        <command>genr lgt_p = log[p/(1 - p)]</command>]) y utilizar esta como
        la variable dependiente en una regresión MCO. Véase Ramanathan,
        cap. 12.</para>
      </sect2>

      <sect2 id="logs">
        <title>logs</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumento:</entry>

                <entry><replaceable>lista_var</replaceable></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Se obtiene el logaritmo natural de cada una de las variables en
        <replaceable>lista_var</replaceable> y el resultado se guarda en una nueva variable con el prefijo
        <literal>l_</literal>, que es una <quote>ele</quote> con el carácter desubrayado.
        <command>logs x y</command> crea las nuevas variables
        <varname>l_x</varname> = ln(<varname>x</varname>) y
        <varname>l_y</varname> = ln(<varname>y</varname>).</para>
      </sect2>

      <sect2 id="loop">
        <title>loop</title>
	<para>(bucle)</para>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Uso:</entry>

                <entry><command>loop</command> <replaceable>número_de_veces</replaceable></entry>
              </row>

              <row>
                <entry></entry>

                <entry><command>loop while</command>
                <replaceable>condición</replaceable></entry>
              </row>

              <row>
                <entry></entry>

                <entry><command>loop for i=</command>
                <replaceable>principio</replaceable><command>..</command>
                <replaceable>final</replaceable></entry>
              </row>

              <row>
                <entry>Ejemplos:</entry>

                <entry><command>loop 1000</command></entry>
              </row>

              <row>
                <entry></entry>

                <entry><command>loop while difscr > .00001</command></entry>
              </row>

              <row>
                <entry></entry>

                <entry><command>loop for i=1991..2000</command></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Esta instrucción da acceso a un modo especial, en el que el programa
        acepta instrucciones a repetir, bien un número especificado de veces, o bien
        mientras se satisfaga alguna condición, o bien para valores
        sucesivos de la variable índice (interna) <varname>i</varname>.
        Dentro de un bucle, sólo se pueden utilizar siete instrucciones:
        <command>genr</command>, <command>ols</command>, <command>print</command>,<command>sim</command>
        <command>smpl</command>, <command>store</command> y
        <command>summary</command> (<command>store</command> no
        puede utilizarse en un bucle de <quote>while</quote>). Se sale del
        modo de introducción de órdenes de bucle con la instrucción <command>endloop</command>:
        en este punto, se ejecutarán las instrucciones acumuladas hasta entonces. Los
        bucles construidos mediante <quote>loop</quote> no pueden estar anidados. Para conocer más detalles, véase el <xref
        linkend="c-looping" />.</para>
      </sect2>

      <sect2 id="meantest">
        <title>meantest</title>

	<para>(contraste de medias)</para>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumentos:</entry>

                <entry><replaceable>var1 var2</replaceable>
                <literal>[ -o ]</literal></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Calcula el estadístico <emphasis>t</emphasis> para contrastar la hipótesis
        nula de que las medias poblacionales son iguales, para las variables
        <replaceable>var1</replaceable> y <replaceable>var2</replaceable> y
        muestra su valor p. Sin la opción
        <literal>-o</literal>, el estadístico se calcula partiendo del
        supuesto de que las varianzas son iguales para las dos variables;
        con la opción <literal>-o</literal>, se supone que las varianzas son
        distintas. (La opción sólo es relevante si hay un número diferente de
        observaciones no perdidas para las dos variables.)</para>
      </sect2>

      <sect2 id="mpols">
        <title>mpols</title>

	<para>(MCO de precisión múltiple)</para>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumentos:</entry>

                <entry><replaceable>vardep varindeps</replaceable></entry>
              </row>

              <row>
                <entry>Ejemplos:</entry>

                <entry><command>mpols 1 0 2 4 6 7</command></entry>
              </row>

              <row>
                <entry></entry>

                <entry><command>mpols y 0 x1 x2 x3</command></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Calcula los estimadores de mínimo cuadrados ordinarios (MCO) con <replaceable>vardep</replaceable>
        como variable dependiente y <replaceable>varindeps</replaceable> como
        lista de variables independientes, utilizando aritmética de punto
        flotante y precisión múltiple. Las variables pueden especificarse por su nombre o su número;
        utilice el número cero para indicar un término constante. Esta
        instrucción sólo está disponible si <application>gretl</application> ha
        sido compilado con soporte GMP, la biblioteca GNU de precisión múltiple.
        </para>

        <para>Para estimar un ajuste polinomial, utilizando aritmética de
        precisión múltiple para generar las potencias requeridas de la
        variable independiente, se utiliza, por ejemplo, <command>mpols y 0 x
        ; 2 3 4</command> . Esto realiza una regresión de <varname>y</varname>
        sobre <varname>x</varname>, <varname>x</varname> al cuadrado,
        <varname>x</varname> al cubo y <varname>x</varname> elevado a la
        cuarta potencia. En otras palabras, los números a la derecha del punto y coma 
        (que han de ser números enteros y positivos) , especifican
        las potencias de <varname>x</varname> a utilizar. Si se
        especifica más de una variable independiente, la última variable
        antes del punto y coma es la que será elevada a las potencias que se indican.
        </para>
      </sect2>

      <sect2 id="multiply">
        <title>multiply</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumentos:</entry>

                <entry><replaceable>x sufijo vars</replaceable></entry>
              </row>

              <row>
                <entry>Ejemplos:</entry>

                <entry><command>multiply invpop pc 3 4 5 6</command></entry>
              </row>

              <row>
                <entry></entry>

                <entry><command>multiply 1000 big x1 x2 x3</command></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>las variables de la lista <replaceable>vars</replaceable> (referenciadas
        por nombre o número) se multiplican por <replaceable>x</replaceable>,
        que puede ser un valor numérico o el nombre de una variable
        previamente definida. Los productos se nombran con el
        <replaceable>sufijo</replaceable> especificado (máximo 3 caracteres).
        Si hace falta, se truncan primero los nombres de las variables originales.
        Por ejemplo, si se desea crear las versiones per capita de
        ciertas variables y existe ya la variable <varname>pob</varname>
        (población), una serie de instrucciones apropiadas sería:
        <command>genr invpop = 1/pob;</command> <command>multiply invpob pc
        renta gasto</command> lo cual creará <varname>rentapc</varname>
        como el producto de <varname>renta</varname> y <varname>invpob</varname>,
        y <varname>gastopc</varname> como <varname>gasto</varname>
        multiplicado por <varname>invpob</varname>.</para>
      </sect2>

      <sect2 id="noecho">
        <title>noecho</title>

        <para>Suprime el eco normal al introducir las instrucciones y comentarios (excepto los
        introducidos utilizando la instrucción <command>print</command>) a la hora
        de ejecutar un lote de instrucciones.</para>
      </sect2>

      <sect2 id="nulldata">
        <title>nulldata</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumento:</entry>

                <entry><replaceable>tamaño_serie</replaceable></entry>
              </row>

              <row>
                <entry>Ejemplo:</entry>

                <entry><command>nulldata 100</command></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Establece un conjunto de datos <quote>vacío</quote>, que
        contiene sólo una constante, con periodicidad 1 y el número de observaciones
        especificado. Esto puede usarse para hacer
        simulaciones: algunas de las instrucciones <command>genr</command> (por
        ejemplo, <command>genr uniform()</command>, <command>genr normal()</command>,
        <command>genr time</command>) generarán datos ficticios desde cero
        para rellenar el conjunto de datos. Este orden puede resultar útil
        al utilizarla conjuntamente con <command>loop</command>. Véase también la instrucción
        <command>seed</command>.</para>
      </sect2>

      <sect2 id="ols">
        <title>ols</title>

	<para>(Mínimos cuadrados ordinarios - MCO)</para>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumentos:</entry>

                <entry><replaceable>vardep varindeps</replaceable>
                <literal>[ -o ]</literal></entry>
              </row>

              <row>
                <entry>Ejemplos:</entry>

                <entry><command>ols 1 0 2 4 6 7</command></entry>
              </row>

              <row>
                <entry></entry>

                <entry><command>ols -o y 0 x1 x2 x3</command></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Calcula las estimaciones de mínimos cuadrados ordinarios (MCO) con <replaceable>vardep</replaceable>
        como variable dependiente y <replaceable>varindeps</replaceable>
        como lista de variables independientes. La opción
        <literal>-o</literal> hace que se muestre la matriz de covarianzas de
        los coeficientes de regresión. Las variables pueden
        especificarse bien por su nombre, o por su número; se utiliza el
        número cero para indicar un término constante. El programa también
        muestra el valor p para los estadísticos
        <emphasis>t</emphasis> (a dos colas) y <emphasis>F</emphasis>. Un
        valor p menor que 0,01 indica significación al
        nivel del 1 por ciento y se marca con <literal>***</literal>.
        <literal>**</literal> indica significatividad a niveles entre el 1 y el
        5 por ciento y <literal>*</literal> indica significatividad a niveles
        entre el 5 y el 10 por ciento. También se presentan algunos estadísticos de
        selección de modelos (descritos en el libro de Ramanathan, Sección 4.3). Varias de
        las variables internas pueden recuperarse mediante la instrucción
        <command>genr</command>, siempre que <command>genr</command>
        se invoque justo después de la instrucción <command>ols</command>.</para>
      </sect2>

      <sect2 id="omit">
        <title>omit</title>

	<para>(excluir)</para>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumento:</entry>

                <entry><replaceable>lista_var</replaceable> <literal>[ -o ]</literal></entry>
              </row>

              <row>
                <entry>Ejemplo:</entry>

                <entry><command>omit 5 7 9</command></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Debe ejecutarse después de una instrucción de estimación. Las variables en <replaceable>lista_var</replaceable> se excluyen
        del modelo anterior y se estimará el nuevo modelo. Si se omite
        más de una variable, se muestra el estadístico <emphasis>F</emphasis>
        de Wald junto con su valor p (sólo para el
        método MCO). Un valor p menor que
        0,05 indica que los coeficientes son conjuntamente significativos al
        nivel del 5 por ciento. Algunas variables internas pueden
        recuperarse mediante la instrucción <command>genr</command>, siempre que
        <command>genr</command> se invoque justo después de
        esta instrucción. Si se indica la opción <literal>-o</literal>
        se mostrará la matriz de covarianzas de los coeficientes.</para>
      </sect2>

      <sect2 id="omitfrom">
        <title>omitfrom</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumentos:</entry>

                <entry><replaceable>ID_de_modelo lista_var</replaceable></entry>
              </row>

              <row>
                <entry>Ejemplo:</entry>

                <entry><command>omitfrom 2 5 7 9</command></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Funciona de modo similar a la instrucción <command>omit</command>,
        excepto que hay que especificar un modelo previo (mediante su número
        de identificación, que aparece al comienzo de los resultados del modelo),
        para tomarlo la como base para excluir las variables. En el ejemplo de arriba
        se omiten las variables con números 5, 7 y 9 del Modelo 2.</para>
      </sect2>

      <sect2 id="open">
        <title>open</title>

	<para>(abrir)</para>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumento:</entry>

                <entry><replaceable>archivo_de_datos</replaceable></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Abre un archivo de datos. Si ya hay un archivo de datos abierto,
        este será reemplazado por el nuevo. El programa intentará detectar el
        formato del archivo nuevo (propio, CSV o BOX1) y lo tratará como corresponda.</para>
      </sect2>

      <sect2 id="pergm">
        <title>pergm</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumento:</entry>

                <entry><replaceable>nombre_de_variable</replaceable> <literal>[ -o ]</literal></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Calcula y muestra (y en modo interactivo, representa) el espectro de la
        variable especificada. Sin la opcioón <literal>-o</literal>, se obtiene el periodograma
        muestral; con la opción <literal>-o</literal>, se utiliza una ventana de retardos de Bartlett
        de tamaño 2 raíz <emphasis>T</emphasis> (donde <emphasis>T</emphasis>
        es el tamaño de la muestra) para estimar el espectro (véase el capítulo
        18 del libro de Greene, <citetitle>Econometric Analysis</citetitle>).
        Al mostrar el periodograma muestral, también se proporciona un contraste
        <emphasis>t</emphasis> de integración fraccional de la serie (<quote>de
        memoria larga</quote>): la hipótesis nula es que el orden de
        integración de la serie es cero.</para>
      </sect2>

      <sect2 id="plot">
        <title>plot</title>

	<para>(gráfico en modo texto, de baja calidad)</para>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Ejemplos:</entry>

                <entry><command>plot x1</command></entry>
              </row>

              <row>
                <entry></entry>

                <entry><command>plot x1 x2</command></entry>
              </row>

              <row>
                <entry></entry>

                <entry><command>plot -o x1 x2</command></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Representa los valores de los datos para las variables especificadas,
        para el rango de observaciones actualmente en efecto utilizando
        símbolos ASCII. Cada línea se refiere a una observación y los valores
        se representan horizontalmente. Con la opción <literal>-o</literal>,
        <varname>x1</varname> y <varname>x2</varname> se representan en la misma
        escala, si no, la escala de cada una se ajusta por separado de manera apropiada.
	La opción <literal>-o</literal> sólo debe emplearse si las variables
	tienen aproximadamente sus valores dentro del
        mismo rango (por ejemplo, la variable dependiente
        observada y su estimación). Véase también la orden <command>gnuplot</command>.</para>
      </sect2>

      <sect2 id="pooled">
        <title>pooled</title>

	<para>(MCO combinados)</para>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumentos:</entry>

                <entry><replaceable>vardep varindeps</replaceable>
                <literal>[ -o ]</literal></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Estima un modelo mediante MCO (véase <command>ols</command>
        para detalles sobre su sintaxis), y lo marca como un modelo combinado
        o de panel. Por lo tanto, hace que la opción de contraste
        <command>hausman</command> se muestre disponible.</para>
      </sect2>

      <sect2 id="print">
        <title>print</title>

	<para>(mostrar, presentar en la pantalla)</para>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumento:</entry>

                <entry>[ <replaceable>lista_var</replaceable> ]
                <literal>[ -o | -t ]</literal> ó [
                <replaceable>cadena</replaceable> ]</entry>
              </row>

              <row>
                <entry>Ejemplos:</entry>

                <entry><command>print</command></entry>
              </row>

              <row>
                <entry></entry>

                <entry><command>print x y</command></entry>
              </row>

              <row>
                <entry></entry>

                <entry><command>print 1 2 3 -o</command></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Si se ha indicado una <replaceable>lista_var</replaceable>, muestra en la pantalla los valores de las variables especificadas; si no se ha indicado ninguna lista, se
        muestran los valores de todas las variables que hay en el archivo de datos
        actual. Con la opción <literal>-o</literal>, los datos se
        muestran por observaciones, y si no, por variables. Con la opción
        <literal>-t</literal>, los datos se muestran con 10 valores significativos.</para>

        <para>Si el argumento de <command>print</command> es una cadena de texto
        literal (que tiene que empezar con comillas dobles,
        <literal>"</literal>), se imprime la cadena tal cual.</para>
      </sect2>

      <sect2 id="probit">
        <title>probit</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumentos:</entry>

                <entry><replaceable>vardep varindeps</replaceable></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Regresión probit. La variable dependiente ha de ser una variable
        binaria. Se obtienen los estimadores de máxima verosimilitud de los coeficientes de
        las <replaceable>varindeps</replaceable> mediante mínimos
        cuadrados iterativos (el método EM o expectativa-maximización). Como el
        modelo es no lineal, las pendientes dependen de los valores de las
        variables independientes: las pendientes se evalúan en
        las medias de estas variables. El estadístico de contraste
        chi-cuadrado contrasta la hipótesis nula de que todos los coeficientes, excepto el
        término constante, son cero.</para>

        <para>El probit para el análisis proporcional no esta implementado en
        <application>gretl</application> actualmente.</para>
      </sect2>

      <sect2 id="pvalue">
        <title>pvalue</title>

	<para>(valor p)</para>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Uso:</entry>

                <entry></entry>
              </row>

              <row>
                <entry></entry>

                <entry><command>pvalue 1</command> <replaceable>valor_x</replaceable>
                (distribución normal)</entry>
              </row>

              <row>
                <entry></entry>

                <entry><command>pvalue 2</command> <replaceable>gl valor_x</replaceable>
                (distribución <emphasis>t</emphasis>)</entry>
              </row>

              <row>
                <entry></entry>

                <entry><command>pvalue 3</command> <replaceable>gl valor_x</replaceable>
                (distribución chi-cuadrado)</entry>
              </row>

              <row>
                <entry></entry>

                <entry><command>pvalue 4</command> <replaceable>gln gld valor_x</replaceable>
                (distribución <emphasis>F</emphasis> )</entry>
              </row>

              <row>
                <entry></entry>

                <entry><command>pvalue 5</command> <replaceable>media varianza
                valor_x</replaceable> (distribución Gamma)</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Calcula el area a la derecha del <replaceable>valor_x</replaceable>
        en la distribución especificada. <replaceable>gl</replaceable> son
        los grados de libertad, <replaceable>gln</replaceable> son los grados
        de libertad del numerador, <replaceable>gld</replaceable> son los
        grados de libertad del denominador. En vez de los dígitos se puede
        utilizar <literal>z</literal>, <literal>t</literal>,
        <literal>X</literal>, <literal>F</literal> y <literal>G</literal> para
        las distribuciones normal, <emphasis>t</emphasis>, chi-cuadrado, distribución,
        <emphasis>F</emphasis>, y gamma respectivamente.</para>
      </sect2>

      <sect2 id="quit">
        <title>quit</title>
	<para>(salir)</para>

        <para>Salir de <application>gretl</application>, ofrece la posibilidad de guardar
        los resultados de la sesión antes de cerrar (<replaceable>q</replaceable> es un atajo; <replaceable>x</replaceable> sale sin preguntar si se deben guardar los resultados).</para>
      </sect2>

      <sect2 id="reset">
        <title>reset</title>

        <para>Debe utilizarse inmediatamente después de la estimación de un modelo
        mediante MCO. Realiza el contraste de especificación de modelos (no linealidad) RESET de
        Ramsey, añadiendo el
        cuadrado y el cubo de los valores ajustados a la regresión, y
        calculando el estadístico <emphasis>F</emphasis> para la hipótesis
        nula de que los parámetros de los dos términos añadidos son cero.</para>

        <para role="bodgea4">&nbsp;</para>
      </sect2>

      <sect2 id="rhodiff">
        <title>rhodiff</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumentos:</entry>

                <entry><replaceable>lista_rho</replaceable> <literal>;</literal>
                <replaceable>lista_var</replaceable></entry>
              </row>

              <row>
                <entry>Ejemplos:</entry>

                <entry><command>rhodiff .65 ; 2 3 4</command></entry>
              </row>

              <row>
                <entry></entry>

                <entry><command>rhodiff r1 r2 ; x1 x2 x3</command></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Crea las transformaciones rho-diferenciadas de las variables en
        <replaceable>lista_var</replaceable> (identificadas por su nombre o por
        su número) y las añade al conjunto de datos, utilizando el sufijo
        <literal>#</literal> para las nuevas variables . Dada la variable
        <varname>v1</varname> en <replaceable>lista_var</replaceable>, y las
        entradas <varname>r1</varname> y <varname>r2</varname> en
        <replaceable>lista_rho</replaceable>, se crea <varname>v1# = v1(t) -
        r1*v1(t-1) - r2*v1(t-2)</varname>. Las entradas de
        <replaceable>lista_rho</replaceable> pueden darse como valores
        numéricos, o mediante los nombres de variables previamente definidas.</para>
      </sect2>

      <sect2 id="rmplot">
        <title>rmplot</title>
	<para>(gráfico rango-media)</para>
        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumento:</entry>

                <entry><replaceable>nombre_de_variable</replaceable></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Esta instrucción crea un sencillo gráfico para ayudar a decidir si
        una serie temporal, <emphasis>y</emphasis>(t), tiene varianza
        constante o no. Se toma la muestra completa t=1,...,T y se divide
        en pequeñas submuestras de un tamaño arbitrario <emphasis>k</emphasis>.
        La primera submuestra se forma mediante <emphasis>y</emphasis>(1),...,<emphasis>y</emphasis>(k),
        la segunda, <emphasis>y</emphasis>(k+1), ..., <emphasis>y</emphasis>(2k),
        y así sucesivamente. Para cada submuestra, calculamos la media de la
        muestra y su rango (= máximo-mínimo), y construimos un gráfico
        con las medias sobre el eje horizontal, y los rangos en el vertical.
        De esta forma cada submuestra se representa por un punto en el plano. Si la varianza de
        la serie es constante, esperaríamos que el rango de las submuestras
        fuera independiente de la media de las submuestras; por tanto, si vemos
        que los puntos se aproximan a una recta con pendiente positiva, esto
        sugiere que la varianza de la serie se incrementa con su media; y
        si los puntos se aproximan a una recta con pendiente negativa, esto
        parece indicar que la varianza está decreciendo con su media.</para>

        <para>Aparte del gráfico, <application>gretl</application> muestra las
        medias y los rangos de cada submuestra, el coeficiente de la
        pendiente de la regresión MCO de los rangos sobre las medias y
        el valor p de la hipótesis nula de que esta
        pendiente es cero. Si el coeficiente de la pendiente es significativo
        al nivel de significación del 10 por ciento, entonces el gráfico también
        muestra la recta de regresión estimada de los rangos sobre las medias.</para>
      </sect2>

      <sect2 id="run">
        <title>run</title>
	<para>(ejecutar)</para>
        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumento:</entry>

                <entry><replaceable>archivo_de_entrada</replaceable></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Ejecuta las instrucciones del <replaceable>archivo_de_entrada</replaceable>
        (archivo de instrucciones) y devuelve el control al cursor interactivo.</para>
      </sect2>

      <sect2 id="runs">
        <title>runs</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumento:</entry>

                <entry><replaceable>nombre_de_variable</replaceable></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Realiza el "contraste de rachas" (no paramétrico) sobre aleatoriedad de la variable especificada. Si
        se quiere hacer un contraste para la aleatoriedad de las desviaciones
        respecto a la mediana de una variable llamada <varname>x1</varname> con
        una mediana distinta de cero, se puede hacer de la siguiente forma:</para>

      <programlisting>
    genr signx1 = x1 - median(x1)
    runs signx1
      </programlisting>
      </sect2>

      <sect2 id="scatters">
        <title>scatters</title>
	<para>(gráficos bivariantes)</para>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumentos:</entry>

                <entry><replaceable>vary</replaceable> <literal>;</literal>
                <replaceable>lista_varx</replaceable> </entry>
              </row>
	      <row> <entry> </entry> <entry><replaceable>lista_vary</replaceable> <literal>;</literal><replaceable>varx</replaceable> </entry>
	      </row>

              <row>
                <entry>Ejemplos:</entry>

                <entry><command>scatters 1 ; 2 3 4 5</command></entry>
              </row>

              <row>
                <entry></entry>

                <entry><command>scatters 1 2 3 4 5 6 ; time</command></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Representa (mediante gnuplot) gráficos bivariantes (scatterplots) por parejas de variables
        <replaceable>vary</replaceable> con respecto a todas las variables en
        <replaceable>lista_varx</replaceable>, o de todas las variables en
        <replaceable>lista_vary</replaceable> contra <replaceable>varx</replaceable>.
        El primer ejemplo sitúa la variable 1 en el eje <emphasis>y</emphasis>
        y se dibujan cuatro gráficos, el primero con la variable dos en el eje
        <emphasis>x</emphasis>, el segundo con la variable 3 en el eje
        <emphasis>x</emphasis>, y así sucesivamente. El segundo ejemplo traza
        cada una de las variables, desde 1 hasta 6, a lo largo del tiempo. Un
        paso útil en el análisis exploratorio de datos consiste en
        inspeccionar un conjunto de gráficos de este tipo. No se admiten más
        de 6 gráficos; cualquier variable extra en la lista será ignorada.</para>
      </sect2>

      <sect2 id="seed">
        <title>seed</title>
	<para>(semilla)</para>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumento:</entry>

                <entry><replaceable>integer</replaceable></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Establece la semilla para el generador de números pseudo-aleatorios
        para la distribucion uniforme [<function>uniform()</function>] y
        <function>normal()</function> (véase la instrucción <command>genr</command>).
        Al iniciar el programa se establece la semilla por defecto utilizando
        el reloj del sistema. Si se desea obtener secuencias de
        números pseudo-aleatorios repetibles, hay que establecer la semilla de forma
        manual.</para>
      </sect2>

      <sect2 id="setobs">
        <title>setobs</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumentos:</entry>

                <entry><replaceable>setobs periodicidad primobs</replaceable></entry>
              </row>

              <row>
                <entry>Ejemplos:</entry>

                <entry><command>setobs 4 1990.1</command></entry>
              </row>

              <row>
                <entry></entry>

                <entry><command>setobs 12 1978.03</command></entry>
              </row>

              <row>
                <entry></entry>

                <entry><command>setobs 20 1.01</command></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Obliga al programa a interpretar el conjunto de datos actual
        como una serie temporal o de panel, cuando los datos han
        sido leídos inicialmente como una serie simple sin fechas. La
        <replaceable>periodicidad</replaceable> tiene que ser un número entero;
        <replaceable>primobs</replaceable> es una cadena que representa la
        fecha o identificación de panel de la primera observación. Véase
        también el <xref linkend="c-panel" />.</para>
      </sect2>

      <sect2 id="setmiss">
        <title>setmiss</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumentos:</entry>

                <entry><replaceable>valor</replaceable> <literal>[</literal>
                <replaceable>lista_var</replaceable> <literal>]</literal></entry>
              </row>

              <row>
                <entry>Ejemplos:</entry>

                <entry><command>setmiss -1</command></entry>
              </row>

              <row>
                <entry></entry>

                <entry><command>setmiss 100 x2</command></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Hace que el programa interprete un valor numérico especificado
        (el primer parámetro de la instrucción) como código de
        <quote>valor perdido</quote> cuando se importan datos. Si este
        valor es el único parámetro, como en el primer ejemplo de arriba,
        esta interpretación también se aplicará a todas las series en el
        conjunto de datos. Si el <replaceable>valor</replaceable> va seguido de
        una lista de variables, definidas por su nombre o por su número, la
        interpretación se limitará a la(s) variable(s) especificadas. Por lo
        tanto, en el segundo ejemplo, el valor 100 será
        interpretado como un código para definir <quote>valor perdido</quote>,
        pero sólo para la variable <literal>x2</literal>.</para>
      </sect2>

      <sect2 id="shell">
        <title>shell</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Usage:</entry>

                <entry><command>!</command> <replaceable>shellcommand</replaceable></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Un <command>!</command> al comienzo de una línea de instrucción se
        interpreta como un escape al sistema operativo (al <quote>shell</quote> del usuario).
        De este modo, se pueden ejecutar instrucciones del shell desde dentro de
        <application>gretl</application> (no disponible en la versión para MS Windows).</para>
      </sect2>

      <sect2 id="sim">
        <title>sim</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumentos:</entry>

                <entry><replaceable>primobs ultobs y a0 a1 a2 ...</replaceable>
                ...</entry>
              </row>
            </tbody>
          </tgroup>

          <tgroup cols="3">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Ejemplos:</entry>

                <entry><command>sim 1979.2 1983.1 y 0 0.9</command></entry>

                <entry>crea <varname>y(t) = 0.9*y(t-1)</varname></entry>
              </row>

              <row>
                <entry></entry>

                <entry><command>sim 15 25 y 10 0.8 x</command></entry>

                <entry>crea <varname>y(t) = 10 + 0.8*y(t-1) + x(t)*y(t-2)</varname></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Simula valores para <replaceable>y</replaceable> para los
        periodos desde <replaceable>primobs</replaceable> hasta
        <replaceable>ultobs</replaceable>. La variable
        <replaceable>y</replaceable> tiene que haber sido definida con
        anterioridad con los valores iniciales apropiados. La fórmula empleada es
        <varname>y(t) = a0(t) + a1(t)*y(t-1) + a2(t)*y(t-2) + ...</varname> Los términos
        <varname>ai(t)</varname> pueden ser constantes numéricas o nombres de
        variables definidas previamente.</para>

	<para>En el siguiente ejemplo se simula un proceso autorregresivo de orden uno con coeficiente 0.8
<varname>y(t) = 0.8*y(t-1) + u(t)</varname> para <varname>t = 2, ...,100</varname> siendo <varname>u(t)</varname> normal (0,1):</para>
	<programlisting>
	genr y = const*0
	genr coeff = const*0.8
	genr u = normal()
	sim 2 100 y u coeff
	</programlisting>
      </sect2>

      <sect2 id="smpl">
        <title>smpl</title>
	<para>(muestra)</para>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumentos:</entry>

                <entry><replaceable>primobs ultobs</replaceable></entry>
              </row>

              <row>
                <entry></entry>

                <entry><command>smpl -o</command> <replaceable>var_ficticia</replaceable></entry>
              </row>

              <row>
                <entry></entry>

                <entry><command>smpl -o</command></entry>
              </row>

              <row>
                <entry></entry>

                <entry><command>smpl -r</command> <replaceable>condición</replaceable></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Cambia el rango de la muestra. En el primer modo,
        <replaceable>primobs</replaceable> y <replaceable>ultobs</replaceable>
        tienen que ser consistentes con la periodicidad de los datos. En el
        segundo modo, <replaceable>var_ficticia</replaceable> tiene que ser una
        variable indicadora con valores 0 o 1 en cada observación; la
        muestra se restringirá a las observaciones cuyo valor sea 1. El
        tercer modo, <command>smpl -o</command>, excluye todas las observaciones
        para las cuales los valores de una o más variables estén <quote>perdidos</quote>. El cuarto
        modo (<literal>-r</literal>) restringe la muestra a las observaciones que
        cumplan con la condición (Booleana) impuesta.</para>

        <informaltable frame="none">
          <tgroup cols="2">
            <colspec colwidth="2in" colnum="1" />

            <tbody>
              <row>
                <entry><command>smpl 3 10</command></entry>

                <entry>datos con periodicidad 1</entry>
              </row>

              <row>
                <entry><command>smpl 1950 1990</command></entry>

                <entry>datos anuales con periodicidad 1</entry>
              </row>

              <row>
                <entry><command>smpl 1960.2 1982.4</command></entry>

                <entry>datos trimestrales</entry>
              </row>

              <row>
                <entry><command>smpl 1960.04 1985.10</command></entry>

                <entry>datos mensuales</entry>
              </row>

              <row>
                <entry><command>smpl 1960.2 ;</command></entry>

                <entry>mantiene <replaceable>ultobs</replaceable> sin cambios</entry>
              </row>

              <row>
                <entry><command>smpl ; 1984.3</command></entry>

                <entry>mantiene <replaceable>primobs</replaceable> sin
                cambios</entry>
              </row>

              <row>
                <entry><command>smpl -o dum1</command></entry>

                <entry>crea una muestra de las observaciones donde
                <literal>dum1=1</literal></entry>
              </row>

              <row>
                <entry><command>smpl -r renta > 30000</command></entry>

                <entry>restringe la muestra a los casos en los que la variable
                <varname>renta</varname> tenga un valor mayor que 30000.</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Conviene tomar nota sobre las formas <literal>-o</literal> y
        <literal>-r</literal> del <command>smpl</command>: Cualquier
        información <quote>estructural</quote> en el fichero de cabecera de
        los datos (referente a la naturaleza de los datos, es decir, que sean
        series temporales o de panel) se pierde al ejecutar esta orden.
        Se puede reimponer de nuevo la estructura con la instrucción <command>setobs</command>.</para>
      </sect2>

      <sect2 id="spearman">
        <title>spearman</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumentos:</entry>

                <entry><replaceable>x y</replaceable> <literal>[ -o ]</literal></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Calcula el coeficiente de correlación por rangos de Spearman
         para las dos variables, <emphasis>x</emphasis> e
        <emphasis>y</emphasis>. No es preciso previamente ordenar las variables y asignar los rangos
        de forma manual; la instrucción se encarga de hacer
        esto. Con la opción <literal>-o</literal>, se muestran
        los datos originales junto con los ordenados.</para>

        <para>La ordenación automática se hace de mayor a menor
        (es decir, al dato mayor se le asigna rango 1). Si Vd
        necesita invertir ese orden, puede crear una nueva variable cuyos valores sean
        los de la variable original cambiados de signo. Por ejemplo:</para>

      <programlisting>
      genr altx = -x
    spearman altx y</programlisting>
      </sect2>

      <sect2 id="square">
        <title>square</title>
	<para>(cuadrados)</para>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumento:</entry>

                <entry><replaceable>lista_var</replaceable> <literal>[ -o ]</literal></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Genera nuevas variables correspondientes a los cuadrados y a los
        productos cruzados de las variables en <replaceable>lista_var</replaceable>
        (<literal>-o</literal> creará los productos cruzados). Por ejemplo,
        <command>square x y</command> generará <varname>sq_x</varname> =
        <varname>x</varname> cuadrado, <varname>sq_y</varname> =
        <varname>y</varname> cuadrado y <varname>x_y</varname> =
        <varname>x</varname> por <varname>y</varname>. Si hay alguna variable en
        particular que es ficticia, esta no será elevada al cuadrado ya que el
        resultado sería la misma variable.</para>
      </sect2>

      <sect2 id="store">
        <title>store</title>
	<para>(guardar)</para>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumento:</entry>

                <entry><replaceable>nombre_fichero</replaceable> [
                <replaceable>lista_var</replaceable> ] [
                <replaceable>flag</replaceable> ]</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para><replaceable>nombre_fichero</replaceable> es el nombre del archivo
        donde se guardarán los valores.</para>

        <para>Si falta <replaceable>lista_var</replaceable>, se guardan los
        valores de todas las series de datos en el conjunto de datos actual.
        Nótese que las variables escalares no se guardan de manera
        automática: si deseamos guardar las escalares, tenemos que incluirlas
        explícitamente en <replaceable>lista_var</replaceable>.</para>

        <para>Por defecto, se guardarán en el formato XML nativo de
        <application>gretl</application>. Hay seis <replaceable>opciones</replaceable>
        validas (excluyentes entre sí):</para>

        <informaltable frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry><literal>-z</literal></entry>

                <entry>El formato por defecto, pero comprimido con gzip.</entry>
              </row>

              <row>
                <entry><literal>-o</literal></entry>

                <entry>los datos se guardan en formato binario utilizando precisión doble.</entry>
              </row>

              <row>
                <entry><literal>-s</literal></entry>

                <entry>los datos se guardan en formato binario
                utilizando precisión simple.</entry>
              </row>

              <row>
                <entry><literal>-c</literal></entry>

                <entry>los datos se guardan en formato CSV (comma-separated
                values --- valores separados por comas). Los programas de
                hojas de cálculo pueden leer este formato directamente.</entry>
              </row>

              <row>
                <entry><literal>-r</literal></entry>

                <entry>los datos se guardan en formato GNU R.</entry>
              </row>

              <row>
                <entry><literal>-m</literal></entry>

                <entry>los datos se guardan en formato GNU Octave.</entry>
              </row>

              <row>
                <entry><literal>-t</literal></entry>

                <entry>los datos se guardan en formato ESL, <quote>tradicional</quote> de
                <application>gretl</application> con un archivo de datos ASCII y otro fichero separado
                de cabecera.</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </sect2>

      <sect2 id="summary">
        <title>summary</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumento:</entry>

                <entry>[ <replaceable>lista_var</replaceable> ]</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Muestra los estadísticos principales de las variables incluidas en
        <replaceable>lista_var</replaceable> o, si se omite <replaceable>lista_var</replaceable>,
	de todas las variables incluidas en el conjunto de datos. Los resultados que se proporcionan son la media, la desviación típica (sd), el coeficiente de variación (= dt/media), la mediana, el mínimo, el máximo, el
        coeficiente de asimetría y el exceso de curtosis.</para>
      </sect2>

      <sect2 id="tabprint">
        <title>tabprint</title>

        <para>Debe de ejecutarse despues de la estimación de un modelo mediante MCO.
        Guarda el modelo estimado en forma de <quote>entorno tabular</quote> de LaTeX, en un
        archivo con el nombre <filename>model_N.tex</filename>, donde
        <varname>N</varname> es el número de modelos estimados hasta el momento
        en la sesión actual. Este archivo puede incorporarse a un documento
        LaTeX. Véase también <command>eqnprint</command>.</para>
      </sect2>

      <sect2 id="testuhat">
        <title>testuhat</title>

        <para>Debe seguir a una instrucción de estimación de modelos. Muestra la
        distribución de frecuencias de los residuos del modelo junto con el
        contraste chi-cuadrado de normalidad.</para>
      </sect2>

      <sect2 id="tsls">
        <title>tsls</title>
	<para>(Mínimos cuadrados en dos etapas)</para>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumentos:</entry>

                <entry><replaceable>vardep lista_var1</replaceable>
                <literal>;</literal> <replaceable>lista_var2</replaceable>
                <literal>[ -o opcional]</literal></entry>
              </row>

              <row>
                <entry>Ejemplo:</entry>

                <entry><command>tsls y1 0 y2 y3 x1 x2 ; 0 x1 x2 x3 x4 x5 x6</command></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Calcula las estimaciones de los parámetros por el método de mínimos cuadrados en dos etapas
        (MC2E). <replaceable>vardep</replaceable> es la
        variable dependiente, <replaceable>lista_var1</replaceable> es la lista
        de las variables independientes (incluyendo las variables endógenas)
        en la ecuación estructural para las cuales se necesitan las estimaciones
        de MC2E. <replaceable>lista_var2</replaceable> es la lista conjunta de
        las variables predeterminadas y exógenas en todas las ecuaciones. Si
        <replaceable>lista_var2</replaceable> no es, por lo menos, tan larga
        como <replaceable>lista_var1</replaceable>, el modelo no está identificado.
        La opción <literal>-o</literal> muestra la matriz de covarianzas de los
        coeficientes. En el ejemplo de arriba, las <varname>ys</varname>
        son las variables endógenas y las <varname>xs</varname> son las
        variables exógenas y predeterminadas. Algunas variables internas
        pueden recuperarse mediante la instrucción <command>genr</command>, siempre que
        <command>genr</command> se invoque justo después de esta
        instrucción.</para>
      </sect2>

      <sect2 id="var">
        <title>var</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumentos:</entry>

                <entry><replaceable>orden vardep varindep</replaceable></entry>
              </row>

              <row>
                <entry>Ejemplos:</entry>

                <entry><command>var 4 x1 const time x2 x3</command></entry>
              </row>

              <row>
                <entry></entry>

                <entry><command>var 3 1 0 2 3 4</command></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Calcula (vía MCO) las estimaciones de una autorregresión
        vectorial. El primer argumento especifica el orden de los retardos,
        luego sigue la especificación de la primera ecuación, de igual forma que en 
        la instrucción <command>ols</command>. Hay que tener cuidado de no
        incluir los retardos entre los elementos de la lista
        <replaceable>varindep</replaceable> - estos se añaden de forma
        automática. Se ejecutará una regresión para cada variable de la lista,
        excluyendo la constante, la tendencia temporal y cualquier variable
        ficticia. Los resultados de cada ecuación incluyen los contrastes
        <emphasis>F</emphasis> para restricciones cero en todos los retardos
        de cada una de las variables, y un contraste <emphasis>F</emphasis>
        para el retardo máximo.</para>
      </sect2>

      <sect2 id="list">
        <title>varlist</title>

        <para>Muestra una lista de las variables disponibles en la actualidad.
        <command>list</command> y <command>ls</command> son sinónimos.</para>
      </sect2>

      <sect2 id="vartest">
        <title>vartest</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumentos:</entry>

                <entry><replaceable>var1 var2</replaceable></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Calcula el estadístico <emphasis>F</emphasis> para la hipótesis
        nula de que las varianzas poblacionales de las variables
        <replaceable>var1</replaceable> y <replaceable>var2</replaceable> son
        iguales y muestra su valor p.</para>
      </sect2>

      <sect2 id="wls">
        <title>wls</title>

        <informaltable role="cmd" frame="none">
          <tgroup cols="2">
            <colspec colwidth="82pt" colnum="1" />

            <tbody>
              <row>
                <entry>Argumentos:</entry>

                <entry><replaceable>varpesos vardep varindeps</replaceable>
                <literal>[ -o opcional ]</literal></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Se obtienen las estimaciones de mínimos cuadrados ponderados
        siendo <replaceable>varpesos</replaceable> la variable de ponderaciones,
        <replaceable>vardep</replaceable> la variable dependiente y
        <replaceable>varindeps</replaceable> la lista de variables
        independientes. Más concretamente, se ejecuta una regresión MCO
        de <replaceable>varpesos</replaceable> <literal>*</literal>
        <replaceable>vardep</replaceable> contra <replaceable>t</replaceable>
        <literal>*</literal> <replaceable>varindeps</replaceable>. Si
        <replaceable>varpesos</replaceable> es una variable ficticia, esto
        equivale a la eliminación de todas las observaciones que tengan valor
        cero para <replaceable>varpesos</replaceable>. Con la opción
        <literal>-o</literal> se proporciona la matriz de covarianzas de los
        coeficientes. Mediante la instrucción <command>genr</command> pueden recuperarse
	algunas variables internas, siempre que
        <command>genr</command> sea invocada inmediatamente después de la
        instrucción <command>wls</command>.</para>
      </sect2>
    </sect1>

    <sect1 id="estimators">
      <title>Estimadores y contrastes: resumen</title>

      <para>La <xref linkend="tab-estim" /> muestra los estimadores disponibles
      bajo el menú de <quote>Modelo</quote> en la ventana principal de
      <application>gretl</application>. La instrucción de consola correspondiente
      (en caso de que haya una) se muestra entre paréntesis. Para más detalles
      consúltese el apartado sobre la instrucción en el <xref linkend="c-cmdref" />.</para>

      <table id="tab-estim" frame="none">
        <title>Estimadores</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Estimador</entry>

              <entry>Comentario</entry>

            </row>
          </thead>

          <tbody>
            <row>
              <entry>Mínimos Cuadrados Ordinarios</entry>

              <entry>El estimador MCO básico</entry>
            </row>

            <row>
              <entry>Mínimos Cuadrados Ponderados</entry>

              <entry>Heterocedasticidad, exclusión de observaciones
              seleccionadas</entry>
            </row>

            <row>
              <entry>HCCM</entry>

              <entry>MCO con matriz de covarianzas corregida de heterocedasticidad</entry>
            </row>

            <row>
              <entry>Corregida de heterocedasticidad </entry>

              <entry>Mínimos Cuadrados Ponderados basados en la varianza del
              error de predicción</entry>
            </row>

            <row>
              <entry>Cochrane-Orcutt</entry>

              <entry>Autocorrelación de primer orden</entry>
            </row>

            <row>
              <entry>Hildreth-Lu </entry>

              <entry>Autocorrelación de primer orden</entry>
            </row>

            <row>
              <entry>Estimación autorregresiva</entry>

              <entry>Autocorrelación de orden superior (Cochrane-Orcutt
              generalizado)</entry>
            </row>

            <row>
              <entry>Autorregresión vectorial (VAR)</entry>

              <entry>Sistemas de ecuaciones de series temporales</entry>
            </row>

            <row>
              <entry>Contraste de cointegración </entry>

              <entry>Relaciones de largo plazo entre series</entry>
            </row>

            <row>
              <entry>Mínimos cuadrados en dos etapas </entry>

              <entry>Ecuaciones simultáneas</entry>
            </row>

            <row>
              <entry>Logit</entry>

              <entry>Variable dependiente binaria (distribución logística)</entry>
            </row>

            <row>
              <entry>Probit</entry>

              <entry>Variable dependiente binaria (distribución normal)</entry>
            </row>

            <row>
              <entry>Mínima desviación absoluta</entry>

              <entry>Alternativa a Mínimos Cuadrados</entry>
            </row>

            <row>
              <entry>Correlación por rangos</entry>

              <entry>Correlación con datos ordinales</entry>
            </row>

            <row>
              <entry>MCO combinados</entry>

              <entry>Estimación MCO para datos combinados de sección cruzada y
              de series temporales</entry>
            </row>

            <row>
              <entry>MCO con precisión múltiple</entry>

              <entry>Estimación MCO usando aritmética de precisión múltiple</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para role="bodge">&nbsp;</para>

      <para role="bodge">&nbsp;</para>

      <para role="bodge">&nbsp;</para>

      <para>La <xref linkend="tab-tests" /> muestra los contrastes disponibles en
      el menú de contrastes en una ventana de modelo, después de la
      estimación.</para>

      <table id="tab-tests" frame="none">
        <title>Contrastes para los modelos</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>contraste</entry>

              <entry>Instrucción correspondiente</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>Omitir variables (contraste <emphasis>F</emphasis> si es
              MCO)</entry>

              <entry><command>omit</command></entry>
            </row>

            <row>
              <entry>Añadir variables (contraste <emphasis>F</emphasis> si es
              MCO)</entry>

              <entry><command>add</command></entry>
            </row>

            <row>
              <entry>No linealidad (cuadrados)</entry>

              <entry><command>lmtest</command></entry>
            </row>

            <row>
              <entry>No linealidad (logaritmos)</entry>

              <entry><command>lmtest</command></entry>
            </row>

            <row>
              <entry>No linealidad (el contraste RESET de Ramsey)</entry>

              <entry><command>reset</command></entry>
            </row>

            <row>
              <entry>Heterocedasticidad (contraste de White)</entry>

              <entry><command>lmtest</command></entry>
            </row>

            <row>
              <entry>Autocorrelación hasta la frecuencia de los datos</entry>

              <entry><command>lmtest -o</command></entry>
            </row>

            <row>
              <entry>Chow (cambio estructural)</entry>

              <entry><command>chow</command></entry>
            </row>

            <row>
              <entry>CUSUM (estabilidad de los parámetros)</entry>

              <entry><command>cusum</command></entry>
            </row>

            <row>
              <entry>ARCH (heterocedasticidad condicional)</entry>

              <entry><command>arch</command></entry>
            </row>

            <row>
              <entry>Normalidad de los residuos</entry>

              <entry><command>testuhat</command></entry>
            </row>

            <row>
              <entry>Diagnósticos de panel</entry>

              <entry><command>hausman</command></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </sect1>
  </chapter>

  <!-- Keep this comment at the end of the file
Local variables:
sgml-default-dtd-file:"../manual.ced"
mode: xml
sgml-parent-document:("../manual.xml" "book" "chapter")
End:
-->

