<?xml version="1.0" encoding="iso-8859-1"?>

  <chapter id="c-looping">
    <title>Construcción de iteraciones</title>

    <sect1 id="monte-carlo">
      <title>Simulaciones Monte Carlo</title>

      <para><application>Gretl</application> ofrece un soporte (limitado) para
      realizar simulaciones de Monte Carlo. Para hacer este tipo de trabajos se
      puede utilizar o bien el programa GUI en modo <quote>lote de instrucciones</quote>
      (véase <xref linkend="scripts" /> arriba), o bien el cliente de línea de
      instrucciones. La instrucción <command>loop</command> (bucle) abre el programa en
      un modo especial, en el cual se acepta la repetición de una
      instrucción el número de veces indicado . Sólo 7 instrucciones pueden ser
      utilizadas dentro de dicho bucle: <command>genr</command>,
      <command>ols</command>, <command>print</command>, <command>sim</command>,
      <command>smpl</command>, <command>store</command> y <command>summary</command>.
      <command>genr</command> y <command>ols</command> permiten hacer bastantes operaciones.
      Tecleando la instrucción <command>endloop</command>
      se sale de este modo: esto hace que se ejecute el lote de instrucciones.
      Los bucles no pueden estar anidados.</para>

      <para>La instrucción <command>ols</command> produce un resultado especial dentro
      del modo bucle; no se muestran los resultados de cada regresión individual y, en su lugar, 
      el programa muestra (a) el valor medio de cada
      coeficiente estimado en cada una de las iteraciones, (b) la desviación
      típica de estos coeficientes estimados, (c) el valor medio de la desviación típica
      estimada de cada coeficiente, y (d) la desviación típica de las desviaciones
      típicas estimadas. Todos estos resultados cobran sentido solamente
      si se introduce algún efecto aleatorio.</para>

      <para>La instrucción <command>print</command> también se comporta de manera
      diferente en el modo bucle. Muestra la media y la desviación típica
      de la variable a lo largo de todas las repeticiones del bucle. Está pensada para ser
      utilizada con variables que tengan un sólo valor en cada iteración, por
      ejemplo la suma de cuadrados de los errores de una regresión.</para>

      <para>La instrucción <command>store</command> (a utilizar una única vez en
      cada bucle) escribe los valores de las variables especificadas en
      cada una de las iteraciones, en el archivo indicado por el usuario. Por lo
      tanto, mantiene un historial completo de las variables. Es posible leer
      y analizar este archivo de datos dentro del programa.</para>

      <para>En el <xref
      linkend="script-loop" /> se muestra un sencillo ejemplo de simulación de Monte Carlo.</para>

      <example id="script-loop">
        <title>Una simulación sencilla de Monte Carlo</title>

    <programlisting>
      (* Crear un conjunto de datos vacío de tamaño 50 *)
      nulldata 50
      genr x = uniform()
      (* abrir un bucle que se repite 100 veces *)
      loop 100
        genr u = normal()
        (* construir la variable dependiente *)
        genr y = 10*x + 20*u
        (* ejecutar una regresión MCO *)
        ols y const x
        (* recuperar el R-cuadrado de la regresión *)
        genr r2 = $rsq
        (* hacer que se muestren las estadísticas sobre los R-cuadrados calculados *)
        print r2
        (* recuperar las estimaciones de los coeficientes individuales *)
        genr a = coeff(const)
        genr b = coeff(x)
        (* y guardarlas en un fichero *)
        store foo.gdt a b
      endloop</programlisting>
      </example>

      <para>Este bucle mostrará los estadísticos de resumen
      correspondientes a las estimaciones de `a' y `b' en cada una de las
      100 ietraciones, así como los valores <emphasis>R</emphasis><superscript>2</superscript>
      de las 100 regresiones. Después de ejecutar el bucle, el
      archivo <filename>foo.gdt</filename>, que contiene las estimaciones de
      los coeficientes individuales de todas las veces que ha sido ejecutado
      el bucle, puede abrirse desde <application>gretl</application> para
      examinar la distribución de frecuencias de las estimaciones con más
      detalle. Por favor, téngase en cuenta que aunque se permiten líneas de
      comentarios dentro de una replicación (como muestra el ejemplo), estos
      no pueden exceder una linea.</para>

      <para>La instrucción <command>nulldata</command> es útil para realizar
      trabajos de Monte Carlo. En lugar de abrir unos datos <quote>reales</quote>,
      <command>nulldata 50</command> (por ejemplo) abre un conjunto
      de datos vacío, con solamente una constante, y un tamaño muestral igual
      a 50. Después pueden añadirse variables mediante la instrucción
      <command>genr</command>.</para>

      <para>Véase la instrucción <command>seed</command> en el <xref linkend="c-cmdref" />
      para información sobre cómo generar series pseudo-aleatorias
      repetibles.</para>
    </sect1>

    <sect1 id="ils">
      <title>Mínimos cuadrados iterativos</title>

      <para>Se ha diseñado una segunda forma de estructurar las replicaciones,
      principalmente para calcular mínimos cuadrados iterativos. Greene
      (2000, c. 11) muestra cómo puede usarse este método para estimar
      modelos no lineales.</para>

      <para>Para comenzar este tipo de replicaciones, hay que especificar una
      <emphasis>condición</emphasis> en lugar de un número incondicional de
      veces a iterar. Esta condición debe tener la forma de la palabra clave
      <command>while</command> (mientras) seguida por una desigualdad: el término de la
      izquierda debe ser el nombre de la variable ya definida; el término de
      la derecha puede ser una constante numérica o el nombre de otra variable
      predefinida. Por ejemplo,</para>

      <para><command> loop while essdiff > .00001 </command></para>

      <para>Las instrucciones serán ejecutadas dentro del bucle (es decir, hasta
      que se encuentre <command>endloop</command>) mientras se cumpla
      la condición que estamos evaluando.</para>

      <para>El programa supone que si se especifica una replicación tipo
      <quote>número de veces</quote>, probablemente estemos realizando un
      análisis de Monte Carlo, y, por lo tanto, no nos interesan los resultados de
      cada iteración individual, sino más bien los momentos de ciertas
      variables en el conjunto de las iteraciones. Por otra parte, si se
      especifica una replicación de tipo <quote>while</quote>
      probablemente se esté haciendo algo como mínimos cuadrados iterativos y
      por lo tanto nos gustaría visualizar el resultado final - y también,
      quizá, los valores de alguna(s) variable(s) (por ejemplo, la suma de
      cuadrados de los residuos) de cada iteración dentro del bucle. 
      El comportamiento de las instrucciones <command>print</command>
      y <command>ols</command> se acomoda a estas suposiciones. En una
      bucle <quote>while</quote>, <command>print</command> se comporta
      como siempre; así que se imprimen la(s) variable(s) especificada(s) en
      cada iteración. La instrucción <command>ols</command> imprime los resultados
      de la estimación final.</para>

      <para>El <xref linkend="greene-consump" /> utiliza un bucle
      <quote>while</quote> para reproducir la estimación de una función de
      consumo no lineal de la forma <inlineequation><alt role="tex">$C =
      \alpha + \beta Y^{\gamma} + \epsilon$</alt><inlinemediaobject><imageobject><imagedata
      align="center" fileref="figures/greeneC" /></imageobject></inlinemediaobject></inlineequation>
      como en Greene (2000, Ejemplo 11.3). Este lote de instrucciones se incluye en
      la distribución de <application>gretl</application> bajo el nombre de<filename>
      greene11_3.inp</filename>; se puede encontrar en
      <application>gretl</application> bajo la opción del menú <quote>Archivo, Abrir
      archivo de instrucciones, archivo de ejercicios, Greene...</quote>.</para>

      <example id="greene-consump">
        <title>Función de consumo no lineal</title>

    <programlisting>
      open greene11_3.gdt
      (* ejecutar MCO inicialmente *)
      ols C 0 Y
      genr essbak = $ess
      genr essdiff = 1
      genr b0 = coeff(Y)
      genr gamma0 = 1
      (* formar las variables linealizadas *)
      genr C0 = C + gamma0 * b0 * Y^gamma0 * log(Y)
      genr x1 = Y^gamma0
      genr x2 = b0 * Y^gamma0 * log(Y)
      (* iterar los MCO hasta que la suma de cuadrados converja *)
      loop while essdiff > .00001
        ols C0 0 x1 x2 -o
        genr b0 = coeff(x1)
        genr gamma0 = coeff(x2)
        genr C0 = C + gamma0 * b0 * Y^gamma0 * log(Y)
        genr x1 = Y^gamma0 genr x2 = b0 * Y^gamma0 * log(Y)
        genr ess = $ess genr
        essdiff = abs(ess - essbak)/essbak
        genr essbak = ess
      endloop
      (* mostrar las estimaciones de los parámetros usando sus "propios nombres" *)
      genr alpha = coeff(0)
      genr beta = coeff(x1)
      genr gamma = coeff(x2)
      print alpha beta gamma</programlisting>
      </example>
    </sect1>

    <sect1>
      <title>Bucle con índice</title>

      <para>El tercer modo de construir un bucle en
      <application>gretl</application> es hacer un bucle con índice, utilizando
      la variable interna <varname>i</varname>. Es necesario especificar los
      valores inicial y final para <varname>i</varname>, que aumenta en
      cada iteración del bucle. La sintaxis es la siguiente:
      <command>loop i=1..20</command>. El <xref linkend="panel-loop" /> muestra
      el uso de esta construcción. Considérese el caso de un conjunto de datos
      de panel, consistente en observaciones sobre varios hospitales entre los
      años 1991-2000. Restringimos la muestra para cada uno de estos años sucesivamente
      y obtenemos los estadísticos de resumen de sección cruzada para
      las variables 1 a 4.</para>

      <example id="panel-loop">
        <title>Ejemplo de un bucle indexado</title>
    <programlisting>
      open hospitals.gdt
      loop for i=1991..2000
        smpl -r (year=i)
        summary 1 2 3 4
      endloop</programlisting>
      </example>
    </sect1>
  </chapter>

  <!-- Keep this comment at the end of the file
Local variables:
sgml-default-dtd-file:"../manual.ced"
mode: xml
sgml-parent-document:("../manual.xml" "book" "chapter")
End:
-->

