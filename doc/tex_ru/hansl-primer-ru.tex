\documentclass[oneside]{book}
\usepackage{url,verbatim,fancyvrb}
\usepackage{pifont}
\usepackage[T1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{hyphenat}
\usepackage[pdftex]{graphicx}
%\usepackage[authoryear]{natbib}
\usepackage{color, gretl-cmr}
\usepackage[a4paper,body={6.07in,9.7in},top=.8in,left=1.1in]{geometry}
\usepackage[pdftex,hyperfootnotes=false]{hyperref}
\usepackage{dcolumn,amsmath,bm,longtable}
\usepackage[scaled=0.8]{noto-mono}

%% \pdfimageresolution=120
\hypersetup{pdftitle={A Hansl Primer},
            pdfsubject={The scripting language of gretl},
            pdfauthor={Riccardo (Jack) Lucchetti},
            colorlinks=true,
            linkcolor=blue,
            urlcolor=red,
            citecolor=steel,
            bookmarks=true,
            bookmarksnumbered=true,
            plainpages=false
}

\begin{document}

\VerbatimFootnotes
\setlength{\parindent}{0pt}
\setlength{\parskip}{1ex}
\setcounter{tocdepth}{1}

%% titlepage

\thispagestyle{empty}

\begin{center}
\pdfbookmark[1]{A Hansl Primer}{titlepage}

\htitle{Праймер Hansl}

\gsubtitle{Изучаем язык программы Gretl за \pageref{LastPage} минут}

{\large \sffamily
Аллин Коттрелл\\
Факультет Экономики\\
Wake Forest University\\

\vspace{20pt}
Риккардо (Jack) Луккетти\\
Факультет Социальных и Экономических Дисциплин\\
Universit\`a Politecnica delle Marche\\

\vspace{20pt}
Русский перевод выполнен:\\
Петренко Олеся\\
University of West Bohemia\\
\vspace{20pt}
\input date
}

\end{center}
\clearpage

%% end titlepage, start license page

\thispagestyle{empty}

\pdfbookmark[1]{License}{license}

\vspace*{2in}

Предоставляется разрешение на копирование, распространение и/или
изменение данного документа на условиях лицензии \emph{GNU Free
  Documentation License}, версия 1.1 или любая более поздняя версия,
опубликованная фондом Free Software Foundation
(см. \url{http://www.gnu.org/licenses/fdl.html})

\cleardoublepage

%% end license page, start table of contents
\pdfbookmark[1]{Table of contents}{contents}

\pagenumbering{roman}
\pagestyle{headings}

\tableofcontents

\clearpage
\pagenumbering{arabic}
%\setcounter{chapter}{-1}


\chapter{Введение}
%\addcontentsline{toc}{chapter}{Introduction}

\section*{Что такое Hansl и чем он не является}

Hansl --- это рекурсивная аббревиатура, которая расшифровывается как
“Hansl’s A Neat Scripting Language” («аккуратный язык
Hansl»). Конечно, вы можете ожидать найти здесь общепринятые
вещи. Спешим вас заверить, что это не совсем так. Hansl родился как
язык сценариев для программы эконометрики gretl, и его роль вряд ли
изменится. Следовательно, его не следует рассматривать как полноценный
язык программирования, такой как C, Fortran, Perl или Python, не
потому, что ему не хватает чего-то важного, чтобы считаться таковым
\footnote{Язык Hansl считается полным по Тьюрингу.}, а потому, что
цель его применения иная. Hansl следует рассматривать как язык
специального назначения или предметно-ориентированный язык,
предназначенный для облегчения жизни эконометриста. Именно поэтому он
включает в себя ряд технических решений, которые могут раздражать
пуристов и порой оказывать незначительное влияние на чистую
производительность, но мы, как эконометристы-профессионалы, считаем
что это больше достоинство, чем недостаток. Это отличает Hansl от
простых интерпретируемых языков, ориентированных на матрицу, таких как
семейство Matlab / Octave, Ox и так далее.

С другой стороны, Hansl --- это не просто инструмент для автоматизации
обыденных задач. Он включает в себя несколько особенностей, которые
поддерживают более продвинутый уровень решения задач:
структурированное программирование, рекурсия, сложные структуры данных
и так далее. Что касается стиля, возможно, язык командной оболочки
Bash больше всего напоминает Hansl.

\section*{Назначение и структура данного документа}

Предполагаемые читатели этого документа --- те, кто уже знает, как
писать код, и знакомы с соответствующими правилами, которые определяют
всевозможные «можно» и «нельзя». У вас может появиться желание
добавить Hansl в свой набор инструментов, наряду с такими языками, как
C или FORTRAN, или такими программами, как R, Ox, Matlab, Stata или
Gauss, которыми вы пользуетесь уверенно. Таким образом, в данном
документе основное внимание уделяется не столько вопросу «Как мне это
сделать?», а скорее «Как мне сделать это в Hansl?».

Поэтому цель написания данного документа – сделать читателя достаточно
продвинутым пользователем за (относительно) короткое время. Однако
следует отметить, что не все особенности Hansl проиллюстрированы
здесь. Всем, кому захочется узнать больше, мы рекомендуем обратиться к
Справочнику по командам \GCR{} и Руководству пользователя \GUG{} на
английском языке.

Это руководство состоит из двух основных
частей. Часть~\ref{part:hp-nodata} (``Без набора данных'') описывает
Hansl как матрично-ориентированный язык программирования в чистом
виде. Часть ~\ref{part:hp-data} (``С набором данных'') объясняет тот
факт, что скрипты Hansl запускаются через программму gretl, которая
располагает хорошими возможностями для обработки наборов
статистических данных (с примерами, если необходимо). Это обеспечивает
Hansl рядом дополнительных функций, которые делают его чрезвычайно
легким языком для написания сценариев с целью выполнения всевозможных
статистических процедур.

% A short third part (which is likely to be expanded in future) gives a
% brief account of a few ``further topics''.

Чтобы использовать Hansl, вам понадобится установленный пакет
Gretl. Если по какой-то причине вы еще не установили наш бесплатный
пакет, пожалуйста, обратитесь к главе 1 Руководства пользователя \GUG.

\section*{Другие источники информации об использовании Gretl}

Если вы серьезно относитесь к изучению языка Hansl, то во время/после
проработки этого учебного пособия мы рекомендуем вам ознакомиться со
следующими дополнительными ресурсами на английском языке:
\begin{itemize}
\item Справочник по командам Gretl. Он содержит полный список команд и
  встроенных функций, доступные в Hansl, с полным описанием их
  синтаксиса и опций. Для иллюстрации некоторых действий
  предоставляются примеры использования программы. Данный документ
  находится в свободном доступе в онлайн-версии программы, а также в
  формате PDF, оба варианта доступны через меню «Справка» в
  графическом интерфейсе пользователя Gretl.
\item Руководство пользователя Gretl User's Guide. В главах с 10 по
  16, в частности, более подробно рассматриваются некоторые из
  обсуждаемых здесь тем программирования (типы данных, циклы,
  определение и использование функций). В дополнении к Части II
  Руководства по эконометрическим методам дано несколько подробных
  примеров использования Hansl. Руководство доступно через меню
  «Справка» gretl; последнюю версию также можно найти в Интернете по
  адресу \url{http://sourceforge.net/projects/gretl/files/manual/}.
\item Примеры скриптов. Пакет gretl устанавливается с большим
  количеством примеров или практических скриптов, который можно найти
  в пункте меню / Файл / Скрипты / Образцы скрипта. Многие упражнения
  достаточно просты и сводятся к повторению задач из учебника, но вы
  также найдете и более интересные примеры через вкладку Gretl в этом
  же окне.
\item Функциональные пакеты. Относительно сложные примеры
  Hansl-кодирования можно найти в различных «функциональных
  пакетах». Вы можете скачать эти пакеты через пункт меню gretl / Файл
  / Пакеты функций / На сервере. После загрузки пакет появляется в
  списке в / Файл / Пакеты функций / На локальном компьютере; в
  появившемся окне вы можете щелкнуть правой кнопкой мыши и выбрать
  опцию «Просмотреть код», чтобы изучить функции более подробно.
\item Рассылка для пользователей Gretl. На большинство ваших вопросов
  мы стараемся отвечать быстро и исчерпывающе. См.
  \url{https://gretlml.univpm.it/postorius/lists/}.
\end{itemize}

\chapter{Для особенно нетерпеливых}
\label{chap:impatient}

Хорошо, что вы нетерпеливы. Если это так, то возможно, вы рассуждаете
следующим образом: «Неужели мне нужно досконально изучить весь этот
докуент? В конце концов, я уже какое-то время занимаюсь
эконометрическими кодами и уверен, что могу работать с новым скриптом,
если он достаточно понятен. Мне бы просто получить пару полезных
советов, чтобы сразу начать работать правильно». Если это совсем не
то, о чем вы сейчас думаете, мы предлагаем вам перейти к главе 3; но
если вы думаете именно так, то мы готовы поделиться с вами сценарием
Hansl уже сейчас. Это тот самый сценарий, который иллюстрирует
изрядное количество тем, обсуждаемых в остальной части данного
документа. В нашем примере мы будем использовать модель векторной
авторегрессии, или сокращенно VAR.

Как вы, возможно, знаете, модель VAR конечного порядка можно оценить с
помощью метода условного максимального правдоподобия путем
использования OLS для каждого уравненя по очереди. Это решение
сводится к применению метода наименьших квадратов. Сама задача и ее
решение могут быть отображены в матричной записи как
$\hat{\Pi} = (X'X)^{-1} X'Y$, где $Y$ содержит эндогенные переменные,
а $X$ содержит их лаги, а также другие экзогенные переменные (обычно,
как минимум, константу). Однако, если есть желание, вы можете найти
максимум концентрированного правдоподобия
$\mathcal{L} = -(T/2) \ln|\hat{\Sigma}|$ и численно.

В следующем примере содержится сценарий Hansl, который выполняет
следующие действия:
\begin{enumerate}
\item Читает данные из файла на диске.
\item Выполняет некоторые преобразования данных и простую визуализацию.
\item Оценивает VAR через
  \begin{enumerate}
  \item собственную команду Hansl \texttt{var} 
  \item последовательный однонаправленный МНК
  \item применение матричной алгебры (тремя различными способами)
  \item численную максимизацию логарифма правдоподобия.
  \end{enumerate}
\item Выводит (демонстрирует вам) результаты..
\end{enumerate}
Более того, данный скрипт содержит краткие комментарии.

\begin{scode}
open AWM.gdt --quiet                   # загружает данные с диска

/* Трансформация и визуализация данных */

series y = 100 * hpfilt(ln(YER))       # концепт "серий": работать с      
series u = 100 * URX                   # векторами на поэлементной основе
series r = STN - 100*sdiff(ln(HICP))   # (но в вашем распоряжении также есть спец. функции) 

scatters y r u --output=display        # пример команды с опцией: graph data

/* in-house VAR */

scalar p = 2                           # Строгая типизация: скаляр не является
                                       # ни матрицей, ни серией

var p y r u                            # команда оценивания
A = $coeff                             # и соответствующий  аксессор

/* через итерации OLS */

list X = y r u                         # cписок это еще один тип переменной

matrix B = {}                          # ввести пустую матрицу
loop foreach i X                       # повторить 3 равенства var 
    ols $i const X(-1 to -p) --quiet   # используя встроенную команду OLS
    B ~= $coeff                        # и сохранить оцененные коэффициенты
endloop                                # как столбцы матрицы

/* через матрицы */

matrix mY = { y, r, u }                # составить матрицу из серий
matrix mX = 1 ~ mlag(mY, {1,2})        # или матричных операторов/функций
mY = mY[p+1:,]                         # и выбрать соответствуюшие ряды
mX = mX[p+1:,]                         # через синтакс "range"

C1 = mX\mY                             # matlab-style matrix inversion
C2 = mols(mY, mX)                      # или встроенная функция
C3 = inv(mX'mX) * (mX'mY)              # или простейшие алгебраические действия

/* или сложным, излишне запутанным способом -- ну, чтобы просто повыделываться */

function scalar loglik(matrix param, const matrix X, const matrix Y)

    # Эта функция считает концентрированную логарифмическую вероятность
    # для неограниченной многомерной регрессионной модели

    scalar n = cols(Y)
    scalar k = cols(X)
    scalar T = rows(Y)
    matrix C = mshape(param, k, n)
    matrix E = Y - X*C
    matrix Sigma = E'E

    return -T/2 * ln(det(Sigma))
end function

matrix c = zeros(21,1)                  # обозначить параметры
mle ll = loglik(c, mX, mY)              # и максимизировать вероятность
    params c                            # через BFGS и вывести 
end mle                                 # результаты после завершения расчетов

D = mshape(c, 7, 3)                     # изменить форму результатов для соответствия

/* вывести результаты */

# примечание: порядок строк между приведенными альтернативами может отличаться

print A B C1 C2 C3 D
\end{scode}
%$

Если вы смогли выполнить приведенный выше сценарий во всех его частях,
примите наши поздравления. Вам нет необходимости читать остальную
часть данного документа (хотя мы не возражаем, если вы это все же
сделаете). Но если вас ужаснул вышеприведенный сценарий, не бойтесь:
мы будем действовать шаг за шагом. Читайте дальше.

\part{Без набора данных}
\label{part:hp-nodata}
\include{hp-hello}
\include{hp-matrices}
\include{hp-output}
\include{hp-bundles}
\include{hp-numerical}
\include{hp-ctrlflow}
\include{hp-functions}

\part{С набором данных}
\label{part:hp-data}
\include{hp-dataset}
\include{hp-series}
\include{hp-estimate}

\part{Рекомендации}
\label{part:hp-reference}
\include{hp-reference}
\include{operators}
\include{hp-greeks}


% \part{Further topics}
% \include{hp-further}

% \clearpage
% \include{biblio}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
