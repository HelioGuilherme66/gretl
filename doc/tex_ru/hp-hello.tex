\chapter{Hello, world!}
\label{chap:hello}

Начнем с проверенной временем программы «Hello, world» ---
обязательного первого шага в любом языке программирования. На самом
деле в Hansl все очень просто:
\begin{code}
  # Первый пример
  print "Hello, world!"
\end{code}

Есть несколько способов запустить приведенный выше сценарий: вы можете
поместить его в текстовый файл \texttt{first\_ex.inp} и пусть gretl
выполнит его прямо из командной строки с помощью команды
\begin{code}
  gretlcli -b first_ex.inp
\end{code}
или же вы можете просто скопировать содержимое скрипта в окно
редактора сеанса gretl с графическим интерфейсом и щелкнуть по значку
«шестеренки». Решать вам: используйте тот способ, который вам больше
нравится.

С синтаксической точки зрения позвольте обратить ваше внимание на
следующие моменты:
\begin{enumerate}
\item Строка, начинающаяся с решетки (\texttt{\#}), является
  комментарием: если встречается знак решетки, все от этой точки до
  конца текущей строки рассматривается как комментарий и игнорируется
  программой.
\item Следующая строка содержит команду \emph{command} (\cmd{print})
  (в данном случае: «вывод»), за которой следует аргумент; это
  довольно типично для Hansl: многие работы выполняются с помощью
  различных команд.
\item У Hansl нет явного указателя конца команды, такого как
  ``\texttt{;}'' символ в семействе языков C (C++, Java, C\#, \ldots)
  или GAUSS; вместо этого он использует символ новой строки как
  неявный терминатор. Итак, в конце команды вы \emph{должны} вставить
  новую строку; и наоборот, \emph{нельзя} вставлять новую строку в
  середине команды. То есть можно НЕ без специальных мер: если вам
  нужно разбить команду на более чем одну строку для удобства чтения,
  вы можете использовать символ ``\textbackslash'' (обратная косая
  черта), который заставляет gretl игнорировать следующий разрыв
  строки.
 \end{enumerate}

 Также обратите внимание, что команда печати \cmd{print} автоматически
 добавляет разрыв строки и не распознает ``escape''
 последовательности, такие как ``\verb|\n|''; такие последовательности
 выводятся буквально. Команда printf может использоваться для большего
 контроля над выводом; см. главу \ref{chap:formatting}.

Давайте теперь рассмотрим простой вариант этого же сценария:
\begin{code}
  /*
    Второй пример
  */
  string foo = "Hello, world"
  print foo
\end{code}

В этом примере наш первый сценарий написан с использованием условия,
принятого в языке программирования C: все, что находится между
``\verb|/*|'' и ``\verb|*/|'', игнорируется \footnote{Каждый тип
  комментария может быть перекрыт другим:
	\begin{itemize}
        \item Если \texttt{/*} следует за \texttt{\#} в данной строке,
          которая еще не прочтена программой в режиме игнорирования,
          то в \texttt{/*} нет ничего особенного, это просто часть
          комментария в стиле \texttt{\#}.
        \item Если \texttt{\#} появляется, когда мы уже находимся в
          режиме комментариев, это просто часть комментария.
\end{itemize}}. Комментарии этого типа не поддерживаются.

Далее у нас есть строка
\begin{code}
  string foo = "Hello, world"
\end{code}
В этой строке мы присваиваем значение ``\texttt{Hello, world}''
переменной с именем \texttt{foo}. Обратите внимание на то, что
\begin{enumerate}
\item оператором присваивания является знак равенства (\texttt{=}).
\item имя переменной (ее идентификатор) должно соответствовать
  следующим условиям: идентификаторы не могут быть длиннее 31 символа
  и должны быть в формате ASCII. Они также должны начинаться с буквы,
  и могут содержать только буквы, цифры и нижнее
  подчеркивание.\footnote{Фактически поддерживается лишь одно
    исключение из этого правила: идентификаторы могут содержать одну
    греческую букву. Подробнее в гл.~\ref{chap:greeks}.}
  Идентификаторы в Hansl чувствительны к регистру, поэтому
  \texttt{foo}, \texttt{Foo} и \texttt{FOO} --- это три разных
  имени. Конечно, некоторые слова уже зарезервированы и поэтому не
  могут использоваться в качестве идентификаторов (однако почти все
  зарезервированные слова содержат только строчные буквы и символы).
\item Разделителем строки является двойная кавычка (\verb|"|). 
\end{enumerate}

В Hansl переменная должна быть одного из следующих типов:
\texttt{scalar}, \texttt{series}, \texttt{matrix}, \texttt{list},
\texttt{string}, \texttt{bundle} or \texttt{array}. Как мы только что
определили, строковые переменные используются для хранения
последовательностей буквенно-цифровых символов. Остальные мы будем
вводить постепенно; например, следующая глава будет посвещена
матрицам.

Читатель мог заметить, что строка 
\begin{code}
  string foo = "Hello, world"
\end{code}
неявно выполняет две задачи: объявляет \texttt{foo} как переменную
типа \texttt{string} и одновременно присваивает значение
\texttt{foo}. Первый компонент строго не требуется. В большинстве
случаев Gretl может самостоятельно определить тип данных для вновь
введенной переменной, и строка \verb|foo = "Hello, world"| (без
спецификатора типа) работает правильно.  Однако пользователям, во всем
любящих порядок (который, как известно, приводит к более разборчивому
и удобному в коду), рекомендовано использовать спецификатор типа по
крайней мере первый раз, когда вводится новая переменная.
  
В следующем примере мы будем использовать переменную \texttt{scalar}
скалярного типа:
\begin{code}
  scalar x = 42
  print x
\end{code}
Скаляр \texttt{scalar} --- это число с плавающей запятой двойной
точности, поэтому \texttt{42} совпадает с \texttt{42.0} или
\texttt{4.20000E+01}. Обратите внимание, что в Hansl нет специального
типа переменной для целых или комплексных чисел.

Следует объяснить важную деталь: в отличие от большинства других
матрично-ориентированных языков, используемых в сообществах
эконометристов, Hansl строго типизирован. Это означает, что нельзя
присвоить значение одного типа для переменной, которая уже была
объявлена как переменная другого типа. Например, возникнет следующая
ошибка:
\begin{code}
  string a = "zoo"
  a = 3.14 # нет-нет!
\end{code}
Если вы попытаетесь запустить приведенный выше пример, вы получите
данную ошибку. Однако допустимо уничтожить исходную переменную с
помощью команды удаления \cmd{delete}, а затем повторно присвоить ее
другому типу:
\begin{code}
  scalar X = 3.1415
  delete X
  string X = "apple pie"
\end{code}

Здесь нет ``type-casting'' как в C, но возможны некоторые
автоматические преобразования типов (подробнее об этом поговорим
позже).

Многие команды могут содержать более одного аргумента, как в:
\begin{code}
  set echo off
  set messages off

  scalar x = 42
  string foo = "not bad"
  print x foo 
\end{code}
В этом примере одна функция вывода \texttt{print} используется для
демонстрации значений двух переменных; в более общем виде за словом
\texttt{print} может следовать любое количество аргументов. Другое
отличие от предыдущего примера состоит в том, что здесь используются
две команды set. Подробное описание команды \texttt{set} отвлечет нас
от темы главы на долгое время; достаточно сказать, что эта команда
используется для установки значения различных «переменных состояния»,
влияющих на поведение программы; здесь она используется для того,
чтобы заглушить нежелательный вывод описания действия. См. Справочник
по командам Gretl для получения дополнительной информации о
команде\texttt{set}.

% There was a reference here to a {chap:settings}, but it has not
% been written at this point

Команда \cmd{eval} полезна, когда вы хотите увидеть результат
выражения без присваивания какого-либо имени или типа данной
переменной. Следующая команда
\begin{code}
  eval 2+3*4
\end{code}
выведет на экран число 14. Эта команда наиболее полезна при запуске
gretl как калькулятора, но ее можно использовать и в сценарии Hansl
для проверки выражений, как в следующем (довольно упрощенном) примере:
\begin{code}
  scalar a = 1
  scalar b = -1
  # это должно быть 0
  eval a+b
\end{code}

\section{Действия со скалярными величинами}

Алгебраические операции работают очевидным образом, а классические
алгебраические операторы имеют свои традиционные правила приоритета:
знак вставки (\verb|^|) используется для возведения в
степень. Например,
\begin{code}
  scalar phi = exp(-0.5 * (x-m)^2 / s2) / sqrt(2 * $pi * s2)
\end{code}

здесь мы предполагаем, что\texttt{x}, \texttt{m} и \texttt{s2} --- уже
существующие скалярные величины. Данный пример содержит два
примечательных момента:
\begin{itemize}
\item Использование функций \cmd{exp} (экспонента) и \cmd{sqrt}
  (кв.корень) само собой разумеется: Hansl обладает достаточно широким
  набором таких функций. См. Справочник по командам для полного списка
  функций.
\item Использование \verb|$pi| для постоянного $\pi$. Хотя
  пользовательские идентификаторы должны начинаться с буквы,
  встроенные идентификаторы для внутренних объектов обычно имеют
  префикс «доллар»; они известны как аксессоры \emph{accessors}(в
  основном, переменные только для чтения). Большинство средств доступа
  определены в контексте открытого набора данных (см. часть
  ~\ref{part:hp-data}), но некоторые из них представляют собой заранее
  определенные константы, такие как $\pi$. Опять же, см. Справочник по
  командам для полного списка функций.
\end{itemize}

Hansl не имеет определенного типа Boolean, но скаляры могут
использоваться для хранения истинного / ложного значения. Отсюда
следует, что вы также можете использовать логические операторы
\emph{and} – и (\verb|&&|), \emph{or} – или (\verb+||+), \emph{not} –
не (\verb|!|) для скалярных величин, как в следующем примере:
\begin{code}
  a = 1
  b = 0
  c = !(a && b) 
\end{code}
В приведенном выше примере \texttt{c} будет равно 1 (истина),
поскольку \verb|(a && b)| --- ложь, а восклицательный знак ---
оператор отрицания. Обратите внимание, что 0 оценивается как ложь, а
все остальное (не обязательно 1) оценивается как истина.  Некоторые
конструкции взяты из семейства языков C. В частности, одна из них ---
оператор приращения:
\begin{code}
  a = 5
  b = a++
  print a b
\end{code}
вторая строка эквивалентна \texttt{a++}, за которой следует a ++, что,
в свою очередь, является сокращением для \texttt{a = a+1}, поэтому
выполнение приведенного выше кода приведет к результату, где b = 5, и
a=6. Вычитание также поддерживается программой; однако префиксные
операторы не поддерживаются. Другое заимствование C это измененное
присвоение, как в случае \texttt{a += b} (эквивалентно \texttt{a = a +
  b}); несколько других подобных операторов также доступны, например
\texttt{-=}, \texttt{*=} и другие. Подробности: см. Справку по
командам Gretl для полного списка функций.

Внутреннее представление отсутствующего значения --- \texttt{NaN} («не
число», not a number), как определено в стандарте IEEE 754. Программа
обычно выводит NaN, если мы пытаемся вычислить такие величины, как
квадратный корень или логарифм отрицательного числа. Возможно заранее
установить значение «не существует» напрямую, используя буквы
\texttt{NA}. Дополнительные функции \cmd{missing} и \cmd{ok} могут
использоваться для определения того, что скаляр \texttt{NA}, «не
существует». В следующем примере переменной с именем \texttt{test}
присваивается нулевое значение:
\begin{code}
  scalar not_really = NA
  scalar test = ok(not_really)
\end{code}
Обратите внимание на то, что вы не можете проверять на равенство
\texttt{NA} никакие переменные, как в:
\begin{code}
  if x == NA ... # неверно!
\end{code}
потому что отсутствующее значение считается неопределенным и,
следовательно, ничему не равным. Этот последний пример, несмотря на
то, что он ошибочен, иллюстрирует один важный момент: оператор
проверки на равенство в Hansl --- это двойной знак равенства,
``\texttt{==}'' (в отличие от простого ``\texttt{=}'', указывающего на
присвоение).

\section{Действия со строками}

Большая часть предыдущего раздела с очевидными изменениями применима к
строкам: вы можете совершать действия над строками, используя
операторы и/или функции. Репертуар функций Hansl для работы со
строками предлагает все стандартные возможности, которые можно
ожидать, такие как \cmd{toupper}, \cmd{tolower}, \cmd{strlen}, etc., а
также несколько более специализированных. Опять же, см. Справочник по
командам Gretl для полного списка функций.  Чтобы получить доступ к
желаемой части строки, вы можете использовать функцию
\cmd{substr}\footnote{На самом деле, есть более продвинутый метод,
  который использует тот же синтаксис, что и для матриц (см. Главу
  \ref{chap:matrices}): \cmd{substr(s, 3, 5)} функционально
  эквивалентен \cmd{s[3:5]}} как в
\begin{code}
  string s = "endogenous"
  string pet = substr(s, 3, 5)
\end{code}
что приведет к присвоению значения \texttt{dog} переменной
\texttt{pet}. Ниже приведены некоторые полезные операторы для строк:
\begin{itemize}
\item оператор тильда \verb|~| для соединения двух или более строк,
  как в \footnote{На некоторых клавиатурах нет символа тильды
    \verb|~|. В редакторе скриптов gretl знак тильды можно вставить
    через Юникод: введите Ctrl-Shift-U, а затем 7e.}
  \begin{code}
    string s1 = "sweet"
    string s2 = "Home, " ~ s1 ~ " home."
  \end{code}
\item подобный оператор \verb|~=| который действует как оператор
  присваивания с изменением угла наклона (так что \verb|a ~= "_ij"|
  эквивалентно \verb|a = a ~ "_ij"|);
\item оператор смещения \texttt{+}, который возвращает подстроку
  предыдущего элемента, начиная с данного символа смещения. Пустая
  строка выводится, если смещение больше, чем длина строки, о которой
  идет речь.
\end{itemize}

Примечательный момент: строки могут быть (почти) произвольно длинными;
кроме того, они могут содержать специальные символы, такие как перенос
строки и табуляция. Поэтому можно использовать Hansl для выполнения
сложных операций с текстовыми файлами, если загрузить их в память в
виде очень длинной строки, а затем с этим работать; заинтересованные
читатели могут обратиться к функциям \cmd{readfile}, \cmd{getline},
\cmd{strsub} и \cmd{regsub} в справочнике по командам
\GCR.\footnote{Мы не утверждаем, что Hansl будет предпочтительным
  инструментом для обработки текста в целом. Тем не менее, упомянутые
  здесь функции могут быть полезны для таких задач, как
  предварительная обработка файлов данных в виде простого текста,
  который не соответствует требованиям для прямого импортирования в
  gretl.}

Для создания сложных строк наиболее гибким инструментом является
функция \cmd{sprintf}. Ее использование подробно описано в
главе~\ref{chap:formatting}.

% Finally, it is quite common to use \emph{string
%   substitution} in hansl sripts; however, this is another topic that
% deserves special treatment so we defer its description to section
% \ref{sec:stringsub}.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "hansl-primer"
%%% End: 
