\chapter{Funzioni definite dall'utente}
\label{functions}

\section{Definizione di una funzione}
\label{func-define}

A partire dalla versione 1.4.0, \app{gretl} contiene un nuovo
meccanismo per definire funzioni all'interno di uno script.
\footnote{Si noti che il nuovo modo di definire le funzioni presenta
  aspetti non compatibili con quello incluso nella versione 1.3.3 del programma.}

Occorre definire una funzione prima di poterla utilizzare. La sintassi
per farlo è la seguente:

\begin{code}
      function nome-funzione parametri
         corpo della funzione
      end function
\end{code}

Il \textsl{nome-funzione} identifica la funzione in modo univoco: deve
iniziare con una lettera, può essere lungo al massimo 31 caratteri
(eventuali caratteri in più verranno troncati) e non può contenere
spazi. Se si tenta di definire una funzione con lo stesso nome di un
comando di \app{gretl} o di una funzione preesistente, si otterrà
un'errore. Nel secondo caso, per evitare un errore (ossia per poter
ridefinire una funzione utente), basta far precedere la definizione
della funzione da:
    
\begin{code}
      function nome-funzione clear
\end{code}

I \textsl{parametri} di una funzione (se esistono) vanno indicati
sotto forma di lista separata da virgole. I parametri possono essere
di uno dei seguenti tipi:

\begin{center}
\begin{tabular}{ll}
\multicolumn{1}{c}{Tipo} &
\multicolumn{1}{c}{Descrizione} \\ [4pt]
\texttt{bool} & variabile scalare usata come interruttore Booleano \\
\texttt{int}  & variabile scalare usata come numero intero \\
\texttt{scalar} & variabile scalare \\
\texttt{series} & serie di dati \\
\texttt{list}   & lista di serie \\
\texttt{matrix} & matrice o vettore
\end{tabular}
\end{center}

Ogni elemento della lista di parametri è composto da due termini: per prima
cosa un indicatore di tipo, quindi il nome con cui il parametro verrà
riconosciuto all'interno della funzione. Ecco un esempio (le parentesi che
racchiudono la lista dei parametri sono opzionali):
    
\begin{code}
      function funzione (series y, list xvars, bool verboso)
\end{code}


Quando una funzione viene chiamata, i parametri vengono istanziati
usando gli argomenti indicati nella chiamata della funzione. Vengono
fatti dei controlli automatici per assicurarsi che il numero degli
argomenti contenuti in una chiamata di funzione corrisponda al numero
di parametri, e che i tipi degli argomenti corrispondano ai tipi
specificati nella definizione della funzione; se qualcuna di queste
condizioni è violata, viene segnalato un errore. Una serie può essere
indicata come argomento specificando il nome della variabile in
questione, oppure il suo numero identificativo. Gli scalari possono
essere indicati specificando il nome di una variabile o un valore
numerico (non è possibile indicare il numero identificativo della
variabile). Le liste devono essere indicate per nome.
    
Il \textsl{corpo della funzione} è composto da comandi \app{gretl} o
funzioni definite dall'utente (ossia, le funzioni possono essere
nidificate).  Una funzione può persino chiamare sé stessa (ossia, le
funzioni possono essere ricorsive), fino a un massimo di 8 ``livelli
di ricorsività'', ma questo valore è provvisorio, potrà essere
aumentato se sembra troppo restrittivo.  Se il corpo della funzione
può contenere chiamate ad altre funzioni non può però contenere
definizioni di altre funzioni, ossia non è possibile definire una
funzione all'interno di un'altra funzione.
    
Le funzioni possono essere chiamate, ma non definite, all'interno di
un loop (si veda il capitolo~\ref{looping}).

\section{Chiamata di una funzione}
\label{func-call}

Una funzione utente viene chiamata, o invocata, usando il suo nome,
eventualmente seguito da argomenti; se si usano due o più argomenti,
vanno separati da virgole. L'esempio seguente mostra una chiamata di
funzione che rispetta la definizione della funzione stessa.
    
\begin{code}
      # Definizione della funzione
      function ols_ess (series y, list xvars)
        ols y 0 xvars --quiet
        scalar myess = $ess
        printf "ESS = %g\n", myess
        return scalar myess
      end function
      # Script principale
      open data4-1
      list xlist = 2 3 4
      # Chiamata della funzione (il valore restituito viene qui ignorato)
      ols_ess price, xlist
\end{code}

La chiamata della funzione contiene due argomenti: il primo è una
serie di dati specificata per nome, e il secondo è una lista di
regressori. Si noti che la funzione produce la variabile \verb+myess+
come risultato, ma in questo esempio esso è ignorato. Una nota a
margine: se si desidera che una funzione calcoli alcuni valori che
hanno a che fare con una regressione, ma non si è interessati ai
risultati completi della regressione, è possibile usare l'opzione
\verb+--quiet+ con il comando di stima, come visto sopra.
    
Un secondo esempio mostra una chiamata di funzione che assegna i
valori prodotti dalla funzione ad alcune variabili:
    
\begin{code}
      # Definizione di funzione
      function ess_uhat (series y, list xvars)
        ols y 0 xvars --quiet
        scalar myess = $ess
        printf "ESS = %g\n", myess
        series uh = $uhat
        return scalar myess, series uh
      end function
      # Script principale
      open data4-1
      list xlist = 2 3 4
      # Chiamata di funzione
      (SSR, resids) = ess_uhat price, xlist
\end{code}

\section{Programmazione delle funzioni}
\label{func-details}
 
\subsection{Ambito delle variabili}

Tutte le variabili create in una funzione sono locali a quella
funzione, e vengono distrutte quando la funzione termina la sua
esecuzione, a meno che esse siano rese disponibili come valori di
ritorno, e che questi siano ``raccolti'' o assegnati nella chiamata
della funzione.

Le funzioni non hanno accesso alle variabili dell'``ambiente esterno''
(ossia le variabili che esistono nello script da cui la funzione è
chiamata), a meno che queste siano passate esplicitamente alla
funzione come argomenti. Anche in questo caso, quello che viene
passato alla funzione è una copia delle variabili in questione, quindi
le variabili nell'ambiente esterno non vengono mai modificate da una
funzione, a meno che non vengano assegnate come valore prodotto da una
funzione.


\subsection{Valori di uscita}

Le funzioni possono produrre zero o più valori di uscita: questi
possono essere scalari, serie o matrici (non liste). I valori di uscita sono
specificati con una dichiarazione all'interno del corpo della funzione
che comincia con la parola chiave \verb+return+, seguita da una lista
separata da virgole, ogni elemento della quale è composto da un
indicatore di tipo e dal nome di una variabile (in modo analogo a
quanto avviene per la lista dei parametri di una funzione).
All'interno di una funzione può esserci solo una di queste
dichiarazioni. Ecco un esempio di dichiarazione return valida:
    
\begin{code}
      return scalar SSR, series resid
\end{code}

Si noti che la dichiarazione \verb+return+ \emph{non} indica alla
funzione di produrre il valore (terminare) nel punto in cui essa
appare nel corpo della funzione. Piuttosto, essa specifica quali
variabili sono disponibili per l'assegnazione quando la funzione
terminerà, cosa che può avvenire solo quando: a) viene raggiunta la
fine del codice che definisce la funzione; b) si incontra una
dichiarazione \verb+funcerr+ (si veda oltre); c) gretl produce un
errore.
    
La parola chiave \verb+funcerr+, che può essere seguita da una stringa
contenuta fra virgolette doppie, fa terminare una funzione con un
messaggio di errore, che può essere generico o rappresentato dalla
stringa indicata.
    

\subsection{Controllo degli errori}

Quando gretl legge e ``compila'' una definizione di funzione, esegue
un controllo degli errori minimale: controlla che il nome della
funzione sia accettabile e che non si tenti di definire una funzione
all'interno di una funzione (si veda la sezione~\ref{func-define}). Se
il corpo della funzione contiene comandi non validi, verrà segnalato
solo quando la funzione viene chiamata.

\section{Pacchetti di funzioni}
\label{func-packages}

A partire dalla versione 1.6.0, \app{gretl} contiene un meccanismo per creare
pacchetti di funzioni e renderli disponibili agli altri utenti. Questa
funzionalità è ancora sperimentale, ma è già utilizzabile seguendo
le istruzioni contenute in questa sezione.

Usando l'interfaccia grafica del programma, nel menù ``File, Funzioni'', si trovano
quattro voci: ``Sul sistema locale'', ``Sul server di gretl'', ``Modifica
pacchetto'', ``Nuovo pacchetto''.

Il comando ``Nuovo pacchetto'' funziona solo quando è stata caricata
in memoria almeno una funzione definita dall'utente, altrimenti si otterrà
un messaggio di avvertimento.

Ci sono vari modi per caricare una funzione in memoria:

\begin{itemize}
\item Se si ha un file script che contiene definizioni di funzioni, aprendo
  il file ed eseguendolo;
\item Creando un file script da zero, includendo almeno una definizione di
  funzione ed eseguendo lo script;
\item Aprendo il terminale di gretl e inserendo una definizione di funzione in
  modalità interattiva. Questo metodo non è particolarmente raccomandato: è
  probabilmente più comodo definire una funzione in modalità non interattiva.
\end{itemize}

Dopo aver caricato una funzione, la voce ``Nuovo pacchetto'' nel menù
``File, Funzioni'' è utilizzabile. La prima finestra di dialogo presenta due
alternative:

\begin{itemize}
\item Una o più funzioni pubbliche da impacchettare;
\item Zero o più funzioni ausiliarie ``private''.
\end{itemize}

Le funzioni pubbliche saranno disponibili per gli utenti, quelle private
fanno parte del meccanismo che lavora ``dietro le quinte'' in un pacchetto di funzioni.

Facendo clic su ``OK'' apparirà una seconda finestra di dialogo, in cui occorre
inserire le informazioni sul pacchetto (al momento: l'autore, la versione, la
data e una breve descrizione), oltre che un testo di aiuto che descrive
l'interfaccia pubblica della funzione. Se una funzione ha più di una interfaccia
pubblica, verrà mostrato un menù a discesa con cui è possibile attivare le varie
interfacce. Si ha l'opportunità di modificare il codice delle funzioni,
selezionandole dal menù e facendo clic su ``Modifica codice della funzione''.
Infine, è possibile scegliere di caricare il pacchetto sul server di gretl
appena lo si salva, selezionando l'apposita casella.

Facendo clic su ``OK'', si otterrà una finestra di salvataggio del file, che
suggerirà di salvare il file in una directory chiamata \texttt{functions}, collocata
sotto la directory di sistema di \app{gretl} (se si ha il permesso di scrittura
su di essa), oppure nella directory utente di \app{gretl}. Questo è il posto
suggerito per salvare i pacchetti di funzioni, visto che il programma li
cercherà automaticamente qui, al momento di aprire questo tipo di file.

Ovviamente, il comando ``File, Funzioni, Modifica pacchetto'' permette di
modificare un pacchetto precedentemente salvato.

\vspace{6pt}

Qualche informazione sui file dei pacchetti di funzioni: per impostazione
predefinita essi hanno l'estensione \texttt{.gfn}, e, a differenza dei file di
comandi di \app{gretl}, sono file in formato XML che contengono il codice delle
funzioni e le informazioni aggiunte dal creatore del pacchetto. Gli utenti
esperti possono anche scrivere questi file da zero, invece di usare l'editor di
pacchetti, ma la maggior parte delle persone troverà più comodo usare
quest'ultimo. Si noti che i caratteri speciali XML nel codice della funzione
vanno commentati, ad esempio \texttt{\&} va rappresentato come \texttt{\&amp;}.
Inoltre, alcuni elementi della sintassi delle funzioni differiscono dalla loro
rappresentazione standard all'interno degli script di comandi: i parametri e i
valori di uscita (se esistono) vanno rappresentati in XML. Sostanzialmente, la
funzione viene analizzata e caricata in modo veloce usando la \textsf{libxml}.

\vspace{6pt}

Perché impacchettare le funzioni in questo modo? Per scoprirlo, proviamo a
chiudere gretl, a riaprirlo, e ad andare nel menù ``File, Funzioni, Sul sistema
locale''. Se le operazioni precedenti sono andate a buon fine, troveremo il
pacchetto che avevamo creato, insieme alla sua breve descrizione. Facendo clic
su ``Info'', si ottiene una finestra con tutte le informazioni disponibili sul
pacchetto; facendo clic sull'icona ``Visualizza codice'' della barra degli
strumenti di questa nuova finestra, si aprirà una finestra che mostra il codice
delle funzioni contenute nel pacchetto. Tornando alla finestra ``Pacchetti funzioni'',
facendo clic sul nome di un pacchetto, le funzioni verranno caricate, pronte per
essere eseguite, usando il pulsante ``Chiama'' o l'interfaccia a riga di
comando.

Dopo aver caricato le funzioni contenute nel pacchetto, aprendo il terminale di
gretl, sarà possibile richiamare il testo di aiuto relativo ad una delle nuove
funzioni caricate, se esso esiste, con il comando \texttt{help funzione},
dove \texttt{funzione} è il nome di una delle funzioni del pacchetto caricato.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "gretl-guide-it"
%%% End: 

