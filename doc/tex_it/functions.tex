\chapter{Funzioni definite dall'utente}
\label{functions}

\section{Definizione di una funzione}
\label{func-define}

A partire dalla versione 1.3.3, \app{gretl} contiene un meccanismo per definire
funzioni all'interno di uno script. Questa funzionalità ha subito alcune
modifiche prima di raggiungere un assetto stabile ed estensibile, ma pensiamo che
la versione presente in \app{gretl} 1.6.1 costituisca una solida base per gli
sviluppi futuri.

Occorre definire una funzione prima di poterla utilizzare. La sintassi
per farlo è la seguente:

\begin{code}
      function nome-funzione(parametri)
         corpo della funzione
      end function
\end{code}

Il \textsl{nome-funzione} identifica la funzione in modo univoco: deve
iniziare con una lettera, può essere lungo al massimo 31 caratteri
(eventuali caratteri in più verranno troncati) e non può contenere
spazi. Se si tenta di definire una funzione con lo stesso nome di un
comando di \app{gretl}.

I \textsl{parametri} di una funzione vanno indicati sotto forma di lista
separata da virgole. I parametri possono essere di uno dei seguenti tipi:

\begin{center}
\begin{tabular}{ll}
\multicolumn{1}{c}{Tipo} &
\multicolumn{1}{c}{Descrizione} \\ [4pt]
\texttt{bool} & variabile scalare usata come interruttore Booleano \\
\texttt{int}  & variabile scalare usata come numero intero \\
\texttt{scalar} & variabile scalare \\
\texttt{series} & serie di dati \\
\texttt{list}   & lista di serie \\
\texttt{matrix} & matrice o vettore
\end{tabular}
\end{center}

Ogni elemento della lista di parametri deve includere due termini: per prima
cosa un indicatore di tipo, quindi il nome con cui il parametro verrà
riconosciuto all'interno della funzione. Ecco un esempio:
    
\begin{code}
      function funzione(series y, list xvars, bool verboso)
\end{code}

Oltre a questi elementi richiesti, la specificazione di un parametro
\texttt{scalare} può includere fino a tre ulteriori informazioni: un valore
minimo, uno massimo e un valore predefinito. Questi valori aggiuntivi devono
seguire direttamente il nome del parametro, devono essere racchiusi tra
parentesi quadre e i singoli elementi devono essere separati dal carattere due
punti. Ad esempio, ipotizzando di avere un parametro intero chiamato
\texttt{ordine} per cui si vuole specificare un valore minimo di 1, un massimo
di 12 e un valore predefinito di 4, si può scrivere
%    
\begin{code}
      int ordine[1:12:4]
\end{code} 
%
Per omettere uno dei tre valori aggiuntivi, basta lasciare vuoto il campo
corrispondente. Ad esempio, \texttt{[1::4]} specifica un minimo di 1 e un valore
predefinito di 4, senza porre limiti al valore massimo.

Per parametri di tipo \texttt{bool} è possibile specificare come valori predefiniti 
1 (vero) o 0 (falso), come in questo esempio:
%    
\begin{code}
      bool verboso[0]
\end{code} 
%

È possibile definire funzioni che non hanno parametri (quelle che in alcuni
linguaggi di programmazione vengono chiamate ``routine''). In questo caso,
occorre usare la parola chiave \texttt{void} al posto dell'elenco dei
parametri:
%    
\begin{code}
      function funzione2(void)
\end{code}

Quando una funzione viene chiamata, i parametri vengono istanziati
usando gli argomenti indicati nella chiamata della funzione. Vengono
fatti dei controlli automatici per assicurarsi che il numero degli
argomenti contenuti in una chiamata di funzione corrisponda al numero
di parametri, e che i tipi degli argomenti corrispondano ai tipi
specificati nella definizione della funzione; se qualcuna di queste
condizioni è violata, viene segnalato un errore\footnote{È consentito
omettere degli argomenti alla fine della lista, a patto che i valori predefiniti
siano specificati nella definizione della funzione. Più precisamente: il
controllo consiste nell'assicurarsi che il numero degli argomenti sia almeno
uguale al numero dei parametri \textit{richiesti} e non superiore al numero
totale dei parametri.}.

È possibile indicare uno scalare, una serie, o una matrice come argomento
di una funzione, sia specificando il nome di una variabile preesistente,
oppure (con un'eccezione che si vedrà in seguito) utilizzando un'espressione
che, valutata, restituisce una variabile del tipo appropriato.
Gli scalari possono essere indicati anche sotto forma di valori numerici, mentre
le liste devono essere indicate per nome.

Il \textsl{corpo della funzione} è composto da comandi \app{gretl} o
funzioni definite dall'utente (ossia, le funzioni possono essere
nidificate).  Una funzione può persino chiamare sé stessa (ossia, le
funzioni possono essere ricorsive), fino a un massimo di 8 ``livelli
di ricorsività'', ma questo valore è provvisorio, potrà essere
aumentato se sembra troppo restrittivo.  Se il corpo della funzione
può contenere chiamate ad altre funzioni non può però contenere
definizioni di altre funzioni, ossia non è possibile definire una
funzione all'interno di un'altra funzione.

\section{Chiamata di una funzione}
\label{func-call}

Una funzione utente viene chiamata, o invocata, usando il suo nome,
eventualmente seguito da argomenti tra parentesi; se si usano due o più argomenti,
vanno separati da virgole. L'esempio seguente mostra una chiamata di
funzione che rispetta la definizione della funzione stessa.
    
\begin{code}
      # Definizione della funzione
      function ols_ess(series y, list xvars)
        ols y 0 xvars --quiet
        scalar myess = $ess
        printf "ESS = %g\n", myess
        return scalar myess
      end function
      # Script principale
      open data4-1
      list xlist = 2 3 4
      # Chiamata della funzione (il valore restituito viene qui ignorato)
      ols_ess(price, xlist)
\end{code}

La chiamata della funzione contiene due argomenti: il primo è una
serie di dati specificata per nome, e il secondo è una lista di
regressori. Si noti che la funzione produce la variabile \verb+myess+
come risultato, ma in questo esempio esso è ignorato. Una nota a
margine: se si desidera che una funzione calcoli alcuni valori che
hanno a che fare con una regressione, ma non si è interessati ai
risultati completi della regressione, è possibile usare l'opzione
\verb+--quiet+ con il comando di stima, come visto sopra.
    
Un secondo esempio mostra una chiamata di funzione che assegna il
valore prodotto dalla funzione ad alcune variabili:
    
\begin{code}
      # Definizione di funzione
      function get_uhat(series y, list xvars)
        ols y 0 xvars --quiet
        series uh = $uhat
        return series uh
      end function
      # Script principale
      open data4-1
      list xlist = 2 3 4
      # Chiamata di funzione
      series resids = get_uhat(price, xlist)
\end{code}

\section{Programmazione delle funzioni}
\label{func-details}
 
\subsection{Ambito delle variabili}

Tutte le variabili create in una funzione sono locali a quella
funzione, e vengono distrutte quando la funzione termina la sua
esecuzione, a meno che esse siano rese disponibili come valori di
ritorno, e che questi siano ``raccolti'' o assegnati nella chiamata
della funzione.

Le funzioni non hanno accesso alle variabili dell'``ambiente esterno''
(ossia le variabili che esistono nello script da cui la funzione è
chiamata), a meno che queste siano passate esplicitamente alla
funzione come argomenti.

Nel caso standard, quando una variabile viene passata a una funzione come
argomento, la funzione ottiene una copia della variabile esterna, quindi il
valore della variabile nell'ambiente esterno non viene modificato dalle
operazioni che avvengono all'interno della funzione. Esiste tuttavia un
meccanismo per consentire a una funzione e all'ambiente di ``cooperare'' in modo
che una variabile esterna possa essere modificata dalla funzione. Questo
meccanismo consente a una funzione di restituire più di un valore (anche se una
funzione può restituire direttamente al massimo una variabile, come spiegato in
seguito). Questo metodo assomiglia (almeno superficialmente) al passaggio
dell'indirizzo di una variabile in linguaggio C. Il parametro in questione viene
contrassegnato col prefisso \texttt{*} nella definizione della funzione, mentre
l'argomento corrispondente viene contrassegnato col prefisso complementare
\verb+&+ nella chiamata. Ad esempio:
%
\begin{code}
      function get_uhat_and_ess(series y, list xvars, scalar *ess)
        ols y 0 xvars --quiet
        ess = $ess
        series uh = $uhat
        return series uh
      end function
      # Script principale
      open data4-1
      list xlist = 2 3 4
      # Chiamata di funzione
      scalar SSR
      series resid = get_uhat_and_ess(price, xlist, &SSR)
\end{code}
%
In questo caso, alla funzione viene passato l'indirizzo della variabile scalare
\texttt{SSR} a cui viene assegnato un valore (usando il nome \texttt{ess}).
Per chi ha familiarità con la programmazione in C, si noti che non è necessario
(né possibile) ``dereferenziare'' la variabile in questione nella funzione
usando l'operatore \texttt{*}. Per accedere al contenuto della variabile
nell'ambiente esterno è sufficiente usare il nome della variabile senza
prefissi.

La specificazione di uno o più parametri speciali nella definizione di una
funzione può essere utile per offrire informazioni opzionali alla chiamata. Se
il parametro ``indirizzo'' è opzionale, occorre fornire come valore predefinito
\texttt{null}. In questo caso la funzione dovrebbe controllare se alla chiamata
è stato fornito un argomento corrispondente, usando la funzione \texttt{isnull()}.
Ad esempio, ecco la funzione vista in precedenza, modificata in modo da rendere
opzionale l'indicazione del valore di \texttt{ess}.
%
\begin{code}
      function get_uhat_and_ess(series y, list xvars, scalar *ess[null])
        ols y 0 xvars --quiet
        if !isnull(ess) 
           ess = $ess
        endif
        series uh = $uhat
        return series uh
      end function
\end{code}
%
Se alla chiamata non si ha interesse per il valore di \texttt{ess}, occorre usare
\texttt{null} al posto di un vero argomento:
%
\begin{code}
      series resid = get_uhat_and_ess(price, xlist, null)
\end{code}


\subsection{Valori di uscita}

Le funzioni possono non produrre alcun valore (limitandosi ad esempio
a stampare un risultato), oppure possono produrre una singola variabile:
una scalare, una serie o una matrice. Il valore di uscita è specificato
con una dichiarazione all'interno del corpo della funzione
che comincia con la parola chiave \verb+return+, seguita dall'indicatore del
tipo e dal nome della variabile (in modo analogo a quanto avviene per la lista
dei parametri di una funzione).  All'interno di una funzione può esserci solo
una di queste dichiarazioni. Ecco un esempio di dichiarazione return valida:
%
\begin{code}
      return scalar SSR
\end{code}
%
Si noti che la dichiarazione \verb+return+ \emph{non} indica alla
funzione di produrre il valore (terminare) nel punto in cui essa
appare nel corpo della funzione. Piuttosto, essa specifica quale
variabile è disponibile per l'assegnazione quando la funzione
terminerà, cosa che può avvenire solo quando: a) viene raggiunta la
fine del codice che definisce la funzione, oppure b) si incontra una
dichiarazione \verb+funcerr+ (si veda oltre), o c) gretl produce un
errore.
 
La parola chiave \verb+funcerr+, che può essere seguita da una stringa
contenuta fra virgolette doppie, fa terminare una funzione con un
messaggio di errore, che può essere generico o rappresentato dalla
stringa indicata.
    

\subsection{Controllo degli errori}

Quando gretl legge e ``compila'' una definizione di funzione, esegue
un controllo degli errori minimale: controlla che il nome della
funzione sia accettabile e che non si tenti di definire una funzione
all'interno di una funzione (si veda la sezione~\ref{func-define}). Se
il corpo della funzione contiene comandi non validi, verrà segnalato
solo quando la funzione viene chiamata.

\section{Pacchetti di funzioni}
\label{func-packages}

A partire dalla versione 1.6.0, \app{gretl} contiene un meccanismo per creare
pacchetti di funzioni e renderli disponibili agli altri utenti. Questa
funzionalità è ancora sperimentale, ma è già utilizzabile seguendo
le istruzioni contenute in questa sezione.

Usando l'interfaccia grafica del programma, nel menù ``File, Funzioni'', si trovano
quattro voci: ``Sul sistema locale'', ``Sul server di gretl'', ``Modifica
pacchetto'', ``Nuovo pacchetto''.

Il comando ``Nuovo pacchetto'' funziona solo quando è stata caricata
in memoria almeno una funzione definita dall'utente, altrimenti si otterrà
un messaggio di avvertimento.

Ci sono vari modi per caricare una funzione in memoria:

\begin{itemize}
\item Se si ha un file script che contiene definizioni di funzioni, aprendo
  il file ed eseguendolo;
\item Creando un file script da zero, includendo almeno una definizione di
  funzione ed eseguendo lo script;
\item Aprendo il terminale di gretl e inserendo una definizione di funzione in
  modalità interattiva. Questo metodo non è particolarmente raccomandato: è
  probabilmente più comodo definire una funzione in modalità non interattiva.
\end{itemize}

Dopo aver caricato una funzione, la voce ``Nuovo pacchetto'' nel menù
``File, Funzioni'' è utilizzabile. La prima finestra di dialogo presenta due
alternative:

\begin{itemize}
\item Una funzione pubblica da impacchettare;
\item Zero o più funzioni ausiliarie ``private''.
\end{itemize}

Le funzioni pubbliche sono direttamente disponibili per gli utenti, quelle private
fanno parte del meccanismo che lavora ``dietro le quinte'' in un pacchetto di funzioni.

Facendo clic su ``OK'' apparirà una seconda finestra di dialogo, in cui occorre
inserire le informazioni sul pacchetto (al momento: l'autore, la versione, la
data e una breve descrizione), oltre che un testo di aiuto che descrive
l'interfaccia pubblica della funzione. Si ha l'opportunità di modificare il
codice delle funzioni, selezionandole dal menù e facendo clic su ``Modifica
codice della funzione''.  Infine, è possibile scegliere di caricare il pacchetto
sul server di gretl appena lo si salva, selezionando l'apposita casella.

Facendo clic su ``OK'', si otterrà una finestra di salvataggio del file, che
suggerirà di salvare il file in una directory chiamata \texttt{functions}, collocata
sotto la directory di sistema di \app{gretl} (se si ha il permesso di scrittura
su di essa), oppure nella directory utente di \app{gretl}. Questo è il posto
suggerito per salvare i pacchetti di funzioni, visto che il programma li
cercherà automaticamente qui, al momento di aprire questo tipo di file.

Ovviamente, il comando ``File, Funzioni, Modifica pacchetto'' permette di
modificare un pacchetto precedentemente salvato.

\vspace{6pt}

Qualche informazione sui file dei pacchetti di funzioni: per impostazione
predefinita essi hanno l'estensione \texttt{.gfn}, e, a differenza dei file di
comandi di \app{gretl}, sono file in formato XML che contengono il codice delle
funzioni e le informazioni aggiunte dal creatore del pacchetto. Gli utenti
esperti possono anche scrivere questi file da zero, invece di usare l'editor di
pacchetti, ma la maggior parte delle persone troverà più comodo usare
quest'ultimo. Si noti che i caratteri speciali XML nel codice della funzione
vanno commentati, ad esempio \texttt{\&} va rappresentato come \texttt{\&amp;}.
Inoltre, alcuni elementi della sintassi delle funzioni differiscono dalla loro
rappresentazione standard all'interno degli script di comandi: i parametri e i
valori di uscita (se esistono) vanno rappresentati in XML. Sostanzialmente, la
funzione viene analizzata e caricata in modo veloce usando la \textsf{libxml}.

\vspace{6pt}

Perché impacchettare le funzioni in questo modo? Per scoprirlo, proviamo a
chiudere gretl, a riaprirlo, e ad andare nel menù ``File, Funzioni, Sul sistema
locale''. Se le operazioni precedenti sono andate a buon fine, troveremo il
pacchetto che avevamo creato, insieme alla sua breve descrizione. Facendo clic
su ``Info'', si ottiene una finestra con tutte le informazioni disponibili sul
pacchetto; facendo clic sull'icona ``Visualizza codice'' della barra degli
strumenti di questa nuova finestra, si aprirà una finestra che mostra il codice
delle funzioni contenute nel pacchetto. Tornando alla finestra ``Pacchetti funzioni'',
facendo clic sul nome di un pacchetto, le funzioni verranno caricate, pronte per
essere eseguite, usando il pulsante ``Chiama'' o l'interfaccia a riga di
comando.

Dopo aver caricato le funzioni contenute nel pacchetto, aprendo il terminale di
gretl, sarà possibile richiamare il testo di aiuto relativo ad una delle nuove
funzioni caricate, se esso esiste, con il comando \texttt{help funzione},
dove \texttt{funzione} è il nome di una delle funzioni del pacchetto caricato.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "gretl-guide-it"
%%% End: 

