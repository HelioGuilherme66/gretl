\chapter{Matrix manipulation}
\label{chap-matrices}

\section{Introduzione}
\label{matrix-intro}

Dalla versione 1.5.1, gretl offre la possibilità di creare e manipolare matrici
definite dall'utente. Questa funzionalità è ancora sperimentale.

\section{Creazione di matrici}
\label{matrix-create}

È possibile creare una matrice in uno dei quattro modi seguenti:

\begin{enumerate}
\item Specificando direttamente i valori scalari che compongono la matrice,
  in forma numerica o per riferimento a variabili scalari preesistenti, o in un
  modo misto;
\item fornendo una lista di serie di dati;
\item fornnendo una \textit{lista personalizzata} di serie:
\item usando una formula simile a quelle usate con il comando
  \texttt{genr}, in cui una nuova matrice viene definita in termini di matrici
  e/o scalari esistenti, oppure attraverso funzioni speciali.
\end{enumerate}

Questi metodi non possono essere mescolati nella specificazione di una singola
matrice. Ecco alcuni esempi.

Per specificare una matrice \textit{direttamente in termini di scalari}, la
sintassi è la seguente:

\begin{code}
matrix A = { 1, 2, 3 ; 4, 5, 6 }
\end{code}

La matrice viene definita per righe successive; gli elementi di ogni riga sono
separati da virgole e le righe sono separate da punti e virgola. L'intera
espressione va racchiusa tra parentesi graffe. Gli spazi tra le parentesi non
sono significativi. L'espressione vista sopra definisce una matrice $2\times3$.
Ogni elemento deve essere un valore numerico o il nome di una variabile scalare
preesistente. Per ottenere la matrice trasposta, basta aggiungere un apostrofo
(\texttt{'}) direttamente dopo la parentesi graffa che chiude l'espressione.

Per specificare una matrice \textit{in termini di serie di dati} la sintassi è
la seguente:
%
\begin{code}
matrix A = { x1, x2, x3 }
\end{code}
%
dove i nomi delle variabili sono separati da virgole. Per impostazione
predefinita, ogni variabile rappresenta una colonna (e può esserci solo una
variabile per ogni colonna). L'intervallo dei valori dei dati inclusi nella
matrice dipende dall'impostazione corrente dell'intervallo del campione.

Si noti che mentre le funzioni statistiche di gretl sono in grado di gestire
valori mancanti, le funzioni che trattano le matrici non lo sono, quindi si
otterrà un errore se si cerca di costruire una matrice usando delle serie che
contengono valori mancanti.

Invece di fornire una lista esplicita di variabili, è possibile fornire il
\textit{nome di una lista personalizzata} (si veda il capitolo~\ref{persist}),
come nell'esempio
%
\begin{code}
list xlist = x1 x2 x3
matrix A = { xlist }
\end{code}
%
Se si usa il nome di una lista, le serie che la costituiscono vengono usate per
comporre le colonne, come risulta naturale in un contesto econometrico; se si
vuole che vengano usate come righe, basta usare il simbolo di trasposizione.

È possibile creare nuove matrici, o sostituire matrici esistenti, usando varie
trasformazioni, in modo simile a quelle usate per il comando \texttt{genr}
per gli scalari e le serie di dati. Per ottenere una matrice come risultato,
però, il comando deve iniziare con la parola chiave \texttt{matrix}, non
\texttt{genr}.  I prossimi paragrafi spiegano nel dettaglio questi meccanismi.

\tip{I nomi delle matrici devono soddisfare gli stessi requisiti dei nomi delle
variabili in gretl: il nome non può essere più lungo di 15 caratteri, deve
iniziare per una lettera e deve essere composto da lettere, numeri e il
carattere trattino basso.}

\section{Operatori matriciali}
\label{matrix-op}

Per le matrici sono disponibili gli operatori seguenti:

\begin{center}
\begin{tabular}{ll}
\texttt{+} & addizione \\
\texttt{-} & sottrazione \\
\texttt{*} & moltiplicazione matriciale \\
\texttt{/} & ``divisione'' matriciale (si veda oltre) \\
\texttt{.*} & moltiplicazione per elementi \\
\texttt{./} & divisione per elementi \\
\verb+.^+ & elevazione a potenza per elementi \\
\verb+~+ & concatenazione per colonne \\
\texttt{**} & prodotto di Kronecker \\
\texttt{=} & test per l'uguaglianza 
\end{tabular}
\end{center}

Ecco qualche spiegazione per i casi meno ovvi. Per prima cosa, la
``divisione'' tra matrici, $A/B$ è algebricamente equivalente a $B^{-1}A$
(pre-moltiplicazione per mezzo dell'inversa del ``divisore''). Quindi in linea
di principio le due espressioni seguenti sono equivalenti:
%
\begin{code}
matrix C = A / B
matrix C = inv(B) * A
\end{code}
%
dove \texttt{inv()} è la funzione di inversione tra matrici (si veda oltre).
Però la prima forma può essere più accurata della seconda, perché la soluzione è
ottenuta tramite la scomposizione LU, senza calcolare esplicitamente la matrice
inversa.

Nella moltiplicazione per elementi, scrivendo
%
\begin{code}
matrix C = A .* B
\end{code}
% 
il risultato dipende dalle dimensioni di $A$ e $B$. Se $A$ è una matrice
$m \times n$ e $B$ è una matrice $p \times q$.  
%
\begin{itemize}
\item Se $m=p$ e $n=q$, $C$ sarà una matrice $m\times n$ con $c_{ij} = a_{ij}
  \times b_{ij}$.
\item Se $m=1$ e $n=q$, oppure $n=1$ e $m=p$, $C$ sarà una matrice
  $p\times q$ con $c_{ij} = b_{ij} \times a_k$, dove $k=j$ se $m=1$,
  altrimenti $k=i$.
\item Se $p=1$ e $n=q$, oppure $q=1$ e $m=p$, $C$ sarà una matrice
  $m\times n$ con $c_{ij} = a_{ij} \times b_k$, dove $k=j$ se $p=1$,
  altrimenti $k=i$.
\item Se non è soddisfatta alcuna delle condizioni viste, il prodotto non è
  definito e viene segnalato un errore.
\end{itemize}

Nella divisione per elementi, le due matrici devono essere delle stesse
dimensioni. Data
%
\begin{code}
matrix C = A ./ B
\end{code}
% 
il risultato è la matrice $C$ tale che $c_{ij} = a_{ij}/b_{ij}$.

L'elevamento a potenza per elementi, come in
%
\begin{code}
matrix C = A .^ B
\end{code}
% 
produce $c_{ij} = a_{ij}^k$. La variabile $k$ deve essere uno scalare o una
matrice $1\times 1$.

Nella concatenazione tra una matrice $A$ $m\times n$ e una matrice $B$ $m\times
p$, il risultato è una matrice $m\times (n+p)$. Ossia,
%
\begin{code}
C = A ~ B
\end{code}
% 
produce $C = \left[ \begin{array}{cc} A & B \end{array} \right]$.

\section{Funzioni matriciali}
\label{matrix-func}

Sono disponibili le seguenti funzioni per \textit{la trasformazione
elemento per elemento} delle matrici: \texttt{log}, \texttt{exp},
\texttt{sin}, \texttt{cos}, \texttt{tan}, \texttt{atan}, \texttt{int},
\texttt{abs}, \texttt{sqrt}, \texttt{dnorm}, \texttt{cnorm},
\texttt{qnorm}, \texttt{gamma} e \texttt{lngamma}. Queste funzioni hanno
lo stesso significato di quando sono usate con \texttt{genr}. Ad esempio,
se una matrice \texttt{A} è già stata definita,
%
\begin{code}
matrix B = sqrt(A)
\end{code}
%
genera una matrice tale che $b_{ij} = \sqrt{a_{ij}}$.  Tutte queste
funzioni richiedono una sola matrice come argomento, o un'espressione
che si risolve in una singola matrice.

Le funzioni \texttt{sort()} e \texttt{dsort()} utilizzabili con le serie di
dati, possono essere usate anche con le matrici. In questo caso,
l'argomento di queste funzioni deve essere un vettore ($p \times 1$ o
$1\times p$).  Il valore restituito è un vettore che contiene gli elementi del
vettore originale riordinati in ordine di grandezza crescente (\texttt{sort})
o decrescente (\texttt{dsort}).

Infine, ci sono funzioni dedicate in modo specifico alle matrici, che è
possibile suddividere in quattro categorie:
%
\begin{enumerate}
\item Quelle che richiedono come argomento una sola matrice e restituiscono uno scalare.
\item Quelle che richiedono come argomento una sola matrice e restituiscono una matrice.
\item Quelle che richiedono come argomento uno o due valori e restituiscono una matrice.
\item Quelle che richiedono come argomento una o due matrici e restituiscono una o due matrici.
\end{enumerate}
%
Questi gruppi di funzioni vengono presentati nell'ordine.

\subsection{Funzioni da matrice a scalare}
\label{matrix-to-scalar}

Le funzioni che richiedono come argomento una sola matrice e restituiscono uno
scalare sono:

\begin{center}
\begin{tabular}{ll}
\texttt{det()} & determinante \\
\texttt{ldet()} & log-determinante \\
\texttt{tr()} & traccia \\
\texttt{onenorm()} & norma-1 \\
\texttt{rcond()} & reciproco del numero di condizione \\
\texttt{rows()} & numero di righe \\
\texttt{cols()} & numero di colonne 
\end{tabular}
\end{center}

L'argomento di queste funzioni può essere il nome di una matrice esistente o
un'espressione che si risolve in una matrice. Si noti che le funzioni
\texttt{det}, \texttt{ldet} e \texttt{tr} richiedono una matrice quadrata.

La funzione \texttt{onenorm} restituisce la norma-1 di una matrice, ossia
il massimo tra le colonne della matrice della somma dei valori assoluti degli
elementi della colonna. La funzione \texttt{rcond} restituisce il reciproco del
numero di condizione per una matrice simmetrica definita positiva.

\subsection{Funzioni da matrice a matrice}
\label{matrix-to-matrix}

Le funzioni che richiedono come argomento una sola matrice e restituiscono una
matrice sono:

\begin{center}
\begin{tabular}{ll}
\texttt{inv()} & inversa \\
\texttt{cholesky()} & scomposizione di Cholesky \\
\texttt{diag()} & diagonale principale \\
\texttt{transp()} & trasposta \\
\texttt{cdemean()} & sottrazione della media delle colonne 
\end{tabular}
\end{center}

Come per il gruppo precedente di funzioni, l'argomento deve essere il nome di
una matrice esistente o un'espressione che si risolve in una matrice.

La funzione \texttt{cholesky} calcola la scomposizione di Cholesky
$L$ di una matrice simmetrica definita positiva $A$: $A = LL'$; $L$ è
triangolare inferiore (contiene zeri al di sopra della diagonale).

La funzione \texttt{diag} restituisce la diagonale principale di una matrice
$n\times n$ $A$ come vettore colonna, ossia come vettore $n$-dimensionale $v$
tale che $v_i = a_{ii}$.

La funzione \texttt{cdemean} applicata a una matrice $A$ $m \times n$
restituisce una mattrice $B$ $m \times n$ tale che $b_{ij} = a_{ij} -
\bar{A}_j$, dove $\bar{A}_j$ indica la media della colonna $j$ di $A$.  

\subsection{Matrix filling functions}
\label{matrix-fill}

Le funzioni che richiedono come argomento uno o due valori e restituiscono una
matrice sono:

\begin{center}
\begin{tabular}{ll}
\texttt{I(}\textsl{n}\texttt{)} & matrice identità $n\times n$ \\
\texttt{zeros(}\textsl{m}\texttt{,}\textsl{n}\texttt{)} & 
   matrice nulla $m\times n$ \\
\texttt{ones(}\textsl{m}\texttt{,}\textsl{n}\texttt{)} &
   matrice $m\times n$ con tutti gli elementi pari a 1 \\
\texttt{uniform(}\textsl{m}\texttt{,}\textsl{n}\texttt{)} &
   matrice $m\times n$ con elementi casuali uniformi \\
\texttt{normal(}\textsl{m}\texttt{,}\textsl{n}\texttt{)} &
   matrice $m\times n$ con elementi casuali normali \\
\end{tabular}
\end{center}

Le dimensioni \textsl{m} e \textsl{n} possono essere indicate numericamente o
per riferimento a variabili scalari pre-esistenti, come in
%
\begin{code}
scalar m = 4
scalar n = 5
matrix A = normal(m,n)
\end{code}
%
Le funzioni matriciali \texttt{uniform()} e \texttt{normal()} riempiono la
matrice con valori estratti dalla distribuzione uniforme (0--1) e dalla
distribuzione normale standard.

\subsection{Multiple-return matrix functions}
\label{matrix-multiples}

Le funzioni che richiedono come argomento una o due matrici e restituiscono una
o due matrici sono:

\begin{center}
\begin{tabular}{ll}
\texttt{qrdecomp()} & Scomposizione QR \\
\texttt{eigensym()} & Auto-analisi di una matrice simmetrica \\
\texttt{eigengen()} & Auto-analisi di una matrice generica
\end{tabular}
\end{center}

La sintassi per queste funzioni è della forma
%
\begin{textcode}
matrix B = func(\textsl{A}, \textsl{C})
\end{textcode}
%
Il primo argomento, \ttsl{A}, rappresenta i dati in ingresso, ossia la matrice
di cui è richiesta la scomposizione o l'analisi. Questo deve essere specificato
sotto forma di nome di una matrice esistente; in questo caso non è accettata
un'espressione che si risolve in una matrice.

Il secondo argomento, \ttsl{C}, può essere il nome di una matrice, nel qual caso
il risultato della funzione viene scritto in quella matrice, oppure la parola
chiave \texttt{null}, nel qual caso il risultato non è mostrato o è scartato.

Nel caso in cui venga specificato il nome di una matrice come secondo argomento,
se questa matrice non era già stata definita in precedenza, verrà creata una nuova
matrice con questo nome. Se esiste già una matrice con questo nome, sarà
sovrascritta con il risultato della funzione (non è richiesto che la matrice
preesistente abbia le dimensioni corrette per ricevere il risultato della
funzione).

La funzione \texttt{qrdecomp} calcola la scomposizione QE di una matrice $m
\times n$ $A$: $A = QR$, dove $Q$ è una matrice ortonormale $m \times n$
e $R$ è una matrice $n \times n$ triangolare superiore.
La matrice $Q$ è prodotta direttamente, mentre $R$ può essere recuperata
attraverso il secondo argomento. Ecco due esempi:
%
\begin{code}
matrix Q = qrdecomp(M, R)
matrix Q = qrdecomp(M, null)
\end{code}
%
Nel primo esempio, la matrice triangolare $R$ è salvata come \texttt{R};
nel secondo, $R$ è scartata.

La funzione \texttt{eigensym} calcola gli autovalori, e opzionalmente gli
autovettori destri, di una matrice simmetrica $n \times n$.
Gli autovalori sono restituiti direttamente in un vettore colonna di lunghezza
$n$; se vengono richiesti gli autovettori, sono restituiti in una matrice $n
\times n$. Ad esempio:
%
\begin{code}
matrix E = eigensym(M, V)
matrix E = eigensym(M, null)
\end{code}
%
Nel primo caso \texttt{E} contiene gli autovalori di \texttt{M} e
\texttt{V} contiene gli autovettori. Nel secondo, \texttt{E} contiene gli
autovalori, ma gli autovettori non vengono calcolati.

La funzione \texttt{eigengen} calcola gli autovalori, e opzionalmente gli
autovettori, di una matrice generica $n \times n$. Gli autovalori vengono
restituiti direttamente in un vettore colonna di lunghezza $2n$: i primi
$n$ elementi sono le componenti reali, mentre i restanti $n$ sono le componenti
immaginarie. Se vengono richiesti gli autovettori (ossia il secondo argomento di
\texttt{eigengen} non è \texttt{null}), essi vengono restituiti in una matrice
$n \times n$.

\section{Matrix accessors}
\label{matrix-accessors}

In addition to the matrix functions discussed above,
various ``accessor'' strings allow you to create copies of internal
matrices associated with models previously estimated:

\begin{center}
\begin{tabular}{ll}
\texttt{\$coeff} & vector of estimated coefficients \\
\texttt{\$stderr} & vector of estimated standard errors \\
\texttt{\$uhat} & vector of residuals \\
\texttt{\$yhat} & vector of fitted values \\
\texttt{\$vcv} & covariance matrix for coefficients \\
\texttt{\$rho} & autoregressive coefficients for error process
\end{tabular}
\end{center}

If these accessors are given without any prefix, they retrieve results
from the last model estimated, if any.  Alternatively, they may be
prefixed with the name of a saved model plus a period (\texttt{.}), in
which case they retrieve results from the specified model.  Here are
some examples:
%
\begin{textcode}
matrix u = \$uhat\\
matrix b = m1.\$coeff\\
matrix v2 = m1.\$vcv[1:2,1:2]
\end{textcode}
%
The first command grabs the residuals from the last model; the second
grabs the coefficient vector from model \texttt{m1}; and the third
(which uses the mechanism of sub-matrix selection described in the
following section) grabs a portion of the covariance matrix from model
\texttt{m1}.

If the ``model'' in question is actually a system (a VAR
or VECM, or system of simultaneous equations), \texttt{\$uhat}
retrieves the matrix of residuals (one column per equation) and
\texttt{\$vcv} gets the cross-equation covariance matrix.  At present
the other accessors are not available for equation systems.


\section{Selecting sub-matrices}
\label{matrix-sub}

You can select sub-matrices of a given matrix using the syntax

\texttt{A[}\textsl{rows},\textsl{cols}\texttt{]}

where \textsl{rows} can take one of four forms:

\begin{center}
\begin{tabular}{ll}
empty & selects all rows \\
a single integer & selects the single specified row \\
two integers separated by a colon & selects a range of rows \\
the name of a matrix & selects the specified rows \\
\end{tabular}
\end{center}

With regard to the second option, the integer value can be given
numerically, or as the name of an existing scalar variable.  With the
last option, the index matrix given in the \textsl{rows} field must be
either $p\times 1$ or $1\times p$, and should contain integer values
in the range 1 to $n$, where $n$ is the number of rows in the matrix
from which the selection is to be made.

The \textsl{cols} specification works in the same way, \textit{mutatis
  mutandis}.  Here are some examples.
%
\begin{code}
matrix B = A[1,]
matrix B = A[2:3,3:5]
matrix B = A[2,2]
matrix idx = { 1, 2, 6 }
matrix B = A[idx,]
\end{code}
%
The first example selects row 1 from matrix \texttt{A}; the second
selects a $2\times 3$ submatrix; the third selects a scalar; and
the fourth selects rows 1, 2, and 6 from matrix \texttt{A}.

In addition there is a special pre-defined ``index matrix''
specification, \texttt{diag}, which selects the principal diagonal of
a square matrix, as in \texttt{B[diag]}, where \texttt{B} is square.

You can use selections of this sort on either the right-hand side of
a matrix-generating formula or the left.  Here is an example of use of
a selection on the right, to extract a $2\times 2$ submatrix $B$ from a
$3\times 3$ matrix $A$:
%
\begin{code}
matrix A = { 1, 2, 3; 4, 5, 6; 7, 8, 9 }
matrix B = A[1:2,2:3]
\end{code}
%
And here are examples of selection on the left.  The second line below
writes a $2\times 2$ identity matrix into the bottom right corner of the
$3\times 3$ matrix $A$.  The fourth line replaces the diagonal of $A$ 
with 1s.
%
\begin{code}
matrix A = { 1, 2, 3; 4, 5, 6; 7, 8, 9 }
matrix A[2:3,2:3] = I(2)
matrix d = { 1, 1, 1 }
matrix A[diag] = d
\end{code}

\section{Namespace issues}
\label{matrix-namespace}

Matrices share a common namespace with data series and scalar
variables.  In other words, no two objects of any of these types can
have the same name.  In case of potential collisions --- where an
object of one type already exists with a certain name, and you try to
create an object of a different type with the same name --- gretl
follows the policy of allowing you to overwrite the existing object, 
with the exception that \textit{data series are protected and cannot be
over-written by scalars or matrices}.  Some implications of this
policy are noted below.
%
\begin{itemize}
\item If a series called, say, \texttt{X}, exists and you try to
  create a matrix named \texttt{X}, an error is flagged.
\item If you create a series named \texttt{X} --- using the
  \texttt{genr} or \texttt{series} commands, or by reading from a data
  file, or by importation from a database --- then any pre-existing
  matrix named \texttt{X} is automatically deleted.
\item If you create a scalar named \texttt{X}, any existing matrix
  \texttt{X} is deleted.
\end{itemize}
%
If you really want to create a matrix using a name that is currently
assigned to a data series, you must first delete the data series using
the \texttt{delete} command or rename it using \texttt{rename}.

\section{Creating a data series from a matrix}
\label{matrix-create-series}

Section~\ref{matrix-create} above describes how to create a matrix
from a data series or set of series.  You may sometimes wish to go in
the opposite direction, that is, to copy values from a matrix 
into a regular data series.  The syntax for this operation is
%
\begin{textcode}
series \textsl{sname} = \textsl{mspec}
\end{textcode}
%
where \ttsl{sname} is the name of the series to create and
\ttsl{mspec} is the name of the matrix to copy from, possibly followed
by a matrix selection expression.  Here are two examples.
%
\begin{code}
series s = x
series u1 = U[,1]
\end{code}
%
It is assumed that \texttt{x} and \texttt{U} are pre-existing
matrices.  In the second example the series \texttt{u1} is formed from
the first column of the matrix \texttt{U}.

For this operation to work, the matrix (or matrix selection) must be a
vector with length equal to either the full length of the current
dataset, $n$, or the length of the current sample range, $n^{\prime}$.
If $n^{\prime} < n$ then only $n^{\prime}$ elements are drawn from the
matrix; if the matrix or selection comprises $n$ elements, the
$n^{\prime}$ values starting at element $t_1$ are used, where $t_1$
represents the starting observation of the sample range.  Any values
in the series that are not assigned from the matrix are set to the
missing code.
 
Please note that when forming a series in this way, the right-hand
side of the \texttt{series} command can be \textit{only} the name of a
matrix, or the name of a matrix plus a selection expression.  There is
no provision for matrix calculation in this context.

\section{Eliminazione di matrici}
\label{matrix-delete}

Per eliminare una matrice, si usa la sintassi
%
\begin{code}
matrix A delete
\end{code}
%
dove \texttt{A} è il nome della matrice da eliminare.

\section{Further points and example}
\label{matrix-example}

Example \ref{examp-matrix} shows how matrix methods can be used to
replicate gretl's built-in OLS functionality.  The example illustrates
various additional points.  

First, if you just write \texttt{matrix A}, where a matrix \texttt{A}
is already defined, the effect is to print the matrix.

Second, there is some ``cross over'' between matrix expressions and
\texttt{genr} (actually the synonym \texttt{scalar} is used in the
script).  In a \texttt{genr} formula, you can use matrix functions
that produce scalar results (e.g.\ \texttt{rows()}).  You can also
reference $1\times 1$ matrices as if they were ordinary scalars.  And
in a \texttt{matrix} formula you can reference scalar variables where
appropriate.  

Note, however, that ordinary data series cannot be used in
\texttt{matrix} expressions, other than in the special case of
defining a matrix from a list of series as in
section~\ref{matrix-create} above.  Similarly, matrices larger than
$1\times 1$ cannot be used in the generation of a data series,
other than as described in section~\ref{matrix-create-series}.

\begin{script}[htbp]
  \caption{OLS via matrix methods}
  \label{examp-matrix}
\begin{code}
  open data4-1
  matrix X = { const, sqft }
  matrix y = { price }
  matrix b = inv(X'*X) * X'*y
  printf "estimated coefficient vector\n"
  matrix b
  matrix uh = y - X*b
  scalar SSR = uh'*uh
  scalar s2 = SSR / (rows(X) - rows(b))
  matrix V = s2 * inv(X'*X)
  matrix V
  matrix se = sqrt(diag(V))
  printf "estimated standard errors\n"
  matrix se
  # compare with built-in function
  ols price const sqft --vcv
\end{code}
\end{script}



















