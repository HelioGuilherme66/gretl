\chapter{Operazioni con le matrici}
\label{chap-matrices}

\section{Introduzione}
\label{matrix-intro}

Dalla versione 1.5.1, gretl offre la possibilità di creare e manipolare matrici
definite dall'utente. Questa funzionalità è ancora sperimentale.

\section{Creazione di matrici}
\label{matrix-create}

È possibile creare una matrice in uno dei quattro modi seguenti:

\begin{enumerate}
\item Specificando direttamente i valori scalari che compongono la matrice,
  in forma numerica o per riferimento a variabili scalari preesistenti, o in un
  modo misto;
\item fornendo una lista di serie di dati;
\item fornendo una \textit{lista personalizzata} di serie:
\item usando una formula simile a quelle usate con il comando
  \texttt{genr}, in cui una nuova matrice viene definita in termini di matrici
  e/o scalari esistenti, oppure attraverso funzioni speciali.
\end{enumerate}

Questi metodi non possono essere mescolati nella specificazione di una singola
matrice. Ecco alcuni esempi.

Per specificare una matrice \textit{direttamente in termini di scalari}, la
sintassi è la seguente:

\begin{code}
matrix A = { 1, 2, 3 ; 4, 5, 6 }
\end{code}

La matrice viene definita per righe successive; gli elementi di ogni riga sono
separati da virgole e le righe sono separate da punti e virgola. L'intera
espressione va racchiusa tra parentesi graffe. Gli spazi tra le parentesi non
sono significativi. L'espressione vista sopra definisce una matrice $2\times3$.
Ogni elemento deve essere un valore numerico o il nome di una variabile scalare
preesistente. Per ottenere la matrice trasposta, basta aggiungere un apostrofo
(\texttt{'}) direttamente dopo la parentesi graffa che chiude l'espressione.

Per specificare una matrice \textit{in termini di serie di dati} la sintassi è
la seguente:
%
\begin{code}
matrix A = { x1, x2, x3 }
\end{code}
%
dove i nomi delle variabili sono separati da virgole. Per impostazione
predefinita, ogni variabile rappresenta una colonna (e può esserci solo una
variabile per ogni colonna). L'intervallo dei valori dei dati inclusi nella
matrice dipende dall'impostazione corrente dell'intervallo del campione.

Si noti che mentre le funzioni statistiche di gretl sono in grado di gestire
valori mancanti, le funzioni che trattano le matrici non lo sono, quindi si
otterrà un errore se si cerca di costruire una matrice usando delle serie che
contengono valori mancanti.

Invece di fornire una lista esplicita di variabili, è possibile fornire il
\textit{nome di una lista personalizzata} (si veda il capitolo~\ref{persist}),
come nell'esempio
%
\begin{code}
list xlist = x1 x2 x3
matrix A = { xlist }
\end{code}
%
Se si usa il nome di una lista, le serie che la costituiscono vengono usate per
comporre le colonne, come risulta naturale in un contesto econometrico; se si
vuole che vengano usate come righe, basta usare il simbolo di trasposizione.

È possibile creare nuove matrici, o sostituire matrici esistenti, usando varie
trasformazioni, in modo simile a quelle usate per il comando \texttt{genr}
per gli scalari e le serie di dati. Per ottenere una matrice come risultato,
però, il comando deve iniziare con la parola chiave \texttt{matrix}, non
\texttt{genr}.  I prossimi paragrafi spiegano nel dettaglio questi meccanismi.

\tip{I nomi delle matrici devono soddisfare gli stessi requisiti dei nomi delle
variabili in gretl: il nome non può essere più lungo di 15 caratteri, deve
iniziare per una lettera e deve essere composto da lettere, numeri e il
carattere trattino basso.}

\section{Operatori matriciali}
\label{matrix-op}

Per le matrici sono disponibili gli operatori seguenti:

\begin{center}
\begin{tabular}{ll}
\texttt{+} & addizione \\
\texttt{-} & sottrazione \\
\texttt{*} & moltiplicazione matriciale \\
\texttt{/} & ``divisione'' matriciale (si veda oltre) \\
\texttt{.*} & moltiplicazione per elementi \\
\texttt{./} & divisione per elementi \\
\verb+.^+ & elevazione a potenza per elementi \\
\verb+~+ & concatenazione per colonne \\
\texttt{**} & prodotto di Kronecker \\
\texttt{=} & test per l'uguaglianza 
\end{tabular}
\end{center}

Ecco qualche spiegazione per i casi meno ovvi. Per prima cosa, la
``divisione'' tra matrici, $A/B$ è algebricamente equivalente a $B^{-1}A$
(pre-moltiplicazione per mezzo dell'inversa del ``divisore''). Quindi in linea
di principio le due espressioni seguenti sono equivalenti:
%
\begin{code}
matrix C = A / B
matrix C = inv(B) * A
\end{code}
%
dove \texttt{inv()} è la funzione di inversione tra matrici (si veda oltre).
Però la prima forma può essere più accurata della seconda, perché la soluzione è
ottenuta tramite la scomposizione LU, senza calcolare esplicitamente la matrice
inversa.

Nella moltiplicazione per elementi, scrivendo
%
\begin{code}
matrix C = A .* B
\end{code}
% 
il risultato dipende dalle dimensioni di $A$ e $B$. Se $A$ è una matrice
$m \times n$ e $B$ è una matrice $p \times q$.  
%
\begin{itemize}
\item Se $m=p$ e $n=q$, $C$ sarà una matrice $m\times n$ con $c_{ij} = a_{ij}
  \times b_{ij}$. Questo tipo di prodotto è tecnicamente noto come
  \emph{prodotto di Hadamard}.
\item Se $m=1$ e $n=q$, oppure $n=1$ e $m=p$, $C$ sarà una matrice
  $p\times q$ with $c_{ij} = a_k \times b_{ij}$, where $k=j$ if $m=1$,
  altrimenti $k=i$.
\item Se $p=1$ e $n=q$, oppure $q=1$ e $m=p$, $C$ sarà una matrice
  $m\times n$ con $c_{ij} = a_{ij} \times b_k$, dove $k=j$ se $p=1$,
  altrimenti $k=i$.
\item Se non è soddisfatta alcuna delle condizioni viste, il prodotto non è
  definito e viene segnalato un errore.
\end{itemize}

La divisione per elementi funziona in modo simile alla moltiplicazione per elementi,
sostituendo $\times$ con $\div$ nella spiegazione precedente.

L'elevamento a potenza per elementi, come in
%
\begin{code}
matrix C = A .^ B
\end{code}
% 
produce $c_{ij} = a_{ij}^k$. La variabile $k$ deve essere uno scalare o una
matrice $1\times 1$.

Nella concatenazione tra una matrice $A$ $m\times n$ e una matrice $B$ $m\times
p$, il risultato è una matrice $m\times (n+p)$. Ossia,
%
\begin{code}
C = A ~ B
\end{code}
% 
produce $C = \left[ \begin{array}{cc} A & B \end{array} \right]$.

\section{Funzioni matriciali}
\label{matrix-func}

Sono disponibili le seguenti funzioni per \textit{la trasformazione
elemento per elemento} delle matrici: \texttt{log}, \texttt{exp},
\texttt{sin}, \texttt{cos}, \texttt{tan}, \texttt{atan}, \texttt{int},
\texttt{abs}, \texttt{sqrt}, \texttt{dnorm}, \texttt{cnorm},
\texttt{qnorm}, \texttt{gamma} e \texttt{lngamma}. Queste funzioni hanno
lo stesso significato di quando sono usate con \texttt{genr}. Ad esempio,
se una matrice \texttt{A} è già stata definita,
%
\begin{code}
matrix B = sqrt(A)
\end{code}
%
genera una matrice tale che $b_{ij} = \sqrt{a_{ij}}$.  Tutte queste
funzioni richiedono una sola matrice come argomento, o un'espressione
che si risolve in una singola matrice.

Le funzioni \texttt{sort()} e \texttt{dsort()} utilizzabili con le serie di
dati, possono essere usate anche con le matrici. In questo caso,
l'argomento di queste funzioni deve essere un vettore ($p \times 1$ o
$1\times p$).  Il valore restituito è un vettore che contiene gli elementi del
vettore originale riordinati in ordine di grandezza crescente (\texttt{sort})
o decrescente (\texttt{dsort}).

Infine, ci sono funzioni dedicate in modo specifico alle matrici, che è
possibile suddividere in quattro categorie:
%
\begin{enumerate}
\item Quelle che richiedono come argomento una sola matrice e restituiscono uno scalare.
\item Quelle che richiedono come argomento una sola matrice e restituiscono una matrice.
\item Quelle che richiedono come argomento uno o due valori e restituiscono una matrice.
\item Quelle che richiedono come argomento una o due matrici e restituiscono una o due matrici.
\end{enumerate}
%
Questi gruppi di funzioni vengono presentati nell'ordine.

\subsection{Funzioni da matrice a scalare}
\label{matrix-to-scalar}

Le funzioni che richiedono come argomento una sola matrice e restituiscono uno
scalare sono:

\begin{center}
\begin{tabular}{ll}
\texttt{det()} & determinante \\
\texttt{ldet()} & log-determinante \\
\texttt{tr()} & traccia \\
\texttt{onenorm()} & norma-1 \\
\texttt{rcond()} & reciproco del numero di condizione \\
\texttt{rows()} & numero di righe \\
\texttt{cols()} & numero di colonne 
\end{tabular}
\end{center}

L'argomento di queste funzioni può essere il nome di una matrice esistente o
un'espressione che si risolve in una matrice. Si noti che le funzioni
\texttt{det}, \texttt{ldet} e \texttt{tr} richiedono una matrice quadrata.

La funzione \texttt{onenorm} restituisce la norma-1 di una matrice, ossia
il massimo tra le colonne della matrice della somma dei valori assoluti degli
elementi della colonna. La funzione \texttt{rcond} restituisce il reciproco del
numero di condizione per una matrice simmetrica definita positiva.

\subsection{Funzioni da matrice a matrice}
\label{matrix-to-matrix}

Le funzioni che richiedono come argomento una sola matrice e restituiscono una
matrice sono:

\begin{center}
\begin{tabular}{ll}
\texttt{sumc()} & somma per colonna \\
\texttt{sumr()} & somma per riga \\
\texttt{inv()} & inversa \\
\texttt{cholesky()} & scomposizione di Cholesky \\
\texttt{diag()} & diagonale principale \\
\texttt{transp()} & trasposta \\
\texttt{cdemean()} & sottrazione della media delle colonne 
\end{tabular}
\end{center}

Come per il gruppo precedente di funzioni, l'argomento deve essere il nome di
una matrice esistente o un'espressione che si risolve in una matrice.

Per una matrice $A$ con $m$ righe e $n$ colonne, \texttt{sumc(A)}
produce un vettore riga con le $n$ somme per colonna; \texttt{sumr(A)}
produce un vettore colonna con le $m$ somme per riga.

La funzione \texttt{cholesky} calcola la scomposizione di Cholesky
$L$ di una matrice simmetrica definita positiva $A$: $A = LL'$; $L$ è
triangolare inferiore (contiene zeri al di sopra della diagonale).

La funzione \texttt{diag} restituisce la diagonale principale di una matrice
$n\times n$ $A$ come vettore colonna, ossia come vettore $n$-dimensionale $v$
tale che $v_i = a_{ii}$.

La funzione \texttt{cdemean} applicata a una matrice $A$ $m \times n$
restituisce una matrice $B$ $m \times n$ tale che $b_{ij} = a_{ij} -
\bar{A}_j$, dove $\bar{A}_j$ indica la media della colonna $j$ di $A$.  

\subsection{Funzioni da scalare a matrice}
\label{matrix-fill}

Le funzioni che richiedono come argomento uno o due valori e restituiscono una
matrice sono:

\begin{center}
\begin{tabular}{ll}
\texttt{I(}\textsl{n}\texttt{)} & matrice identità $n\times n$ \\
\texttt{zeros(}\textsl{m}\texttt{,}\textsl{n}\texttt{)} & 
   matrice nulla $m\times n$ \\
\texttt{ones(}\textsl{m}\texttt{,}\textsl{n}\texttt{)} &
   matrice $m\times n$ con tutti gli elementi pari a 1 \\
\texttt{uniform(}\textsl{m}\texttt{,}\textsl{n}\texttt{)} &
   matrice $m\times n$ con elementi casuali uniformi \\
\texttt{normal(}\textsl{m}\texttt{,}\textsl{n}\texttt{)} &
   matrice $m\times n$ con elementi casuali normali \\
\end{tabular}
\end{center}

Le dimensioni \textsl{m} e \textsl{n} possono essere indicate numericamente o
per riferimento a variabili scalari pre-esistenti, come in
%
\begin{code}
scalar m = 4
scalar n = 5
matrix A = normal(m,n)
\end{code}
%
Le funzioni matriciali \texttt{uniform()} e \texttt{normal()} riempiono la
matrice con valori estratti dalla distribuzione uniforme (0--1) e dalla
distribuzione normale standard.

\subsection{Funzioni da matrici a matrici}
\label{matrix-multiples}

Le funzioni che richiedono come argomento una o due matrici e restituiscono una
o due matrici sono:

\begin{center}
\begin{tabular}{ll}
\texttt{qrdecomp()} & Scomposizione QR \\
\texttt{eigensym()} & Auto-analisi di una matrice simmetrica \\
\texttt{eigengen()} & Auto-analisi di una matrice generica
\end{tabular}
\end{center}

La sintassi per queste funzioni è della forma
%
\begin{textcode}
matrix B = func(\textsl{A}, \textsl{C})
\end{textcode}
%
Il primo argomento, \ttsl{A}, rappresenta i dati in ingresso, ossia la matrice
di cui è richiesta la scomposizione o l'analisi. Questo deve essere specificato
sotto forma di nome di una matrice esistente; in questo caso non è accettata
un'espressione che si risolve in una matrice.

Il secondo argomento, \ttsl{C}, può essere il nome di una matrice, nel qual caso
il risultato della funzione viene scritto in quella matrice, oppure la parola
chiave \texttt{null}, nel qual caso il risultato non è mostrato o è scartato.

Nel caso in cui venga specificato il nome di una matrice come secondo argomento,
se questa matrice non era già stata definita in precedenza, verrà creata una nuova
matrice con questo nome. Se esiste già una matrice con questo nome, sarà
sovrascritta con il risultato della funzione (non è richiesto che la matrice
preesistente abbia le dimensioni corrette per ricevere il risultato della
funzione).

La funzione \texttt{qrdecomp} calcola la scomposizione QR di una matrice $m
\times n$ $A$: $A = QR$, dove $Q$ è una matrice ortogonale $m \times n$
e $R$ è una matrice $n \times n$ triangolare superiore.
La matrice $Q$ è prodotta direttamente, mentre $R$ può essere recuperata
attraverso il secondo argomento. Ecco due esempi:
%
\begin{code}
matrix Q = qrdecomp(M, R)
matrix Q = qrdecomp(M, null)
\end{code}
%
Nel primo esempio, la matrice triangolare $R$ è salvata come \texttt{R};
nel secondo, $R$ è scartata.

La funzione \texttt{eigensym} calcola gli autovalori, e opzionalmente gli
autovettori destri, di una matrice simmetrica $n \times n$.
Gli autovalori sono restituiti direttamente in un vettore colonna di lunghezza
$n$; se vengono richiesti gli autovettori, sono restituiti in una matrice $n
\times n$. Ad esempio:
%
\begin{code}
matrix E = eigensym(M, V)
matrix E = eigensym(M, null)
\end{code}
%
Nel primo caso \texttt{E} contiene gli autovalori di \texttt{M} e
\texttt{V} contiene gli autovettori. Nel secondo, \texttt{E} contiene gli
autovalori, ma gli autovettori non vengono calcolati.

La funzione \texttt{eigengen} calcola gli autovalori, e opzionalmente gli
autovettori, di una matrice generica $n \times n$. Gli autovalori vengono
restituiti direttamente in un vettore colonna di lunghezza $2n$: i primi
$n$ elementi sono le componenti reali, mentre i restanti $n$ sono le componenti
immaginarie. Se vengono richiesti gli autovettori (ossia il secondo argomento di
\texttt{eigengen} non è \texttt{null}), essi vengono restituiti in una matrice
$n \times n$.

\section{Matrici accessorie}
\label{matrix-accessors}

Oltre alle funzioni matriciali viste sopra, esistono vari ``accessori'' che
permettono di salvare una copia di alcune matrici che vengono generate
automaticamente dal programma quando viene stimato un modello:

\begin{center}
\begin{tabular}{ll}
\texttt{\$coeff} & vettore dei coefficienti stimati \\
\texttt{\$stderr} & vettore degli errori standard stimati \\
\texttt{\$uhat} & vettore dei residui \\
\texttt{\$yhat} & vettore dei valori stimati \\
\texttt{\$vcv} & matrice di covarianza dei coefficienti \\
\texttt{\$rho} & coefficienti di autoregressione per il processo di errore
\end{tabular}
\end{center}

Quando questi accessori sono utilizzati senza farli precedere da alcun prefisso,
producono i risultati dell'ultimo modello stimato, se esiste. Altrimenti,
se sono prefissati dal nome di un modello salvato in precedenza, separato
da un punto (\texttt{.}), producono i risultati dal modello specificato. Ecco
alcuni esempi:
%
\begin{textcode}
matrix u = \$uhat\\
matrix b = m1.\$coeff\\
matrix v2 = m1.\$vcv[1:2,1:2]
\end{textcode}
%
Il primo comando produce i residui dell'ultimo modello; il secondo produce il
vettore dei coefficienti del modello \texttt{m1}, mentre il terzo (che usa il
meccanismo della selezione di sotto-matrici descritto nel prossimo paragrafo)
produce una porzione della matrice di covarianza del modello
\texttt{m1}.

Se il ``modello'' in questione è in realtà un sistema (un VAR, un VECM, o un
sistema di equazioni simultanee), \texttt{\$uhat} produce la matrice dei
residui (una colonna per equazione) e \texttt{\$vcv} produce la matrice di
covarianza tra le equazioni. Al momento non sono disponibili altri accessori
per i sistemi di equazioni.


\section{Selezione di sotto-matrici}
\label{matrix-sub}

È possibile selezionare delle sotto-matrici a partire da una matrice usando la
sintassi:

\texttt{A[}\textsl{righe},\textsl{colonne}\texttt{]}

dove \textsl{righe} può avere una delle seguenti quattro forme:

\begin{center}
\begin{tabular}{ll}
Vuoto & seleziona tutte le righe \\
Un valore intero & seleziona la riga identificata dal numero \\
Due interi separati dal carattere due punti & seleziona un intervallo di righe \\
Il nome di una matrice & seleziona le righe specificate dai valori della matrice \\
\end{tabular}
\end{center}

Rispetto alla seconda opzione, il valore intero può essere indicato
numericamente o attraverso il nome di una variabile scalare esistente.
Con l'ultima opzione, la matrice indicata nel campo \textsl{righe} deve
avere dimensioni $p\times 1$ o $1\times p$ e deve contenere valori interi
nell'intervallo da 1 a $n$, dove $n$ è il numero di righe da selezionare
dalla matrice principale.

L'uso del parametro \textsl{colonne} è simile, \textit{mutatis
  mutandis}.  Ecco alcuni esempi.
%
\begin{code}
matrix B = A[1,]
matrix B = A[2:3,3:5]
matrix B = A[2,2]
matrix idx = { 1, 2, 6 }
matrix B = A[idx,]
\end{code}
%
Il primo esempio seleziona la prima riga dalla matrice \texttt{A}; il secondo
seleziona una sotto-matrice $2\times 3$; il terzo seleziona uno scalare, mentre
il quarto seleziona le righe 1, 2 e 6 dalla matrice \texttt{A}.

In aggiunta, c'è una ``matrice indice'' predefinita, \texttt{diag}, che
seleziona la diagonale principale di una matrice quadrata, come in
\texttt{B[diag]}, dove \texttt{B} è quadrata.

È possibile usare la selezione di sotto-matrici sia a destra sia a sinistra in
una formula che genera una matrice. Ecco un esempio di uso della selezione nella
parte destra, per estrarre una sotto-matrice $2\times 2$ $B$ da una matrice
$3\times 3$ $A$:
%
\begin{code}
matrix A = { 1, 2, 3; 4, 5, 6; 7, 8, 9 }
matrix B = A[1:2,2:3]
\end{code}
%
Ed ecco un esempio di selezione sulla sinistra. La seconda riga nell'esempio
scrive una matrice identità $2\times 2$ nell'angolo inferiore destro della matrice
$3\times 3$ $A$. La quarta riga rimpiazza la diagonale di $A$ con valori 1.
%
\begin{code}
matrix A = { 1, 2, 3; 4, 5, 6; 7, 8, 9 }
matrix A[2:3,2:3] = I(2)
matrix d = { 1, 1, 1 }
matrix A[diag] = d
\end{code}

\section{Conflitti tra nomi}
\label{matrix-namespace}

Le matrici condividono lo spazio dei nomi consentiti con le serie di dati e le
variabili scalari. In altre parole, non possono esistere due oggetti di questo
tipo con lo stesso nome. In caso di potenziali conflitti, quando un oggetto di
un certo tipo esiste già e si tenta di creare un altro oggetto con lo stesso
nome, gretl permette di sovrascrivere l'oggetto preesistente, con la sola
eccezione che \textit{le serie di dati sono protette e non possono essere
sovrascritte da scalari o matrici}. Di seguito sono presentate alcune
implicazioni di questa regola.
%
\begin{itemize}
\item Se esiste una serie chiamata \texttt{X} e si tenta di creare una matrice
  di nome \texttt{X}, viene segnalato un errore.
\item Se si crea una serie chiamata \texttt{X} usando i comandi
  \texttt{genr} o \texttt{series}, oppure leggendola da un file di dati, o
  importandola da un database, una eventuale matrice preesistente chiamata
  \texttt{X} viene automaticamente cancellata.
\item Se si crea uno scalare chiamato \texttt{X}, una eventuale matrice
  preesistente \texttt{X} viene cancellata.
\end{itemize}
%
Se si vuole davvero creare una matrice con il nome di una serie esistente,
occorre per prima cosa cancellare la serie con il comando \texttt{delete}
o rinominarla con il comando \texttt{rename}.

\section{Creazione di una serie di dati da una matrice}
\label{matrix-create-series}

Il capitolo~\ref{matrix-create} descrive come creare una matrice da una o più
serie di dati. In alcuni casi può essere necessario dover fare l'operazione
inversa, ossia copiare valori da una matrice a una serie. La sintassi da usare è
%
\begin{textcode}
series \textsl{serie} = \textsl{matrice}
\end{textcode}
%
dove \ttsl{serie} è il nome della serie da creare e \ttsl{matrice} è il nome della
matrice da cui copiare i valori (che può essere seguita da un'espressione di
selezione). Ecco alcuni esempi:
%
\begin{code}
series s = x
series u1 = U[,1]
\end{code}
%
Si assume che \texttt{x} e \texttt{U} siano matrici preesistenti. Nel secondo
esempio, la serie \texttt{u1} è formata dalla prima colonna della matrice
\texttt{U}.

Affinché questa operazione funzioni, la matrice (o il risultato dell'operazione
di selezione matriciale) deve essere un vettore con lunghezza pari alla
lunghezza del dataset attuale, $n$, oppure alla lunghezza dell'intervallo del
campione attuale, $n^{\prime}$. Se $n^{\prime} < n$, verranno estratti dalla
matrice solo $n^{\prime}$ elementi; se la matrice comprende $n$ elementi,
vengono usati i $n^{\prime}$ valori a partire dall'elemento $t_1$, dove $t_1$
rappresenta l'osservazione iniziale dell'intervallo del campione. Ad ogni valore
della serie che non proviene dalla matrice viene assegnato il codice di
valore mancante.
 
Si noti che quando si crea una serie in questo modo, il secondo membro del
comando \texttt{series} può essere \textit{solo} il nome di una matrice, o il
nome di una matrice seguito da un'espressione di selezione. Non è possibile
eseguire operazioni tra le matrici in questo contesto.

\section{Eliminazione di matrici}
\label{matrix-delete}

Per eliminare una matrice, si usa la sintassi
%
\begin{code}
matrix A delete
\end{code}
%
dove \texttt{A} è il nome della matrice da eliminare.

\section{Approfondimenti ed esempi}
\label{matrix-example}

L'esempio~\ref{examp-matrix} mostra l'uso delle operazioni con le matrici per
replicare la funzionalità di stima OLS già fornita da gretl. L'esempio illustra
altri punti importanti.

Per prima cosa, se si scrive solamente \texttt{matrix A}, quando esiste già una
matrice \texttt{A}, l'effetto è quello di mostrare il contenuto della matrice.

Inoltre, è possibile ``incrociare'' le espressioni  matriciali e il comando
\texttt{genr} (anche se nell'esempio è usato il suo sinonimo \texttt{scalar}).
In una formula \texttt{genr}, è possibile usare funzioni matriciali che
producono risultati scalari (ad esempio \texttt{rows()}). Inoltre, è possibile
fare riferimento a matrici $1\times 1$ come se fossero scalari ordinari. Infine,
in una formula \texttt{matrix} è possibile fare riferimento a variabili scalari,
ove appropriato.

Si noti, comunque, che le serie di dati non possono essere usate nelle
espressioni \texttt{matrix} al di fuori del caso speciale della definizione di
una matrice da un elenco di serie, come mostrato in precedenza nel
paragrafo~\ref{matrix-create}.  In modo simile, non è possibile usare matrici
con dimensioni maggiori di $1\times 1$ nella generazione di una serie di dati,
al di fuori del modo descritto nel paragrafo~\ref{matrix-create-series}.

\begin{script}[htbp]
  \caption{OLS usando le matrici}
  \label{examp-matrix}
\begin{code}
  open data4-1
  matrix X = { const, sqft }
  matrix y = { price }
  matrix b = inv(X'*X) * X'*y
  printf "vettore dei coefficienti stimati\n"
  matrix b
  matrix uh = y - X*b
  scalar SSR = uh'*uh
  scalar s2 = SSR / (rows(X) - rows(b))
  matrix V = s2 * inv(X'*X)
  matrix V
  matrix se = sqrt(diag(V))
  printf "errori standard stimati\n"
  matrix se
  # Confronto con la funzione OLS di gretl
  ols price const sqft --vcv
\end{code}
\end{script}



















