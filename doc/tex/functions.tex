\chapter{User-defined functions}
\label{functions}

\section{Defining a function}
\label{func-define}

As of version 1.4.0, \app{gretl} contains a revised mechanism for
defining functions in the context of a script.  Details
follow.\footnote{Note that the revised definition of functions
  represents a backward-incompatible change relative to version 1.3.3
  of the program.}

Functions must be defined before they are called.  The syntax for
defining a function looks like this
    
\begin{code}
      function function-name parameters
         function body
      end function
\end{code}

\textsl{function-name} is the unique identifier for the function.
Names must start with a letter. They have a maximum length of 31
characters; if you type a longer name it will be truncated.  Function
names cannot contain spaces.  You will get an error if you try to
define a function having the same name as an existing \app{gretl}
command, or with the same name as a previously defined user function.
To avoid an error in the latter case (that is, to be able to redefine
a user function), preface the function definition with
    
\begin{code}
      function function-name clear
\end{code}

The \textsl{parameters} for a function (if any) are given in the form
of a comma-separated list.  Parameters can be of any of the types
shown below.

\begin{center}
\begin{tabular}{ll}
\multicolumn{1}{c}{Type} & 
\multicolumn{1}{c}{Description} \\ [4pt]
\texttt{bool} & scalar variable acting as a Boolean switch \\
\texttt{int}  & scalar variable acting as an integer  \\
\texttt{scalar} & scalar variable \\
\texttt{series} & data series \\
\texttt{list}   & named list of series \\
\texttt{matrix} & named matrix or vector 
\end{tabular}
\end{center}

Each element in the listing of parameters is composed of two terms: a
type specifier followed by the name by which the parameter shall be
known within the function.  An example follows (the parentheses
enclosing the list of parameters are optional):
    
\begin{code}
      function myfunc (series y, list xvars, bool verbose)
\end{code}

When a function is called, the parameters are instantiated by
arguments given by the caller.  There are automatic checks in place to
ensure that the number of arguments given in a function call matches
the number of parameters, and that the types of the given arguments
match the types specified in the definition of the function.  An error
is flagged if either of these conditions is violated.  A series
argument may be specified either using either the name of the variable
in question or its ID number.  Scalar arguments may be specified by
giving the name of a variable or a numerical value (the ID number of a
variable is not acceptable).  List arguments must be specified by
name.
    
The \textsl{function body} is composed of \app{gretl} commands, or
calls to user-defined functions (that is, functions may be nested).  A
function may call itself (that is, functions may be recursive). There
is a maximum ``stacking depth'' for user functions: at present this is
set to 8.  While the function body may contain function calls, it may
not contain function definitions.  That is, you cannot define a
function inside another function.  

Functions may be called, but may not be defined, within the context of
a command loop (see Chapter~\ref{looping}).
    

\section{Calling a function}
\label{func-call}

A user function is called or invoked by typing its name followed by
zero or more arguments.  If there are two or more arguments these
should be separated by commas.  The following trivial example
illustrates a function call that correctly matches the function
definition.
    
\begin{code}
      # function definition
      function ols_ess (series y, list xvars)
        ols y 0 xvars --quiet
        scalar myess = $ess
        printf "ESS = %g\n", myess
        return scalar myess
      end function
      # main script
      open data4-1
      list xlist = 2 3 4
      # function call (the return value is ignored here)
      ols_ess price, xlist
\end{code}

The function call gives two arguments: the first is a data series
specified by name and the second is a named list of regressors.  Note
that while the function offers the variable \verb+myess+ as a return
value, it is ignored by the caller in this instance.  (As a side note
here, if you want a function to calculate some value having to do with
a regression, but are not interested in the full results of the
regression, you may wish to use the \verb+--quiet+ flag with the
estimation command as shown above.)
    
A second example shows how to write a function call that assigns
return values to variables in the caller:
    
\begin{code}
      # function definition
      function ess_uhat (series y, list xvars)
        ols y 0 xvars --quiet
        scalar myess = $ess
        printf "ESS = %g\n", myess
        series uh = $uhat
        return scalar myess, series uh
      end function
      # main script
      open data4-1
      list xlist = 2 3 4
      # function call
      (SSR, resids) = ess_uhat price, xlist
\end{code}

\section{Function programming details}
\label{func-details}

\subsection{Scope of variables}

All variables created within a function are local to that function,
and are destroyed when the function exits, unless they are made
available as return values and these values are ``picked up'' or
assigned by the caller.
    
Functions do not have access to variables in ``outer scope'' (that is,
variables that exist in the script from which the function is called)
except insofar as these are explicitly passed to the function as
arguments.  Even in this case, what the function actually gets is a
copy of the variables in question.  Therefore, variables in outer
scope are never modified by a function other than via assignment of
the return values from the function.
    

\subsection{Return values}

Functions can return zero or more values; these can be scalars, series
or matrices (not lists).  Return values are specified via a statement
within the function body beginning with the keyword \verb+return+,
followed by a comma-separated list, each element of which is composed
of a type specifier and the name of a variable (as in the listing of
parameters).  There can be only one such statement.  An example of a
valid return statement is shown below:
    
\begin{code}
      return scalar SSR, series resid
\end{code}

Note that the \verb+return+ statement does \emph{not} cause the
function to return (exit) at the point where it appears within the
body of the function. Rather, it specifies which variables are
available for assignment when the function exits, and a function exits
only when (a) the end of the function code is reached, or (b) a
\verb+funcerr+ statement is reached (see below), or (c) a gretl error
occurs.
    
The \verb+funcerr+ keyword, which may be followed by a string enclosed
in double quotes, causes a function to exit with an error flagged.  If
a string is provided, this is printed on exit otherwise a generic
error message is printed.
    

\subsection{Error checking}

When gretl first reads and ``compiles'' a function definition there is
minimal error-checking: the only checks are that the function name is
acceptable, and, so far as the body is concerned, that you are not
trying to define a function inside a function (see Section
\ref{func-define}). Otherwise, if the function body contains invalid
commands this will become apparent only when the function is called,
and its commands are executed.

\section{Function packages}
\label{func-packages}

As of \app{gretl} 1.6.0, there is a mechanism to package functions and
make them available to other users of \app{gretl}.  This is currently
experimental, but here is a walk-through of the process.

Start the GUI program and take a look at the ``File, Function files'' menu.
This menu contains four items: ``On local machine'', ``On server'', ``Edit
package'', ``New package''.

The ``New package'' command will return an error message, unless at least one
user-defined function is currently loaded in memory.

There are several ways to load a function:

\begin{itemize}
\item If you have a script file containing function definitions, open
  that file and run it.
\item Create a script file from scratch.  Include at least one
  function definition, and run the script.
\item Open the GUI console and type a function definition
  interactively.  This method is not particularly recommended; you are
  probably better composing a function non-interactively.
\end{itemize}

After loading a function, try again using the command ``File, Function
files, New package''. In the first dialog you get to select:

\begin{itemize}
\item One or more public functions to package.
\item Zero or more ``private'' helper functions.
\end{itemize}

Public functions will be available to users; private functions are
part of the ``behind the scenes'' mechanism in a function package.

On clicking ``OK'' a second dialog should appear, where you get to
enter the package information (currently, author, version, date, and a
short description).  You also get to enter help text for the public
interface(s).  If there's more than one such interface, you get a
drop-down selector that can be used to activate the various interfaces.  
You have a last chance to edit the code of the functions to be
packaged, by selecting them from the drop-down selector and clicking on
``Edit function code''. Finally, you can choose to upload the package on
gretl's server as soon as it is saved, by checking the relevant checkbox.

Clicking ``OK'' in this dialog leads you to a File Save dialog.  All
being well, this should be pointing towards a directory named
\texttt{functions}, either under the \app{gretl} system directory (if
you have write permission on that) or the \app{gretl} user directory.
This is the recommended place to save function package files, since
that is where the program will look in the special routine for opening
such files (see below).

Needless to say, the menu command ``File, Function files, Edit package''
allows you to edit again a local function package.

\vspace{6pt}

A word on the file you just saved.  By default, it will have a
\texttt{.gfn} extension.  This is a ``function package'' file: unlike
an ordinary \app{gretl} script file, it is an XML file containing both
the function code and the extra information entered in the packager.
Hackers might wish to write such a file from scratch rather than using
the GUI packager, but most people are likely to find it awkward.  Note
that XML-special characters in the function code have to be escaped,
e.g.\ \texttt{\&} must be represented as \texttt{\&amp;}.  Also, some
elements of the function syntax differ from the standard script
representation: the parameters and return values (if any) are
represented in XML.  Basically, the function is pre-parsed, and ready
for fast loading using \textsf{libxml}.

\vspace{6pt}

Why package functions in this way?  To see what's on offer so far, try
this second phase of the walk-through.

Close gretl, then re-open it.  Now go to ``File, Function files, On
local machine''. If the first stage above has gone OK, you should
see the file you packaged and saved, with its short description.  If
you click on ``Info'' you get a window with all the information gretl
has gleaned from the function package.  If you click on the ``View
code'' icon in the toolbar of this new window, you get a script view
window showing the actual function code. Now, back to the ``Function
packages'' window, if you click on the package's name, the functions
are loaded into gretl, ready to be called by clicking on the ``Call''
button, or by using the CLI.

After loading the function(s) from the package, open the GUI console.
Try typing \texttt{help foo}, replacing \texttt{foo} with the name of
a public interface from the loaded function package: if any help text
was provided for the function, it should be presented.

In a similar way, you can browse and load the functions packages
available on gretl's server, by selecting ``File, Function files, On
server''.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "gretl-guide"
%%% End: 

