\documentclass{article}
\usepackage[letterpaper,body={6.0in,9.1in},top=0.7in,left=1.25in,nohead]{geometry}
\usepackage{verbatim,fancyvrb}
\usepackage{color,gretl}
\usepackage[authoryear]{natbib}
\usepackage[pdftex]{graphicx}
\usepackage[pdftex,hyperfootnotes=false]{hyperref}

\definecolor{steel}{rgb}{0.03,0.20,0.45}

\hypersetup{pdftitle={Complex matrices in gretl},
            pdfauthor={Allin Cottrell},
            colorlinks=true,
            linkcolor=blue,
            urlcolor=red,
            citecolor=steel,
            bookmarksnumbered=true,
            plainpages=false
}

\begin{document}

\setlength{\parindent}{0pt}
\setlength{\parskip}{1ex}
\setcounter{secnumdepth}{2}

\title{Complex matrices in gretl}
\author{Allin Cottrell}
\maketitle

\section{Introduction}
\label{sec:intro}

As of mid-August 2019, gretl has native support for complex
matrices. Not all of hansl's matrix functions accept complex input,
but we have enabled a sizable subset of these functions which we
believe should suffice for most econometric purposes. Complex support
may be extended in future as need arises.

A first point to note is that complex values are treated as a special
case of the hansl \texttt{matrix} type; there's no \texttt{complex}
type as such. Complex scalars fall under the \texttt{matrix} type as
$1 \times 1$ matrices; the hansl \texttt{scalar} type is only for real
values.

This document explains how to create and manipulate complex matrices,
and discusses some questions of backward compatibility.

\section{Creating a complex matrix}
\label{sec:create}

The unique explicit constructor for complex matrices is the
\texttt{complex()} function which takes two arguments, giving the real
and imaginary parts respectively, and sticks them together, as in
\begin{code}
C = complex(A, B)
\end{code}
Three cases are supported, as follows. (Other than in the subscripts,
$i$ denotes $\sqrt{-1}$.)
\begin{itemize}
\item \texttt{A} and \texttt{B} are both $m \times n$ real matrices
  Then \texttt{C} is an $m \times n$ complex matrix such that
  $c_{ij} = a_{ij} + b_{ij}i$.
\item \texttt{A} and \texttt{B} are both scalars: \texttt{C} is a
  $1 \times 1$ complex matrix such that $c = a + bi$.
\item \texttt{A} is an $m \times n$ real matrix and \texttt{B} is a
  scalar: \texttt{C} is an $m \times n$ matrix such that
  $c_{ij} = a_{ij} + bi$.
\end{itemize}

In addition, complex matrices may naturally arise as the result of
certain computations.

With both real and complex matrices in circulation, one may wish to
determine whether a particular matrix is complex. The function
\texttt{iscomplex()} can tell you. Passed an identifier, it returns 1
if it names a complex matrix, 0 if it names a real matrix, or
\texttt{NA} otherwise.

\section{Indexation}

Indexation of complex matrices works just as with real matrices, on
the understanding that each element of a complex matrix is a complex
pair. So for example \texttt{C[i,j]} gets you the complex pair at row
\texttt{i}, column \texttt{j} of \texttt{C}, in the form of a
$1 \times 1$ complex matrix.

If you wish to access just the real or imaginary part of a given
element, or range of elements, you can use the functions \texttt{Re()}
or \texttt{Im()}, as in
\begin{code}
scalar rij = Re(C[i,j])
\end{code}
which gets you the real part of $c_{ij}$.

In addition the dummy selectors \texttt{real} and \texttt{imag} can be
used to assign to just the real or imaginary component of a complex
matrix. Here are two examples:
\begin{code}
# replace the real part of C with random normals
C[real] = mnormal(rows(C), cols(C))

# set the imaginary part of C to all zeros
C[imag] = 0
\end{code}
The replacement must be either a real matrix of the same dimensions as
the target, or a scalar.

\section{Operators}
\label{sec:ops}

Most of the operators available for working with real matrices are
also available for complex ones; this includes the ``dot-operators''
which work element-wise or by ``broadcasting'' vectors. Moreover,
``mixed'' operands are accepted, as in \texttt{D = C + A} where
\texttt{C} is complex and \texttt{A} real. The result, \texttt{D},
will be complex. In such cases the real operand is treated as a
complex matrix with an all-zero imaginary part.

The operators \textit{not} defined for complex values are:
\begin{itemize}
\item Those that include an inequality (such as ``\verb+.>+''), since
  complex values as such cannot be compared as greater or lesser
  (though they can be compared as equal or not equal).
\item The (real) modulus operator (percent sign), as in \texttt{x \%
    y} which gives the remainder on division of \texttt{x} by
  \texttt{y}.
\end{itemize}

The ``\texttt{'}'' operator is available in both unary form
(transpose), as in \texttt{B = A'}, and binary form
(transpose-multiply), as in \texttt{C = A'B}. But note that for
complex \texttt{A} this means the conjugate transpose, $A^\mathrm{H}$ or
$A^*$. If you need the non-conjugated transpose you can use
\texttt{transp()}--- see section~\ref{sec:funcs}.

You may wish to note, although none of gretl's explicit regressions
functions (or commands) accept complex input you can calculate
parameter estimates for a least-squares regression of complex $Y$
($T \times 1$) on complex $X$ ($T \times k$) via \verb|B = X \ Y|.

\section{Functions}
\label{sec:funcs}

To give an idea of what works, and what doesn't work, for complex
matrices, we'll walk through the hansl function-space using the
categories employed in gretl's online ``Function reference'' (under the
\textsf{Help} menu in the GUI program).

\subsection{Linear algebra}

The only functions that accept complex arguments at present are:
\texttt{det}, \texttt{ldet}, \texttt{eigengen}, \texttt{eigensym} (for
Hermitian matrices), \texttt{fft}, \texttt{ffti}, \texttt{inv},
\texttt{ginv}, \texttt{hdprod}, \texttt{rank}, \texttt{svd},
\texttt{tr}, and \texttt{transp}.

In addition there's the complex-only function \texttt{ctrans()} which
gives the conjugate transpose; note that \texttt{transp} gives the
straight (non-conjugated) transpose of a complex matrix.

\subsection{Matrix building}

Given what was said in section~\ref{sec:create} above, several of the
functions in this category should be thought of as applying to the
real or imaginary part of a complex matrix (for example, \texttt{ones}
and \texttt{mnormal}), and are of course usable in that way.  However,
some of these functions can be applied to complex matrices as such,
namely, \texttt{diag}, \texttt{diagcat}, \texttt{lower},
\texttt{upper}, \texttt{vec}, \texttt{vech} and \texttt{unvech}.

Please note: when \texttt{unvech()} is applied to a suitable real
vector it produces a symmetric matrix, but when applied to a complex
vector it produces a Hermitian matrix.

The only functions \textit{not} available for complex matrices are
\texttt{cnameset} and \texttt{rnameset}. That is, you cannot name the
columns or rows of such matrices (although this restriction could
probably be lifted without great difficulty).

\subsection{Matrix shaping}

The functions that accept complex input are: \texttt{cols},
\texttt{rows}, \texttt{mreverse}, \texttt{mshape}, \texttt{selifc},
\texttt{selifr} and \texttt{trimr}.

The functions \texttt{msortby}, \texttt{sort} and \texttt{dsort} are
excluded for the reason mentioned in section~\ref{sec:ops}.

\subsection{Statistical}

Supported for complex input: \texttt{meanc}, \texttt{meanr},
\texttt{sumc}, \texttt{sumr}, \texttt{prodc} and \texttt{prodr}. And
that's all.

\subsection{Mathematical}

In the matrix context, these are functions that are applied element by
element. For complex input the following are supported: \texttt{log},
\texttt{exp} and \texttt{sqrt}, plus all of the trigonometric
functions with the exception of \texttt{atan2}.

In addition there are the complex-only functions \texttt{cmod}
(complex modulus, also accessible via \texttt{abs}), \texttt{carg}
(complex ``argument''), \texttt{conj} (complex conjugate), \texttt{Re}
(real part) and \texttt{Im} (imaginary part). Note that
$\mbox{carg}(z) = \mbox{atan2}(y,x)$ for $z=x + yi$.

\subsection{Transformations}

The functions \texttt{cum} and \texttt{diff} may be applied to complex
matrices, but no others.

\section{File input/output}

Complex matrices should be stored and retrieved correctly in the
XML serialization used for gretl session files (\texttt{*.gretl}).

The functions \texttt{mwrite} and \texttt{mread} also work correctly
for use with gretl itself, but for exchange of data with other
programs we recommend using \texttt{mwrite} on the two parts of a
complex matrix separately. An example is shown in
Listing~\ref{cmplx-io}: we export a complex matrix to \textsf{octave},
\textsf{python} and \textsf{julia} in turn; calculate its inverse in
the foreign program; then verify that the imported result is the same
as that produced in gretl.

\begin{script}[htbp]
  \caption{Exporting and importing complex matrices}
  \label{cmplx-io}
\begin{scode}
set seed 34756
matrix C = complex(mnormal(3,3), mnormal(3,3))
D = inv(C)

mwrite(Re(C), "Cr.mat", 1)
mwrite(Im(C), "Ci.mat", 1)

foreign language=octave
  A = gretl_loadmat('Cr.mat');
  B = gretl_loadmat('Ci.mat');
  D = inv(complex(A, B));
  gretl_export(real(D), 'oct_Dr.mat');
  gretl_export(imag(D), 'oct_Di.mat');
end foreign

oct_Dr = mread("oct_Dr.mat", 1)
oct_Di = mread("oct_Di.mat", 1)
eval D - complex(oct_Dr, oct_Di)

foreign language=python
   import numpy as np
   A = gretl_loadmat('Cr.mat')
   B = gretl_loadmat('Ci.mat')
   D = np.linalg.inv(A + B*1j)
   gretl_export(np.real(D), 'py_Dr.mat')
   gretl_export(np.imag(D), 'py_Di.mat')
end foreign

py_Dr = mread("py_Dr.mat", 1)
py_Di = mread("py_Di.mat", 1)
eval D - complex(py_Dr, py_Di)

foreign language=julia
  A = gretl_loadmat("Cr.mat")
  B = gretl_loadmat("Ci.mat")
  D = inv(A + B*im)
  gretl_export(real(D), "jl_Dr.mat")
  gretl_export(imag(D), "jl_Di.mat")
end foreign

jl_Dr = mread("jl_Dr.mat", 1)
jl_Di = mread("jl_Di.mat", 1)
eval D - complex(jl_Dr, jl_Di)
\end{scode}
\end{script}

\section{Backward compatibility}
\label{sec:compat}

Compatibility issues arise in two contexts, both related to the fact
that gretl offered some degree of support for complex matrices before
they became full citizens of the hansl polity.

\begin{enumerate}
\item The functions \texttt{fft} (fast Fourier transform for real
  input) and \texttt{eigengen} (eigenvalues and/or eigenvectors of a
  non-symmetric real matrix) returned complex matrices in what we may
  call the ``legacy'' representation. In the case of \texttt{fft} and
  the eigenvalues from \texttt{eigengen} this took the form of a
  regular gretl matrix with real values in the first (or odd-numbered)
  column(s) and imaginary parts in the second (or even-numbered)
  column(s). Since calculating with such matrices using the standard
  matrix operators would result in nonsense, we provided the tailored
  functions \texttt{cmult} and \texttt{cdiv}.

  In the case of complex eigenvectors from \texttt{eigengen}---well,
  you probably don't want to know, but if you do, consult the help text
  for \texttt{eigengen}; they were not easy for a user to handle!
\item The function packages \texttt{cmatrix} and
  \texttt{ghosts}. These are relatively recent additions to gretl,
  designed to support frequency-domain analysis. Prior to the
  development of native complex-matrix functionality, \texttt{cmatrix}
  was needed as an dependency for \texttt{ghosts} (multivariate
  spectral analysis).
\end{enumerate}

So what happens with these functions and packages under the new
regime?

Our resolution on the two built-in functions is this:
\begin{itemize}
\item \texttt{fft} and \texttt{eigengen} continue to behave exactly as
  before. They do not accept complex input and they produce old-style
  output. In the documentation they will be marked as legacy
  functions, not for use in newly written hansl code.
\item We have added new counterpart functions, \texttt{fft2} and
  \texttt{eiggen2}. These accept either real or complex input and they
  produce new-style complex output in both cases.
\end{itemize}

On the affected packages: \texttt{cmatrix} is no longer required, and
will not be supported any more: attempting to load this package will
produce an error message in the next gretl release. We will make
available an updated version of \texttt{ghosts} which uses gretl's
native complex functionality.

\section{Internals, testing}

In the \textsf{C} programming language a double-precision complex
value is basically just two regular ``doubles'' contiguous in memory
(but with a good deal of useful synactic sugar). Since gretl matrices
are in column-major order this means that an $m \times n$ complex
matrix is in a sense equivalent to a $2m \times n$ real matrix, with
real parts on the odd-numbered rows and imaginary parts on the even
ones.

In certain special conditions it may be useful to be able to switch
the interpretation of a given matrix. To this end there's a ``hidden''
function \verb|_setcmplx|; it takes a matrix argument followed by a
boolean: 1 to switch the interpretation from real to complex, 0 to go
from complex to real. While it's always possible to go from complex to
real, the opposite switch fails if the matrix in question has an odd
number of rows. Note that \verb|_setcmplx| modifies its matrix
argument. Example:
\begin{code}
? matrix C = complex({1,2;3,4},{0,1;0,1})
Generated matrix C
? print C
C (2 x 2)

 1 + 0i   2 + 1i
 3 + 0i   4 + 1i

? _setcmplx(C, 0)
? print C
C (4 x 2)

  1   2
  0   1
  3   4
  0   1
\end{code}

\end{document}
