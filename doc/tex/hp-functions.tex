\chapter{User-written functions}

Hansl natively provides a reasonably wide array of pre-defined
functions for manipulating variables of all kinds; the previous
chapters contain several examples. However, it is also possible to
extend hansl's native capabilities by defining additional
functions.

Here's how a user-defined function looks like:
\begin{flushleft}
\texttt{function \emph{type} \emph{funcname}(\emph{parameters})}\\
   \quad \ldots\\
   \quad \texttt{\emph{function body}}\\
   \quad \ldots \\
\texttt{end function}
\end{flushleft}

The opening line of a function definition contains these elements, in
strict order:

\begin{enumerate}
\item The keyword \texttt{function}.
\item \texttt{\emph{type}}, which states the type of value returned by the
  function, if any.  This must be one of \texttt{void} (if the
  function does not return anything), \texttt{scalar},
  \texttt{series}, \texttt{matrix}, \texttt{list} or \texttt{string}.
\item \texttt{\emph{funcname}}, the unique identifier for the
  function.  Function names have a maximum length of 31 characters;
  they must start with a letter and can contain only letters, numerals
  and the underscore character. It cannot coincide with a native gretl
  command or function.
\item The functions's \texttt{\emph{parameters}}, in the form of a
  comma-separated list enclosed in parentheses.
\end{enumerate}

Function parameters can be of any of the types shown below.

\begin{center}
\begin{tabular}{ll}
  \multicolumn{1}{c}{Type} & 
  \multicolumn{1}{c}{Description} \\ [4pt]
  \texttt{bool}   & scalar variable acting as a Boolean switch \\
  \texttt{int}    & scalar variable acting as an integer  \\
  \texttt{scalar} & scalar variable \\
  \texttt{series} & data series (see section~\ref{sec:series})\\
  \texttt{list}   & named list of series  (see section~\ref{sec:lists})\\
  \texttt{matrix} & matrix or vector \\
  \texttt{string} & string variable or string literal \\
  \texttt{bundle} & all-purpose container
\end{tabular}
\end{center}

Each element in the listing of parameters must include two terms: a
type specifier, and the name by which the parameter shall be known
within the function.  An example follows:
%    
\begin{code}
function scalar myfunc (series y, list xvars, bool verbose)
\end{code}

In order to get a feel for how functions work, here's a simple
example:

\begin{code}
function scalar quasi_log(scalar x)
/* popular approximation to the natural logarithm
   via Padé polynomials */

   if (x<0)
      scalar ret = NA
   else 
      scalar ret = 2*(x-1)/(x+1)
   endif

   return ret
end function

loop for (x=0.5; x<2; x+=0.1)
   printf "x = %4.2f; ln(x) = %g, approx = %g\n", x, ln(x), quasi_log(x)
end loop
\end{code}

The code above computes the rational function
\[
  f(x) = 2 \cdot \frac{x-1}{x+1} ,
\]
which provides a decent approximation to the natural logarithm in a
neighborhood of 1.

\begin{enumerate}
\item We begin by defining the function via the \cmd{function}
  keyword; the function definition will end with the \texttt{end
    function} marker below;
\item since the function is meant to return a scalar, we put the
  keyword \texttt{scalar} after \cmd{function};
\item between the round brackets, the arguments follow; in this case,
  we only have one, which we call \texttt{x} and is assumed to be a
  scalar;
\item on the next line, the function definition begins: this can be
  (almost) arbitrary hansl code; in this case, it includes a comment,
  and an \cmd{if} block;
\item the function ends with the \cmd{return} keyword, which exports
  the result;
\item the next lines provide a simple usage example; note that in the
  \cmd{printf} command, the two functions \cmd{ln()} and
  \cmd{quasi\_log()} are indistinguishable from a purely syntactic
  viewpoint, although the former is a native function and the
  latter is a user-defined one. 
\end{enumerate}

In many cases, you may end up writing several functions, which may be
quite long; in order to avoid cluttering your script with the function
definition, hansl provides the \cmd{include} command, so you can put all
your function definition in a separate file (or separate files if
necessary). For example, imagine you saved the \verb|quasi_log()|
function definition above in a separate file called
\verb|quasilog_def.inp|: the code above could be written more
compactly as
\begin{code}
include quasilog_def.inp

loop for (x=0.5; x<2; x+=0.1)
   printf "x = %4.2f; ln(x) = %g, approx = %g\n", x, ln(x), quasi_log(x)
end loop
\end{code}
Moreover, \cmd{include} commands can be nested.


\section{Parameter passing and return values}
\label{sec:params-returns}

Important points to remember:
\begin{itemize}
\item parameters are passed \emph{by value}; if you need a function to
  modify its arguments, you ought to use pointers (see below);
\item In hansl, you cannot use global variables
\item If you have to pass many parameters, you might want to wrap them
  into a bundle.
\end{itemize}

\subsection{Pointers}

Each of the type-specifiers, with the exception of \texttt{list} and
\texttt{string}, may be modified by prepending an asterisk to the
associated parameter name, as in
%    
\begin{code}
function scalar myfunc (series *y, scalar *b)
\end{code}

The meaning of this modification is related to the use of pointer
arguments in the C programming language.

For matrix arguments, this is a nice way to write faster functions, as
producing a copy of a large matrix can be quite
time-consuming. However, the \cmd{const} qualifier achieves the same
effect.

\section{Recursion}

Obligatory factorial example
\begin{code}
function scalar factorial(scalar n)
    if (n<0) || (n>floor(n))
        # filter out everything that isn't a 
        # non-negative integer
        return NA
    elif n==0
        return 1
    else
        return n*factorial(n-1)
    endif
end function

loop i=0..6 --quiet
    printf "%d! = %d\n", i, factorial(i)
end loop
\end{code}

Note: this is fun, but in practice, you'll be much better off using
the pre-cooked gamma function (or, better still, its logarithm).

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "hansl-primer"
%%% End: 
