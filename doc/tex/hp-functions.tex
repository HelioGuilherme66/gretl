\chapter{User-written functions}

Hansl natively provides a reasonably wide array of pre-defined
functions for manipulating variables of all kinds; the previous
chapters contain several examples. However, it is also possible to
extend hansl's native capabilities by defining additional
functions.

Here's what a user-defined function looks like:
\begin{flushleft}
\texttt{function \emph{type} \emph{funcname}(\emph{parameters})}\\
   \quad \ldots\\
   \quad \texttt{\emph{function body}}\\
   \quad \ldots \\
\texttt{end function}
\end{flushleft}

The opening line of a function definition contains these elements, in
strict order:

\begin{enumerate}
\item The keyword \texttt{function}.
\item \texttt{\emph{type}}, which states the type of value returned by
  the function, if any.  This must be one of \texttt{void} (if the
  function does not return anything), \texttt{scalar},
  \texttt{series}, \texttt{matrix}, \texttt{list}, \texttt{string} or
  \texttt{bundle}.
\item \texttt{\emph{funcname}}, the unique identifier for the
  function.  Function names have a maximum length of 31 characters;
  they must start with a letter and can contain only letters, numerals
  and the underscore character. It cannot coincide with a native gretl
  command or function.
\item The functions's \texttt{\emph{parameters}}, in the form of a
  comma-separated list enclosed in parentheses.\footnote{If you have
    to pass many parameters, you might want to consider wrapping them
    into a bundle to avoid syntax cluttering.} Note: parameters are
  the only way hansl function can receive anything from ``the
  outside''. In hansl, there is no such thing as global variables.
\end{enumerate}

Function parameters can be of any of the types shown below.

\begin{center}
\begin{tabular}{ll}
  \multicolumn{1}{c}{Type} & 
  \multicolumn{1}{c}{Description} \\ [4pt]
  \texttt{bool}   & scalar variable acting as a Boolean switch \\
  \texttt{int}    & scalar variable acting as an integer  \\
  \texttt{scalar} & scalar variable \\
  \texttt{series} & data series (see section~\ref{sec:series})\\
  \texttt{list}   & named list of series  (see section~\ref{sec:lists})\\
  \texttt{matrix} & matrix or vector \\
  \texttt{string} & string variable or string literal \\
  \texttt{bundle} & all-purpose container
\end{tabular}
\end{center}

Each element in the listing of parameters must include two terms: a
type specifier, and the name by which the parameter shall be known
within the function.  

The \emph{function body} contains (almost) arbitrary hansl code, which
should compute the \emph{return value}, that is the value the function
is supposed to yield. Any variable declared inside the function is
\emph{local}, so it will cease to exist when the function ends.

The \cmd{return} command is used to stop execution of the code inside
the function and deliver its result to the calling code (note that
this typically happens at the end of the function body, but doesn't
have to).  The function definition must end with the expression
\verb|end function|, on a line of its own.

\tip{Beware: unlike some other languages (e.g.\ Matlab or GAUSS), you
  cannot directly return multiple outputs from a function. However,
  you can return a bundle and stuff it with as many objects as you
  want.}


In order to get a feel for how functions work in practice, here's a
simple example:
\begin{code}
function scalar quasi_log(scalar x)
/* popular approximation to the natural logarithm
   via Padé polynomials */

   if (x<0)
      scalar ret = NA
   else 
      scalar ret = 2*(x-1)/(x+1)
   endif

   return ret
end function

loop for (x=0.5; x<2; x+=0.1)
   printf "x = %4.2f; ln(x) = %g, approx = %g\n", x, ln(x), quasi_log(x)
endloop
\end{code}

The code above computes the rational function
\[
  f(x) = 2 \cdot \frac{x-1}{x+1} ,
\]
which provides a decent approximation to the natural logarithm in the
neighborhood of 1.

\begin{enumerate}
\item We begin by defining the function via the \cmd{function}
  keyword; the function definition will end with the \texttt{end
    function} marker below;
\item since the function is meant to return a scalar, we put the
  keyword \texttt{scalar} after \cmd{function};
\item between the round brackets, the arguments follow; in this case,
  we only have one, which we call \texttt{x} and is specified to be a
  scalar;
\item on the next line, the function definition begins; in this case,
  it includes a comment and an \cmd{if} block;
\item the function ends with the \cmd{return} keyword, which exports
  the result;
\item the next lines provide a simple usage example; note that in the
  \cmd{printf} command, the two functions \cmd{ln()} and
  \cmd{quasi\_log()} are indistinguishable from a purely syntactic
  viewpoint, although the former is a native function and the
  latter is a user-defined one. 
\end{enumerate}

In many cases, you may end up writing several functions, which may be
quite long; in order to avoid cluttering your script with the function
definition, hansl provides the \cmd{include} command, so you can put
all your function definitions in a separate file, or separate files if
you appreciate tidiness; note, however, that you can put as many
function definitions as you want in any included file. For
example, imagine you saved the \verb|quasi_log()| function definition
above in a separate file called \verb|quasilog_def.inp|: the code
above could be written more compactly as
\begin{code}
include quasilog_def.inp

loop for (x=0.5; x<2; x+=0.1)
   printf "x = %4.2f; ln(x) = %g, approx = %g\n", x, ln(x), quasi_log(x)
endloop
\end{code}
Moreover, \cmd{include} commands can be nested.


\section{Parameter passing and return values}
\label{sec:params-returns}

In hansl, parameters are passed \emph{by value}, so what is used
inside the function is a copy of the original argument. You may modify
it, but you'll be just modifying the copy. The following example
should make this point clear:
\begin{code}
function void f(scalar x)
    x = x*2
    print x
end function

scalar x = 3
f(x)
print x
\end{code}
Running the above code yields
\begin{code}
              x =  6.0000000
              x =  3.0000000
\end{code}
The first \cmd{print} statement happens inside the function, and the
displayed value is 6 because \verb|x| is doubled; however, what really
gets doubled is simply the \emph{copy} of \texttt{x}: this is
demonstrated by the second \cmd{print} statement.  If you need a
function to modify its arguments, you ought to use pointers (see
below).

\subsection{Pointers}

Each of the type-specifiers, with the exception of \texttt{list} and
\texttt{string}, may be modified by prepending an asterisk to the
associated parameter name, as in
%    
\begin{code}
function scalar myfunc (matrix *y, scalar *b)
\end{code}
This indicates that \verb|*y|, isn't a matrix, but a \emph{pointer} to
a matrix.  In practice, a pointer to a variable contains the memory
address at which the variable is stored.

This is usually considered a bit mysterious by people unfamiliar with
the C programming language, so allow us to explain how pointers work
by means of a (quite silly) example: suppose you set up a barber
shop. Ideally, your customers would walk into your shop, sit on a
chair and have their hair trimmed or their beard shaved. However,
local regulations forbid you to modify anything coming in through your
shop door; of course, you wouldn't do much business if people must
leave your shop with their hair untouched. Nevertheless, you have a
simple way to go around this limitation: your customers can come to
your shop, tell you their home address and walk out. Then, nobody
stops you from going to their place and excercising your fine
profession. Formally, you're OK with the law, because no modification
of anything took place inside your shop.

Unlike C, in hansl you don't have to take any special care inside the
function body to distinguish the variable from its
address;\footnote{In C, this would be called \emph{dereferencing} the
  pointer.} you just use the variable's name. In order to supply the
address of a variable when you invoke the function, you use the
ampersand (\verb|&|) operator.

An example should, hopefully, make things clearer; the following code
\begin{code}
function void swap(scalar *a, scalar *b)
    scalar tmp = a
    a = b
    b = tmp
end function

scalar x = 0
scalar y = 1000000
swap(&x, &y)
print x y
\end{code}
gives
\begin{code}
              x =  1000000.0
              y =  0.0000000
\end{code}
so \texttt{x} and \texttt{y} have in fact been swapped. How?

First you have the function definition, in which the arguments are
pointers to scalars. Inside the function body, the distinction is
moot, as \verb|a| is taken to mean ``the scalar that you'll find at
the address \verb|*a|, which you'll get as the first parameter'' (and
likewise for \verb|b|). The rest of the function simply swaps
\texttt{a} and \texttt{b} by means of a local temporary variable.

Outside the function, we first initialize the two scalars \texttt{x}
to 0 and \texttt{y} to a big number. Then we call the function.  When
the function is called, it's given as arguments \verb|&a| and
\verb|&b|, which hansl identifies as ``the address of'' the two
scalars \texttt{a} and \texttt{b}, respectively.

Writing a function with pointer arguments has two main consequences:
first, as we just saw, it makes it possible to modify the function
arguments. Second, it avoids the computational cost of having to
allocate memory for a copy of the arguments and performing the copy
operation; such cost is proportional to the size of the argument. 
Hence, for matrix arguments, this is a nice way to write faster
functions, as producing a copy of a large matrix can be quite
time-consuming.\footnote{However, the \cmd{const} qualifier achieves the same
effect. See \GUG\ for further details.}

\section{Recursion}

Hansl functions can be recursive; what follows is the obligatory
factorial example:
\begin{code}
function scalar factorial(scalar n)
    if (n<0) || (n>floor(n))
        # filter out everything that isn't a 
        # non-negative integer
        return NA
    elif n==0
        return 1
    else
        return n * factorial(n-1)
    endif
end function

loop i=0..6 --quiet
    printf "%d! = %d\n", i, factorial(i)
endloop
\end{code}

Note: this is fun, but in practice, you'll be much better off using
the pre-cooked gamma function (or, better still, its logarithm).

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "hansl-primer"
%%% End: 
