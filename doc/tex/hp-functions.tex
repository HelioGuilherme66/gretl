\chapter{User-written functions}

Main structure:

\begin{flushleft}
\texttt{function \emph{type} \emph{funcname}(\emph{parameters})}\\
   \quad \ldots\\
   \quad \emph{function body}\\
   \quad \ldots \\
\texttt{end function}
\end{flushleft}

The opening line of a function definition contains these elements, in
strict order:

\begin{enumerate}
\item The keyword \texttt{function}.
\item \texttt{\emph{type}}, which states the type of value returned by the
  function, if any.  This must be one of \texttt{void} (if the
  function does not return anything), \texttt{scalar},
  \texttt{series}, \texttt{matrix}, \texttt{list} or \texttt{string}.
\item \texttt{\emph{funcname}}, the unique identifier for the function.
  Function names have a maximum length of 31 characters; they must
  start with a letter and can contain only letters, numerals and the
  underscore character.  You will get an error if you try to define a
  function having the same name as an existing gretl command.
\item The functions's \texttt{\emph{parameters}}, in the form of a
  comma-separated list enclosed in parentheses.
\end{enumerate}

Function parameters can be of any of the types shown below.

\begin{center}
\begin{tabular}{ll}
  \multicolumn{1}{c}{Type} & 
  \multicolumn{1}{c}{Description} \\ [4pt]
  \texttt{bool}   & scalar variable acting as a Boolean switch \\
  \texttt{int}    & scalar variable acting as an integer  \\
  \texttt{scalar} & scalar variable \\
  \texttt{series} & data series \\
  \texttt{list}   & named list of series \\
  \texttt{matrix} & matrix or vector \\
  \texttt{string} & string variable or string literal \\
  \texttt{bundle} & all-purpose container (see chapter~\ref{chap:bundles})
\end{tabular}
\end{center}

Each element in the listing of parameters must include two terms: a
type specifier, and the name by which the parameter shall be known
within the function.  An example follows:
%    
\begin{code}
function scalar myfunc (series y, list xvars, bool verbose)
\end{code}

In order to get a feel for how functions work, here's a simple
example:

\begin{code}
function scalar quasi_log(scalar x)
/* popular approximation to the natural logarithm
   via Padé polynomials */

   if (x<0)
      scalar ret = NA
   else 
      scalar ret = -2*(1-x)/(1+x)
   endif

   return ret
end function

loop for (x=0; x<3; x+=0.1)
   printf "x = %4.2f; ln(x) = %g, approx = %g\n", x, ln(x), quasi_log(x)
end loop
\end{code}

\begin{itemize}
\item we begin by defining the function (scalar $\to$ scalar)
\item with a comment for good measure
\item (almost) arbitrary hansl code follows
\item the \cmd{return} keyword exports the result
\item usage example
\end{itemize}

In practice, you may want to use the \cmd{include} command and put all
your function definition in a separate file (or separate files if
necessary); \cmd{include} commands can be nested.


\section{Parameter passing and return values}
\label{sec:params-returns}

Important points to remember:
\begin{itemize}
\item parameters are passed \emph{by value}; if you need a function to
  modify its arguments, you ought to use pointers (see below);
\item In hansl, you cannot use global variables
\item If you have to pass many parameters, you might want to wrap them
  into a bundle.
\end{itemize}

\subsection{Pointers}

Each of the type-specifiers, with the exception of \texttt{list} and
\texttt{string}, may be modified by prepending an asterisk to the
associated parameter name, as in
%    
\begin{code}
function scalar myfunc (series *y, scalar *b)
\end{code}

The meaning of this modification is related to the use of pointer
arguments in the C programming language.

For matrix arguments, this is a nice way to write faster functions, as
producing a copy of a large matrix can be quite
time-consuming. However, the \cmd{const} qualifier achieves the same
effect.

\section{Recursion}

Obligatory factorial example
\begin{code}
function scalar factorial(scalar n)
    if (n<0) || (n>floor(n))
        # filter out everything that isn't a 
        # non-negative integer
        return NA
    elif n==0
        return 1
    else
        return n*factorial(n-1)
    endif
end function

loop i=0..6 --quiet
    printf "%d! = %d\n", i, factorial(i)
end loop
\end{code}

Note: this is fun, but in practice, you'll be much better off using
the pre-cooked gamma function (or, better still, its logarithm).

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "hansl-primer"
%%% End: 
