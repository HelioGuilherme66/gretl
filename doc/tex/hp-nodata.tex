\part{Without a dataset}

\chapter{Hello, world!}

We begin with the time-honored ``Hello, world'' program, the
obligatory first step in any programming language. It's actually very
simple in hansl:
\begin{code}
  # First example
  print "Hello, world!"
\end{code}

There are several ways to run the above example: you can put it in a
text file \texttt{first\_ex.inp} and have gretl execute it from the
command line through the command
\begin{code}
  gretlcli -b first_ex.inp
\end{code}
or you could just copy its contents in the editor window of a GUI
gretl session and click on the ``gears'' icon. It's up to you; use
whatever you like best.

From a syntactical point of view, allow us to draw attention on
the following points:
\begin{enumerate}
\item The line that begins with a hash mark (\texttt{\#}) is a
  comment: if a hash mark is encountered, everything from that point
  to the end of the current line is treated as a comment, and ignored
  by the interpreter.
\item The next line contains a \emph{command} (\cmd{print}) followed
  by an \emph{argument}; this is fairly typical of hansl: many jobs
  are carried out by calling commands.
\item Hansl does not have an explicit command terminator such as the
  ``\texttt{;}'' character in the C language family (C++, Java, C\#,
  \ldots) or GAUSS; instead it uses the newline character as an
  implicit terminator. So at the end of a command, you \emph{must}
  insert a newline; conversely, you \emph{can't} put a newline in the
  middle of a command---or not without taking special measures. If you
  need to break a command over more than one line for the sake of
  legibility you can use the ``\textbackslash'' (backslash) character,
  which causes gretl to ignore the next line break.
\end{enumerate}

Note also that the \cmd{print} command automatically appends a line
break, and does not recognize ``escape'' sequences such as
``\verb|\n|''; such sequences are just printed literally. The
\cmd{printf} command can be used for greater control over output; see
chapter \ref{chap:formatting}.

Let's now examine a simple variant of the above:
\begin{code}
  /*
    Second example
  */
  string foo = "Hello, world"
  print foo
\end{code}

In this example, the comment is written using the convention adopted
in the C programming language: everything between ``\verb|/*|'' and
``\verb|*/|'' is ignored.\footnote{Each type of comment can be masked
  by the other:
\begin{itemize}
\item If \texttt{/*} follows \texttt{\#} on a given line which does
  not already start in ignore mode, then there's nothing special about
  \texttt{/*}, it's just part of a \texttt{\#}-style comment.
\item If \texttt{\#} occurs when we're already in comment mode, it is
  just part of a comment.
\end{itemize}} Comments of this type cannot be nested.

Then we have the line
\begin{code}
  string foo = "Hello, world"
\end{code}
In this line, we assign the value ``\texttt{Hello, world}'' to the
variable named \texttt{foo}. Note that
\begin{enumerate}
\item The assignment operator is the equals sign (\texttt{=}).
\item The name of the variable (its \emph{identifier}) must follow
  the following convention: identifiers can be at most 31 characters
  long. They must start with a letter, and can contain only letters,
  numbers and the underscore character. Identifiers in hansl are
  case-sensitive, so \texttt{foo}, \texttt{Foo} and \texttt{FOO} are
  three distinct names. Of course, some words are reserved and can't
  be used as identifiers (however, nearly all reserved words only
  contain lowercase characters).
\item The string delimiter is the double quote (\verb|"|). 
\end{enumerate}

In hansl, a variable has to be of one of these types: \texttt{scalar},
\texttt{series}, \texttt{matrix}, \texttt{list}, \texttt{string} or
\texttt{bundle}. As we've already seen, string variables are used to
hold sequences of alphanumeric characters. We'll introduce the other
ones gradually; for example, the \texttt{matrix} type will be the
object of the next chapter.  

The reader may have noticed that the line 
\begin{code}
  string foo = "Hello, world"
\end{code}
implicitly performs two tasks: it \emph{declares} \texttt{foo} as a
variable of type \texttt{string} and, at the same time, \emph{assigns}
a value to \texttt{foo}. This is, in fact, not strictly required.  In
most cases gretl is able to figure out by itself what type the
variable should have, so the line \verb|foo = "Hello, world"| (without
a type specifier) would have worked just fine.  However, it is more
elegant (and leads to more legible and maintainable code) to use a
type specifier at least the first time you introduce a variable.
  
In the next example, we will use a variable of the \texttt{scalar}
type:
\begin{code}
  scalar x = 42
  print x
\end{code}
A \texttt{scalar} is a double-precision floating point number, so
\texttt{42} is the same as \texttt{42.0} or \texttt{4.20000E+01}. Note
that hansl doesn't have a separate variable type for integers or
complex numbers.

An important detail to note is that, contrary to most other
matrix-oriented languages in use in the econometrics community, hansl
is \emph{strongly typed}. That is, you cannot assign a value of one
type to a variable that has already been declared as another type. For
example, this will return an error:
\begin{code}
  string a = "zoo"
  a = 3.14 # no, no, no!
\end{code}
If you try running the example above, an error will be
flagged. However, it is acceptable to destroy the original variable,
via the \cmd{delete} command, and then re-declare it, as in
\begin{code}
  scalar X = 3.1415
  delete X
  string X = "apple pie"
\end{code}

There is no ``type-casting'' as in C, but some automatic type
conversions are possible (more on this later).

Many commands can take more than one argument, as in
\begin{code}
  set echo off
  set messages off

  scalar x = 42
  string foo = "not bad"
  print x foo 
\end{code}
In this example, one \texttt{print} is used to print the values of two
variables; more generally, \texttt{print} can be followed by as many
arguments as desired. The other difference with respect to the
previous code examples is in the use of the two \texttt{set}
commands. Describing the \texttt{set} command in detail would lead us
to an overly long diversion; suffice it to say that here it is used as
a way to silence unwanted output. See chapter \ref{chap:settings} or
the \GCR{}.

The \cmd{eval} command is useful when you want to look at the result
of an expression without assigning it to a variable; for example
\begin{code}
  eval 2+3*4
\end{code}
will print the number 14. This is most useful when running gretl
interactively, like a calculator, but it is usable in a hansl script
for checking purposes, as in the following (rather silly) example:
\begin{code}
  scalar a = 1
  scalar b = -1
  # this ought to be 0
  eval a+b
\end{code}

\section{Manipulation of scalars}

Algebraic operations work in the obvious way, with the classic
algebraic operators having their traditional precedence rules: the
caret (\verb|^|) is used for exponentiation. For example,
\begin{code}
  scalar phi = exp(-0.5 * (x-m)^2 / s2) / sqrt(2 * $pi * s2)
\end{code}
%$
In which we assume that \texttt{x}, \texttt{m} and \texttt{s2} are
pre-existing scalars. The example above contains two noteworthy
points:
\begin{itemize}
\item The usage of the \cmd{exp} (exponential) and \cmd{sqrt} (square
  root) functions; it goes without saying that hansl possesses a
  reasonably wide repertoire of such functions. See the \GCR{} for the
  complete list.
\item The usage of \verb|$pi| for the constant $\pi$. While
  user-specified identifiers must begin with a letter, built-in
  identifiers for internal objects typically have a ``dollar'' prefix;
  these are known as \emph{accessors} (basically, read-only
  variables).  Most accessors are defined in the context of an open
  dataset (see part \ref{part:hp-data}), but some represent
  pre-defined constants, such as $\pi$. Again, see the \GCR{} for a
  comprehensive list.
\end{itemize}

Hansl does not possess a specific boolean type, but scalars can be
used for holding true/false values. It follows that you can also use
the logical operators \emph{and} (\verb|&&|), \emph{or} (\verb+||+),
and \emph{not} (\verb|!|) with scalars, as in the following example:
\begin{code}
  a = 1
  b = 0
  c = !(a && b) # c = 1 (true), since (a && b) = 0 (false)
\end{code}
Note that 0 evaluates to false, and anything else evaluates to
true.

A few constructs are taken from the C language family: one is the
postfix increment operator:
\begin{code}
  a = 5
  b = a++
  print a b
\end{code}
the second line is equivalent to \texttt{b = a}, followed by
\texttt{a++}, which in turn is shorthand for \texttt{a = a+1}, so
running the code above will result in \texttt{b} containing 5 and
\texttt{a} containing 6. Postfix subtraction is also supported; prefix
operators, however, are not. Another C borrowing is the inflected
assignment, as in \texttt{a += b}, which is equivalent to \texttt{a =
  a + b}; several other similar operators are available, such as
\texttt{-=}, \texttt{*=} and more. See the \GCR{} for details.

The internal representation for a missing value is \texttt{DBL\_MAX},
the largest double-precision number (generally in the neighborhood of
1.7E+308). This is what you get if you try to compute quantities like
the square root or the logarithm of a negative number. You can also
set a value to ``missing'' directly using the keyword \texttt{NA}.
The function \cmd{ok} can be used to determine whether a scalar is
\texttt{NA}, as in the following example which assigns a value of zero
\texttt{test}:
\begin{code}
  scalar not_really = NA
  scalar test = ok(not_really)
\end{code}
Note that you cannot test for equality to \texttt{NA}, as in
\begin{code}
  if x == NA ... # wrong!
\end{code}
because a missing value is taken as indeterminate and hence not equal
to anything.

\section{Manipulation of strings}

Most of the previous section applies, with obvious modifications, to
strings: you may manipulate strings via operators and/or
functions. Hansl's repertoire of functions for manipulating strings
offers all the standard capabilities one would expect, such as
\cmd{toupper}, \cmd{tolower}, \cmd{strlen}, etc., plus some more
specialized ones. Again, see the \GCR\ for a complete list.

In order to access part of a string, you may use the \cmd{substr}
function, as in
\begin{code}
  string s = "endogenous"
  string pet = substr(s, 3, 5)
\end{code}
which would result to assigning the value \texttt{dog} to the variable
\texttt{pet}.

The following are useful operators for strings:
\begin{itemize}
\item the \verb|~| operator, to join two or more strings, as
in\footnote{Note on some national keyboards, you don't have the tilde
  (\texttt{\~}) character. In gretl's script editor, this can be
  obtained via its Unicode representation: type Ctrl-Shift-U, followed
  by \texttt{7e}.}
  \begin{code}
    string s1 = "sweet"
    string s2 = "Home, " ~ s1 ~ " home."
  \end{code}
\item the closely related \verb|~=| operator, which acts as an
  inflected assignment operator (so \verb|a ~= "_ij"| is equivalent to
  \verb|a = a ~ "_ij"|);
\item the offset operator \texttt{+}, which yields a substring of the
  preceding element, starting at the given character offset.  An empty
  string is returned if the offset is greater than the length of the
  string in question.
\end{itemize}

A noteworthy point: strings may be (almost) arbitrarily long;
moreover, they can contain special characters such as line breaks and
tabs. It is therefore possible to use hansl for performing rather
complex operations on text files by loading them into memory as a very
long string and then operating on that;\footnote{Of course, the reader
  is invited to take this with a grain of salt. If your job involves
  manipulating a text files several gigabytes long, you should
  consider using appropriate tools instead of hansl, such as for
  example \app{perl} or \app{python}. However, on modern hardware
  hansl may be a very defensible choice for text files up to a few
  hundred megabytes.} interested readers should take a look at the
\cmd{readfile} and \cmd{getline} functions in the \GCR.

For \emph{creating} complex strings, the most flexible tool is the
\cmd{sprintf} function. Its usage, however, is best illustrated in an
ad-hoc portion of this primer, namely Chapter
\ref{chap:formatting}. Finally, it is quite common, in hansl scripts,
to use \emph{string substitution}; however, this is another topic that
deserves special treatment, so we will defer its description to
section \ref{sec:stringsub}.

\chapter{Matrices}

Matrices are one- or two-dimensional arrays of double-precision
floating-point numbers. Hansl users who are accustomed to other matrix
languages should note that multi-index objects are not
supported. Matrices have rows and columns, and that's it.

\section{Matrix indexing}
\label{sec:mat-index}

Individual matrix elements are accessed through the \verb|[r,c]|
syntax (indexing starts at 1). For example, \texttt{X[3,4]} indicates
the element of $X$ on the third row, fourth column. For example,
\begin{code}
  matrix X = zeros(2,3)
  X[2,1] = 4
  print X
\end{code}
produces
\begin{code}
X (2 x 3)

  0   0   0 
  4   0   0 
\end{code}

Here are some more advanced ways to access matrix elements:
\begin{enumerate}
\item In case the matrix has only one row (column), the column (row)
  specification can be omitted, as in \texttt{x[3]}.
\item Omitting the row or column specification means ``take them
  all'', as in \texttt{x[4,]} (fourth matrix row).
\item For square matrices, the special syntax \texttt{x[diag]} can be
  used, which will return the diagonal.
\item Consecutive rows (columns) can be specified via the colon
  (\texttt{:}) character, as in \texttt{x[,2:4]} (columns 2 to 4).
  (Note that, unlike some other matrix languages, the syntax
  \texttt{[m:n]} is illegal if $m>n$.)
\item It is possible to use a vector to hold indices to a matrix. E.g.\
  if $e = [2,3,6]$, then \texttt{X[,e]} contains the second, third and
  sixth column of $X$.
\end{enumerate}
Moreover, matrices can be empty (zero rows/columns). 

In the example above, the matrix \texttt{X} was constructed using
the function \texttt{zeros()}, whose meaning should be obvious, but
matrix elements can also be specified directly, as in
\begin{code}
scalar a = 2*3
matrix A = { 1, 2, 3 ; 4, 5, a }
\end{code}
The matrix is defined by rows; the elements on each row are separated
by commas and rows are separated by semicolons.  The whole expression
must be wrapped in braces.  Spaces within the braces are not
significant. The above expression defines a $2\times3$ matrix.

Note that each element should be a numerical value, the name of a
scalar variable, or an expression that evaluates to a scalar. In the
example above the scalar \texttt{a} was first assigned a value and
then used in matrix construction. (Also note, in passing, that
\texttt{a} and \texttt{A} are two separate identifiers, due to
case-sensitivity.)

\section{Matrix operations}
\label{sec:mat-op}

Matrix sum, difference and product are obtained via \texttt{+},
\texttt{-} and \texttt{*}, respectively. The prime operator
(\texttt{'}) can act as a unary operator, in which case it transposes
the preceeding matrix, or as a binary operator, in which case it acts
as in ordinary matrix algebra, that is transposes the first matrix and
multiplies it into the second one. Errors are flagged if
conformability is a problem. For example:
\begin{code}
  matrix a = {11, 22 ; 33, 44}  # a is square 2 x 2
  matrix b = {1,2,3; 3,2,1}     # b is 2 x 3

  matrix c = a'         # c is the transpose of a
  matrix d = b*a        # d is a 2x3 equal to b times a

  matrix gina = b'd     # valid: gina is 3x3
  matrix lina = d + b   # valid: lina is 2x3

  /* -- these would generate errors if uncommented ----- */

  # pina = c + a  # sum non-conformability
  # rina = d * b  # product non-conformability
\end{code}

Other noteworthy matrix operators include \texttt{\^} (matrix power),
\texttt{**} (Kronecker product), and the ``concatenation'' operators
\verb|~| (horizontal) and \texttt{|} (vertical). Readers are invited
to try them out by running the following code
\begin{code}
matrix A = {2,1;0,1}
matrix B = {1,1;1,0}

matrix KP = A ** B
matrix PWR = A^3 
matrix HC = A ~ B
matrix VC = A | B

print A B KP PWR HC VC
\end{code}
Note, in particular, that $A^3 = A \cdot A \cdot A$, which is different
from what you get by computing the cubes of each element of $A$
separately.

Hansl also supports matrix left- and right-``division'', via the
\verb'\' and \verb'/' operators, respectively. The expression
\verb|A\b| solves $Ax = b$ for the unknown $x$. $A$ is assumed to be
an $m \times n$ matrix with full column rank. If $A$ is square the
method is LU decomposition. If $m > n$ the QR decomposition is used to
find the least squares solution. In most cases, this is numerically
more robust and more efficient than inverting $A$ explicitly.

Element-by-element operations are supported by the so-called ``dot''
operators, which are obtained by putting a dot (``\texttt{.}'') before
the corresponding operator. For example, the code
\begin{code}
A = {1,2; 3,4}
B = {-1,0; 1,-1}
eval A * B
eval A .* B
\end{code}
produces
\begin{code}
   1   -2 
   1   -4 

  -1    0 
   3   -4 
\end{code}

It's easy to verify that the first operation performed is regular
matrix multiplication $A \cdot B$, whereas the second one is the
Hadamard (element-by-element) product $A \odot B$. In fact, dot
operators are more general and powerful than shown in the example
above; see the chapter on matrices in \GUG{} for details.

Dot and concatenation operators are less rigid than ordinary matrix
operations in terms of conformability requirements: in most cases
hansl will try to do ``the obvious thing''. For example, a common
idiom in hansl is \texttt{Y = X ./ w}, where $X$ is an $n \times k$
matrix and $w$ is an $n \times 1$ vector. The results $Y$ is an $n
\times k$ matrix in which each row of $X$ is divided by the
corresponding element of $w$. In proper matrix notation, this
operation should be written as
\[
  Y = \langle w \rangle^{-1} X,
\]
where the $\langle \cdot \rangle$ indicates a diagonal
matrix. Translating literally the above expression would imply
creating a diagonal matrix out of $w$ and then inverting it, which is
computationally much more expensive than using the dot operation. A
detailed discussion is provided in \GUG.

Hansl provides a reasonably comprehensive set of matrix functions,
that is, functions that produce and/or operate on matrices. For a
full list, see the \GCR, but a basic ``survival kit'' is provided
in Table~\ref{tab:essential-matfuncs}.  Moreover, most scalar
functions, such as \texttt{abs(), log()} etc., will operate on a
matrix element-by-element.

\begin{table}[htbp]
  \centering
  \begin{tabular}{rp{0.6\textwidth}}
    \textbf{Function(s)} & \textbf{Purpose} \\
    \hline
    \texttt{rows(X), cols(X)} & return the number of rows and columns
    of $X$, respectively \\
    \texttt{zeros(r,c), ones(r,c)} & produce matrices with $r$ rows
    and $c$ columns, filled with zeros and ones, respectively \\
    \texttt{mshape(X,r,c)} & rearrange the elements of $X$ into a
    matrix with $r$ rows and $c$ columns \\
    \texttt{I(n)} & identity matrix of size $n$ \\
    \texttt{seq(a,b)} & generate a row vector containing integers form
    $a$ to $b$ \\
    \texttt{inv(A)} & invert, if possible, the matrix $A$ \\
    \texttt{maxc(A), minc(A), meanc(A)} & return a row vector
    with the max, min, means of each column of $A$, respectively\\
    \texttt{maxr(A), minr(A), meanr(A)} & return a column vector
    with the max, min, means of each row of $A$, respectively\\
    \texttt{mnormal(r,c), muniform(r,c)} & generate $r \times c$
    matrices filled with standard Gaussian and uniform pseudo-random
    numbers, respectively \\
    \hline
  \end{tabular}
  \caption{Essential set of hansl matrix functions}
  \label{tab:essential-matfuncs}
\end{table}

The following piece of code is meant to provide a concise example of
all the features mentioned above.

\begin{code}
# example: OLS using matrices

# fix the sample size
scalar T = 256

# construct vector of coefficients by direct imputation
matrix beta = {1.5, 2.5, -0.5} # note: row vector

# construct the matrix of independent variables
matrix Z = mnormal(T, cols(beta)) # built-in functions

# now construct the dependent variable: note the
# usage of the "dot" and transpose operators

matrix y = {1.2} .+ Z*beta' + mnormal(T, 1)

# now do estimation
matrix X = 1 ~ Z  # concatenation operator
matrix beta_hat1 = inv(X'X) * (X'y) # by hand
matrix beta_hat2 = mols(y, X)       # via the built-in function
matrix beta_hat3 = X\y              # via matrix division

print beta_hat1 beta_hat2 beta_hat3
\end{code}

\section{Matrix pointers}
\label{sec:mat-pointers}

Hansl uses the ``by value'' convention for passing parameters to
functions. That is, when a variable is passed to a function as an
argument, what the function actually uses is a \emph{copy} of the
variable, which means that the value of the variable at the caller
level is not modified by anything that goes on inside the function.
But the use of pointers allows a function and its caller to cooperate
such that an outer variable can be modified by the function.

This mechanism is used by some built-in matrix functions to provide
more than one ``return'' value. The primary result is always provided
by the return value proper but certain auxiliary values may be
retrieved via ``pointerized'' arguments; this usage is flagged by
prepending the ampersand symbol, ``\texttt{\&}'', to the name of the
argument variable.

The \texttt{eigensym} function, which performs the eigen-analysis of
symmetric matrices, is a case in point. In the example below the first
argument \texttt{A} represents the input data, that is, the matrix
whose analysis is required. This variable will not be modified in any
way by the function call. The primary result is the vector of
eigenvalues of $A$, which is here assigned to the variable
\texttt{ev}. The (optional) second argument, \texttt{\&V} (which may
be read as ``the address of \texttt{V}''), is used to retrieve the
right eigenvectors of $A$. A variable named in this way must be
already declared, but it need not be of the right dimensions to
receive the result; it will be resized as needed.
\begin{code}
matrix A = {1,2 ; 2,5}
matrix V
matrix ev = eigensym(A, &V)
print A ev V
\end{code}

\chapter{Nice-looking output}
\label{chap:formatting}

\section{Formatted output}
\label{sec:printf}

To give you more control over output, hansl provides you with the
\cmd{printf} command, which works in a very similar way as in a great
number of programming languages.

Its syntax goes like this:
\begin{flushleft}
  \texttt{printf \emph{format string}, \emph{arguments}}
\end{flushleft}

The \cmd{printf} command gives you extreme flexibility in what to
print and how. The \emph{format string} is used to specify the precise
way in which you want the \emph{arguments} to be printed.

\subsection{The format string}
\label{sec:fmtstring}

Technically, the \cmd{printf} command prints out the format string;
this must be an expression that evaluates to a string, but in most
cases will just be a constant string, that is an alphanumeric sequence
surrounded by double quotes. However, some character sequences in the
format string have a special meaning: those beginning with the percent
character (\texttt{\%}) are interpreted as ``placeholders'' for the
items contained in the argument list; moreover, special characters
such as the newline character are represented via a combination
beginning with the backslash (\verb|\|).

For example,
\begin{code}
printf "The square root of %d is (roughly) %6.4f.\n", 5, sqrt(5)
\end{code}
will print 
\begin{code}
The square root of 5 is (roughly) 2.2361.
\end{code}

Let's see how:
\begin{itemize}
\item The first special sequence is \verb|%d|: this indicates that we
  want an integer number at that place in the output string; since it
  is the leftmost ``percent'' expression, it is matched to the first
  argument, that is 5;
\item the second special sequence is \verb|%6.4f|, which stands for a
  decimal value with 4 digits after the decimal separator\footnote{The
    decimal separator is the dot in English, but may be different in
    certain locales.} and at least 6 digits wide; this will be matched
  to the second argument; note that arguments are separated by
  commas. Also note that the second argument is not a scalar constant
  nor a scalar variable, but an expression that evaluates to a scalar;
\item the format string ends with a \verb|\n| sequence, which inserts
  a newline.
\end{itemize}

The escape sequences \verb|\n| (newline), \verb|\t| (tab), \verb|\v|
(vertical tab) and \verb|\\| (literal backslash) are recognized. To
print a literal percent sign, use \verb|%%|.

Apart from those shown in the above example, recognized numeric
formats are \verb|%e|, \verb|%E|, \verb|%f|, \verb|%g|, and \verb|%G|,
in each case with the various modifiers available in C. The format
\verb|%s| should be used for strings. As in C, numerical values that
form part of the format (width and or precision) may be given directly
as numbers, as in \verb|%10.4f|, or they may be given as variables. In
the latter case, one puts asterisks into the format string and
supplies corresponding arguments in order. For example,

\begin{code}
  scalar width = 12 
  scalar precision = 6 
  printf "x = %*.*f\n", width, precision, x
\end{code}

If a matrix argument is given in association with a numeric format,
the entire matrix is printed using the specified format for each
element. 

\subsection{Output to a string}
\label{sec:sprintf}

Nearly the same thing can be achieved via the \cmd{sprintf} function:
instead of printing out the result, it stores it to a string, as in 
\begin{code}
  string G = sprintf("x = %*.*f\n", width, precision, x)
\end{code}
after which the variable \texttt{G} can be the object of further
processing.

\tip{Both \cmd{printf} and \cmd{sprintf} started their career as
  commands. Both of them can now be used as functions too. This is
  going to go at some point: in the future, \cmd{sprintf} will
  retain the function form only; as for \cmd{printf}, we haven't made
  a final decision yet.}

\subsection{Output to a file}
\label{sec:outfile}

The \cmd{outfile} command diverts output to filename, until further
notice. Use the flag \option{append} to append output to an existing
file or \option{write} to start a new file (or overwrite an existing
one). Only one file can be opened in this way at any given
time. The \option{close} flag is used to close an output file that was
previously opened as above. Output will then revert to the default
stream.

For example:
\begin{code}
  printf "One!\n"
  outfile "myfile.txt" --write
  printf "Two!\n"
  outfile "myfile.txt" --close
  printf "Three!\n"
  outfile "myfile.txt" --append
  printf "Four!\n"
  outfile "myfile.txt" --close
  printf "Five!\n"
\end{code}
will result in the file \texttt{myfile.txt} containing the lines
\begin{code}
Two!
Four!  
\end{code}

Three special variants on the above are available. If you give the
keyword null in place of a real filename along with the write option, the effect is to suppress all printed output until redirection
is ended. If either of the keywords stdout or stderr are given in
place of a regular filename the effect is to redirect output to
standard output or standard error output respectively.

The \option{quiet} option is for use with \option{write} or
\option{append}: its effect is to turn off the echoing of commands and
the printing of auxiliary messages while output is redirected. It is
equivalent to doing
\begin{code}
  set echo off 
  set messages off
\end{code}
except that when redirection is ended the original values of the echo
and messages variables are restored.

\section{Graphics}

Hansl has no graphical capabilities \emph{per se}. Everything that has
to do with pretty pictures is outsourced to \app{gnuplot}. 

FIXME: expand, but not too much. Refer to \GUG.

\chapter{Bundles}
\label{chap:bundles}

Bundles are \emph{associative arrays}, that is, generic containers for
any assortment of hansl types (including other bundles) in which each
element is identified by a string. Python users call these
\emph{dictionaries}; in C++ and Java, they are referred to as
\emph{maps}; they are known as \emph{hashes} in Perl. We call them
\emph{bundles}. Each item placed in the bundle is associated with a
key which can used to retrieve it subsequently.

To use a bundle you first either ``declare'' it, as in
%
\begin{code}
bundle foo
\end{code}
%
or define an empty bundle using the \texttt{null} keyword:
%
\begin{code}
bundle foo = null
\end{code}
%
These two formulations are basically equivalent, in that they both
create an empty bundle. The difference is that the second variant
may be reused --- if a bundle named \texttt{foo} already exists the
effect is to empty it --- while the first may only be used once in
a given \app{gretl} session; it is an error to declare a variable that
already exists. 

To add an object to a bundle you assign to a compound left-hand value:
the name of the bundle followed by the key. Two forms of syntax are
acceptable in this context. The first form requires that the key be
given as a quoted string literal enclosed in square brackets.  For
example, the statement
\begin{code}
foo["matrix1"] = m
\end{code}
adds an object called \texttt{m} (presumably a matrix) to bundle
\texttt{foo} under the key \texttt{matrix1}. 

A simpler syntax is also available, \emph{provided} the key satisfies
the rules for a \app{gretl} variable name (31 characters maximum,
starting with a letter and composed of just letters, numbers or
underscore).\footnote{When using the original syntax, keys do not have
  to be valid as variable names---for example, they can include
  spaces---but they are still limited to 31 characters.}  In that case
you can simply join the key to the bundle name with a dot, as in

\begin{code}
foo.matrix1 = m
\end{code}

To get an item out of a bundle, again use the name of the bundle
followed by the key, as in

\begin{code}
matrix bm = foo["matrix1"]
# or using the dot notation
matrix m = foo.matrix1
\end{code}

Note that the key identifying an object within a given bundle is
necessarily unique. If you reuse an existing key in a new assignment,
the effect is to replace the object which was previously stored under
the given key. It is not required that the type of the replacement
object is the same as that of the original.

Also note that when you add an object to a bundle, what in fact
happens is that the bundle acquires a copy of the object. The external
object retains its own identity and is unaffected if the bundled
object is replaced by another. Consider the following script fragment:

\begin{code}
bundle foo
matrix m = I(3)
foo.mykey = m
scalar x = 20
foo.mykey = x
\end{code}

After the above commands are completed bundle \texttt{foo} does not
contain a matrix under \texttt{mykey}, but the original matrix
\texttt{m} is still in good health.

To delete an object from a bundle use the \texttt{delete} command,
with the bundle/key combination, as in

\begin{code}
delete foo.mykey
delete foo["quoted key"]
\end{code}

This destroys the object associated with the key and removes the key
from the hash table.

Besides adding, accessing, replacing and deleting individual items,
the other operations that are supported for bundles are union and
printing. As regards union, if bundles \texttt{b1} and \texttt{b2} are
defined you can say

\begin{code}
bundle b3 = b1 + b2
\end{code}

to create a new bundle that is the union of the two others. The
algorithm is: create a new bundle that is a copy of \texttt{b1}, then
add any items from \texttt{b2} whose keys are not already present in
the new bundle. (This means that bundle union is not commutative if
the bundles have one or more key strings in common.)

If \texttt{b} is a bundle and you say \texttt{print b}, you get a
listing of the bundle's keys along with the types of the corresponding
objects, as in

\begin{code}
? print b
bundle b:
 x (scalar)
 mat (matrix)
 inside (bundle)
\end{code}

\section{Bundle usage}
\label{sec:bundle-usage}

To illustrate the way a bundle can hold information, we will use the
Ordinary Least Squares (OLS) model as an example: the following code
estimates an OLS regression and stores all the results in a bundle.

\begin{code}
/* assume y and X are given T x 1 and T x k matrices */

bundle my_model = null               # initialization
my_model["T"] = rows(X)              # sample size
my_model["k"] = cols(X)              # number of regressors
matrix e                             # will hold the residuals
b = mols(y, X, &e)                   # perform OLS via native function
s2 = meanc(e.^2)                     # compute variance estimator
matrix V = s2 .* invpd(X'X)          # compute covariance matrix

/* now store estimated quantities into the bundle */

my_model["betahat"] = b
my_model["s2"] = s2
my_model["vcv"] = V
my_model["stderr"] = sqrt(diag(V))
\end{code}

The bundle so obtained is a container that can be used for all sort of
purposes. For example, the next code snippet illustrates how to use
a bundle with the same structure as the one created above to perform
an out-of sample forecast. Imagine that $k=4$ and the value of
$\mathbf{x}$ for which we vant to forecast $y$ is
\[
  \mathbf{x}' = [ 10 \quad 1  \quad -3 \quad 0.5 ]
\]
The formulae for the forecast would then be
\begin{eqnarray*}
  \hat{y}_f & = & \mathbf{x}'\hat{\beta} \\
  s_f & = & \sqrt{\hat{\sigma}^2 + \mathbf{x}'V(\hat{\beta})\mathbf{x}} \\
  CI & = & \hat{y}_f \pm 1.96 s_f 
\end{eqnarray*}
where $CI$ is the (approximate) 95 percent confidence interval. The
above formulae translate into
\begin{code}
  x = { 10, 1, -3, 0.5 }
  scalar ypred    = x * my_model["betahat"]
  scalar varpred  = my_model["s2"] + qform(x, my_model["vcv"])
  scalar sepred   = sqrt(varpred)
  matrix CI_95    = ypred + {-1, 1} .* (1.96*sepred)
  print ypred CI_95
\end{code}

\input{hp-ctrlflow}
\input{hp-functions}

\chapter{Numerical methods}

\section{Numerical differentiation and optimization}

Many, if not most, cases in which an econometrician wants to use a
programming language such as hansl instead of relying on pre-canned
software involve some form of numerical optimization. This could take
the form of maximization of a likelihood or similar methods of
inferential statistics. Alternatively, optimization could be used in a
more general and abstract way, for example to solve portfolio choice
or analogous resource allocation problems.

Since hansl is Turing-complete, in principle any numerical
optimization technique could be programmed in hansl itself. Some of
these, however, are already part of hansl's offering of native
functions, in the interest of simplicity of use and CPU
efficiency. These are geared towards the most common kind of problem
encountered in economics and econometrics, that is unconstrained
optimization of differentiable functions.

In this chapter, we will briefly review what hansl offers to solve
generic problems of the kind
\[
\hat{\mathbf{x}} \equiv \argmax_{\mathbf{x} \in \Re^k} f(\mathbf{x}; \mathbf{a}),
\]
where $f(\mathbf{x}; \mathbf{a})$ is a function of $\mathbf{x}$, whose
shape depends on a vector of parameters $\mathbf{a}$. The objective
function $f(\cdot)$ is assumed to return a scalar real value. In most
cases, it will be assumed it is also continuous and differentiable,
although this need not be necessarily the case. Note that, in hansl,
you get functions for maximizing the objective function, but of course
minimization can be achieved simply by flipping the sign of
$f(\cdot)$.

A special case of the above occurs when $\mathbf{x}$ is a vector of
parameters and $\mathbf{a}$ is ``data''. In these cases, the objective
function is usually a (log-)likelihood or a similar objective
function, and the problem is one of estimation. For those cases, hansl
offers several special constructs, which are reviewed in Section
\ref{sec:est-blocks} and are aimed at making the job easier. Here, we
deal with more generic problems; nevertheless, the differences are
only in the hansl syntax involved: the mathematical algorithms that
hansl employs to solve the optimization problem are the same.

The reader is invited to read the ``Numerical methods'' chapter of
\GUG\ for a comprehensive treatment. Here, we will only give a small
example which should give an idea of how things are done.

\begin{code}
function scalar Himmelblau(matrix x)
    /* maxima:
    f(3.0, 2.0) = 0.0, 
    f(-2.805118, 3.131312) = 0.0,
    f(-3.779310, -3.283186) = 0.0
    f(3.584428, -1.848126) = 0.0
    */
    scalar ret = (x[1]^2 + x[2] - 11)^2
    return -(ret + (x[1] + x[2]^2 - 7)^2)

end function

# ----------------------------------------------------------------------

set max_verbose 1

matrix theta1 = { 0, 0 }
y1 = BFGSmax(theta1, "Himmelblau(theta1)")
matrix theta2 = { 0, -1 }
y2 = NRmax(theta2, "Himmelblau(theta2)")

print y1 y2 theta1 theta2
\end{code}

We use for exemplification here a classic ``nasty'' function from the
numerical optimization literature, namely the Himmelblau function,
which has four different minima; $f(x, y) = (x^2+y-11)^2 +
(x+y^2-7)^2$. The example proceeds as follows:
\begin{enumerate}
\item first, we define the function to optimize: it must return a
  scalar and have, among its arguments, the vector to optimize; in
  this particular case, that is its only argument, but there could
  have been other ones if necessary.  Note that, since we are solving
  for a minimum, our definition returns the negative of the Himmelblau
  function proper.
\item Then, we set \verb|max verbose| to 1. This is another example of
  the uage of the \cmd{set} command; its meaning is ``let me see how
  the iterations go'' and it defaults to 0. By using the \cmd{set}
  command with appropriate parameters, you control several features of
  the optimization process, such as numerical tolerances,
  visualization of the iterations, and so forth.
\item Define $\theta_1 = [0, 0]$ as the starting point.
\item Invoke the \cmd{BFGSmax} function; this will search the maximum
  via the BFGS technique. Its base syntax is \texttt{BFGSmax(arg1,
    arg2)}, where \texttt{arg1} is the vector contining the
  optimization variable, while \texttt{arg2} is a string containing
  the invocation of the function to maximize; BFGS will try several
  values of $\theta_1$ until the maximum is reached; on successful
  completion, the vector \texttt{theta1} will contain the final
  point. (Note: there's \emph{much} more to this. For details, be sure
  to read \GUG and the \GCR.)
\item Then, try the same with a different starting point and a
  different optimization technique: we start from $\theta_2 = [0, -1]$
  and use Newton-Raphson instead of BFGS, by using the \cmd{NRmax()}
  function instead if \cmd{BFGSmax()}; the syntax, however, is the
  same.
\item Finally, we print the results.
\end{enumerate}
Table \ref{tab:optim-output} on page \pageref{tab:optim-output}
contains a selected portion of the output. Note that the second run
converges to a different local optimum than the first one. This is a
consequence of having initialized the algorithm with a different
starting point. In this example, numerical derivatives were used, but
you can supply analytically computed derivatives to both methods if
you have a hansl function for them; see \GUG\ for more detail.

\begin{table}[ht]
  \begin{footnotesize}
\begin{scode}
? matrix theta1 = { 0, 0 }
Replaced matrix theta1
? y1 = BFGSmax(theta1, "Himmelblau(11, theta1)")
Iteration 1: Criterion = -170.000000000
Parameters:       0.0000      0.0000
Gradients:        14.000      22.000 (norm 0.00e+00)

Iteration 2: Criterion = -128.264504038 (steplength = 0.04)
Parameters:      0.56000     0.88000
Gradients:        33.298      39.556 (norm 5.17e+00)

...

--- FINAL VALUES: 
Criterion = -1.83015730011e-28 (steplength = 0.0016)
Parameters:       3.0000      2.0000
Gradients:    1.7231e-13 -3.7481e-13 (norm 7.96e-07)

Function evaluations: 39
Evaluations of gradient: 16
Replaced scalar y1 = -1.83016e-28
? matrix theta2 = { 0, -1 }
Replaced matrix theta2
? y2 = NRmax(theta2, "Himmelblau(11, theta2)")
Iteration 1: Criterion = -179.999876556 (steplength = 1)
Parameters:   1.0287e-05     -1.0000
Gradients:        12.000  2.8422e-06 (norm 7.95e-03)

Iteration 2: Criterion = -175.440691085 (steplength = 1)
Parameters:      0.25534     -1.0000
Gradients:        12.000  4.5475e-05 (norm 1.24e+00)

...

--- FINAL VALUES: 
Criterion = -3.77420797114e-22 (steplength = 1)
Parameters:       3.5844     -1.8481
Gradients:   -2.6649e-10  2.9536e-11 (norm 2.25e-05)

Gradient within tolerance (1e-07)
Replaced scalar y2 = -1.05814e-07
? print y1 y2 theta1 theta2

             y1 = -1.8301573e-28

             y2 = -1.0581385e-07
theta1 (1 x 2)

  3   2 

theta2 (1 x 2)

      3.5844      -1.8481 
\end{scode}
    
  \end{footnotesize}
  \caption{Output from maximization}
  \label{tab:optim-output}
\end{table}

The optimization methods hansl puts at your disposal are:
\begin{itemize}
\item BFGS, via the \cmd{BFGSmax()} function; this is, in most cases,
  the best compromise between performance and robustness. It assumes
  that the function to maximize is differentiable and will try to
  approximate its curvature by cleverly using the change in the
  gradient between iterations. You can supply it with an
  analytically-computed gradient for speed and accuracy, but if you
  don't, the first derivatives will be computed numerically. 
\item Newton--Raphson, via the \cmd{NRmax()} function; actually, the
  name is misleading. It should be called something like
  ``curvature-based'', since it relies on the iterations
  \[
    x_{i+1} = -\lambda_i C(x_i)^{-1} g(x_i)
  \]
  where $g(x)$ is the gradient and $C(x_i)$ is some measure of
  curvature of the function to optimize; if $C(x)$ is the Hessian
  matrix, you get Newton-Raphson. Again, you can code your own
  functions for $g(\cdot)$ and $C(\cdot)$, but if you don't numerical
  approximations to the gradient and the Hessian will be used,
  respectively. Other popular optimization methods (such as for
  example BHHH and the scoring algorithm) can be implemented by
  supplying to \cmd{NRmax()}the appropriate curvature matrix
  $C(\cdot)$. This method is very efficient when it works, but is
  rather fragile: for example, if $C(x_i)$ happens to be non-negative
  definite at some iteration convergence may become problematic.
\item Derivative-free methods: the only method that hansl offers
  presently is simulated annealing, via the \cmd{simann()} function,
  but an implementiation of the Nelder-Mead algorithm (aka the
  ``amoeba'' method) should be just a matter of time. These methods
  work even when the function to maximize ha some form of
  disconinuities or is not differentiable somewhere; however, they may
  be very slow and CPU-intensive.
\end{itemize}


For numerical differentiation we have
\texttt{fdjac}\footnote{\textbf{Note to self:} we \emph{must}
  implement bilateral numerical differentiation if we don't already
  (have to check) and parallelization.}. For example:

\begin{code}
set echo off
set messages off

function scalar beta(scalar x, scalar a, scalar b)
    return x^(a-1) * (1-x)^(b-1)
end function

function scalar ad_beta(scalar x, scalar a, scalar b)
    scalar g = beta(x, a-1, b-1)
    f1 = (a-1) * (1-x)
    f2 = (b-1) * x
    return (f1 - f2) * g
end function

function scalar nd_beta(scalar x, scalar a, scalar b)
    matrix mx = {x}
    return fdjac(mx, beta(mx, a, b))
end function

a = 3.5
b = 2.5

loop for (x=0; x<=1; x+=0.1) --quiet
    printf "x = %3.1f; beta(x) = %7.5f, ", x, beta(x, a, b)
    A = ad_beta(x, a, b)
    N = nd_beta(x, a, b)
    printf "analytical der. = %8.5f, numerical der. = %8.5f\n", A, N
endloop
\end{code}

returns 

\begin{code}
x = 0.0; beta(x) = 0.00000, analytical der. =  0.00000, numerical der. =  0.00000
x = 0.1; beta(x) = 0.00270, analytical der. =  0.06300, numerical der. =  0.06300
x = 0.2; beta(x) = 0.01280, analytical der. =  0.13600, numerical der. =  0.13600
x = 0.3; beta(x) = 0.02887, analytical der. =  0.17872, numerical der. =  0.17872
x = 0.4; beta(x) = 0.04703, analytical der. =  0.17636, numerical der. =  0.17636
x = 0.5; beta(x) = 0.06250, analytical der. =  0.12500, numerical der. =  0.12500
x = 0.6; beta(x) = 0.07055, analytical der. =  0.02939, numerical der. =  0.02939
x = 0.7; beta(x) = 0.06736, analytical der. = -0.09623, numerical der. = -0.09623
x = 0.8; beta(x) = 0.05120, analytical der. = -0.22400, numerical der. = -0.22400
x = 0.9; beta(x) = 0.02430, analytical der. = -0.29700, numerical der. = -0.29700
x = 1.0; beta(x) = 0.00000, analytical der. = -0.00000, numerical der. =       NA
\end{code}

\clearpage

\section{Random number generation}

\begin{itemize}
\item Mersenne Twister in its various incarnations
\item Ziggurat vs Box--Muller
\item Other distributions
\end{itemize}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "hansl-primer"
%%% End: 
