\part{With a dataset}
\label{part:hp-data}

\chapter{What is a dataset?}

A dataset is a memory area designed to hold the data you want to work
on, if any. It may be thought of a big global variable, containing a
(possibly huge) matrix of data and a hefty collection of metadata.

\app{R} users may think that a dataset is similar to what you get when
you \texttt{attach} a data frame in \app{R}. Not really: in hansl, you
cannot have more than one dataset open at the same time. That's why we
talk about \emph{the} dataset.

When a dataset is present in memory (that is, open), a number of
objects become available for your hansl script in a transparent and
convenient way. Of course, the data themselves: the columns of the
dataset matrix are called \emph{series}, which will be described in
section \ref{sec:series}; sometimes, you will want to organize one or
more series in a \emph{list} (section \ref{sec:lists}). Additionally,
you have the possibility of using, as read-only global variables, some
scalars or matrices, such as the number of observations, the number of
variables, the nature of your dataset (cross-sectional, time series or
panel), and so on. These are called \emph{accessors}, and will be
discussed in section \ref{sec:accessors}.

You can open a dataset by reading data from a disk file, via the
\cmd{open} command, or by creating one from scratch.

\section{Creating a dataset from scratch}
\begin{itemize}
\item The \cmd{nulldata} command
\item The \cmd{setobs} command
\end{itemize}

Example:
\begin{code}
set echo off
set messages off

set seed 443322           # initialize the random number generator
nulldata 240              # stipulate how long your series will be
setobs 12 1995:1          # monthly dataset, starting Jan 1995   
\end{code}

For more details, see \GUG\ and the \GCR\ for the \cmd{nulldata} and
\cmd{setobs} commands. The only important thing to say at this point,
however, is that you can resize your dataset and/or change some of its
characteristics, such as its periodicity, at nearly any point inside
your script if necessary.

Once your dataset is in place, you can start populating it with
series, either by reading it from disk files (see the next section) or
by generating them via appropriate commands and functions.

\section{Reading a dataset from a file}

Important commands: \cmd{open}, \cmd{append}, \cmd{join}

The \cmd{open} command is what you'll want to use in most cases, since
(i) it handles transparently a decent variety of formats (native, CSV,
spreadsheet, other packages' such as Stata and Eviews) and (ii) it
takes care automatically of setting up the dataset for you.
\begin{code}
  open mydata.gdt    # native format
  open yourdata.dta  # Stata format
  open theirdata.xls # Excel format
\end{code}

\begin{itemize}
\item native format
\item import capabilities (from URLs as well)
\item nifty tricks with csv data (eg \cmd{join}).
\end{itemize}

You can also use \cmd{open} to read stuff off tne Net, by using an URL
instead of a filename, like eg in
\begin{code}
  open http://someserver.com/somedata.csv
\end{code}

\section{Saving datasets}

\begin{itemize}
\item Storing with \cmd{store} (binary format vs XML)
\item Using \cmd{store} to export to CSV
\item (maybe) using \cmd{printf} and \cmd{outfile} if you need to do
  something unusual; real-life cases?
\end{itemize}

\section{The \cmd{smpl} command}

The \cmd{smpl} command then allows you to discard observations
selectively, so that your series will contain only the observations
you want (automatically changing the dimension of the dataset in the
process). See chapter 4 in \GUG\ for further
information.\footnote{Users with a Stata background may find the hansl
  way of doing things a little disconcerting at first. In hansl, you
  first restrict your sample through the \cmd{smpl} command, which
  applies until further notice, then you do what you have to. There is
  no equivalent to Stata's \texttt{if} clause to commands.}

There are basically three variants to the \cmd{smpl} command:
\begin{enumerate}
\item Selecting a contiguous subset of observations: this will be
  mostly useful with time-series datasets. For example:
  \begin{code}
    smpl 4 122            # select observations for 4 to 122
    smpl 1984:1 2008:4    # the so-called "Great Moderation" period
    smpl 2008-01-01 ;     # form January 1st, 2008 onwards
  \end{code}
\item Selecting observations on the basis of some criterion: this is
  typically what you want with cross-sectional datasets. Example:
  \begin{code}
    smpl male == 1 --restrict                # males only
    smpl male == 1 && age < 30 --restrict    # just the young guys
    smpl employed --dummy                    # via a dummy variable
  \end{code}
  Note that, in this context, restrictions go ``on top'' of previous
  ones. In order to start from scratch, you either reset the full
  sample via \texttt{smpl full} or by using the \option{replace}
  option.
\item Restricting the active dataset to some observations so that a
  certain effect is achieved automatically: for example, drawing a
  random subsample, or ensuring that all rows that have missing
  observations are automatically excluded. This is achieved via the
  \option{no-missing}, \option{contiguous}, and \option{random}
  options.
\end{enumerate}

In the context of panel datasets, some extra qaulifications have to be
made. See \GUG.

\chapter{Series, lists and accessors}

Scalars, matrices and strings can be used in a hansl script at any
point; series and lists, on the other hand, are inherently tied to a
dataset and therefore can be used only when a dataset is currently
open.

\section{The \texttt{series} type}
\label{sec:series}
 
Series are just what any applied economist would call ``variables'',
that is, repeated observations of a given quantity; a dataset is an
ordered array of series, complemented by additional information,
such as the nature of the data (time-series, cross-section or panel),
descriptive labels for the series and/or the observations, source
information and so on.

The series belonging to a dataset are named via standard hansl
identifiers (strings of maximum length 31 characters as described
above). In the context of commands that take series as arguments,
series may be referenced either by name or by \emph{ID number}, that
is, the index of the series within the dataset. Position 0 in a
dataset is always taken by the automatic constant known as
\texttt{const}, which is just a column of 1s. The IDs of the actual
data series can be displayed via the \cmd{varlist} command. (But note
that in \textit{function calls}, as opposed to commands, series must
be referred to by name.)  A detailed description of how a dataset
works can be found in chapter 4 of \GUG.

Some basic rules regarding series follow:
\begin{itemize}
\item If \texttt{lngdp} belongs to a time series or panel dataset,
  then the syntax \texttt{lngdp(-1)} yields its first lag, and
  \texttt{lngdp(+1)} its first lead.
\item To access individual elements of a series, you use square
  brackets enclosing either
  \begin{itemize}
  \item the progressive (1-based) number of the observation you want,
    as in \verb|lngdp[15]|, or
  \item the corresponding observation marker string, if the dataset
    contains any (as in \verb|lngdp["2002:3"]|).
  \end{itemize}
\end{itemize}

The rules for assigning values to series are just the same as for
other objects, so the following example should be self-explanatory:
\begin{code}
  series k = 3         # implicit conversion from scalar; a constant series
  series x = normal()  # pseudo-rv via a built-in functions
  series s = a/b       # element-by-element operations

  series movavg = 0.5*(x + x(-1)) # using lags
  series y[2012:4] = x[2011:2]    # using individual data points 
\end{code}

\tip{In hansl, you don't have separate commands for \emph{creating}
  series and \emph{modifying} them. Other popular packages make this
  distinction, but we still struggle to understand why this is
  supposed to be useful.}

\subsection{Converting series from/to matrices}

The reason why hansl provides a specific series type, distinct from
the matrix type, is historical. However, is also a very convenient
feature.  Operations that are typically performed on series in applied
work can be awkward to implement using ``raw'' matrices. We have in
mind tasks such as the computation of leads and lags, or regular and
seasonal differences; the treatment of missing values; the addition of
descriptive labels, and so on. Series are the basic data type on which
gretl's built-in estimation commands depend.

Basically:
\begin{itemize}
\item to turn series into matrices, you use the curly braces syntax,
  as in
  \begin{code}
    matrix MACRO = { outputgap, unemp, infl }
  \end{code}
  where you can also use lists; the number of rows of the resulting
  matrix will depend on your currently selected sample.
\item To turn matrices into series, you can just use matrix columns,
  as in
  \begin{code}
    series y = my_matrix[,4]
  \end{code}
  and it's your responsibility to make sure that the number of rows in
  \texttt{my\_matrix} matches the currently selected sample.
\end{itemize}

Note that you can also assign a matrix to a list, but that has a
completely different meaning.

Be aware of the \cmd{lincomb} and \cmd{filter} functions too: they are
quite useful for creating and manipulating series without having to
convert them to matrices (which could be computationally costly with
large datasets).


\subsection{The ternary operator with series}

\begin{code}
  worker_income = employed ? income : 0
\end{code}

Here we assume that \texttt{employed} is a dummy series coding for
employee status; its value will be tested for each observation in the
current sample range and the value assigned to \texttt{worker\_income}
at that observation will be determined accordingly. It is therefore
equivalent to the following much more verbose formulation (where
\dollar{t1} and \dollar{t2} are accessors for the start and end of the
sample range):
\begin{code}
series worker_income
loop i=$t1..$t2
    if employed[i]
        worker_income[i] = income[i]
    else
        worker_income[i] = 0
    endif
endloop
\end{code}

\section{The \texttt{list} type}
\label{sec:lists}
 
In hansl parlance, a \textit{list} is an array of integers,
representing the ID numbers of a set (in a loose sense of the word) of
series.  For this reason, the most common operations you perform on
lists are set operations such as addition or deletion of members,
union, intersection and so on. Unlike sets, however, hansl lists are
ordered, so individual list members can be accessed via the
\texttt{[]} syntax, as in \texttt{X[3]}.

There are several ways to assign values to a list.  The most basic
sort of expression that works in this context is a space-separated
list of series, given either by name or by ID number.  For example,
\begin{code}
list xlist = 1 2 3 4
list reglist = income price 
\end{code}
An empty list is obtained by using the keyword \texttt{null}, as in
\begin{code}
list W = null  
\end{code}
or simply by bare declaration. Some more special forms (for example,
using wildcards) are described in \GUG.

The main idea is to use lists to group, under one identifier, one or
more series that logically belong together somehow (for example, as
explanatory variables in a model). So for example
\begin{code}
list xlist = x1 x2 x3 x4
ols y 0 xlist
\end{code}
is an idiomatic way of specifying the OLS regression that could also
be written as
\begin{code}
ols y 0 x1 x2 x3 x4
\end{code}

Lists can be concatenated, as in as in \texttt{list L3 = L1 L2} (where
\texttt{L1} and \texttt{L2} are names of existing lists). This will
not necessarily do what you want, however, since the resulting list
may contain duplicates. It's more common to use the following set
operations:

\begin{center}
  \begin{tabular}{rl}
    \textbf{Operator} & \textbf{Meaning} \\
    \hline
    \verb,||, & Union \\
    \verb|&&| & Intersection \\
    \verb|-|  & Set difference \\
    \hline
  \end{tabular}
\end{center}

So for example, if \texttt{L1} and \texttt{L2} are existing lists,
after running the following code snippet
\begin{code}
  list UL = L1 || L2 
  list IL = L1 && L2
  list DL = L1 - L2
\end{code}
the list \texttt{UL} will contain all the members of \texttt{L1}, plus
any members of \texttt{L2} that are not already in \texttt{L1};
\texttt{IL} will contain all the elements that are present in both
\texttt{L1} and \texttt{L2} and \texttt{DL} will contain all the
elements of \texttt{L1} that are not present in \texttt{L2}. 

To \textit{append} or \textit{prepend} variables to an existing list,
we can make use of the fact that a named list stands in for a
``longhand'' list.  For example, we can do
%
\begin{code}
list xlist = xlist 5 6 7
xlist = 9 10 xlist 11 12
\end{code}
 
Another option for appending terms to, or dropping terms from, an
existing list is to use \texttt{+=} or \texttt{+=}, respectively, as
in
\begin{code}
xlist += cpi
zlist -= cpi
\end{code}
A nice example of the above is provided by a common idiom: you may
see in hansl scripts something like
\begin{code}
  list C -= const
  list C = const C
\end{code}
which ensures that the series \texttt{const} is included (exactly
once) in the list \texttt{C}, and comes first.

\subsection{The \texttt{foreach} loop variant with lists}

Lists can be used as the ``catalogue'' in the \texttt{foreach} variant
of the \cmd{loop} construct (see section \ref{sec:loop-foreach}). This
is especially handy when you have to perform some operation on
multiple series. For example, the following syntax can be used to
calculate and print the mean of each of several series:
\begin{code}
list X = age income experience
loop foreach i X
    printf "mean($i) = %g\n", mean($i)
endloop
\end{code}

\section{Accessors}
\label{sec:accessors}
 
These begin with a dollar sign: eg, \dollar{nobs}. They could be
series, lists, scalars or matrices, depending on context. Note that
accessors cannot be assigned to; there are read-only, so to speak.

\chapter{Estimation methods}
\label{chap:estimation}

\section{Primitive estimation techniques}
\label{sec:canned}

By ``primitive'' we mean coded in C, really.

These share, more or less, the syntax
\begin{flushleft}
\texttt{\emph{commandname parameters options}}
\end{flushleft}
with a few exceptions (eg systems)

A crude categorization: 
\begin{description}
\item[Linear, single equation] \cmd{ols}, \cmd{tsls}, \cmd{ar1},
  \cmd{mpols}
\item[Linear, multi-equation] \cmd{system}, \cmd{var}, \cmd{vecm} 
\item[Nonlinear, single equation] \cmd{logit}, \cmd{probit},
  \cmd{poisson}, \cmd{negbin}, \cmd{tobit}, \cmd{intreg},
  \cmd{logistic}
\item[Panel] \cmd{panel}, \cmd{dpanel}
\item[Assorted] \cmd{arima}, \cmd{garch}, \cmd{heckit},
  \cmd{quantreg}, \cmd{lad}, \cmd{biprobit}, \cmd{duration}
\end{description}

Don't let names deceive you: for example, the \cmd{probit} command can
estimate ordered models, random-effect panel probit models, \ldots

See the \GCR{} for details

\subsection{Simultaneous systems}

The \cmd{system} block.

\section{Post-estimation accessors}
\label{sec:postest-accessors}

After having estimated a model, you can access most of the relevant
quantities via accessors.

\begin{itemize}
\item Generic: \dollar{coeff}, \dollar{vcv}, \dollar{uhat}
\item Model-specific: for example, \dollar{jbeta}, \dollar{h},
  \dollar{mnlprobs}
\end{itemize}

\subsection{Named models}

\begin{code}
diff y x
ADL <- ols y const y(-1) x(0 to -1)
ECM <- ols d_y const d_x y(-1) x(-1)
ssr_a = ADL.$ess
ssr_e = ECM.$ess # should be equal
\end{code}

\section{Generic estimation tools}
\label{sec:est-blocks}

These are useful if you want to write your own estimator. Here we give
a generic overview. See the relevant chapters in \GUG{} for a full explanation.

\begin{itemize}
\item \cmd{nls}
\item \cmd{mle}
\item \cmd{gmm}
\end{itemize}

\subsection{Formatting your output}

The \cmd{modprint} command.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "hansl-primer"
%%% End: 
