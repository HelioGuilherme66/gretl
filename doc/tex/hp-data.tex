\part{With a dataset}
\label{part:hp-data}

\chapter{What is a dataset?}

A dataset is a memory area designed to hold the data you want to work
on, if any. It may be thought of a big global variable, containing a
(possibly huge) matrix of data and a hefty collection of metadata.

\app{R} users may think that a dataset is similar to what you get when
you \texttt{attach} a data frame in \app{R}. Not really: in hansl, you
cannot have more than one dataset open at the same time. That's why we
talk about \emph{the} dataset.

When a dataset is present in memory (\emph{ie} open), a number of
objects become available for your hansl script in a transparent and
convenient way. Of course, the data themselves: the columns of the
dataset matrix are called \emph{series}, which will be described in
section \ref{sec:series}; sometimes, you will want to organize one or
more series in a \emph{list} (section \ref{sec:lists}). Additionally,
you have the possibility of using, as read-only global variables, some
scalars or matrices, such as the number of observations, the number of
variables, the nature of your dataset (cross-sectional, time series or
panel), etcetera. These are called \emph{accessors}, and will be
discussed in section \ref{sec:accessors}.

You can open a dataset by reading data from a disk file, via the
\cmd{open} command, or by creating one from scratch.

\section{Creating a dataset from scratch}
\begin{itemize}
\item The \cmd{nulldata} command
\item The \cmd{setobs} command
\end{itemize}

\section{Reading a dataset from a file}
\begin{itemize}
\item native format
\item import capabilities (from URLs as well)
\item ifty tricks with csv data (eg \cmd{join}).
\end{itemize}

\section{Saving datasets}

\section{The \cmd{smpl} command}

The \cmd{smpl} command then allows
you to discard observations selectively, so that your series will
contain only the observations you want (automatically changing the
dimension of the dataset in the process). See chapter 4 in \GUG\ for
further information.\footnote{Users with a Stata background may find
  the hansl way of doing things a little disconcerting at first. In
  hansl, you first restrict your sample through the \cmd{smpl}
  command, which applies until further notice, then you do what you
  have to. There is no equivalent to Stata's \texttt{if} clause to
  commands.}

\chapter{Series, lists and accessors}

Scalars, matrices and strings can be used in a hansl script at any
point; series and lists, on the other hand, are inherently tied to a
dataset and therefore can be used only when a dataset is currently
open.

\section{The \texttt{series} type}
\label{sec:series}
 
Series are just what any applied economist would call ``variables'',
that is, repeated observations of a given quantity; a dataset is an
ordered array of series, complemented by additional information,
such as the nature of the data (time-series, cross-section or panel),
descriptive labels for the series and/or the observations, source
information and so on.

The series belonging to a dataset are named via standard hansl
identifiers (31-characters strings as described above). In the context
of commands that take series as arguments, series may be referenced
either by name or by \emph{ID number}, that is, the index of the
series within the dataset. Position 0 in a dataset is always taken by
the automatic constant known as \texttt{const}, which is just a column
of 1s. The IDs of the actual data series can be displayed via the
\cmd{varlist} command. (But note that in \textit{function calls}, as
opposed to commands, series must be referred to by name.)  A detailed
description of how a dataset works can be found in chapter 4 of
\GUG.

Some basic rules regarding series follow:
\begin{itemize}
\item If \texttt{lngdp} belongs to a time series or panel dataset,
  then the syntax \texttt{lngdp(-1)} yields its first lag, and
  \texttt{lngdp(+1)} its first lead.
\item To access individual elements of a series, you use square
  brackets enclosing either
  \begin{itemize}
  \item the progressive (1-based) number of the observation you want,
    as in \verb|lngdp[15]|, or
  \item the corresponding observation marker string, if the dataset
    contains any (as in \verb|lngdp["2002:3"]|).
  \end{itemize}
\end{itemize}

\subsection{Converting series from/to matrices}

The reason why hansl provides a specific series type, distinct from
the matrix type, is historical. However, it is also very convenient.
Operations that are typically performed on series in applied work can
be awkward to implement using ``raw'' matrices. We have in mind tasks
such as the computation of leads and lags, or regular and seasonal
differences; the treatment of missing values; the addition of
descriptive labels, and so on. Series are the basic data type on which
gretl's built-in estimation commands depend.

\subsection{The ternary operator with series}

\begin{code}
  worker_income = employed ? income : 0
\end{code}

Here we assume that \texttt{employed} is a dummy series coding for
employee status; its value will be tested for each observation in the
current sample range and the value assigned to \texttt{worker\_income}
at that observation will be determined accordingly. It is therefore
equivalent to the following much more verbose formulation (where
\dollar{t1} and \dollar{t2} are accessors for the start and end of the
sample range):
\begin{code}
series worker_income
loop i=$t1..$t2
    if employed[i]
        worker_income[i] = income[i]
    else
        worker_income[i] = 0
    endif
endloop
\end{code}

\section{The \texttt{list} type}
\label{sec:lists}
 
In hansl parlance, a \textit{list} is an array of integers,
representing the ID numbers of a set (in a loose sense of the word) of
series.  For this reason, the most common operations you perform on
lists are set operations such as addition or deletion of members,
union, intersection and so on. Unlike sets, however, hansl lists are
ordered, so individual list members can be accessed via the
\texttt{[]} syntax, as in \texttt{X[3]}.

There are several ways to assign values to a list.  The most basic
sort of expression that works in this context is a space-separated
list of series, given either by name or by ID number.  For example,
\begin{code}
list xlist = 1 2 3 4
list reglist = income price 
\end{code}
An empty list is obtained by using the keyword \texttt{null}, as in
\begin{code}
list W = null  
\end{code}
or simply by bare declaration. Some more special forms (for example,
using wildcards) are described in \GUG.

The main idea is to use lists to group, under one identifier, one or
more series that logically belong together somehow (for example, as
explanatory variables in a model). So for example
\begin{code}
list xlist = x1 x2 x3 x4
ols y 0 xlist
\end{code}
is an idiomatic way of specifying the OLS regression that could also
be written as
\begin{code}
ols y 0 x1 x2 x3 x4
\end{code}

Lists can be concatenated, as in as in \texttt{list L3 = L1 L2} (where
\texttt{L1} and \texttt{L2} are names of existing lists). This will
not necessarily do what you want, however, since the resulting list
may contain duplicates. It's more common to use the following set
operations:

\begin{center}
  \begin{tabular}{rl}
    \textbf{Operator} & \textbf{Meaning} \\
    \hline
    \verb,||, & Union \\
    \verb|&&| & Intersection \\
    \verb|-|  & Set difference \\
    \hline
  \end{tabular}
\end{center}

So for example, if \texttt{L1} and \texttt{L2} are existing lists,
after running the following code snippet
\begin{code}
  list UL = L1 || L2 
  list IL = L1 && L2
  list DL = L1 - L2
\end{code}
the list \texttt{UL} will contain all the members of \texttt{L1}, plus
any members of \texttt{L2} that are not already in \texttt{L1};
\texttt{IL} will contain all the elements that are present in both
\texttt{L1} and \texttt{L2} and \texttt{DL} will contain all the
elements of \texttt{L1} that are not present in \texttt{L2}. 

To \textit{append} or \textit{prepend} variables to an existing list,
we can make use of the fact that a named list stands in for a
``longhand'' list.  For example, we can do
%
\begin{code}
list xlist = xlist 5 6 7
xlist = 9 10 xlist 11 12
\end{code}
 
Another option for appending (or dropping) a term (or a list) to an
existing list is to use \texttt{+=} or  \texttt{+=}, respectively, as in
\begin{code}
xlist += cpi
zlist -= cpi
\end{code}
A nice example of the above is provided by a common idiom: you may
see in hansl scripts something like
\begin{code}
  list C -= const
  list C = const C
\end{code}
which ensures that the series \texttt{const} is included (exactly
once) in the list \texttt{C}, and comes first.

\subsection{The \texttt{foreach} loop variant with lists}

Lists can be used as the ``catalogue'' in the \texttt{foreach} variant
of the \cmd{loop} construct (see section \ref{sec:loop-foreach}). This
is especially handy when you have to perform some operation on
multiple series. For example, the following syntax can be used to
calculate and print the mean of each of several series:
\begin{code}
list X = age income experience
loop foreach i X
    printf "mean($i) = %g\n", mean($i)
endloop
\end{code}

\section{Accessors}
\label{sec:accessors}
 
These begin with a dellar sign: eg, \dollar{nobs}.

\chapter{Estimation methods}

\section{Primitive estimation techniques}
\label{sec:canned}

By ``primitive'' we mean coded in C, really.

These share, more or less, the syntax
\begin{flushleft}
\texttt{\emph{commandname parameters options}}
\end{flushleft}
with a few exceptions (eg systems)

A crude categorization: 
\begin{description}
\item[Linear, single equation] \cmd{ols}, \cmd{tsls}, \cmd{ar1},
  \cmd{mpols}
\item[Linear, multi-equation] \cmd{system}, \cmd{var}, \cmd{vecm} 
\item[Nonlinear, single equation] \cmd{logit}, \cmd{probit},
  \cmd{poisson}, \cmd{negbin}, \cmd{tobit}, \cmd{intreg},
  \cmd{logistic}
\item[Panel] \cmd{panel}, \cmd{dpanel}
\item[Assorted] \cmd{arima}, \cmd{garch}, \cmd{heckit},
  \cmd{quantreg}, \cmd{lad}, \cmd{biprobit}, \cmd{duration}
\end{description}

Don't let names deceive you: for example, the \cmd{probit} command can
estimate ordered models, random-effect panel probit models, \ldots

See the \GCR{} for details

\subsection{Simultaneous systems}

The \cmd{system} block.

\section{Post-estimation accessors}
\label{sec:postest-accessors}

After having estimated a model, you can access most of the relevant
quantities via accessors.

\begin{itemize}
\item Generic: \dollar{coeff}, \dollar{vcv}, \dollar{uhat}
\item Model-specific: for example, \dollar{jbeta}, \dollar{h},
  \dollar{mnlprobs}
\end{itemize}

\subsection{Named models}

\begin{code}
diff y x
ADL <- ols y const y(-1) x(0 to -1)
ECM <- ols d_y const d_x y(-1) x(-1)
ssr_a = ADL.$ess
ssr_e = ECM.$ess # should be equal
\end{code}

\section{Generic estimation tools}
\label{sec:est-blocks}

These are useful if you want to write your own estimator. Here we give
a generic overview. See the relevant chapters in \GUG{} for a full explanation.

\begin{itemize}
\item \cmd{nls}
\item \cmd{mle}
\item \cmd{gmm}
\end{itemize}

\subsection{Formatting your output}

The \cmd{modprint} command.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "hansl-primer"
%%% End: 
