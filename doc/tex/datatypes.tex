\chapter{Gretl datatypes}
\label{chap:datatypes}

\section{Introduction}

\app{Gretl} offers the following data types:
%
\begin{center}
\begin{tabular}{lp{.8\textwidth}}
\texttt{scalar} & holds a single numerical value\\
\texttt{series} & holds $n$ numerical values, where $n$
 is the number of observations in the current dataset \\
\texttt{matrix} & holds a rectangular array of numerical
 values, of any dimensions\\
\texttt{list} & holds the ID numbers of a set of series \\
\texttt{string} & holds a array of characters\\
\texttt{bundle} & holds a variable number of objects of 
 various types (see below for details)
\end{tabular}
\end{center}

In this chapter we give a run-down of the basic characteristics of
each of these types and also explain their ``life cycles'' (creation,
modification and destruction). The list and matrix types, whose uses
are relatively complex, are discussed at greater length in the
following two chapters.

\section{Series}
\label{sec:Series}

We begin with the \texttt{series} type, which is the oldest and in a
sense the most basic type in gretl. When you open a data file in the
gretl GUI, what you see in the main window are the ID numbers, names
(and descriptions, if available) of the series read from the file. All
the series existing at any point in a gretl session are of the same
length, although some may have missing values. The variables that can
be added via the items under the \textsf{Add} menu in the main window
(logs, squares and so on) are also series.

For a gretl session to contain any series, a common series length must
be established. This is most commonly achieved by opening a data file,
or importing a series from a database, in which case the length is set
by the first import. But one can also use the \texttt{nulldata}
command, which takes as it single argument the desired length, a
positive integer.

Each series has these basic attributes: an ID number, a name, and of
course $n$ numerical values. In addition a series may have a
description (which is shown in the main window and is also accessible
via the \texttt{labels} command), a ``display name'' for use in
graphs, a record of the compaction method used in reducing the
variable's frequency (for time-series data only) and a flag marking
the variable as discrete. These attributes can be edited in the GUI by
choosing \textsf{Edit Attributes} (either under the \textsf{Variable}
menu or via right-click), or by means of the \texttt{setinfo} command.

In the context of most commands you are able to reference series by
name or by ID number as you wish. The main exception is the definition
of new variables via a formula (see \texttt{genr}); here you must use
names since ID numbers would get confused with numerical constants.

Note that series ID numbers are always consecutive, and the ID number
for a given series will change if you delete a lower-numbered series.
In some contexts, where gretl is liable to get confused by such
changes, deletion of low-numbered series is disallowed.  

\section{Scalars}
\label{sec:Scalars}

The scalar type is relatively simple: just a convenient named holder
for a single numerical value. Scalars have none of the additional
attributes pertaining to series, do not have public ID numbers, and
must be referenced by name. A common use of scalar variables is to
record information made available by gretl commands for further
processing, as in \texttt{scalar s2 = \$sigma\^{}2} to record the square of
the standard error of the regression following an estimation command
such as \texttt{ols}.

You can define and work with scalars in gretl without having any
dataset in place.

In the gretl GUI, scalar variables can be inspected and their values
edited via the \texttt{Scalars} item under the \texttt{View} menu in
the main window.

\section{Matrices}
\label{sec:Matrices}

Matrices in gretl work much as in other mathematical software (e.g.\
\textsf{Matlab}, \textsf{Octave}). Like scalars they have no public ID
numbers and must be referenced by name, and they can be used without
any dataset in place. Matrix indexing is 1-based: the top-left element
of matrix \texttt{A} is \texttt{A[1,1]}.  Matrices are discussed at
length in chapter~\ref{chap:matrices}; advanced users of gretl will
want to study this chapter in detail.

Matrices have one optional attribute beyond their numerical content:
they may have column names attached, which are displayed when the
matrix is printed. See the \texttt{colnames} function for details.

In the gretl GUI, matrices can be inspected, analysed and edited via
the \texttt{Icon view} item under the \texttt{View} menu in the main
window: each currently defined matrix is represented by an icon.

\section{Lists}
\label{sec:Lists}

As with matrices, lists merit an explication of their own (see
chapter~\ref{chap-persist}).  Briefly, named lists can (and should!)
be used to make commands scripts less verbose and repetitious, and
more easily modifiable. Since lists are in fact lists of series ID
numbers they can be used only when a dataset is in place.

In the gretl GUI, named lists can be inspected and edited under the
\textsf{Data} menu in the main window, via the item \textsf{Define or
  edit list}.

\section{Strings}
\label{sec:Strings}

String variables may be used for labeling, or for constructing
commands. They are discussed in chapter~\ref{chap-persist}. They must
be referenced by name; they can be defined in the absence of a
dataset.

Such variables can be created and modified via the command-line in
the gretl console or via script; there is no means of editing them
via the gretl GUI.


\section{Bundles}
\label{sec:Bundles}

A \texttt{bundle} is a container or wrapper for various sorts of
objects --- specifically, scalars, series, matrices, strings and
bundles. (Yes, a bundle can contain other bundles). A bundle takes
the form of a hash table or associative array: each item placed in the
bundle is associated with a key string which can used to retrieve it
subsequently. We begin by explaining the mechanics of bundles then
offer some thoughts on what they might be good for.

To use a bundle you must first ``declare'' it, as in

\begin{code}
bundle foo
\end{code}

To add an object to a bundle, use the \texttt{bundleset}
function. This takes three arguments: the name of a bundle, a key
string, and the name of the object to add. For example,

\begin{code}
bundleset(foo, "matrix1", m)
\end{code}

adds an object called \texttt{m} (presumably a matrix) to bundle
\texttt{foo} under the key \texttt{matrix1}. To get an item out
of a bundle, use the name of the bundle followed by the key string in
square backets, as in

\begin{code}
matrix bm = foo["matrix1"]
\end{code}

Note that the key identifying an object within a given bundle is
necessarily unique. If you reuse an existing key in a new
\texttt{bundleset} call, the effect is to replace the object
which was previously stored under the given key.

Also note that when you add an object to a bundle, what in fact
happens is that the bundle acquires a copy of the object. The
external object retains its own identity and is unaffected 
if/when the bundled object is replaced by another. Consider
the following script fragment:

\begin{code}
bundle foo
matrix m = I(3)
bundleset(foo, "mykey", m)
scalar x = 20
bundleset(foo, "mykey", x)
\end{code}

After the above commands are executed bundle \texttt{foo} does not
contain a matrix, but the original matrix \texttt{m} is still in good
health.

To delete an object from a bundle, use \texttt{bundledel}: this
function takes the name of a bundle and a key as its arguments;
it destroys the object associated with the key and removes the
key from the hash table.

Besides adding, accessing, replacing and deleting individual items,
the other operations that are supported for bundles are union,
printing and deletion. As regards union, if bundles \texttt{b1} and
\texttt{b2} are defined you can say,

\begin{code}
bundle b3 = b1 + b2
\end{code}

to create a new bundle that is the union of the two others. One
question arises here: what if \texttt{b2} contains an object whose key
string is the same as some object in \texttt{b1}?  In that case
\texttt{b3} gets the object from \texttt{b1}, the first given bundle,
as the value associated with the common key.  The algorithm is: create
a new bundle that is a copy of \texttt{b1}, then add any items from
\texttt{b2} whose keys are not already present in the new bundle.

If \texttt{b} is a bundle and you say \texttt{print b}, you get a
listing of the bundle's keys along with the types of the corresponding
objects, as in

\begin{code}
? print b
bundle b:
 x (scalar)
 mat (matrix)
 inside (bundle)
\end{code}

\subsection{What are bundles good for?}

Bundles are unlikely to be of interest in the context of standalone
\app{gretl} scripts, but they can be very useful in the context of
complex function packages where a good deal of information has to be
passed around between the component functions. Instead of using a
lengthy list of individual arguments, function $A$ can bundle up the
required data and pass it to functions $B$ and $C$, where relevant
information can be extracted via a mnemonic key.

In this context bundles should be passed in ``pointer'' form
(see chapter~\ref{chap:functions}) as illustrated in the following
trivial example, where a bundle is created at one level then filled
out by a separate function.

\begin{code}
# modification of bundle (pointer) by user function

function void fill_out_bundle (bundle *b)
  bundleset(b, "mat", I(3))
  bundleset(b, "str", "foo")
  bundleset(b, "x", 32)
end function

bundle my_bundle 
fill_out_bundle(&my_bundle)
\end{code}

The bundle type can also be used to advantage as the \textit{return
  value} from a packaged function, in cases where a package writer
wants to give the user the option of accessing various results. In the
\app{gretl} GUI, function packages that return a bundle are treated
specially: the output window that displays the printed results
acquires a menu showing the bundled items (their names and types),
from which the user can save items of interest. For example, a
function package that estimates a model might return a bundle that
contains a vector of parameter estimates, a residual series and a
covariance matrix for the parameter estimates, among other
possibilities.

As a refinement to support the use of bundles as a function return
type, the \texttt{setnote} function can be used to add a brief
explanatory note to a bundled item --- such notes will then be shown
in the GUI menu.  This function takes three arguments: the name of a
bundle, a key string, and the note. For example

\begin{code}
setnote(b, "vcv", "covariance matrix")
\end{code}

\section{The life cycle of gretl objects}

Objects of the types discussed above may be brought into existence in
various ways; they are all detroyed using the \texttt{delete} command.

The most basic way to create a new variable is by
\textit{declaration}, where one states the type followed by the name
of the variable to create, as in

\begin{code}
scalar x
series y
matrix A
\end{code}

and so forth. In that case the object in question is given a default
initialization, as follows: a new scalar has value \texttt{NA}
(missing); a new series is filled with zeros; a new matrix is null
(zero rows and columns); a new string is empty; a new list has no
members, and a new bundle is empty.

Declaration can be supplemented by a definite initialization, as in

\begin{code}
scalar x = pi
series y = log(x)
matrix A = zeros(10,4)
\end{code}

Unlike more formal programming languages, however, new variables in
\app{gretl} do not have to be declared by type (although they do have
to be initialized in some way before use).  The traditional way of
creating a new variable in \app{gretl} was via the \app{genr} command
(which is still supported), as in

\begin{code}
genr x = y/100
\end{code}

Here the type of \texttt{x} is left implicit and will be determined
automatically depending on the context: if \texttt{y} is a scalar,
a series or a matrix \texttt{x} will inherit \texttt{y}'s type
(otherwise an error will be generated, since division is applicable to
these types only). And finally, the type of a new variable can be left
implicit \textit{without} use of \texttt{genr}:

\begin{code}
x = y/100
\end{code}

In ``modern'' \app{gretl} scripting we recommend that you state the
type of a new variable explicitly. This makes the intent clearer to a
reader of the script and also guards against some sorts of errors that
might otherwise be difficult to understand (i.e.\ a certain variable
turns out to be of the wrong type for some subsequent calculation, but
you don't notice at first because you didn't say what type you
wanted). An exception to this rule might reasonably be granted for
clear and simple cases where there's little possibility of confusion.

Note that having created a matrix (say) using \texttt{matrix A} at
some point in a script, you do not have to go on referring to this
object as \texttt{matrix A} when you want to modify its value. You are
allowed to do that but there's no point; gretl already knows that
\texttt{A} is a matrix.

Also note that having once created \texttt{A} as a matrix (or whatever
type), while you are free to overwrite its \textit{value} you cannot
overwrite its \textit{type}. If you have a matrix \texttt{A} and later
want a series \texttt{A}, you will have to delete the matrix first.

\tip{One point to watch out for in \app{gretl} scripting is type
  conflicts having to do with the names of series brought in from a
  data file. For example, in setting up a command loop (see
  chapter~\ref{chap:looping}) it is very common to call the loop index
  \texttt{i}. Now a loop index is a scalar (typically incremented each
  time round the loop). If you opened a data file that happens to
  contain a series named \texttt{i} you will get a type error (``Types
  not conformable for operation'') when you try to use \texttt{i} as a
  loop index.}


