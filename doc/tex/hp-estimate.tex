\chapter{Estimation methods}
\label{chap:estimation}

You can, of course, estimate econometric models via hansl without
having a dataset (in the sense in which we're using that term here) in
place---just as you might in \textsf{Matlab}, for instance. You'll
need \textit{data}, but these can be loaded in matrix form (see the
\texttt{mread} function in the \GCR), or generated artificially via
functions such as \texttt{mnormal} or \texttt{muniform}. You can roll
your own estimator using hansl's linear algebra primitives, and you
also have access to more specialized functions such as \texttt{mols}
(see section \ref{sec:mat-op}) and \texttt{mrls} (restricted least
squares) if you need them.

However, unless you need to use an estimation method which is not
currently supported by gretl, or have a strong desire to reinvent the
wheel, you will probably want to make use of the built-in estimation
commands available in hansl. These commands are series-oriented and
therefore require a dataset. They fall into two main categories:
``canned'' procedures, and generic tools that can be used to estimate
a wide variety of models based on common principles.

\section{Canned estimation procedures}
\label{sec:canned}

``Canned'' doesn't sound very appetizing these days but it's the term
that's commonly used. Basically it means two things, neither of them
in fact unappetizing.
\begin{itemize}
\item The user is presented with a fairly simple interface. A few
  inputs must be specified, and perhaps a few options selected, then
  the heavy lifting is done within the gretl library.
\item The algorithm is written in C, by experienced coders. It is
  therefore faster (possibly \textit{much} faster) than an
  implementation in an interpreted language such as hansl.
\end{itemize}

Such procedures share, more or less, the syntax
\begin{flushleft}
\texttt{\emph{commandname parameters options}}
\end{flushleft}
with a few exceptions (e.g.\ systems).

A crude categorization: 
\begin{description}
\item[Linear, single equation] \cmd{ols}, \cmd{tsls}, \cmd{ar1},
  \cmd{mpols}
\item[Linear, multi-equation] \cmd{system}, \cmd{var}, \cmd{vecm} 
\item[Nonlinear, single equation] \cmd{logit}, \cmd{probit},
  \cmd{poisson}, \cmd{negbin}, \cmd{tobit}, \cmd{intreg},
  \cmd{logistic}
\item[Panel] \cmd{panel}, \cmd{dpanel}
\item[Assorted] \cmd{arima}, \cmd{garch}, \cmd{heckit},
  \cmd{quantreg}, \cmd{lad}, \cmd{biprobit}, \cmd{duration}
\end{description}

Don't let names deceive you: for example, the \cmd{probit} command can
estimate ordered models, random-effect panel probit models, \dots{}

See the \GCR{} for details.

\subsection{Simultaneous systems}

The \cmd{system} block.

\section{Post-estimation accessors}
\label{sec:postest-accessors}

After having estimated a model, you can access most of the relevant
quantities via accessors.

\begin{itemize}
\item Generic: \dollar{coeff}, \dollar{vcv}, \dollar{uhat}
\item Model-specific: for example, \dollar{jbeta}, \dollar{h},
  \dollar{mnlprobs}
\end{itemize}

\subsection{Named models}

\begin{code}
diff y x
ADL <- ols y const y(-1) x(0 to -1)
ECM <- ols d_y const d_x y(-1) x(-1)
ssr_a = ADL.$ess
ssr_e = ECM.$ess # should be equal
\end{code}

\section{Generic estimation tools}
\label{sec:est-blocks}

These are useful if you want to write your own estimator. Here we give
a generic overview. See the relevant chapters in \GUG{} for a full explanation.

\begin{itemize}
\item \cmd{nls}
\item \cmd{mle}
\item \cmd{gmm}
\end{itemize}

\subsection{Formatting your output}

The \cmd{modprint} command.

\label{LastPage}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "hansl-primer"
%%% End: 
