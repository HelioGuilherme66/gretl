function void dbnomics_bundle_print(const bundle b, bool print_data[0])
    if b.error
	printf "dbnomics_bundle_print: bundle has error flag set\n"
	if inbundle(b, "errmsg")
	    printf "%s\n", b.errmsg
	endif
	return
    endif

    scalar nf = 0
    if inbundle(b, "id")
	sn = sprintf("Series: %s", b.id)
	nf++
    else
	sn = b.dset_name
    endif
    # make a line of dashes the same length as @sn
    dashline = regsub(sn, ".", "-")

    print dashline
    printf "%s\n", sn
    if inbundle(b, "provider")
	printf "Provider: %s\n", b.provider
	nf++
    endif
    if inbundle(b, "dataset")
	nf++
	if inbundle(b, "dset_name")
	    printf "Dataset: %s (%s)\n", b.dataset, b.dset_name
	else
	    printf "Dataset: %s\n", b.dataset
	endif
    endif
    if nf == 3
	printf "Identifier: %s/%s/%s\n\n", b.provider, b.dataset, b.id
    endif
    if inbundle(b, "series_name")
	# this is actually the description of the series
        printf "%s\n", b.series_name
    endif
    print dashline

    if b.has_data
	n = b.actobs
	printf "pd = %d; %d observations, %s - %s\n",
	b.frequency, n, b.periods[1], b.periods[n]
	if print_data
            loop i=1..n -q
		printf "%s %6.1f\n", b.periods[i], b.vals[i]
            endloop
	endif
    else
        printf "bundle appears to contain no data\n"
    endif
    printf "\n"

end function

### ------------------------------------------------------------------------

function scalar dbnomics_bundle_get_data(const bundle b, series *x, bool verbose[0])
    if !inbundle(b, "frequency")
        printf "dbnomics_bundle_get_data: bundle does not contain a data frequency\n"
	return 1
    endif
    pd = b.frequency
    daily = pd == 7

    if daily # daily data need special treatment
	match = maxc($pd .= {5;6;7})
    else
	match = (pd == $pd)
    endif

    if !match
        funcerr "frequency does not match!"
    endif

    tmpfile = sprintf("%s/tmp%04d.csv", $dotdir, randgen1(i, 0, 9999))
    # n = b.totobs
    outfile @tmpfile --write
    printf "obs\tx\n"
    set warnings off
    loop i=1 .. b.actobs -q
        printf "%s\t%20.15f\n", b.periods[i], b.vals[i]
    endloop
    outfile --close

    if daily
	setopt join --tkey="obs,%Y-%m-%d"
    endif

    join @tmpfile x
    if inbundle(b, "series_name")
        d = b.series_name
        setinfo x --description="@d"
    endif

    if verbose
        printf "dbnomics_bundle_get_data:\n%s\n", b.series_name
    endif
    return 0
end function

### ------------------------------------------------------------------------

function bundle dbnomics_get_series (const string datacode, bool verbose[0],
                                     string *from_json[null])

    bundle ret
    ret.datacode = datacode
    ret.has_data = 0

    string s1 = "https://api.next.nomics.world/series?series_ids="
    string URL = s1 ~ datacode ~ "&offset=0&format=json"
    if verbose
        printf "URL = '%s'\n", URL
    endif

    string json
    string msg
    ret.error = dbn_get_json(URL, &json, &msg)
    if ret.error
	ret.errmsg = msg
        return ret
    endif

    strings S = strsplit(datacode,, "/")
    ret.provider = S[1]
    ret.dataset = S[2]
    ret.id = S[3]
    ret.error = fill_series_bundle(&ret, json, 1)

    return ret
end function

### ------------------------------------------------------------------------

function bundles dbnomics_get_multiple(const string pcode,
				       const string dcode,
				       int limit[0::20],
				       int offset[0],
				       bundle spec[null])
    if !exists(spec)
        bundle spec = null
    endif

    bundles ret = null
    string URL = build_URL(pcode, dcode, limit, offset, spec)
    # printf "%s\n", URL
    string json
    err = dbn_get_json(URL, &json)
    if err
	return ret # or use funcerr?
    endif

    n = 0
    ns = 0
    found = jsonget(json, "$.series.num_found", &n)
    printf "number of series = %s\n", found
    nfound = atof(found)
    if ok(nfound)
        ns = nfound > limit ? limit : nfound
    endif
    if ns > 0
        bundles ret = array(ns)
        loop i = 1..ns --quiet
	    bundle tmp = null
	    err = fill_series_bundle(&tmp, json, i)
	    if !err
		tmp.error = 0
                ret[i] = tmp
	    endif
        endloop
    endif

    return ret
end function

### ------------------------------------------------------------------------

function bundles dbnomics_get_dataset_content(const string pcode,
					      const string dcode,
                                              int limit[0::100],
					      int offset[0])
    bundles ret = null
    site = "api.next.nomics.world"
    URL = sprintf("https://%s/%s/%s/series?limit=%d&offset=%d", site, pcode,
      dcode, limit, offset)
    # printf "%s\n", URL
    string json
    err = dbn_get_json(URL, &json)

    if !err
	n = 0
	ns = 0
	found = jsonget(json, "$.series.num_found", &n)
	if n > 0
            nfound = atof(found)
	    ns = nfound > limit ? limit : nfound
	endif
	if ns > 0
            bundles ret = array(ns)
            strings fields = defarray("name", "code")
            loop i = 1..ns --quiet
		ret[i] = json2bndl(fields, json, "series.docs", i-1)
		ret[i].num_found = nfound
            endloop
	endif
    endif

    return ret
end function

### ------------------------------------------------------------------------

function bundles dbnomics_providers(bool verbose[0])
    magic = "providers.docs"
    URL = "https://api.next.nomics.world/providers"
    if verbose
        printf "URL = '%s'\n", URL
    endif
    nprov = 0
    string json
    err = dbn_get_json(URL, &json)

    if !err
	str = jsonget(json, sprintf("$.%s[*].code", magic), &nprov)
	if nprov == 0
            err = 1
	endif
    endif

    if err
	funcerr "no providers were found"
    endif

    bundles ret = array(nprov)
    strings fields = defarray("name", "terms_of_use", "code", "region", "description", "website")

    loop i = 1..nprov --quiet
        ret[i] = json2bndl(fields, json, magic, i-1)
    endloop

    if verbose
        printf "Available providers: \n"
        loop i = 1..nprov --quiet
            printf "%3d: %15s", i, ret[i].code
            if inbundle(ret[i], "name")
                printf " (%s)", ret[i].name
            endif
            printf "\n"
        endloop
    endif

    return ret
end function

### ------------------------------------------------------------------------

function bundles dbnomics_search(const string s, int limit[0::100],
				 int offset[0], bool verbose[0])
    magic = "results.docs"
    bundles ret = null

    string URL = sprintf("https://api.next.nomics.world/search?q=%s&limit=%d&offset=%d",
    sanitize_url(s), limit, offset)
    if verbose
        printf "URL = '%s'\n", URL
    endif
    string json
    err = dbn_get_json(URL, &json)
    if err
	return ret
    endif

    n = 0
    str = jsonget(json, sprintf("$.%s[*].code", magic), &n)
    ntot = atof(jsonget(json, "$.results.num_found"))
    printf "n = %d, ntot = %d\n", n, ntot

    if n == 0
	if verbose
	    printf "No matches found"
	endif
	return ret
    endif

    bundles ret = array(n)
    strings fields = defarray("code", "nb_matching_series", "name", \
			      "provider_code")
    loop i = 1..n --quiet
        ret[i] = json2bndl(fields, json, magic, i-1)
	ret[i].ntot = ntot
    endloop

    if verbose
        printf "Datasets containing \"%s\" (%d-%d out of %d): \n\n",
        s, offset+1, offset+n, ntot
        loop i = 1..n --quiet
            printf "%3d: %s.%s", i, ret[i].provider_code, ret[i].code
            printf " (%d series)\n", atof(ret[i].nb_matching_series)
        endloop
    endif

    return ret
end function

### ------------------------------------------------------------------------

function bundles dbnomics_categtree(const string provider,
				    bool verbose[0])
    bundles ret = null
    magic = "category_tree"
    URL = sprintf("https://api.next.nomics.world/providers/%s", provider)
    if verbose
        printf "URL = '%s'\n", URL
    endif
    string json
    err = dbn_get_json(URL, &json)
    if err
	return ret # funcerr?
    endif

    n = 0
    str = jsonget(json, sprintf("$.%s[*].code", magic), &n)
    if n > 0
	bundles ret = array(n)
	strings fields = defarray("code", "name")
	loop i = 1..n --quiet
            bundle b = json2bndl(fields, json, magic, i-1)
	    if verbose
		print b
	    endif
	    ret[i] = b
	endloop
    endif

    return ret
end function

### ------------------------------------------------------------------------

function bundle dbnomics_dsets_for_provider(const string provider, bool verbose[0])
    URL = sprintf("https://api.next.nomics.world/providers/%s", provider)
    if verbose
        printf "URL = '%s'\n", URL
    endif
    n = 0
    string json
    err = dbn_get_json(URL, &json)
    if !err
	dscodes = jsonget(json, "$.category_tree..children..code", &n)
    endif
    if n == 0
        funcerr "Found no datasets for provider"
    endif

    bundle ret
    dsnames = jsonget(json, "$.category_tree..children..name")
    ret.error = 0
    ret.codes = strsplit(dscodes,,"\n")
    ret.names = strsplit(dsnames,,"\n")

    return ret
end function

### ------------------------------------------------------------------------

function series dbnomics_fetch (const string id, bool verbose[0])
    series ret = NA
    bundle b = dbnomics_get_series(id, verbose)
    if b.error
	string str = b.errmsg
	funcerr str
    else
	dbnomics_bundle_get_data(b, &ret, verbose)
    endif
    return ret
end function
