function void dbnomics_bundle_print(const bundle b, bool print_data[0])

    sn = b.dset_name
    if inbundle(b, "id")
        sn ~= sprintf(" (%s)", b.id)
    endif
    line = regsub(sn, ".", "-")
    
    printf "%s\n%s\n", line, sn
    if inbundle(b, "provider") && inbundle(b, "database")
        printf "from %s (%s)\n", b.provider, b.database
    endif
    if inbundle(b, "series_name") 
        printf "%s\n", b.series_name
    endif
    printf "%s\n", line

    if b.has_data
	n = b.actobs
	printf "pd = %d; %d observations, [%s - %s]\n", 
	b.frequency, n, b.periods[1], b.periods[n]
	if print_data
            loop i=1..n -q
		printf "%s %6.1f\n", b.periods[i], b.vals[i]
            endloop
	endif
    else
        printf "bundle appears to contain no data\n"
    endif
    printf "\n"
    
end function

### ------------------------------------------------------------------------

function scalar dbnomics_bundle_get_data(const bundle b, series *x, bool verbose[0])
    series ret = NA
    if !inbundle(b, "frequency")
        printf "dbnomics_bundle_get_data: bundle does not contain a data frequency\n"
	return 1
    endif
    pd = b.frequency
    daily = pd == 7
    
    if daily # daily data need special treatment
	match = maxc($pd .= {5;6;7}) 
    else
	match = (pd == $pd)
    endif

    if !match
        funcerr "frequency does not match!"
    endif
    
    tmpfile = sprintf("%s/tmp%04d.csv", $dotdir, randgen1(i, 0, 9999))
    # n = b.totobs
    outfile @tmpfile --write
    printf "obs\tx\n"
    set warnings off
    loop i=1 .. b.actobs -q
        printf "%s\t%20.15f\n", b.periods[i], b.vals[i]
    endloop
    outfile --close

    if daily
	setopt join --tkey="obs,%Y-%m-%d"
    endif
    
    join @tmpfile x
    if inbundle(b, "series_name")
        d = b.series_name
        setinfo x --description="@d" 
    endif
    
    if verbose
        printf "dbnomics_bundle_get_data:\n%s\n", b.series_name
    endif
    return 0
end function

### ------------------------------------------------------------------------

function bundle dbnomics_get_series (const string datacode, bool verbose[0],
                                     string *from_json[null])
                       
    bundle ret = null
    ret.error = 0
    ret.datacode = datacode
    ret.has_data = 0
                       
    string json_src = "https://api.next.nomics.world/series?series_ids="
    URL = json_src ~ datacode ~ "&offset=0&format=json"
    if verbose
        printf "URL = '%s'\n", URL
    endif

    bundle req = null
    req.header = "accept: application/json"
    req.URL = URL
    err = curl(&req)

    # debugging
    if verbose
        print req
    endif
    
    # provisional
    if err
        ret.error = err
        printf "%s", req.errmsg
        return ret
    endif

    # curl went OK, but we may still not have data
    from_json = req.output
    ret.json = from_json
    # print from_json
    string dbnmsg
    ret.error = bad_json(from_json, &dbnmsg)
    if ret.error
        if dbnmsg != ""
            ret.errmsg = sprintf("error message from dbnomics:\n%s\n", dbnmsg)
            printf "%s", ret.errmsg
        endif
        return ret
    endif

    strings ser_id = strsplit(datacode, , "/")
    ret.provider = ser_id[1]
    ret.database = ser_id[2]
    ret.id = ser_id[3]
      
    ret.error = fill_series_bundle(&ret, req.output, 1)
    return ret
end function

### ------------------------------------------------------------------------

function bundles dbnomics_get_multiple(string pcode, string dcode, int limit[0::20],
      scalar offset[0], bundle spec[null])
    
    if !exists(spec)
        bundle spec = null
    endif
    
    bundle req = null
    req.header = "accept: application/json"
    req.URL = build_URL(pcode, dcode, limit, offset, spec)
    # printf "%s\n", req.URL
    err = curl(&req)
    json = req.output
    n = 0
    ns = 0

    found = jsonget(json, "$.series.num_found", &n)
    printf "no. of series = %s\n", found
    nfound = atof(found)
    if ok(nfound)
        ns = nfound > limit ? limit : nfound
    endif
    if ns > 0
        bundles ret = array(ns)
        loop i = 1..ns --quiet
            bundle tmp = null
            err = fill_series_bundle(&tmp, json, i)
            if !err
                ret[i] = tmp
            endif
        endloop 
    else
        bundles ret = null
    endif

    return ret
end function

### ------------------------------------------------------------------------

function bundles dbnomics_get_dataset_content(const string pcode, const string dcode,
                                              int limit[0::100], int offset[0])
    site = "api.next.nomics.world"
    bundle req = null
    req.header = "accept: application/json"
    req.URL = sprintf("https://%s/%s/%s/series?limit=%d&offset=%d", site, pcode,
      dcode, limit, offset)
    # printf "%s\n", req.URL
    err = curl(&req)
    json = req.output

    n = 0
    ns = 0
    found = jsonget(json, "$.series.num_found", &n)
    if n > 0
        nfound = atof(found)
	ns = nfound > limit ? limit : nfound
    endif
    if ns > 0
        bundles ret = array(ns)
        strings fields = defarray("name", "code")
        loop i = 1..ns --quiet
            ret[i] = json2bndl(fields, json, "series.docs", i-1)
	    ret[i].num_found = nfound
        endloop
    else
        bundles ret = null
    endif
    
    return ret
end function

### ------------------------------------------------------------------------

function bundles dbnomics_providers(bool verbose[0])
    magic = "providers.docs"

    bundle req
    req.URL = "https://api.next.nomics.world/providers"
    req.header = "accept: application/json"
    err = curl(&req)
    json = req.output
    nprov = 0
    str = jsonget(json, sprintf("$.%s[*].code", magic), &nprov)
    if nprov == 0
        funcerr "no providers were found"
    endif

    bundles ret = array(nprov)
    strings fields = defarray("name", "terms_of_use", "code", "region", "description", "website")
    
    loop i = 1..nprov --quiet
        ret[i] = json2bndl(fields, json, magic, i-1)
    endloop

    if verbose
        printf "Available providers: \n"
        loop i = 1..nprov --quiet
            printf "%3d: %15s", i, ret[i].code
            if inbundle(ret[i], "name")
                printf " (%s)", ret[i].name
            endif
            printf "\n"
        endloop
    endif

    return ret
end function

### ------------------------------------------------------------------------

function bundles dbnomics_search(string s, int limit[0::100], int offset[0], bool verbose[0])
    bundle req
    magic = "results.docs"
    
    req.URL = sprintf("https://api.next.nomics.world/search?q=%s&limit=%d&offset=%d",
    sanitize_url(s), limit, offset)
    if verbose
        printf "URL = '%s'\n", req.URL
    endif
    req.header = "accept: application/json"
    err = curl(&req)
    json = req.output
    n = 0
    str = jsonget(json, sprintf("$.%s[*].code", magic), &n)
    ntot = atof(jsonget(json, "$.results.num_found"))
    printf "n = %d, ntot = %d\n", n, ntot

    bundles ret = array(n)
    strings fields = defarray("code", "nb_matching_series", "name", "provider_code")
    
    loop i = 1..n --quiet
        ret[i] = json2bndl(fields, json, magic, i-1)
	ret[i].ntot = ntot
    endloop

    if verbose
        printf "Datasets containing \"%s\" (%d-%d out of %d): \n\n",
        s, offset+1, offset+n, ntot
        loop i = 1..n --quiet
            printf "%3d: %s.%s", i, ret[i].provider_code, ret[i].code
            printf " (%d series)\n", atof(ret[i].nb_matching_series)
        endloop
    endif
    return ret
end function

### ------------------------------------------------------------------------

function bundles dbnomics_categtree(const string provider, bool verbose[0])
    magic = "category_tree"
    bundle req
    
    req.URL = sprintf("https://api.next.nomics.world/providers/%s", provider)
    req.header = "accept: application/json"
    err = curl(&req)
    json = req.output
    n = 0
    str = jsonget(json, sprintf("$.%s[*].code", magic), &n)

    bundles ret = array(n)
    strings fields = defarray("code", "name")
    
    loop i = 1..n --quiet
        bundle b = json2bndl(fields, json, magic, i-1)
	if verbose
	    print b
	endif
	ret[i] = b
    endloop

    return ret
end function

### ------------------------------------------------------------------------

function series dbnomics_fetch (const string id, bool verbose[0])
  series ret = NA
  bundle b = dbnomics_get_series(id, verbose)
  if b.error
    string s = b.errmsg
    funcerr "@s"
  else
    dbnomics_bundle_get_data(b, &ret, verbose)
  endif
  return ret
end function
