function bundle json2bndl(const strings fields, const string jsonobj,
			  const string root, int ndx)
    bundle b = null
    k = 0
    loop j = 1..nelem(fields) --quiet
        f = fields[j]
        src = sprintf("$.%s[%d].%s", root, ndx, f)
        str = jsonget(jsonobj, src, &k)
        if k
            b[f] = str
        endif
    endloop
    return b
end function

### ------------------------------------------------------------------------

function string sanitize_url(const string s)
    ret = strsub(s, " ", "%20")
    ret = strsub(ret, sprintf("\""), "%22")
    ret = strsub(ret, ",", "%2C")
    ret = strsub(ret, ":", "%3A")
    ret = strsub(ret, "{", "%7B")
    ret = strsub(ret, "}", "%7D")
    ret = strsub(ret, "[", "%5B")
    ret = strsub(ret, "]", "%5D")
    return ret
end function

### ------------------------------------------------------------------------

function scalar get_frequency(const string json_obj)
    strings alternatives = defarray(".Frequency", ".FREQ", "['@frequency']")
    got = 0
    loop i=1..nelem(alternatives) --quiet
        s = sprintf("$.series.data[0]%s", alternatives[i])
        frq = jsonget(json_obj, s, &got)
        if got
            frq = tolower(frq[1])
	    break
        endif
    endloop

    scalar ret = NA

    if got
        if frq == "a"
            scalar ret = 1
        elif frq == "q"
            scalar ret = 4
        elif frq == "m"
            scalar ret = 12
        elif frq == "d"
            scalar ret = 7
        else # unrecognised
            printf "frq = \"%s\" unrecognized\n", frq
            scalar ret = -1
        endif
    endif

    return ret
end function

### ------------------------------------------------------------------------

function string get_alternatives(const string json_obj, const string root,
				 const strings alternatives)
    got = 0
    ret = ""
    loop i=1..nelem(alternatives) --quiet
        s = sprintf("%s%s", root, alternatives[i])
        ret = jsonget(json_obj, s, &got)
        if got
            break
        endif
    endloop
    return ret
end function


### ------------------------------------------------------------------------

function scalar fill_series_bundle(bundle *b, string output, scalar index)
    got = 0
    has_index = (index == 0) ? "" : sprintf("[%d]", index-1) # zero-based

    b.frequency = get_frequency(output)
    qry = sprintf("$.series.data%s.dataset_name", has_index)
    b.dset_name = jsonget(output, qry)
    # qry = sprintf("$.series.data%s..Unit", has_index)
    qry = sprintf("$.series.data%s.Unit", has_index)
    tmp = jsonget(output, qry, &got)
    if got
        b.unit = tmp
    endif
    qry = sprintf("$.series.data%s.series_name", has_index)
    tmp = jsonget(output, qry, &got)
    if got
        b.series_name = tmp
    endif

    string line

    string root = sprintf("$.series.data%s", has_index)
    s = get_alternatives(output, root, defarray(".period", ".periods"))
    # qry = sprintf("$.series.data%s..period", has_index)
    # s = jsonget(output, qry)

    strings periods
    loop while getline(s, line) -q
        periods += line
    endloop
    n = nelem(periods)

    s = get_alternatives(output, root, defarray(".value", ".values"))
    # qry = sprintf("$.series.data%s..value", has_index)
    # s = jsonget(output, qry)
    strings datavals
    loop while getline(s, line) -q
        datavals += line
    endloop

    # skip any leading blank data rows
    istart = 1
    loop i=1..n -q
        if datavals[i] == "" || datavals[i] == "NA"
            istart++
        else
            break
        endif
    endloop

    b.totobs = n
    b.start = istart
    actobs = n - istart + 1
    b.actobs = actobs
    b.has_data = (actobs > 0)

    if b.has_data
	b.vals = zeros(actobs,1)
	strings b.periods = array(actobs)
	scalar j = 1
	loop i=istart..n -q
            b.vals[j] = atof(datavals[i])
            b.periods[j] = periods[i]
            j++
	endloop
    endif

    return 0
end function

### ------------------------------------------------------------------------

function string make_dimensions(bundle spec, string what)
    ret = ""
    if inbundle(spec, what)
	strings ss = spec[what]
	ret ~= sprintf("\"%s\":[", what)
	loop i = 1 .. nelem(ss) --quiet
            ret ~= sprintf("\"%s\"", ss[i])
            if i<nelem(ss)
		ret ~= ","
            else
		ret ~= "]"
            endif
	endloop
    endif
    return ret
end function

### ------------------------------------------------------------------------

function string build_URL_mid(bundle spec)
    string ret = ""
    if nelem(spec) == 0
        return ret
    endif

    ret = "dimensions={"
    strings filters = array()
    strings dims = defarray("freq", "indicator", "geo")
    n = 0
    loop i = 1..nelem(dims) --quiet
	s = make_dimensions(spec, dims[i])
	if strlen(s) > 0
	    n++
	    filters = filters + defarray(s)
	endif
    endloop

    loop i = 1..n --quiet
	ret ~= filters[i]
	if i < n
	    ret ~= ", "
	endif
    endloop

    ret = ret ~ "}&"
    return ret
end function

### ------------------------------------------------------------------------

function string build_parms(const string pcode, const string dcode,
			    int limit[0::20], int offset[0],
			    bundle spec)
    string head = sprintf("series?provider_code=%s&dataset_code=%s&",
			  pcode, dcode)
    string mid = build_URL_mid(spec)
    string tail = sprintf("limit=%d&offset=%d&format=json", limit, offset)
    ret = head ~ sanitize_url(mid) ~ tail
    return ret
end function

### ------------------------------------------------------------------------

# This is tricky: we may not get a recognizable error code,
# or even an error message, on failure to retrieve any data.

function scalar bad_json (const string s, string *msg)
    ret = 0
    if instring(s, "404 Error") || instring(s, "404 Not Found")
        ret = 404
    elif instring(s, "400 Bad Request")
        ret = 400
    endif
    got = 0
    msg = jsonget(s, "$.error_description", &got)
    if !got
       msg = jsonget(s, "$.warnings", &got)
    endif
    if ret == 0 && got
        ret = got
    endif
    return ret
end function

### ------------------------------------------------------------------------

function scalar dbn_get_json (const string parms, bool verbose[0],
			      string *json, string *msg[null])
    URL = "https://api.next.nomics.world/" ~ parms
    if verbose
	printf "URL = '%s'\n", URL
    endif
    req = defbundle("URL", URL, "header", "accept: application/json")
    # check for curl error
    error = curl(&req)
    string mymsg
    if error
	mymsg = req.errmsg
    else
	# also check for dbnomics error condition
        json = req.output
	string dbnmsg
	error = bad_json(json, &dbnmsg)
	if error
	    mymsg = sprintf("error message from dbnomics:\n\"%s\"\n", dbnmsg)
	endif
    endif
    if error
	printf "%s", mymsg
	if exists(msg)
	    msg = mymsg
	endif
    endif
    return error
end function
