function bundle json2bndl(const strings fields, const string jsonobj,
      const string root, int ndx)
    bundle b = null
    k = 0
    loop j = 1..nelem(fields) --quiet
        f = fields[j]
        src = sprintf("$.%s[%d].%s", root, ndx, f)
        str = jsonget(jsonobj, src, &k)
        if k
            if f == "name"
                # hopefully this can be trashed later
                b[f] = strsub(str, "&#44;", ",")
            else
                b[f] = str
            endif
        endif
    endloop
    return b
end function

### ------------------------------------------------------------------------

function string sanitize_url(const string s)
    ret = strsub(s, " ", "%20")
    ret = strsub(ret, sprintf("\""), "%22")
    ret = strsub(ret, ",", "%2C")
    ret = strsub(ret, ":", "%3A")
    ret = strsub(ret, "{", "%7B")
    ret = strsub(ret, "}", "%7D")
    ret = strsub(ret, "[", "%5B")
    ret = strsub(ret, "]", "%5D")
    return ret
end function

### ------------------------------------------------------------------------

function scalar get_frequency(const string json_obj)
    strings alternatives = defarray(".Frequency", ".FREQ", "['@frequency']")
    got = 0
    loop i=1..nelem(alternatives) --quiet
        s = sprintf("$.series.data[0]%s", alternatives[i])
        frq = jsonget(json_obj, s, &got)
        if got
            frq = tolower(frq[1])
            break
        endif
    endloop

    scalar ret = NA

    if got
        if frq == "a"
            scalar ret = 1
        elif frq == "q"
            scalar ret = 4
        elif frq == "m"
            scalar ret = 12
        elif frq == "d"
            scalar ret = 7
        else
            printf "frq = \"%s\" unrecognized\n", frq
            scalar ret = -1
        endif
    endif

    return ret
end function

### ------------------------------------------------------------------------

function scalar maybe_put_into_bundle(bundle *b, const string json, string key, string qry)
    scalar got = 0
    tmp = jsonget(json, qry, &got)
    if got
        b[key] = tmp
    endif
    return got
end function

### ------------------------------------------------------------------------

function scalar fill_series_bundle(bundle *b, const string json, int idx)
    got = 0
    istr = (idx == 0) ? "" : sprintf("[%d]", idx-1) # zero-based

    b.frequency = get_frequency(json)
    qry = sprintf("$.series.data%s.dataset_name", istr)
    b.dset_name = jsonget(json, qry, &got)
    if !got
	b.dset_name = "untitled"
    endif

    maybe_put_into_bundle(&b, json, "unit", sprintf("$.series.data%s.Unit", istr))
    maybe_put_into_bundle(&b, json, "series_name", sprintf("$.series.data%s.series_name", istr))
    maybe_put_into_bundle(&b, json, "series_code", sprintf("$.series.data%s.series_code", istr))

    string line

    qry = sprintf("$.series.data%s..period", istr)
    s = jsonget(json, qry)

    strings periods
    loop while getline(s, line) -q
        periods += line
    endloop
    n = nelem(periods)

    qry = sprintf("$.series.data%s..value", istr)
    s = jsonget(json, qry)
    strings datavals
    loop while getline(s, line) -q
        datavals += line
    endloop

    # skip any leading blank data rows
    istart = 1
    loop i=1..n -q
        if datavals[i] == "" || datavals[i] == "NA"
            istart++
        else
            break
        endif
    endloop

    b.totobs = n
    b.start = istart
    actobs = n - istart + 1
    b.actobs = actobs
    b.has_data = (actobs > 0)

    if b.has_data
        b.vals = zeros(actobs,1)
        strings b.periods = array(actobs)
        scalar j = 1
        loop i=istart..n -q
            b.vals[j] = atof(datavals[i])
            b.periods[j] = periods[i]
            j++
        endloop
    endif

    return 0
end function

### ------------------------------------------------------------------------

function string make_dimensions(const bundle spec, const string what)
    ret = ""
    if inbundle(spec, what)
        strings ss = spec[what]
        ret ~= sprintf("\"%s\":[", what)
        loop i = 1 .. nelem(ss) --quiet
            ret ~= sprintf("\"%s\"", ss[i])
            if i < nelem(ss)
                ret ~= ","
            else
                ret ~= "]"
            endif
        endloop
    endif
    return ret
end function

### ------------------------------------------------------------------------

function string build_URL_mid(const bundle spec)
    string ret = ""
    if nelem(spec) == 0
        return ret
    endif

    ret = "dimensions={"
    strings filters = array()
    # strings dims = defarray("freq", "indicator", "geo")
    strings dims = getkeys(spec)
    n = 0
    loop i = 1..nelem(dims) --quiet
        s = make_dimensions(spec, dims[i])
        if strlen(s) > 0
            n++
            filters = filters + defarray(s)
        endif
    endloop

    loop i = 1..n --quiet
        ret ~= filters[i]
        if i < n
            ret ~= ", "
        endif
    endloop

    ret = ret ~ "}&"
    return ret
end function

### ------------------------------------------------------------------------

function string build_parms(const string pcode, const string dcode,
      int limit[0::20], int offset[0],
      bundle spec)
    string head = sprintf("series?provider_code=%s&dataset_code=%s&",
      pcode, dcode)
    string mid = build_URL_mid(spec)
    string tail = sprintf("limit=%d&offset=%d&format=json", limit, offset)
    ret = head ~ sanitize_url(mid) ~ tail
    return ret
end function

### ------------------------------------------------------------------------

# This is tricky: we may not get a recognizable error code,
  # or even an error message, on failure to retrieve any data.

function scalar bad_json (const string s, string *msg)
    ret = 0
    if instring(s, "404 Error") || instring(s, "404 Not Found")
        ret = 404
    elif instring(s, "400 Bad Request")
        ret = 400
    endif
    got = 0
    msg = jsonget(s, "$.error_description", &got)
    if !got
        msg = jsonget(s, "$.warnings", &got)
    endif
    if ret == 0 && got
        ret = got
    endif
    return ret
end function

### ------------------------------------------------------------------------

function scalar dbn_get_json (const string parms, bool verbose[0],
      string *json)

    string URL = "https://api.next.nomics.world/" ~ parms
    if verbose
        printf "URL = '%s'\n", URL
    endif
    bundle req = defbundle("URL", URL, "header", "accept: application/json")
    # check for curl error
    scalar error = curl(&req)

    string msg
    if error
        msg = req.errmsg
    else
        # also check for dbnomics error condition
        json = req.output
        dbg = ngetenv("DBNOMICS_DEBUG")
        if ok(dbg) && dbg > 0
            outfile dbn_debug.json --write --quiet
            json
            outfile --close
        endif
        string dbnmsg
        error = bad_json(json, &dbnmsg)
        if error
            msg = sprintf("error message from dbnomics:\n\"%s\"\n", dbnmsg)
        endif
    endif

    if error
        if msg == ""
            msg = "Failed to get the requested information from dbnomics"
        endif
        funcerr msg
    endif

    return error
end function

### ------------------------------------------------------------------------

function bundles general_search(const string key, int limit[0::100],
      int offset[0], bool verbose[0])

    magic = "results.docs"
    bundles ret = null

    string json
    parms = sprintf("search?q=%s&limit=%d&offset=%d", sanitize_url(key),
      limit, offset)
    err = dbn_get_json(parms, 0, &json)
    if err
        return ret
    endif

    n = 0
    str = jsonget(json, sprintf("$.%s[*].code", magic), &n)
    ntot = atof(jsonget(json, "$.results.num_found"))

    #printf "n = %d, ntot = %d\n", n, ntot

    if n == 0
        if verbose
            printf "No matches found"
        endif
        return ret
    endif

    bundles ret = array(n)
    strings fields = defarray("code", "nb_matching_series", "name", \
      "provider_code")
    loop i = 1..n --quiet
        ret[i] = json2bndl(fields, json, magic, i-1)
        ret[i].ntot = ntot
    endloop

    if verbose
        printf "Datasets containing \"%s\" (%d-%d out of %d): \n\n",
          key, offset+1, offset+n, ntot
        loop i = 1..n --quiet
            printf "%3d: %s.%s", i, ret[i].provider_code, ret[i].code
            printf " (%d series)\n", atof(ret[i].nb_matching_series)
        endloop
    endif

    return ret
end function

### ------------------------------------------------------------------------

function bundles dset_search(const string key, const string pcode,
      const string dcode, int limit[0::100],
      int offset[0], bool verbose[0])

    bundles ret = null
    string json
    parms = sprintf("%s/%s/series?q=%s&limit=%d&offset=%d", pcode, dcode,
      sanitize_url(key),limit, offset)

    err = dbn_get_json(parms, 0, &json)

    if !err
        bundle bj = jsongetb(json)
        ret = bj["series"].docs
        tot = bj["series"].num_found

        if verbose
            got = nelem(ret)
            if got > 0
                printf "listing series %d - %d out of %d\n",
                  offset+1, offset+got, tot
                loop i = 1 .. got --quiet
                    bundle desc_i = ret[i]
                    printf "%s - %s\n", desc_i.code, desc_i.name
                endloop
            else
                printf "no series found\n"
            endif
        endif
    endif

    return ret
end function
