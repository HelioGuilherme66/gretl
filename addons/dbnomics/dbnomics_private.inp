function bundle json2bndl(const strings fields, const string jsonobj,
      const string root, int ndx)
    bundle b = null
    k = 0
    loop j = 1..nelem(fields) --quiet
        f = fields[j]
        src = sprintf("$.%s[%d].%s", root, ndx, f)
        str = jsonget(jsonobj, src, &k)
        if k
            b[f] = str
        endif
    endloop
    return b
end function

### ------------------------------------------------------------------------

function string sanitize_url(const string s)
    ret = strsub(s, " ", "%20")
    ret = strsub(ret, sprintf("\""), "%22")
    ret = strsub(ret, ",", "%2C")
    ret = strsub(ret, ":", "%3A")
    ret = strsub(ret, "{", "%7B")
    ret = strsub(ret, "}", "%7D")
    ret = strsub(ret, "[", "%5B")
    ret = strsub(ret, "]", "%5D")
    return ret
end function

### ------------------------------------------------------------------------

function scalar get_frequency(const string json_obj)
    strings alternatives = defarray(".Frequency", ".FREQ", "['@frequency']")
    got = 0
    loop i=1..nelem(alternatives) --quiet
        s = sprintf("$.series.data[0]%s", alternatives[i])
        frq = jsonget(json_obj, s, &got)
        if got
            frq = tolower(frq[1])
            break
        endif
    endloop

    scalar ret = NA

    if got
        if frq == "a"
            scalar ret = 1
        elif frq == "q"
            scalar ret = 4
        elif frq == "m"
            scalar ret = 12
        elif frq == "d"
            scalar ret = 7
        else
            printf "frq = \"%s\" unrecognized\n", frq
            scalar ret = -1
        endif
    endif

    return ret
end function

### ------------------------------------------------------------------------

function scalar fill_series_bundle(bundle *b, const string json, int idx)
    got = 0
    istr = (idx == 0) ? "" : sprintf("[%d]", idx-1) # zero-based

    b.frequency = get_frequency(json)
    qry = sprintf("$.series.data%s.dataset_name", istr)
    b.dset_name = jsonget(json, qry)
    # qry = sprintf("$.series.data%s..Unit", istr)
    qry = sprintf("$.series.data%s.Unit", istr)
    tmp = jsonget(json, qry, &got)
    if got
        b.unit = tmp
    endif
    qry = sprintf("$.series.data%s.series_name", istr)
    tmp = jsonget(json, qry, &got)
    if got
        b.series_name = tmp
    endif

    string line

    qry = sprintf("$.series.data%s..period", istr)
    s = jsonget(json, qry)

    strings periods
    loop while getline(s, line) -q
        periods += line
    endloop
    n = nelem(periods)

    qry = sprintf("$.series.data%s..value", istr)
    s = jsonget(json, qry)
    strings datavals
    loop while getline(s, line) -q
        datavals += line
    endloop

    # skip any leading blank data rows
    istart = 1
    loop i=1..n -q
        if datavals[i] == "" || datavals[i] == "NA"
            istart++
        else
            break
        endif
    endloop

    b.totobs = n
    b.start = istart
    actobs = n - istart + 1
    b.actobs = actobs
    b.has_data = (actobs > 0)

    if b.has_data
        b.vals = zeros(actobs,1)
        strings b.periods = array(actobs)
        scalar j = 1
        loop i=istart..n -q
            b.vals[j] = atof(datavals[i])
            b.periods[j] = periods[i]
            j++
        endloop
    endif

    return 0
end function

### ------------------------------------------------------------------------

function string make_dimensions(const bundle spec, const string what)
    ret = ""
    if inbundle(spec, what)
        strings ss = spec[what]
        ret ~= sprintf("\"%s\":[", what)
        loop i = 1 .. nelem(ss) --quiet
            ret ~= sprintf("\"%s\"", ss[i])
            if i < nelem(ss)
                ret ~= ","
            else
                ret ~= "]"
            endif
        endloop
    endif
    return ret
end function

### ------------------------------------------------------------------------

function string build_URL_mid(const bundle spec)
    string ret = ""
    if nelem(spec) == 0
        return ret
    endif

    ret = "dimensions={"
    strings filters = array()
    # strings dims = defarray("freq", "indicator", "geo")
    strings dims = getkeys(spec)
    n = 0
    loop i = 1..nelem(dims) --quiet
        s = make_dimensions(spec, dims[i])
        if strlen(s) > 0
            n++
            filters = filters + defarray(s)
        endif
    endloop

    loop i = 1..n --quiet
        ret ~= filters[i]
        if i < n
            ret ~= ", "
        endif
    endloop

    ret = ret ~ "}&"
    return ret
end function

### ------------------------------------------------------------------------

function string build_parms(const string pcode, const string dcode,
      int limit[0::20], int offset[0],
      bundle spec)
    string head = sprintf("series?provider_code=%s&dataset_code=%s&",
      pcode, dcode)
    string mid = build_URL_mid(spec)
    string tail = sprintf("limit=%d&offset=%d&format=json", limit, offset)
    ret = head ~ sanitize_url(mid) ~ tail
    return ret
end function

### ------------------------------------------------------------------------

# This is tricky: we may not get a recognizable error code,
  # or even an error message, on failure to retrieve any data.

function scalar bad_json (const string s, string *msg)
    ret = 0
    if instring(s, "404 Error") || instring(s, "404 Not Found")
        ret = 404
    elif instring(s, "400 Bad Request")
        ret = 400
    endif
    got = 0
    msg = jsonget(s, "$.error_description", &got)
    if !got
        msg = jsonget(s, "$.warnings", &got)
    endif
    if ret == 0 && got
        ret = got
    endif
    return ret
end function

### ------------------------------------------------------------------------

function scalar dbn_get_json (const string parms, bool verbose[0],
			      string *json, string *msg[null])
    
    string URL = "https://api.next.nomics.world/" ~ parms
    if verbose
        printf "URL = '%s'\n", URL
    endif
    bundle req = defbundle("URL", URL, "header", "accept: application/json")
    # check for curl error
    scalar error = curl(&req)

    if error
        string mymsg = req.errmsg
    else
        # also check for dbnomics error condition
        json = req.output
        string dbnmsg
        error = bad_json(json, &dbnmsg)
        if error
            string mymsg = sprintf("error message from dbnomics:\n\"%s\"\n", dbnmsg)
        endif
    endif
    
    if error
        printf "%s", mymsg
        if exists(msg)
            msg = mymsg
        endif
    endif
    
    return error
end function
