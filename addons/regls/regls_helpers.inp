# get MSE and R^2

function matrix regls_get_stats (const numeric y, const numeric yhat)
   if typeof(y) == 2 # series
      scalar SSR = sum((y - yhat)^2)
      scalar n = $nobs
   else # must be matrix
      scalar SSR = sumc((y - yhat).^2)
      scalar n = nelem(y)
   endif
   matrix ret = {SSR/n, 1 - SSR/sst(y)}
   cnameset(ret, "MSE R^2")
   return ret
end function

function scalar regls_pc_correct (const numeric y, const numeric yhat)
   if typeof(y) == 2 # series
      series yr = round(yhat)
      return 100 * sum(yr == y) / $nobs
   else # must be matrix
      matrix yr = round(yhat)
      return 100 * sum(yr .= y) / rows(y)
   endif
end function

# get prediction from glmnet, plus non-zero coeff vector

function series glmnet_pred (matrix *Rb, list X)
   matrix sel = Rb .!= 0
   Rb = selifr(Rb, sel)
   matrix mRX = X
   list RX = selifr(mRX', sel)
   rnameset(Rb, varnames(RX))
   return lincomb(RX, Rb)
end function

# construct a fixed folds vector for use with glmnet

function matrix regls_foldvec (int nobs, int nf)
   matrix foldvec = zeros(nobs, 1)
   scalar fsize = nobs / nf
   scalar r = 1
   loop i=1..nf -q
      foldvec[r:r+fsize-1] = i
      r += fsize
   endloop
   return foldvec
end function

# print summary statistics when multiple lambda values are used

function void regls_multiprint (const matrix B, const matrix lambda,
                                const series y, list X,
                                const matrix crit[null])

   if exists(crit)
      printf "\n       lambda     R^2    sum(|b|)   df   criterion\n"
   else
      printf "\n       lambda     R^2    sum(|b|)   df\n"
   endif
   scalar haveconst = 0
   if rows(B) == nelem(X) + 1
      haveconst = 1
   elif rows(B) != nelem(X)
      funcerr "B and X are not conformable"
   endif
   loop i=1..cols(B) -q
      if haveconst
         matrix bi = B[2:,i]
         series yhat = lincomb(X, bi) + B[1,i]
      else
         matrix bi = B[,i]
         series yhat = lincomb(X, bi)
      endif
      scalar l1 = sumc(abs(bi))
      scalar df = sumc(bi .!= 0)
      m = regls_get_stats(y, yhat)
      R2 = m[2]
      if R2 < 0 && R2 > -1.0e16
         # avoid printing -0.0000
         R2 = 0
      endif
      if exists(crit)
         printf "%#13g  %.4f  %#10g  %3d  %#10g\n", lambda[i], R2, l1, df, crit[i]
      else
         printf "%#13g  %.4f  %#10g  %3d\n", lambda[i], R2, l1, df
      endif
   endloop
   printf "\n"
end function

function void mregls_multiprint (const matrix B, const matrix lambda,
                                 const matrix y, const matrix X,
                                 const matrix crit[null])
   if exists(crit)
      printf "\n       lambda     R^2    sum(|b|)   df   criterion\n"
   else
      printf "\n       lambda     R^2    sum(|b|)   df\n"
   endif
   scalar haveconst = 0
   if rows(B) == cols(X) + 1
      haveconst = 1
   elif rows(B) != cols(X)
      funcerr "B and X are not conformable"
   endif
   loop i=1..cols(B) -q
      if haveconst
         matrix bi = B[2:,i]
         matrix yhat = X * bi + B[1,i]
      else
         matrix bi = B[,i]
         matrix yhat = X * bi
      endif
      scalar l1 = sumc(abs(bi))
      scalar df = sumc(bi .!= 0)
      m = regls_get_stats(y, yhat)
      R2 = m[2]
      if R2 < 0 && R2 > -1.0e16
         # avoid printing -0.0000
         R2 = 0
      endif
      if exists(crit)
         printf "%#13g  %.4f  %#10g  %3d  %#10g\n", lambda[i], R2, l1, df, crit[i]
      else
         printf "%#13g  %.4f  %#10g  %3d\n", lambda[i], R2, l1, df
      endif
   endloop
   printf "\n"
end function

# compute fitted values

function series regls_pred (const bundle rb, list X)
   series yhat
   if inbundle(rb, "nzX")
      yhat = lincomb(rb.nzX, rb.nzb)
   else
      matrix b = inbundle(rb, "b") ? rb.b : rb.B
      if rb.stdize
         X = const X
      endif
      yhat = lincomb(X, b)
   endif
   return yhat
end function

function matrix mregls_pred (const bundle mb, const matrix X)
   matrix yhat
   if inbundle(mb, "nzX")
      if mb.stdize
         yhat = X[,mb.nzX] * mb.nzb[2:] + mb.nzb[1]
      else
         yhat = X[,mb.nzX] * mb.nzb
      endif
   else
      matrix b = inbundle(mb, "b") ? mb.b : mb.B
      if mb.stdize
         yhat = X * b[2:] + b[1]
      else
         yhat = X * b
      endif
   endif
   return yhat
end function

# report training-data R-squared after cross validation

function void training_R2 (bundle *b, series y, list X)
   series yhat = regls_pred(b, X)
   matrix m = regls_get_stats(y, yhat)
   printf "training data R-squared = %.4f\n\n", m[2]
   b.training_R2 = m[2]
end function

function void mregls_training_R2 (bundle *b,
                                  const matrix y,
                                  const matrix X)
   matrix yhat = mregls_pred(b, X)
   matrix m = regls_get_stats(y, yhat)
   printf "training data R-squared = %.4f\n\n", m[2]
   b.training_R2 = m[2]
end function
