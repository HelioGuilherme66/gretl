# extra_withdata.inp
# All extra functions that take some actual data (series, lists).

# index:
# gap_filler
# lin_int (private helper)
# winsor
# correspondence
# fracorder
# mat2list

function series gap_filler (series x "Series to fill",
                            int method[0:2:2] "Fill method" {"Don't", "Repetition", "Linear interpolation"})
    errorif($datatype < 2, "This function can only be used with time series or panel datasets")
    string lbl = argname(x)

    if method == 0 # do nothing
        series ret = x
    elif method == 1 # get previous value
	series tt = time
	series OK = ok(x)

	if $datatype == 2
            outside = tt > max(OK ? tt : -1)
	elif $datatype == 3
            outside = tt > pmax(OK ? tt : -1)
	endif

	series ret = x
	series ret = OK ? x : outside ? NA : ret(-1)
        string lbl = sprintf("gap-filled version of %s (with repetition)", argname(x))
        setinfo ret --description="@lbl"

    elif method == 2 # interpolate linearly
        series ret = interpol(x)
        string lbl = sprintf("gap-filled version of %s (with interpolation)", argname(x))
        setinfo ret --description="@lbl"
    endif

    return ret
end function

##############################

function series winsor (series x,
                        scalar p[0:1:0.05],
                        scalar phi[0:1:0])
    # phi (as in p-high) is optional and defines an upper tail mass
    #  different from lower (the default phi == 0 means ignore)
    #
    # This is a rewrite of the function in the winsor.gfn package
    # (originally by JoshuaHe2015@163.com)

    smpl --no-missing x

    # standard symmetric or asymmetric case?
    phi = !phi ? 1 - p : phi
    # determine bounds
    matrix lowhi = quantile({x}, {p, phi})
    # lower end (and address non-existing extreme quantiles)
    scalar low = ok(lowhi[1]) ? lowhi[1] : min(x)
    x = (x < low) ? low : x
    # upper end
    scalar hi = ok(lowhi[2]) ? lowhi[2] : max(x)
    x = (x > hi) ? hi : x

    # prepare output
    string label = sprintf("winsorized %s (%g,%g)", argname(x), p, phi)
    setinfo x --description="@label"

    return x
end function

#######################

function scalar correspondence (series x, series y)
    # This function takes two series and establishes if there's a
    # 1-to-1 relationship between them, in which case it returns 2.
    # If there's a 1-to-n relationship, it returns 1. If there's
    # no relationship, it returns 0.

    # recode values so as to ensure we only get integer values
    matrix v = values(y)
    y = replace(y, v, seq(1,rows(v)))
    matrix v = values(x)
    x = replace(x, v, seq(1,rows(v)))

    matrix H = mxtab(x, y) .> 0
    is_a_function = maxr(sumc(H)) == 1
    is_1_to_1 = maxc(sumr(H)) == 1

    if is_a_function
        ret = is_1_to_1 ? 2 : 1
    else
        ret = 0
    endif

    return ret
end function

######################

function matrix fracorder (const series x, int order[0::0], bool verbosity[0])
    # order == 0 means to leave gretl's default;
    # Applies all available estimators in gretl:
    # - Local Whittle
    # - Geweke Porter-Hudak
    # - Hurst (exponent minus 0.5)
    # (also note the generalized Hurst contributed function package)
    # This function requires gretl 2020c.

    # translate the wanted order and whether to have printouts
    string sorder = !order    ? "" : sprintf("%d", order)
    string sverb  = verbosity ? "" : "--quiet"

    # Local Whittle and Geweke Porter-Hudak
    fractint x @sorder @sverb
    # point, se, teststat, pv
    matrix LocWhit    = vec($result)' ~ $test ~ $pvalue
    fractint x @sorder --gph @sverb
    matrix GewPorthud = vec($result)' ~ $test ~ $pvalue

    # Hurst
    matrix Hurst = mshape(NA, 1, 4)
    if $nobs < 128 && verbosity
        print "Warning: not enough obs for Hurst, leaving result row as NA."
    elif $nobs >= 128
        if verbosity
            hurst x --plot=none
        else
            outfile null    # workaround for the missing quiet option of hurst
                hurst x --plot=none
            end outfile     # This is in >=2018b, so OK here.
        endif
        # shifted to be comparable to d
        Hurst[1:2] = ($result[1] - 0.5) ~ $result[2]
    endif

    matrix ret = LocWhit | GewPorthud | Hurst
    cnameset(ret, "estim SE teststat pval") # is in >= 2018a
    rnameset(ret, "LocalWh GPH Hurst")

    return ret
end function
