set verbose off
clear

# include "../extra.inp" --force
# This won't work with the package extra.gfn, as it uses private functions.
# So you need to run extra.inp manually to have all the functions available.

print "Start with bundle2json()"

bundle bin = null
scalar bin.scalar_1 = 2.4
scalar bin.scalar_2 = -3.9
scalar bin.int_1 = 0
scalar bin.int_2 = -3
scalar bin.int_3 = 2
scalar bin.int_4 = NA
string sout = bundle2json(bin)
if strlen(sout) == 0
    stop
endif
if instring(sout, "int_1") != 1 || instring(sout, "int_2") != 1 || \
      instring(sout, "int_3") != 1 || instring(sout, "int_4") != 1 || \
      instring(sout, "scalar_1") != 1 || instring(sout, "scalar_2") != 1
    stop
endif
catch string sout = jsonget(sout, "$.int_4")
if $error == 0
    printf "\nInfo: jsonget() now seems to handle 'null' values. Adapt test!\n"
endif
if atof(jsonget(sout, "$.int_1")) != 0 || atof(jsonget(sout, "$.int_2")) != -3 || \
      atof(jsonget(sout, "$.int_3")) != 2 || \
  atof(jsonget(sout, "$.scalar_1")) != 2.4 || atof(jsonget(sout, "$.scalar_2")) != -3.9
  #|| nelem(jsonget(sout, "$.int_4")) != 0
    stop
endif


bundle bin = null
scalar bin.scalar_1 = 2.4
scalar bin.int_1 = -3
string bin.str_1 = "foo"
string bin.str_2 = "_foo"
string bin.str_3 = ""
string bin.str_4 = " "
string sout = bundle2json(bin)
if strlen(sout) == 0
    stop
endif
if instring(sout, "int_1") != 1 || instring(sout, "scalar_1") != 1 || \
      instring(sout, "str_1") != 1 || instring(sout, "str_2") != 1 || \
      instring(sout, "str_3") != 1 || instring(sout, "str_4") != 1
    stop
endif
if atof(jsonget(sout, "$.int_1")) != -3 || atof(jsonget(sout, "$.scalar_1")) != 2.4 || \
      jsonget(sout, "$.str_1") != "foo" || jsonget(sout, "$.str_2") != "_foo" || \
      jsonget(sout, "$.str_3") != "" || jsonget(sout, "$.str_4") != " "
    stop
endif



printf "\nInfo: All tests passed.\n"
stop


# FIXME: Tests for series and matrices are still experimental!
# FIXME: It seems that gretl (or rather json-glib) does not handle list-of-lists
# as matrices or series as gretl would do. hence, trying to read arrays for testing
# via jsonget() or jsongetb() is currently tricky

# with series
nulldata 4
series ser_1 = seq(1,4)'
series ser_2 = NA

bundle bin = null
scalar bin.scalar_1 = 2.4
scalar bin.int_1 = -3
string bin.str_1 = "foo"
string bin.str_2 = "_foo"
series bin.ser_1 = ser_1
series bin.ser_2 = ser_2
string sout = bundle2json(bin)
if strlen(sout) == 0
    stop
endif
if instring(sout, "int_1") != 1 || instring(sout, "scalar_1") != 1 || \
      instring(sout, "str_1") != 1 || instring(sout, "str_2") != 1 || \
      instring(sout, "ser_1") != 1 || instring(sout, "ser_2") != 1
    stop
endif
if atof(jsonget(sout, "$.int_1")) != -3 || atof(jsonget(sout, "$.scalar_1")) != 2.4 || \
  jsonget(sout, "$.str_1") != "foo" || jsonget(sout, "$.str_2") != "_foo"
    stop
endif

matrix m = {}
sscanf(jsonget(sout, "$.ser_1"), "%m", m)
print m
eval jsonget(sout, "$.ser_1")

bundle bout = jsongetb(sout)
eval bout.ser_1
matrix m = {}
sscanf(bout.ser_1, "%m", m)
print m


string str = "{'d': [1,null,4, 'Inf']}"		# works with jsongetb()
string str = "{'d': [1,'null',4, 'Inf']}"	# works with jsongetb() and jsonget()
string str = "{'d': [2,[],4, 'Inf']}"		# works with jsongetb()
string str = "{'d': [1,'NaN',4, 'Inf']}"	# works with jsongetb() and jsonget()
#string str = "{'d': [[1,null,4],[1,null,4]]}"
#string str = "{'d': [[1],['null'],[4]]}"		# does not work
# string str = "{'d': [[1],[null],[4]]}"		# does not work
str
eval jsonget(str, "$.d")
bundle bout = jsongetb(str)
matrix m = {}
sscanf(bout.d, "%m", m)
print m



# with matrix instead of series
bundle bin = null
scalar bin.scalar_1 = 2.4
scalar bin.int_1 = -3
string bin.str_1 = "foo"
string bin.str_2 = "_foo"
matrix bin.mat_1 = mshape(seq(1,4),2,2)
matrix bin.mat_2 = {}
string sout = bundle2json(bin)
if strlen(sout) == 0
    stop
endif
if instring(sout, "int_1") != 1 || instring(sout, "scalar_1") != 1 || \
      instring(sout, "str_1") != 1 || instring(sout, "str_2") != 1 || \
      instring(sout, "mat_1") != 1 || instring(sout, "mat_2") != 1
    stop
endif
if atof(jsonget(sout, "$.int_1")) != -3 || atof(jsonget(sout, "$.scalar_1")) != 2.4 || \
  jsonget(sout, "$.str_1") != "foo" || jsonget(sout, "$.str_2") != "_foo"
    stop
endif

# Let's have a look at matrices
eval jsonget(sout, "$.mat_1")		# shows only first column values
eval jsonget(sout, "$.mat_2")		# empty

# Put "sout" into a bundle
bundle bout = jsongetb(sout)
print bout
eval bout.mat_1			# array of dim-2 but only null-values
eval bout.mat_2			# array of dim-0


# make use of sscanf to cast from string to numerical
matrix m = {}
sscanf(jsonget(sout, "$.mat_1"), "%m", m)
print m

matrix m2 = {}
sscanf(jsonget(sout, "$.mat_2"), "%m", m2)
print m2


printf "\nInfo: All tests passed.\n"
