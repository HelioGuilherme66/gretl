set verbose off
clear

string WD = "/home/at/git/gretl-git/addons/extra"

set workdir @WD
include "extra.inp" --force


print "Start with bundle2json()"

bundle bin = null
scalar bin.scalar_1 = 2.4
scalar bin.scalar_2 = -3.9
scalar bin.int_1 = 0
scalar bin.int_2 = -3
scalar bin.int_3 = 2
scalar bin.int_4 = NA		# FIXME: fails to be read by jsonget(sout, "$.int_4") -> replace "NA" by "[]"
string sout = bundle2json(bin)
if strlen(sout) == 0
    stop
endif
if instring(sout, "int_1") != 1 || instring(sout, "int_2") != 1 || \
      instring(sout, "int_3") != 1 || instring(sout, "int_4") != 1 || \
      instring(sout, "scalar_1") != 1 || instring(sout, "scalar_2") != 1
    stop
endif

if atof(jsonget(sout, "$.int_1")) != 0 || atof(jsonget(sout, "$.int_2")) != -3 || \
      atof(jsonget(sout, "$.int_3")) != 2 || nelem(jsonget(sout, "$.int_4")) != 0 || \
      atof(jsonget(sout, "$.scalar_1")) != 2.4 || atof(jsonget(sout, "$.scalar_2")) != -3.9
    stop
endif


bundle bin = null
scalar bin.scalar_1 = 2.4
scalar bin.int_1 = -3
string bin.str_1 = "foo"
string bin.str_2 = "_foo"
string bin.str_3 = ""
string bin.str_4 = " "
string sout = bundle2json(bin)
if strlen(sout) == 0
    stop
endif
if instring(sout, "int_1") != 1 || instring(sout, "scalar_1") != 1 || \
      instring(sout, "str_1") != 1 || instring(sout, "str_2") != 1 || \
      instring(sout, "str_3") != 1 || instring(sout, "str_4") != 1
    stop
endif
if atof(jsonget(sout, "$.int_1")) != -3 || atof(jsonget(sout, "$.scalar_1")) != 2.4 || \
      jsonget(sout, "$.str_1") != "foo" || jsonget(sout, "$.str_2") != "_foo" || \
      jsonget(sout, "$.str_3") != "" || jsonget(sout, "$.str_4") != " "
    stop
endif




printf "\nInfo: All tests passed.\n"
stop


# FIXME: Tests for series and matrices are still experimental!
# FIXME: It seems that gretl (or rather json-glib) does not handle list-of-lists
# as matrices or series as gretl would do. hence, trying to read arrays for testing
# via jsonget() or jsongetb() is currently tricky

# with series
nulldata 4
series ser_1 = seq(1,4)'
series ser_2 = NA

bundle bin = null
scalar bin.scalar_1 = 2.4
scalar bin.int_1 = -3
string bin.str_1 = "foo"
string bin.str_2 = "_foo"
series bin.ser_1 = ser_1
series bin.ser_2 = ser_2
string sout = bundle2json(bin)
if strlen(sout) == 0
    stop
endif
if instring(sout, "int_1") != 1 || instring(sout, "scalar_1") != 1 || \
      instring(sout, "str_1") != 1 || instring(sout, "str_2") != 1 || \
      instring(sout, "ser_1") != 1 || instring(sout, "ser_2") != 1
    stop
endif
if atof(jsonget(sout, "$.int_1")) != -3 || atof(jsonget(sout, "$.scalar_1")) != 2.4 || \
  jsonget(sout, "$.str_1") != "foo" || jsonget(sout, "$.str_2") != "_foo"
    stop
endif


# with matrix instead of series
bundle bin = null
scalar bin.scalar_1 = 2.4
scalar bin.int_1 = -3
string bin.str_1 = "foo"
string bin.str_2 = "_foo"
matrix bin.mat_1 = mshape(seq(1,4),2,2)
matrix bin.mat_2 = {}
string sout = bundle2json(bin)
if strlen(sout) == 0
    stop
endif
if instring(sout, "int_1") != 1 || instring(sout, "scalar_1") != 1 || \
      instring(sout, "str_1") != 1 || instring(sout, "str_2") != 1 || \
      instring(sout, "mat_1") != 1 || instring(sout, "mat_2") != 1
    stop
endif
if atof(jsonget(sout, "$.int_1")) != -3 || atof(jsonget(sout, "$.scalar_1")) != 2.4 || \
  jsonget(sout, "$.str_1") != "foo" || jsonget(sout, "$.str_2") != "_foo"
    stop
endif

# Let's have a look at matrices
eval jsonget(sout, "$.mat_1")		# shows only first column values
eval jsonget(sout, "$.mat_2")		# empty

# Put "sout" into a bundle
bundle bout = jsongetb(sout)
print bout
eval bout.mat_1			# array of dim-2 but only null-values
eval bout.mat_2			# array of dim-0


# make use of sscanf to cast from string to numerical
matrix m = {}
sscanf(jsonget(sout, "$.mat_1"), "%m", m)
print m

matrix m2 = {}
sscanf(jsonget(sout, "$.mat_2"), "%m", m2)
print m2















printf "\nInfo: All tests passed.\n"
