function scalar is_standard_AB(matrix aRd, matrix bRd)
    test = has_unit_diag(aRd) && has_free_diag(bRd)
    return test
end function

function void scoreAB(matrix *ret, matrix *theta, matrix *dat, int p1)
  matrix Sigma Ss A B 
  unscramble_dat(&dat, &Sigma, &Ss)

  p2 = rows(theta)
  matrix aSs = Ss[,1:p1+1]
  matrix bSs = Ss[,p1+2:p2+2]

  n = rows(Sigma)
  ABmat_exp(theta, aSs, bSs, &A, &B)
  matrix iA = inv(A)
  matrix C = iA*B

  if p1>0
    matrix S = aSs[,1:p1] 
    S = -((C') ** iA) * S
  else
    matrix S = {}
  endif

  if p2>p1
    S ~= bSs[,1:cols(bSs)-1]
  endif

  matrix iC = inv(C)
  matrix ret = iC' (qform(iC,Sigma) - I(n))

  ret = vec(ret)'S
end function

function matrix stdAB_init(matrix mX, matrix aRd, matrix bRd)
  # mX should contain the VAR residuals
  matrix aSs = imp2exp(aRd)
  matrix bSs = imp2exp(bRd)
  n = cols(mX)
  p = cols(aSs) - 1

  if p > 0
    matrix S = aSs[,1:p]
    matrix s = aSs[,p+1]

    matrix sel = vec(transp(mshape(seq(1,n*n),n,n)))
    matrix dep = vec(mX)
    matrix reg = (I(n) ** mX)*S[sel,]
    matrix e 
    matrix b = -mols(dep, reg, &e)
    e = mshape(e, rows(mX), n)
    e = sqrt(meanc(e.^2))'
    S = bSs[,1:cols(bSs)-1]
    sel = 1 + seq(0,n-1)*(n+1)
    matrix a = zeros(n*n,1)
    a[sel] = e
    e = S'a
    matrix ret = b | e
  else
    matrix Sigma = (mX'mX) / rows(mX)
    matrix ret = init_C(0, Sigma, bRd)
  endif

  return ret
end function

function matrix nonstdAB_init(matrix E, matrix aRd, matrix bRd)

  matrix aSs = imp2exp(aRd)
  matrix bSs = imp2exp(bRd)
  T = rows(E)
  n = cols(E)
  matrix Sigma = (E'E)./T  
  matrix C = cholesky(Sigma)  

  startA = (rows(aRd) > rows(bRd))
  #startA = 1 # provisional  

  ka = cols(aSs) - 1
  if ka>0
    matrix Sa = aSs[,1:ka]
  endif
  matrix sa = aSs[,ka+1]
      
  kb = cols(bSs) - 1
  if kb>0
    matrix Sb = bSs[,1:kb]
  endif
  matrix sb = bSs[,kb+1]

  if startA = 1
    matrix giSb = invpd(Sb'Sb)*Sb'
    matrix tmp = giSb*(C' ** I(n))
    if ka>0
      matrix giSa = invpd(Sa'Sa)*Sa'
      matrix gama = 0.1*ones(ka,1)
      matrix gamb = tmp * (Sa*gama + sa) - giSb*sb
      tmp = giSa*(inv(C)' ** I(n))
      gama = tmp * (Sb*gamb + sb) - giSa*sa
    else
      matrix gama = {}
      matrix gamb = tmp*sa - Sb'sb
    endif
  else
    matrix giSa = invpd(Sa'Sa)*Sa'
    matrix tmp = giSa*(inv(C)' ** I(n))
    if kb>0
      matrix giSb = invpd(Sb'Sb)*Sb'
      matrix gamb = 0.1*ones(kb,1)
      matrix gama = tmp * (Sb*gamb + sb) - giSa*sa
      tmp = giSb*(C' ** I(n))
      gamb = tmp * (Sa*gama + sa) - giSb*sb
    else
      matrix gama = tmp*sb - Sa'sa
      matrix gamb = {}
    endif
  endif


  if kb > 0
    scale = tr(Sigma) / tr(C*C')
    printf "nonstdAB_init: Scale = %g\n", scale 
    gamb = sqrt(scale) .* gamb
    /*
       elif ka>0
       scalar scale = tr(Sigma) / tr(C*C')
       printf "nonstdAB_init: Scale = %g\n", scale 
       gama = sqrt(scale) ./ gama
    */
  endif

  matrix ret = gama | gamb

  return ret
end function

/*
not needed anymore, just called once (?):

function matrix init_AB(matrix E, matrix aRd, matrix bRd)
    # E: VAR residuals
  matrix ret = is_standard_AB(aRd, bRd) ? \
      stdAB_init(E, aRd, bRd) : nonstdAB_init(E, aRd, bRd)
  #if is_standard_AB(aRd, bRd)
  #  matrix ret = stdAB_init(E, aRd, bRd)
  #else
  #  matrix ret = nonstdAB_init(E, aRd, bRd)
  #endif

  return ret
end function
*/

function void ABmat_exp(matrix theta, matrix aSs, matrix bSs,
			    matrix *A, matrix *B)
  scalar p1 = cols(aSs) - 1
  scalar p2 = rows(theta)

  matrix theta_a = (p1>0) ? theta[1:p1]: {} 
  matrix A = mat_exp(theta_a, aSs)

  matrix theta_b = (p2>p1) ? theta[p1+1:p2] : {}
  matrix B = mat_exp(theta_b, bSs, 1)
end function

function void PseudoHessAB(matrix *H, matrix *theta, matrix *dat, int p1)
  matrix Sigma Ss A B 
  unscramble_dat(&dat, &Sigma, &Ss)

  scalar p2 = rows(theta)
  matrix aSs = Ss[,1:p1+1]
  matrix bSs = Ss[,p1+2:p2+2]

  scalar n = rows(Sigma)
  scalar n2 = n*n
  ABmat_exp(theta, aSs, bSs, &A, &B)

  scalar ka = cols(aSs) - 1
  scalar kb = cols(bSs) - 1
  matrix S = zeros(2*n2, ka+kb)  
  if ka>0
    S[1:n2,1:ka] = aSs[,1:ka]
  endif
  if kb>0
    S[n2+1:,ka+1:ka+kb] = bSs[,1:kb]
  endif

  H = InfoMat(B, S, &A) 
end function

function matrix estAB(matrix *theta, matrix Sigma, matrix aRd, matrix bRd, \
                      matrix *vcv[null], scalar *errcode, int method, \
                      int verbose[1])
  
  matrix aSs  = imp2exp(aRd)
  matrix bSs  = imp2exp(bRd)
  scalar npar = rows(theta)
  scalar n    = rows(Sigma)

  matrix sSig = Sigma

  scalar p1 = cols(aSs) - 1  
  scalar p2 = p1 + cols(bSs) - 1  
  matrix dat = vec(Sigma) ~ aSs ~ bSs

  matrix g H
  if verbose > 1
    set max_verbose 1
  else
    set max_verbose 0
  endif
  scalar err = 0

  if method == 0
    catch scalar ll = BFGSmax(theta, "loglik(&theta, &dat, p1)")
    err = $error
    scoreAB(&g, &theta, &dat, p1)
  elif method == 1
    catch scalar ll = BFGSmax(theta, "loglik(&theta, &dat, p1)", \
    "scoreAB(&g, &theta, &dat, p1)")
    err = $error
  elif method == 2
    catch scalar ll = NRmax(theta, "loglik(&theta, &dat, p1)")
    err = $error
    scoreAB(&g, &theta, &dat, p1)
  elif method == 3
    catch scalar ll = NRmax(theta, "loglik(&theta, &dat, p1)", \
    "scoreAB(&g, &theta, &dat, p1)")
    err = $error
  elif method == 4
    catch scalar ll = NRmax(theta, "loglik(&theta, &dat, p1)", \
    "scoreAB(&g, &theta, &dat, p1)", 
    "PseudoHessAB(&H, &theta, &dat, p1)" )
    err = $error
  endif

  scalar crit = maxr(abs(g))
  scalar warn = (crit > 1.0e-1)

  if err || warn
    C = {}
    errcode = err + 10*warn
    outfile stderr --write
    printf "err = %d; warn = %d; Gradient: %10.6f", err, warn, g
    outfile --close
    return C
  endif

  matrix A B
  ABmat_exp(theta, aSs, bSs, &A, &B)
  
  # use matlab-style "matrix division" for speed and accuracy
  matrix C = A\B 

  if verbose > 1
    printf "Estimated A matrix:\n%12.5f", A
    printf "Estimated B matrix:\n%12.5f", B
    printf "Estimated C matrix:\n%12.5f", C
    printf "Check:\n%12.5f", cholesky(Sigma)
  endif

  return C 
end function

