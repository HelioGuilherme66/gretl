# include extra.gfn # for what was this needed apart from drill?

# For now drill() comes from: include SVAR_compatibility_funcs.inp 
# And the following functions come from include SVAR_signrestr_utils.inp:
#  correspondence, normalize, check_one_irf, check_irfs, check_id;


###
### functions for setting the set constraints
###

function void SVAR_SRfull(bundle *mod,
                          string yname, string sname,  
                          scalar lo[NA], scalar hi[NA],
                          int ini[0::0], int fin[0::0])

    # this function will add to the appropriate element of
    # the bundle "mod" a set of sign restrictions relative
    # to one variable and one shock, organised as a row
    # vector with the following elements; input values are:
    #
    # mod      : the VAR model bundle (in pointer form)
    # yname    : a string with the name of the observable to examine
    # sname    : a string with the shock name
    # lo, hi   : bounds (NA for +- infty)
    # ini, fin : IRF interval to check (0-based)
    #
    # for example, if we assume that a monetary policy shock will
    # impact prices with a negative sign on lags from 0 to 4, then
    # the function call should be
    #
    # SVAR_SRfull(mod, "p", 1, NA, 0, 0, 4)
    #
    # assuming the series for prices is called "p" and that we want
    # our monetary policy shock to come 1st in the ordering (useful for
    # models with sign restrictions on more than one shock)
	
    # (Switched the yname/sname ordering to match SVAR_SRplain; Sven)

    snum = 0
    k = 0

    if !inbundle(mod, "SRest")
        matrix mod.SRest = {}
    endif

    # (this following loop is pretty clumsy - Artur has a function strpos
    #  for this task in his string_utils package...)
    loop i = 1..nelem(mod.snames) --quiet
        if sname == mod.snames[i]
            snum = i
            break
        endif
    endloop

    if snum == 0
        printf "You don't have a shock named %s in your model\n", sname
    endif

    # (same here for the clumsiness...)
    loop i = 1..nelem(mod.Ynames) --quiet
        if yname == mod.Ynames[i]
            k = i
            break
        endif
    endloop

    if k == 0
        printf "Variable %s in not in the model\n", sname
    endif

    if missing(lo) && missing(hi)
        printf "No bounds specified!\n"
    endif

    lo = ok(lo) ? lo : -$huge
    hi = ok(hi) ? hi :  $huge

    if lo > hi
        printf "Invalid bound specified! [%g : %g]\n", lo, hi
    endif

	# Attention: Here the ini and fin inputs are transformed 
    # to 1-based matrix indexing form, not keeping the actual 
    # horizon meaning
    mod.SRest |= {k, lo, hi, ini+1, fin+1, snum}

end function

function void SVAR_SRplain(bundle *mod,
                           string yname,
                           string sname,
                           string what,
                           int length[0::0], int ini[0::0])

    # shorthand for sign restrictions
    scalar hi, lo
    if what == "+"
        hi = NA
        lo = 0
    elif what == "-"
        hi = 0
        lo = NA
    else
        funcerr "invalid restriction"
    endif

    SVAR_SRfull(&mod, yname, sname, lo, hi, ini, ini+length)
end function

function void SVAR_SRexotic(bundle *mod, string chk,
                            int length[0::0], int ini[0::0],
                            bool needs_model[0])

    if !inbundle(mod, "exoticSR")
        strings checks = null
        bundle mod.exoticSR = defbundle("checks", checks, "spans", {},
          "super", {})
    endif

    mod.exoticSR.checks += chk
    # the indexing convention here matches SRfull, +1
    mod.exoticSR.spans = mod.exoticSR.spans | { ini + 1, ini + length + 1 }
    mod.exoticSR.super = mod.exoticSR.super | { needs_model }

end function

###
### other functions
###

function matrices BayesianDraw(const matrix iXX, const matrix B,
                               const matrix Sigma, int T)

    matrix Sigma_draw = iwishart(Sigma*T, T)
    matrix V = Sigma_draw ** iXX
    matrix K = cholesky(V)
    matrix B_draw = vec(B)

    B_draw += K * mnormal(rows(B_draw), 1)
    B_draw = mshape(B_draw, rows(B), cols(B))

    return defarray(B_draw, Sigma_draw)
end function

#-----------------------------------------------------------------

function matrices gen_irfs(bundle b, int h, matrix to_cum)

    # FIXME: So is this meant for actual horizons 0..h-1, or 1..h ??
    # -> Actually it seems to be 0..mod.horizons, so one more than 
    # in the earlier SVAR code => need to adapt 

    matrix B = b.B
    k = b.detterms    # just a number?

    # FIXME: This cumulation spec should be taken from the mod, no?
    any_cumul = nelem(to_cum) > 0

    n = cols(B)
    p = (rows(B) - k) / n # VAR lags
    matrix comp = B[k+1:,]'

    if p > 1
        comp = comp | I(n*(p-1), n*p)
    endif

    matrix K = cholesky(b.Sigma) * b.rot
    matrices ret = array(h)
    ret[1] = K
    matrix tmp = I(rows(comp))
    loop i = 2 .. h --quiet
        tmp = tmp * comp
        matrix irf_i = tmp[1:n,1:n] * K
        if any_cumul
            irf_i[to_cum,] = irf_i[to_cum,] + ret[i-1][to_cum,]
        endif
        ret[i] = irf_i
    endloop

    return ret
end function

# -------------------

function void safetycheck1(const matrix Sigma, const matrix iXX, const matrix B)
    hhh = 10
    matrix V = Sigma ** iXX
    chk = B[1:hhh,1] ~ sqrt(diag(V[1:hhh, 1:hhh]))
    strings pnames = array(hhh)
    loop i = 1..hhh -q
        pnames[i] = sprintf("chk%d", i)
    endloop
    modprint chk pnames
end function 

# -------------------------------

function scalar get_n_exotic(const bundle mod)
    n_exotic = 0
    if inbundle(mod, "exoticSR") 
        n_exotic = nelem(mod.exoticSR.checks)
    endif
    return n_exotic
end function

# ----------------------------------

function void rot_redraw(bundle *b, const bundle mod, bool DO_BAYES, 
                         const matrix B,
                         const matrix iXX )

    if DO_BAYES
        matrices Mats = BayesianDraw(iXX, B, mod.Sigma, b.df)
        b.B = Mats[1]
        b.Sigma = Mats[2]
    endif
    
    matrix b.rot = qrdecomp(mnormal(mod.n, mod.n))

end function 

# -----------------------------------

function matrices prepAis(const bundle mod, const matrix shocks)

    nshocks = rows(shocks)
    matrices Ais = array(nshocks)
    loop i = 1..nshocks --quiet
        matrix Ais[i] = selifr(mod.SRest, mod.SRest[,6] .= shocks[i])
    endloop
    return Ais 
end function 

# -----------------------------------

function matrix get_id_mat (const bundle mod, const matrix shocks,
                            int nshocks, 
                            const matrices irfs, const matrices Ais,
                            bool DO_NORM)

    matrix id_matrix = zeros(nshocks, mod.n)
    loop i = 1..nshocks --quiet
        id_matrix[i,] = check_irfs(irfs, Ais[i])
    endloop

	if DO_NORM
        # printf "Before normalization:\n%6.0f\n", id_matrix
        id_matrix = normalize(id_matrix)
        # printf "After normalization:\n%6.0f\n", id_matrix
    endif

    return id_matrix
end function

# --------------------------------------

function bundles SVAR_setidIRF(bundle mod, int rep, bool DO_BAYES[0],
                               int maxiter[10000])

    # This function draws a random rotations of the Cholesky model
    # until "rep" draws satisfying the sign restrictions have come up.
    # If the DO_BAYES flag is on, the VAR parameters (including Sigma)
    # are resampled too; otherwise, they are kept fixed at the ols
    # estimates.

    #
    # Recover VAR parameters from the model bundle
    #

    matrix B = mod.mu | mod.VARpar'
    scalar horizon = mod.horizon + 1 # original is 0-based

    DO_NORM = 1

    matrix iXX = {}
    if DO_BAYES     # this is only needed for sampling from the posterior
        matrix Data = (mod.X ~ lags(mod.p, mod.Y, 1))[mod.p + 1 : ,]
        iXX = invpd(Data'Data)
    endif

    if 0
        # print a few parameters so we don't screw up with lags etc.
        safetycheck1(mod.Sigma, iXX, B)
    endif

    #
    # prepare the output array and other auxiliary stuff
    #

    bundles drawn = array(0)
    good = 0
    iter = 1

    # how many shocks are to be identified via sign restrictions?
    matrix shocks = values(mod.SRest[,6])
    nshocks = rows(shocks)
    matrices Ais = prepAis(mod, shocks)

    # do we have exotic restrictions?
    n_exotic = get_n_exotic(mod)

    # responses to be cumulated?
    to_cum = mod.ncumul ? mod.cumul : {}

    #
    # the main loop
    #

    bundle b = defbundle("B",B, "Sigma",mod.Sigma, "detterms",rows(mod.mu), \
               "df", mod.T - nelem(B))

    loop while good<rep && iter<=maxiter --quiet

        rot_redraw(&b, mod, DO_BAYES, B, iXX) # b.rot, b.B, b.Sigma 
        matrices irfs = gen_irfs(b, horizon, to_cum)
        matrix id_matrix = get_id_mat(mod, shocks, nshocks, irfs, Ais, DO_NORM)

        chk = DO_NORM ? (rows(id_matrix) == nshocks) : 0 # this check 1st!
        chk = chk && check_id(id_matrix)

        if chk
            # perform the "reflection-permutation" step
            loop i = 1..nelem(irfs) --quiet
                irfs[i] = irfs[i] * id_matrix'
            endloop

            # --- now check for exotic restrictions if necessary -------
            if n_exotic
                loop i = 1..n_exotic --quiet
                    string exo_restrict = mod.exoticSR.checks[i]
                    scalar ini = mod.exoticSR.spans[i,1]
                    scalar fin = mod.exoticSR.spans[i,2]
                    scalar needs_model = mod.exoticSR.super[i]

                    out = 0
                    loop t = ini..fin --quiet
                        matrix M = irfs[t] # hardcoded "M" for the API!
                        if needs_model
                            exocheck = feval(exo_restrict, M, mod)
                        else
                            exocheck = @exo_restrict
                        endif

                        if !exocheck
                            chk = 0
                            out = 1
                            if 0
                                printf "Exotic check %s failed on M[%d]:\n", \
                                       exo_restrict, t-1
                                printf "%7.4f\n", M
                            endif
                            break
                        endif
                    endloop
                    if out
                        break
                    endif
                endloop
            endif

            if chk
                good++

                b.irfs = irfs
                drawn += b
            endif
        else
            # print id_matrix
            # printf "No luck this time\n"
        endif

        factor = (DO_BAYES ? 10 : 50) * xmax(1,floor(sqrt(maxiter/1000)))

        if iter % factor == 0
            printf "draw %5d done (good so far = %5d)\n", iter, good
            flush
        endif
        iter++
    endloop

    if good < rep
        printf "\n\nWARNING: COULDN'T ACHIEVE THE DESIRED NUMBER OF DRAWS"
        printf " (only %d out of %d)\n", good, rep
    else
        printf "draw %5d done (good = %5d)\n", iter-1, good
    endif

    return drawn
end function

###
### plotting functions
###

function void SVAR_spagplot(bundles bs, bundle mod, scalar Var, scalar Shk)
    # one_irf = bs[1].irfs
    rep = nelem(bs)
    h = mod.horizon

    matrix IRFs = zeros(h + 1, rep) ~ seq(0, h)'

    loop i = 1..rep --quiet
        IRFs[,i] = drill(bs[i].irfs, Var, Shk)
    endloop

    plot IRFs
        option with-lines
        #    literal set linetype cycle 4
        literal set linetype 1 lc rgb "#000000" lw 0.1
        literal set linetype 2 lc rgb "#000000" lw 0.1
        literal set linetype 3 lc rgb "#000000" lw 0.1
        literal set linetype 4 lc rgb "#000000" lw 0.1
        literal set linetype 5 lc rgb "#000000" lw 0.1
        literal set linetype 6 lc rgb "#000000" lw 0.1
        literal set linetype 7 lc rgb "#000000" lw 0.1
        literal set linetype 8 lc rgb "#000000" lw 0.1
        literal set xlabel 'lags'
        literal set nokey
        printf "set title '%s -> %s'\n", mod.snames[Shk], mod.Ynames[Var]
    end plot --output=display
end function


function bundle IRF_plotdata(bundles bs, scalar alpha[0.9])

    # here we store the data for plotting the irfs in a matrix, conceptually
    # similar to the "bands" matrix we use in SVAR_boot, that is with H rows
    # (so that descriptive statistics are easy to compute) and ns * nv *
    # horizon columns

    # get dimensions
    H = nelem(bs)    # number of available (accepted) draws
    nvXns = rows(bs[1].Sigma) * cols(bs[1].irfs[1])
    h = nelem(bs[1].irfs)
    # ns = cols(bs[1].irfs[1])
    matrix A = zeros(H, nvXns * h)
    
    loop i = 1..H --quiet
        matrices irfs = bs[i].irfs
        matrix sel = seq(1, nvXns * h, h)

        loop t = 1..h --quiet
            # compute the relevant IRFs
            # and store them in the appropriate column
            A[i, sel] = vec(irfs[t])'     # was: b.irfs
            sel += 1
        endloop
    endloop

    matrix m = meanc(A)	# point-wise means
    matrix s = sdc(A)

    # output bundle (H: num of [accepted] replications) 
	# (leave out ret.raw = A)
    bundle ret = defbundle("rep",H, "alpha",alpha, "biascorr",0)
    matrix ret.irfSRmeans  = mshape(m, h, nvXns)
    matrix ret.irfSRserrs  = mshape(s, h, nvXns)

    # point-wise pseudo confidence bands (ripped from SVAR_boot)
    q_alpha = 0.5 * (1 - alpha)
    matrix locb = quantile(A, q_alpha)
    matrix hicb = quantile(A, 1 - q_alpha)
    matrix mdn  = quantile(A, 0.5)

    matrix ret.lo_cb     = mshape(locb, h, nvXns)
    matrix ret.hi_cb     = mshape(hicb, h, nvXns)
    matrix ret.irfSRmeds = mshape(mdn, h, nvXns)

    return ret
end function
