function void doIRF(bundle *SVARobj)
/*
   constructs the structural VMA representation. Note
   that the companion matrix is never used explicitely;

   The output is not returned by the function, but rather
   put into the bundle under the "IRFs" key.
    */
    scalar type = SVARobj.type
    matrix varA = SVARobj.VARpar
    scalar H = SVARobj.horizon + 1
    scalar n = SVARobj.n

    if (type == 1) || (type == 2) || (type == 4)
        matrix C = SVARobj.C	# was: SVARobj.S1
    elif type == 3
        if inbundle(SVARobj, "C")	# maybe not yet computed
            matrix C = SVARobj.C
        else
            matrix C = SVARobj.S1 \ SVARobj.S2
        endif
    endif

    matrix ret = zeros(H,n*n)
    scalar np = SVARobj.p * n
    matrix tmp = I(np)
    matrix prd = zeros(np,np)

    loop i=1..H --quiet
        ret[i,] = vec(tmp[1:n,1:n] * C)'
        if (np>n)
            prd[n+1:np, ] = tmp[1:np-n, ]
        endif
        prd[1:n,] = varA * tmp
        tmp = prd
    endloop

    if SVARobj.ncumul > 0
        # The following code is now done in SVAR_cumulate
        # once and for all:
        # matrix to_cum = SVARobj.cumul
        # tmp = zeros(n,n)
        # tmp[to_cum,] = 1
        # sel = selifr(transp(seq(1,n*n)), vec(tmp))
        ret[, SVARobj.cumsel] = cum(ret[, SVARobj.cumsel]) # .cumsel was sel
    endif

    matrix SVARobj.IRFs = ret
end function

##############

function matrix FEVD(bundle *SVARobj)
    n = SVARobj.n
    h = SVARobj.horizon + 1

    if !inbundle(SVARobj, "IRFs")
        # Could be missing e.g. in set-id models
        funcerr "Need .IRFs in model bundle"
    endif

    matrix ret = zeros(h, n*n)
    ctmp = cum(SVARobj.IRFs .* SVARobj.IRFs)

    loop i = 1..h --quiet
        tmp = mshape(ctmp[i,],n,n)'
        ret[i,] = vec(tmp ./ sumc(tmp))'
    endloop

    return ret
end function


### The function GetShock() isn't called anywhere, but it's public and
### meant to be used by the user.

function series GetShock(bundle *SVARobj, int i[1::1], int drawix[0::0])
    /*
    Produces the series corresponding to the historical shock 
    realizations associated with the point estimates of the model
    (and IRFs).
    For set identification (sign restrictions) there is no point
    estimate; however, we support that 
    the user picks one of the accepted draws and then the shock series 
    is based on that particular model draw.
    */

    series ret = NA
    type = SVARobj.type
	if type > 4 && type != 10
        printf "Given type %d\n", type
        funcerr "Unknown model type"

    elif type == 10 
        if !SVARobj.storeSRirfs
            funcerr "Need accepted draws content (acc_draws) in set-id case"
        elif drawix == 0
            funcerr "Need to pick one particular draw (index)"
        elif drawix > nelem(SVARobj.acc_draws)
            printf "Only %d accepted draws exist\n", nelem(SVARobj.acc_draws) 
            funcerr "Draw index out of range"
        endif

    elif drawix > 0
        print "Warning: 'drawix' meaningless for standard SVAR, ignoring"

   elif i > SVARobj.n
        printf "Chosen shock index: %d\n", i
        funcerr "Shock index out of range"
    endif

    if (type == 1) || (type == 2) || (type == 4)
        matrix C = SVARobj.C 

    elif type == 3
        if inbundle(SVARobj, "C")	# maybe not yet computed
            matrix C = SVARobj.C
        else
            matrix C = SVARobj.S1 \ SVARobj.S2
        endif

    elif type == 10 # set id 
        matrix C = SVARobj.acc_draws[drawix].irfs[1] # impact effect is C
    endif

    matrix iC = inv(C')
    extra = $nobs - rows(SVARobj.E)
    if extra > 0
        set warnings off
        matrix tmp = ones(extra,1) .* NA
    else
        matrix tmp = {}
    endif
    tmp |= SVARobj.E * iC[,i]
    ret = tmp

    snames = SVARobj.snames # strings array?
    string vlab = snames[i]

    setinfo ret --description="@vlab"

    return ret
end function

#######################

function list SVAR_hd(bundle *Mod, int nv[1::1])

    list ret = null
    loop foreach i n p t1 t2 type --quiet
        scalar $i = Mod.$i
    endloop

    if type > 4
        funcerr "Not implemented for set id (sign restrictions)" 
    endif

    if nv > n
        printf "Hm. There are %d variables in the model. ", n 
        printf "Chosen shock index: %d\n", nv
        funcerr "Shock index out of range"
    endif

    # compute the exogenous part
    if type < 4
        matrix m = Mod.X * Mod.mu

    elif type == 4
        # here we have to take into account the "5 cases"
        dcase = Mod.jcase
        T     = Mod.T
        matrix mreg = (dcase == 1) ? {} : ones(T,1)
        if dcase > 3
            mreg ~= seq(1,T)'
        endif

        matrix m = (mreg ~ Mod.X) * Mod.mu
    endif

    matrix E = Mod.E
    matrix VARpar = Mod.VARpar
    if (type == 1) || (type == 2) || (type == 4)
        matrix C = Mod.C
    elif type == 3
        if inbundle(Mod, "C")
            matrix C = Mod.C
        else
            matrix C = Mod.S1 \ Mod.S2
        endif
    endif

    matrix iC = inv(C)
    strings Ynames = Mod.Ynames
    strings snames = Mod.snames
    string yn = Ynames[nv]

    smpl t1 t2
    if cols(m)>0
        Xdet = varsimul(VARpar, m[p+1:,], Mod.Y[1:p,])
    else
        Xdet = varsimul(VARpar, zeros(Mod.T-p,n), Mod.Y[1:p,])
    endif

    ret += genseries( sprintf("hd_%s_det", yn), Xdet[,nv])

    # the structural shocks
    matrix U = E * iC'
    rotVARpar = iC * Mod.VARpar * (I(p) ** C)

    loop i=1..n --quiet
        a = (seq(1,n) .= i)
        W = varsimul(rotVARpar, U .* a, zeros(p,n)) * C'
        ret += genseries(sprintf("hd_%s_%s", yn,
				 fixname(snames[i])), W[,nv])
    endloop

    return ret
end function
