include SVAR_compatibility_funcs.inp # for basename()

###########################

function scalar range(int a, int n, scalar *n0, scalar *n1)
    # this is used in the plotting function to have
    # 0 as a synonym for "all"
    #
    # The flipping of the shock by passing a negative number
    # is then not possible to specify; users have to do it explicitly
    # in their own loop then.
    #
    # (n0 and n1 are integers, too, but gretl doesn't accept 
    #   pointerized integers)

    if a != 0
        ret = 0
        n0 = a
        n1 = a
    else
        ret = 1
        n0 = 1
        n1 = n
    endif
    return ret
end function

# ---------------------------

function scalar max_eval(const matrix A)
    n = rows(A)
    p = cols(A) / n
    matrix compan = (p==1) ? A : A | (I(n*(p-1)) ~ zeros(n*(p-1), n))
    # TODO: eventually replace this with "eigen" (but needs 2020b or so):
    matrix lambda = eigengen(compan) # deprecated 
    scalar maxmod = maxc(sumr(lambda.^2))
    return maxmod
end function

/* ------------------------------------------------------------------ */

function list determ(const list X, bool cnst, bool trnd, bool seas)
    list ret = cnst ? const : null

    if trnd
        ret += time
    endif

    if seas
        ret += seasonals(0, 1) # centered
    endif

    # stick together deterministics and other exog.
    ret = ret || X
    return ret
end function


function matrix vecm_det(int T, int dcase)
    # build the deterministic matrix for the VECM; if alpha is
    # empty, it will be estimated via ols later

    # deterministics
    # note that in the "even cases" (restr. const or trend)
    # the restricted term is _not_ included in x, since its
    # parameter will be recovered later via alpha*beta

    matrix mreg = (dcase < 3) ? {} : ones(T,1)
    if dcase == 5
        matrix mreg ~= seq(1,T)'
    endif

    return mreg
end function

#################

function matrix N2_ify(const matrix A)
    n2 = rows(A)
    n = int(sqrt(n2))
    k = cols(A)
    matrix e = vec(transp(mshape(seq(1,n2),n,n)))
    return A + A[e,1:k]
end function

function scalar has_unit_diag(const matrix Rd)
    ret = 0
    n2 = cols(Rd) - 1
    n = sqrt(n2)
    matrix test = transp(seq(0,n2-1)) .= seq(0,n2-1,n+1)
    test |= ones(1,n)

    matrix e
    mols(test, Rd', &e)

    return maxr(sumc(e.*e)) < 1.0e-12 # ret
end function

function scalar has_free_diag(const matrix Rd)
    n2 = cols(Rd) - 1
    n = sqrt(n2)
    matrix e = 1 + seq(0,n2-1,n+1)
    matrix test = Rd[,e]
    return ( sumc(abs(test)) < 1.0e-12 ) # ret
end function

function matrix mat_exp(const matrix theta, const matrix Ss)
    # we don't check for conformability, but
    # cols(Ss) should be equal to rows(theta)+1

    n2 = rows(Ss)
    n = int(sqrt(n2))
    k = cols(Ss) - 1
    matrix C = (k>0) ? ( Ss[,1:k]*theta + Ss[,k+1] ) : Ss

    return mshape(C,n,n)
end function

function void unscramble_dat(matrix *dat, matrix *Sigma, matrix *Ss)
    n2 = rows(dat)
    n = int(sqrt(n2))
    k = cols(dat)

    Sigma = mshape(dat[,1],n,n)
    Ss = dat[,2:k]
end function


function void maybe_flip_columns(const matrix C, matrix *X)
/*
   the objective here is to make X as similar as possible to C
   by flipping the sign of the columns. Used for bootstrapping,
   to have IRFs with comparable signs.
    */
    n = rows(C)
    matrix sel = seq(1,n)
    matrix plus = sumc((C + X).^2)
    matrix minus = sumc((C - X).^2)

    matrix flip = plus .< minus
    if sumr(flip) > 0
        sel = selifc(sel, flip)
        X[,sel] = -X[,sel]
    endif
end function

function void printStrMat(const matrix X, matrix V, string name)
    n = rows(X)
    matrix x = vec(X)

    matrix cfse = vec(X)
    matrix se = sqrt(diag(V))

    matrix numzero = selifr(seq(1,rows(se))', (se .< 1.0e-15))
    if rows(numzero) > 1
        se[numzero] = 0.0
    endif

    cfse ~= se
    string parnames = ""

    loop j=1..n --quiet
        loop i=1..n --quiet
            # sprintf tmpstr "%s[%2d;%2d]", name, i, j
            # parnames += tmpstr
            parnames += sprintf("%s[%2d;%2d]", name, i, j)
            if (j<n) || (i<n)
                parnames += ","
            endif
        endloop
    endloop

    modprint cfse parnames
end function


# --------------------------
/* This function was called smash_unstable_roots(),
   renamed because its name was misleading (to Sven at least).
   The new name contains 'add' because the Psi input is added
   to the A input.
*/
function scalar add_and_smash(matrix *A, const matrix Psi)
    # Note that Psi here seems to correspond to -\Psi 
    # in Kilian (1998)! That's why it's added.

    matrix Ab = A + Psi
    # now check stationarity
    scalar maxmod = max_eval(Ab)

    h = 0.99
    H = 1
    maxiter = 1000
    iter = 0
    loop while (maxmod > 0.9999) && (iter < maxiter) --quiet
        iter++
        H *= h
        Ab = A + H .* Psi
        maxmod = max_eval(Ab)
    endloop

    A = Ab
    return (iter >= maxiter) ? NA : H
end function
