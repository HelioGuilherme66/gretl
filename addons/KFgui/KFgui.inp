### --------------------------------------------------
### Private functions
### --------------------------------------------------

function scalar handle_vars (bundle *mod,
                             matrix param,
                             scalar type,
                             scalar n,
                             scalar k,
                             bool has_obsvar)

   # inject parameters into variance matrices,
   # taking into account the the variance for the
   # observation equation shock may be 0

   err = 0 # for future use, maybe?
   if type==1   # variance
      if has_obsvar
         mod.obsvar[diag] = abs(param[1:n])
         mod.statevar[diag] = abs(param[n+1:n+k])
      else
         mod.statevar[diag] = abs(param[1:k])
      endif
   elif type==2 # st. dev.
      if has_obsvar
         mod.obsvar[diag] = param[1:n].^2
         mod.statevar[diag] = param[n+1:n+k].^2
      else
         mod.statevar[diag] = param[1:k].^2
      endif
   elif type==3 # log(stdev)
      err = maxc(param) > 20
      if has_obsvar
         mod.obsvar[diag] = exp(2 * param[1:n])
         mod.statevar[diag] = exp(2 * param[n+1:n+k])
      else
         mod.statevar[diag] = exp(2 * param[1:k])
      endif
   endif

   return err
end function

function void fix_parametrization(matrix *coeff,
                                  matrix *vcv,
                                  scalar type)

   if type == 1   # variance
      coeff = sqrt(abs(coeff))
      vcv = 0.25 * vcv ./ (coeff * coeff')
   elif type == 2 # std. dev
      coeff = abs(coeff)
   elif type == 3 # exp
      coeff = exp(coeff)
      vcv = vcv .* (coeff * coeff')
   endif
end function

function void printout(bundle ret)

   n = ret.n
   k = ret.k
   ini = 1
   fin = k
   if ret.has_obsvar
      printf "\nObservation equation\n"
      strings pnames = array(n)
      loop i = 1 .. n
         pnames[i] = sprintf("stdev[%d]", i)
      endloop
      cs = ret.coeff[1:n] ~ sqrt(diag(ret.vcv)[1:n])
      modprint cs pnames
      printf "\n"
      ini += n
      fin += n
   endif

   printf "State transition equation\n"
   strings pnames = array(k)
   loop i = 1 .. k
      pnames[i] = sprintf("stdev[%d]", i)
   endloop
   cs = ret.coeff[ini:fin] ~ sqrt(diag(ret.vcv)[ini:fin])
   modprint cs pnames


end function

### --------------------------------------------------
### Public function
### --------------------------------------------------

function bundle KFgui (list X "observables",
                       matrix H "Observation matrix",
                       matrix F "State transition matrix",
                       bool has_obsvar[0] "Disturbance in obs. equation?",
                       int param_type[1:3:2] "Parametrization" {"Absolute value", "Square", "Exponential"},
                       int verbosity[0:2:1] "verbosity" {"Quiet", "Normal", "Verbose"},
                       bool smooth[1] "do smoothing")

   scalar n = nelem(X)
   bundle ret = null
   scalar k = rows(H)
   if ( rows(F) != k ) || ( cols(F) != k ) || (cols(H) != n)
      printf "Error: the system matrices are incorrectly sized (k=%d, n=%d)\m", k, n
      ret.err = 37
      return ret
   endif

   bundle ret = defbundle("n", n, "k", k, "has_obsvar", has_obsvar)

   bundle kmod = ksetup(X, H, F, I(k) .* 0.1)
   kmod.inivar = 1.0e4 * I(k)
   npar = has_obsvar ? n+k : k
   matrix param = ones(npar, 1)

   if verbosity == 2
      setopt mle --verbose
   endif

   matrix kmod.statevar = I(k)
   if has_obsvar
      matrix kmod.obsvar = I(n)
   endif

   # do the maximization

   set bfgs_richardson on
   series ll = NA
   catch mle llik = ll
      ERR = handle_vars(&kmod, param[1: npar], param_type, n, k, has_obsvar)
      ERR = ERR || kfilter(&kmod)
      ll = ERR ? NA: kmod.llt
      params param
   end mle --hessian --quiet

   ret.err = $error
   if !ret.err
      if smooth
         ksmooth(&kmod)
      endif
      ret.kmod = kmod
      coeff = $coeff
      vcv = $vcv
      fix_parametrization(&coeff, &vcv, param_type)
      ret.coeff = coeff
      ret.vcv = vcv
      ret.state = kmod.state
      if verbosity > 0
         printout(ret)
      endif
   endif

   return ret
end function
