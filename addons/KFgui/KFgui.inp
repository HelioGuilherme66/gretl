### --------------------------------------------------
### Private functions
### --------------------------------------------------

function scalar handle_vars (bundle *mod,
                             matrix param,
                             scalar type,
                             scalar n,
                             scalar k,
                             bool has_obsvar)

   # inject parameters into variance matrices,
   # taking into account the the variance for the
   # observation equation shock may be 0

   err = 0 # for future use, maybe?
   if type==1   # variance
      if has_obsvar
         mod.obsvar[diag] = abs(param[1:n])
         mod.statevar[diag] = abs(param[n+1:n+k])
      else
         mod.statevar[diag] = abs(param[1:k])
      endif
   elif type==2 # st. dev.
      if has_obsvar
         mod.obsvar[diag] = param[1:n].^2
         mod.statevar[diag] = param[n+1:n+k].^2
      else
         mod.statevar[diag] = param[1:k].^2
      endif
   elif type==3 # log(stdev)
      err = maxc(param) > 20
      if has_obsvar
         mod.obsvar[diag] = exp(2 * param[1:n])
         mod.statevar[diag] = exp(2 * param[n+1:n+k])
      else
         mod.statevar[diag] = exp(2 * param[1:k])
      endif
   endif

   return err
end function

function void fix_parametrization(matrix *coeff,
                                  matrix *vcv,
                                  scalar type)

   if type == 1   # variance
      coeff = sqrt(abs(coeff))
      vcv = 0.25 * vcv ./ (coeff * coeff')
   elif type == 2 # std. dev
      coeff = abs(coeff)
   elif type == 3 # exp
      coeff = exp(coeff)
      vcv = vcv .* (coeff * coeff')
   endif
end function

function void KFgui_print (bundle *b)
   n = b.n
   k = b.k
   ini = 1
   fin = k
   if b.has_obsvar
      printf "\nObservation equation\n"
      strings pnames = array(n)
      loop i = 1..n
         pnames[i] = sprintf("stdev[%d]", i)
      endloop
      cs = b.coeff[1:n] ~ sqrt(diag(b.vcv)[1:n])
      modprint cs pnames
      printf "\n"
      ini += n
      fin += n
   endif

   printf "State transition equation\n"
   strings pnames = array(k)
   loop i = 1..k
      pnames[i] = sprintf("stdev[%d]", i)
   endloop
   cs = b.coeff[ini:fin] ~ sqrt(diag(b.vcv)[ini:fin])
   modprint cs pnames
end function

function scalar check_sizes(scalar n, scalar k, matrix T, matrix Z)
    err = 0
    if cols(T) != k
	printf "ERROR: The state transition matrix isn't square\n"
	printf "%6.1f\n", T
	err = 37
    elif rows(Z) != k
	printf "ERROR: The rows of the Z matrix don't match the number of states (%d)", k
	printf "%6.1f\n", Z
	err = 37
    elif cols(Z) != n
	printf "ERROR: The columns of the Z matrix don't match the number of series (%d)", n
	printf "%6.1f\n", Z
	err = 37
    endif

    return err
end function


### --------------------------------------------------
### Public functions
### --------------------------------------------------

function bundle KFgui (list y "observables",
                       matrix Z "Observation matrix",
                       matrix T "State transition matrix",
                       bool has_obsvar[0] "Disturbance in obs. equation?",
                       int param_type[1:3:2] "Parametrization" {"Absolute value", "Square", "Exponential"},
                       int verbosity[0:2:1] "verbosity" {"Quiet", "Normal", "Verbose"},
                       bool smooth[1] "do smoothing")

   scalar n = nelem(y)
   bundle ret = null
   scalar k = rows(T)
   ret.err = check_sizes(n, k, T, Z)
   if ret.err
      return ret
   endif

   bundle ret = _(n, k, has_obsvar)

   bundle kmod = ksetup(y, Z, T, I(k) .* 0.1)
   kmod.inivar = 1.0e4 * I(k)
   npar = has_obsvar ? n+k : k
   matrix param = ones(npar, 1)

   if verbosity == 2
      setopt mle --verbose
   endif

   matrix kmod.statevar = I(k)
   if has_obsvar
      matrix kmod.obsvar = I(n)
   endif

   # do the maximization

   set bfgs_richardson on
   series ll = NA
   catch mle llik = ll
      ERR = handle_vars(&kmod, param[1: npar], param_type, n, k, has_obsvar)
      ERR = ERR || kfilter(&kmod)
      ll = ERR ? NA: kmod.llt
      params param
   end mle --hessian --quiet

   ret.err = $error
   if !ret.err
      if smooth
         ksmooth(&kmod)
      endif
      ret.kmod = kmod
      matrix coeff = $coeff
      matrix vcv = $vcv
      fix_parametrization(&coeff, &vcv, param_type)
      ret.coeff = coeff
      ret.vcv = vcv
      ret.state = kmod.state
      if verbosity > 0
         KFgui_print(&ret)
      endif
   else
      printf "Filtering failed:\n%s\n", errmsg(ret.err)
   endif

   return ret
end function

function void KFgui_plot (bundle *b)
   matrix P = b.kmod.obsy ~ b.kmod.state

   if cols(b.kmod.obsy) == 1 && cols(b.kmod.state) == 1
      cnameset(P, "y state")
   else
      strings S = array(cols(y) + cols(state)
      loop i=1..cols(y)
         S[i] = sprintf("y%d", i)
      endloop
      loop i=1..cols(state)
         S[i] = sprintf("state%d", i)
      endloop
      cnameset(P, S)
   endif

   gnuplot --matrix=P --time-series --with-lines --output=display
end function
