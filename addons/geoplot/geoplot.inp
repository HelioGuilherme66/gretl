function matrix get_bbox(const bundle jb)
    matrix ret = {}
    if inbundle(jb, "bbox")
        if typeof(jb.bbox) == 3
            # a matrix
            ret = jb.bbox
        else
            n = sscanf(jb.bbox, "%m", ret)
            ret = mshape(ret, 2, round(n/2))'
        endif
    endif
    return ret
end function

function matrix ring2matrix(const arrays ring)
    n = nelem(ring)
    matrix ret = zeros(2,n)
    m = {}
    loop i = 1 .. n
        ri = ring[i]
        sscanf(ri[1:2], "%m", m)
        ret[,i] = m
    endloop
    return ret'
end function

function matrix ring2matrix2(const matrices ring)
    n = nelem(ring)
    matrix ret = zeros(2,n)
    loop i = 1 .. n
        ri = ring[i]
        ret[,i] = ri[1:2]
    endloop
    return ret'
end function

function scalar polygon_area(const matrix XY)
    # taken from https://www.mathopenref.com/coordpolygonarea2.html
    scalar area = 0  # Accumulates area

    loop i = 2 .. rows(XY)
        a = XY[i-1,1] * XY[i, 2]
        b = XY[i,1] * XY[i-1, 2]
        area += (a-b)
    endloop
    return abs(area/2)
end function

function void polygon_extents(const matrix XY, matrix *minmax)
    loop i = 1 .. rows(XY)
        if XY[i,1] < minmax[1,1]
            minmax[1,1] = XY[i,1]
        endif
        if XY[i,1] > minmax[1,2]
            minmax[1,2] = XY[i,1]
        endif
        if XY[i,2] < minmax[2,1]
            minmax[2,1] = XY[i,2]
        endif
        if XY[i,2] > minmax[1,2]
            minmax[2,2] = XY[2,2]
        endif
    endloop
end function

function string describe_poly_coords(const arrays coar, matrix *extents[null],
                                     int verbose, int i)
    ext_ring = coar[1]
    if i > 0
        ret = sprintf("Exterior ring[%d]: %5d points ", i, nelem(ext_ring))
    else
        ret = sprintf("Exterior ring: %5d points ", nelem(ext_ring))
    endif
    if typeof(ext_ring[1]) == 3
        rm = ring2matrix2(ext_ring)
    else
        rm = ring2matrix(ext_ring)
    endif
    scalar area = polygon_area(rm)
    ret = ret ~ sprintf("(area = %12.3f)", area*1000)
    if verbose > 1
        if nelem(coar) == 1
            ret = ret ~ "; no interior rings"
        else
            ret = ret ~ sprintf("; %d interior rings", nelem(coar) - 1)
        endif
    endif
    if exists(extents)
        polygon_extents(rm, &extents)
    endif
    return ret
end function

function bundle create_ids(const bundle f, scalar n)
    bundle ret = null
    loop foreach i f
        key = "$i"
        t = typeof(f.$i)
        if t == 1
            # numeric
            matrix ret[key] = zeros(n, 1)
        elif t == 4
            # string
            strings ret[key] = array(n)
        endif
    endloop
    return ret
end function

function void fill_ids(const bundle f, bundle *ids, scalar featnum)
    loop foreach i ids
        key = "$i"
        if inbundle(f, key)
            ids[key][featnum] = f[key]
        else
            t = typeof(ids.$i)
            if t == 3
                ids[key][featnum] = NA
            elif t == 6
                ids[key][featnum] = ""
            endif
        endif
    endloop
end function

function void print_properties(const bundle f)
    loop foreach i f
        key = "$i"
        t = typeof(f.$i)
        printf "\t%20s: ", "$i"
        if t == 1
            printf "%g\n", f.$i
        elif t == 4
            printf "%s\n", f.$i
        else
            printf "type = %d???\n", t
        endif
    endloop
end function

function bundle describe_geojson (const bundle jb, int verbose[1])

    # as per RFC 7946, "The GeoJSON Format"

    bundle ret = null

    matrix bbox = get_bbox(jb)
    if rows(bbox) == 0
        printf "No bounding box\n"
    else
        printf "%d-dimensional bounding box\n", rows(bbox)
    endif
    ndim = rows(bbox)
    ret.bbox = bbox

    bundles feat = jb.features
    nf = nelem(feat)
    printf "%d features\n", nf
    ret.nf = nf

    bundle ids = null

    loop i = 1 .. nf
        fi = feat[i]

        if i == 1
            ids = create_ids(fi.properties, nf)
        endif

        props = fi.properties
        fill_ids(props, &ids, i)

        if verbose
            if inbundle(fi, "geometry")
                ft = fi.geometry.type
                printf "\n%4d: geometry type = %s, ", i, ft

                if inbundle(fi, "id")
                    if typeof(fi.id) == 1
                        printf "id (numeric) = %g\n", fi.id
                    elif typeof(fi.id) == 4
                        printf "id (string) = %s\n", fi.id
                    else
                        printf "id present, but of unknown type\n"
                    endif
                else
                    printf "no id\n"
                endif

                print_properties(props)
                matrix extents = {$huge, -$huge; $huge, -$huge}

                if ft == "Point"
                    printf "\t [ "
                    pc = fi.geometry.coordinates
                    loop j = 1 .. nelem(pc)
                        printf "%g", atof(pc[j])
                        if j == nelem(pc)
                            printf " ]"
                        else
                            printf ", "
                        endif
                    endloop
                    printf "\n"
                elif ft == "Polygon"
                    printf "\t%s\n", describe_poly_coords(fi.geometry.coordinates, &extents, verbose, 0)
                    printf "\tExtents: X = {%g,%g}; Y = {%g,%g}\n", extents[1,1], extents[1,2],
                      extents[2,1], extents[2,2]
                elif ft == "MultiPolygon"
                    mcoords = feat[i].geometry.coordinates
                    nmulti = nelem(mcoords)
                    printf "\t%d Sub-polygons\n", nmulti
                    if verbose > 1
                        loop j = 1 .. nmulti
                            printf "\t%s\n", describe_poly_coords(mcoords[j], &extents, verbose-1, j)
                        endloop
                        printf "\tExtents: X = {%g,%g}; Y = {%g,%g}\n", extents[1,1], extents[1,2],
                          extents[2,1], extents[2,2]
                    endif
                endif
            else
                printf "\tNo geometry (???)\n"
            endif
        endif
    endloop

    ret.ids = ids
    return ret
end function



