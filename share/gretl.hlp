#
add
@Tests
Add variables to a model and test for their significance

The selected variables will be added to the previous model and the new model
estimated.  If more than one variable is added the F statistic for the joint
significance of the added variables is printed (for the OLS procedure only)
along with its p-value.  A p-value below 0.05 means that the coefficients are
jointly significant at the 5 percent level.

#
adf
@Tests
Augmented Dickey-Fuller test

This command needs an integer lag order.

Computes statistics for two Dickey-Fuller tests.  In each case the null
hypothesis is that the variable in question exhibits a unit root.

The first is a t-test based on the model 

  (1 - L)x(t) = m + g * x(t-1) + e(t)

The null hypothesis is that g = 0.

The second (augmented) test proceeds by estimating an unrestricted regression
(with regressors a constant, a time trend, the first lag of the variable, and
"order" lags of the first difference) and a restricted version (dropping the
time trend and the first lag).  The test statistic is F, determined as

  [(ESSr - ESSu)/2]/[ESSu/(T - k)] 

where T is the sample size and k the number of parameters in the unrestricted
model.  Note that the critical values for these statistics are not the usual
ones.

#
ar
@Estimation
Generalized Cochrane-Orcutt (autoregressive) estimation

The procedure computes the estimates of a model using the generalized
Cochrane-Orcutt iterative procedure.  Iteration is terminated when successive
error sum of squares do not vary by more than 0.005 percent or when 20
iterations have been done.  

The "list of AR lags" specifies the structure of the error process.  For
example, the entry "1 3 4" corresponds to the process

     u(t) = rho1*u(t-1) + rho3*u(t-3) + rho4*u(t-4) + et

#
arch
@Tests
Test for ARCH (Autoregressive Conditional Heteroskedasticity)

This command needs an integer lag order.

Tests the model for ARCH of the specified order.  If the LM test statistic has
p-value below 0.10, then ARCH estimation is also carried out.  If the
predicted variance of any observation in the auxiliary regression is not
positive, then the corresponding uhat square is used instead.  Weighted least
square estimation is then performed on the original model.

#
arma
@Estimation
Univariate ARMA model

Calls X-12-ARIMA to estimate a univariate ARMA (Autoregressive, Moving
Average) model.  This command will work only if the X-12-ARIMA package for
gretl is installed.  See the gretl website, http://gretl.sourceforge.net, for
details.

#
boxplots
@Graphs
Exploratory data analysis

These plots (after Tukey and Chambers) display the distribution of a variable.
The central box encloses the middle 50 percent of the data, i.e. it is bounded
by the first and third quartiles.  The "whiskers" extend to the minimum and
maximum values.  A line is drawn across the box at the median.  

In the case of notched boxes, the notch shows the limits of an approximate 90
percent confidence interval.  This is obtained by the bootstrap method, which
can take a while if the data series is very long.

Clicking the mouse in the boxplots window brings up a menu which enables you
to save the plots as encapsulated postscript (EPS) or as a full-page
postscript file.  Under the X window system you can also save the window as an
XPM file; under MS Windows you can copy it to the clipboard as a bitmap.  The
menu also gives you the option of opening a summary window which displays
five-number summaries (minimum, first quartile, median, third quartile,
maximum), plus a confidence interval for the median if the "notched" option
was chosen.

Some details of gretl's boxplots can be controlled via a (plain text) file
named .boxplotrc which is looked for, in turn, in the current working
directory, the user's home directory (corresponding to the environment
variable HOME) and the gretl user directory (which is displayed and may be
changed under the File, Preferences, General menu).  Options that can be set
in this way are the font to use when producing postscript output (must be a
valid generic postscript font name; the default is Helvetica), the size of the
font in points (also for postscript output; default is 12), the minimum and
maximum for the y-axis range, the width and height of the plot in pixels
(default, 560 x 448), whether numerical values should be printed for the
quartiles and median (default, don't print them), and whether outliers (points
lying beyond 1.5 times the interquartile range from the central box) should be
indicated separately (default, no).  Here is an example:

font = Times-Roman
fontsize = 16
max = 4.0
min = 0
width = 400
height = 448
numbers = %3.2f
outliers = true

On the second to last line, the value associated with "numbers" is a "printf"
format string as in the C programming language; if specified, this controls
the printing of the median and quartiles next to the boxplot, if no "numbers"
entry is given these values are not printed.  In the example, the values will
be printed to a width of 3 digits, with 2 digits of precision following the
decimal point.

Not all of the options need be specified, and the order doesn't matter.  Lines
not matching the pattern "key = value" are ignored, as are lines that begin
with the hash mark, #.

After each variable specified in the boxplot command, a parenthesized boolean
expression may be added, to limit the sample for the variable in question.  A
space must be inserted between the variable name or number and the expression.
Suppose you have salary figures for men and women, and you have a dummy
variable GENDER with value 1 for men and 0 for women.  In that case you could
draw comparative boxplots with the following line in the boxplots dialog:

  salary (GENDER=1) salary (GENDER=0)

#
chow
@Tests
Chow test for structural homogeneity

This command needs an observation number (or date, with dated data).

Must follow an OLS regression.  Creates a dummy variable which equals 1 from
the specified split point to the end of the sample, 0 otherwise, and also
creates interaction terms between this dummy and the original independent
variables.  An augmented regression is run including these terms and an F
statistic is calculated, taking the augmented regression as the unrestricted
and the original as restricted.  This statistic is appropriate for testing the
null hypothesis of no structural break at the given split point.

#
coeffsum
@Tests
Test for the sum of certain coefficients

This command needs a list of variables, selected from the set of independent
variables in a given model.

Calculates the sum of the coefficients on the selected variables, and prints
this value along with its standard error and the p-value for the null
hypothesis that the sum is zero.

#
coint
@Tests
Cointegration test

The command (which needs an integer lag order) carries out Augmented
Dickey-Fuller tests on the null hypothesis that each of the selected variables
has a unit root, using the given lag order. The cointegrating regression is
estimated, and an ADF test is run on the residuals from this regression.  The
Durbin-Watson statistic for the cointegrating regression is also given.  (Note
that none of these test statistics can be referred to the usual statistical
tables.)

#
compact
@Dataset
Writing data to a lower frequency

When you add to a dataset a series that is of higher frequency, it is
necessary to "compact" the new series.  For instance, a monthly series will
have to be compacted to fit into a quarterly dataset.  

In addition, you may sometimes want to compact an entire dataset to a lower
frequency (perhaps, prior to adding a lower-frequency variable to the
dataset).

You are offered four options for compacting:

1. Averaging: The value written to the dataset will be the arithmetic mean of
   the relevant series values.  For instance the value written for the first
   quarter of 1990 will be the average of the values for January, February and
   March of 1990.

2. Summing: The value written to the dataset will be the sum of the relevant
   higher-frequency values.  For example, the first-quarter value will be the
   sum of the January, February and March values.

3. End-of-period values: The value written to the dataset is the last
   relevant value from the higher-frequency data.  For example, the first
   quarter of 1990 will get the March 1990 value.

4. Start-of-period values: The value written to the dataset is the first
   relevant value from the higher-frequency data.  For example, the first
   quarter of 1990 will get the January 1990 value.

In the case of compacting an entire dataset, the choice you make in this
dialog box sets the default method.  But if you have set a compaction method
for an individual variable (menu item "Variable/Edit attributes") that method
is used rather than the default.

#
corc
@Estimation
Cochrane-Orcutt model

This procedure computes the estimates of a model using the Cochrane-Orcutt
iterative procedure.  Iteration is terminated when successive rho values do
not differ by more than 0.001 or when 20 iterations have been done.  The final
transformed regression is performed for the observation range stobs+1 endobs
currently in effect.

#
dialog box for models
@Estimation

To select the dependent variable, highlight a variable in the list on the left
and press the "Choose" button pointing to the Dependent variable slot.  If you
check the "Set as default" box, the selected variable will be pre-selected as
dependent when the model dialog is next opened.  Short cut: double-click on a
variable on the left to select it as the dependent variable and set it as the
default.

To select independent variables, highlight them on the left and press the
"Add" button (or click the right mouse button).  You can highlight several
contiguous variables by dragging with the mouse.  You can highlight a group of
non-contiguous variables by clicking on them with the Ctrl key pressed.

#
diff
@Transformations
First differences

The first difference of each variable in the given list is obtained and the
result stored in a new variable with the prefix "d_".  Thus for instance the
new variables d_x = x(t) - x(t-1).

#
export
@Dataset
Export data from gretl to other formats  

You may export data in Comma-Separated Values (CSV) format: such data may be
opened in spreadsheets and many other application programs.

You may also export data in the native formats of GNU R or GNU octave.  For
further information on these programs (both of which support advanced
statistical analysis) please see their respective websites,
http://www.r-project.org/ and http://www.octave.org/

#
factorized plot
@Graphs
Plot with a dummy variable

This command requires the selection of three variables, the last of which must
be a dummy variable (values 1 or 0).  The Y variable is plotted against the X
variable, with the data points colored differently depending on the value of
the third.

Example: You have data on wages and educational attainment for a sample of
people; you also have a dummy variable with value 1 for men and 0 for women
(as in the supplied file data7-2).  A "factorized plot" of WAGE against EDUC
using the GENDER dummy as factor will show the data points for men in one
color and those for women in another (with a legend to identify them).

#
fcasterr
@Estimation
Forecasts with confidence intervals

After estimating a model via OLS you can print out predicted values over a
specified observation range, along with the estimated standard errors of those
predictions and 95 percent confidence intervals.  The prediction range is not
necessarily the same as the data range over which the model was estimated.

The standard errors are calculated in the manner described by Wooldridge in
chapter 6 of his Introductory Econometrics.  They incorporate two sources of
variation: the variance associated with the expected value of the dependent
variable, conditional on the given values of the independent variables, and
the variance of the regression residuals.

#
genr
@Transformations
Generate a new variable 

Usage:          newvarname = transformation

Creates new variables, usually through transformations of existing
variables. See also diff, logs, lags, ldiff, multiply and square for
shortcuts.

Supported arithmetical operators are, in order of precedence: ^
(exponentiation); *, / and % (modulus or remainder); + and -.  

Boolean operators (again in order of precedence) are ! (logical NOT), &
(logical AND), | (logical OR), >, <, = and != (NOT EQUALS).  The Boolean
operators can be used in constructing dummy variables: for instance (x > 10)
returns 1 if x(t) > 10, 0 otherwise.

Supported functions fall into these groups: 

Standard math functions: abs, cos, exp, int (integer part), ln (natural log:
log is a synonym), sin, sqrt.

Statistical functions: mean (arithmetic mean), median, var (variance), sd
(standard deviation), sum, cov (covariance), corr (correlation coefficient),
min (minimum), max (maximum) and sst (sum of squared deviations from the
mean).

Time-series functions: diff (first difference), ldiff (log-difference, or
first difference of natural logs).  To generate lags of a variable x use the
syntax "x(-N)" where 'N' is replaced by the desired lag length.  To generate
leads, use "x(+N)".

Miscellaneous: cum (cumulate), sort, uniform, normal, missing (return 1 if the
observation of the given variable is missing, otherwise 0), misszero (replace
the missing observation code with zero), zeromiss (inverse operation of
misszero).

All of the above functions with the exception of cov, corr, uniform and normal
take as their single argument either the name of a variable (note that you
can't refer to variable by their ID numbers in a genr command) or a composite
expression that evaluates to a variable (e.g.  ln((x1+x2)/2)).  cov and corr
both require two arguments, and return respectively the covariance and the
correlation coefficient between two named variables.  uniform() and normal(),
which do not take arguments, return pseudo-random series drawn from the
uniform (0-1) and standard normal distributions respectively (see also the
seed command).  

Various internal variables defined in the course of running a regression can
be used in transformations, as follows:

  $ess         error sum of squares
  $rsq         unadjusted R-squared
  $T           number of observations used for the model
  $df          degrees of freedom
  $trsq        TR^2 (sample size times R-squared)
  $sigma       standard error of residuals
  $lnl         log-likelihood (logit and probit models)
  coeff(var)   estimated coefficient for var
  stderr(var)  estimated std. error for var
  rho(i)       ith order autoregressive coefficient for residuals
  vcv(xi,xj)   covariance between coefficients for vars xi and xj

The internal variable $nobs holds the number of observations in the current
sample range, which may or may not equal the value of $T for the last model.

The internal variable $pd holds the periodicity or frequency of the data
(e.g. 4 for quarterly data).

The internal variable t references the observations, starting at 1.  Thus one
can do "genr dum15 = (t=15)" to generate a dummy variable with value 1 for
observation 15, 0 otherwise.

Examples of valid formulas:

   y = x1^3          [x1 cubed]           
   y=ln((x1+x2)/x3)  [composite argument to ln function]   
   z=x>y             [sets z(t) to 1 if x(t) > y(t) else to 0]
   y=x(-2)           [x lagged 2 periods]     
   y=x(2)            [x led 2 periods]
   y = mean(x)       [arithmetic mean]    
   y = diff(x)       [y(t) = x(t) - x(t-1)]
   y = ldiff(x)      [y = ln(x(t)) - ln(x(t-1))]
                      ldiff(x) is the instantaneous rate of growth of x.
   y = sort(x)       [sort x in increasing order and store in y]
   y = - sort(-x)    [sort x in decreasing order]
   y = int(x)        [truncate x and store its integer value as y]
   y = abs(x)        [store the absolute values of x]
   y = sum(x)        [sum x values excluding missing -999 entries]
   y = cum(x)        [cumulate x: y(t) is the sum of x up to t]
   aa = $ess         [aa = Error Sum of Squares from last regression]
   x = coeff(sqft)   [grab sqft coefficient from last model]
   rho4 = rho(4)     [grab 4th-order autoregressive coeff. from last
                      model (presumes an ar model)]
   cv=vcv(x1, x2)    [covariance of x1 and x2 coeffs. in last model]
   x=uniform()       [uniform pseudo-random variable, range 0 to 1]
   x=3*normal()      [normal pseudo-random var, mean 0, std. dev. 3]

Tips on dummy variables: 
* Suppose x is coded with values 1, 2, or 3 and you want three dummy
variables, d1 = 1 if x = 1, 0 otherwise, d2 = 1 if x = 2, and so on.  To
create these, use the formulas d1 = (x=1), d2 = (x=2), and d3 = (x=3).
* To get z = max(x,y) generate d=x>y and then z=(x*d)+(y*(1-d))

#
graphing
@Graphs
generating plots of various kinds

Gretl calls a separate program, namely gnuplot, to generate graphs.  Gnuplot
is a very full-featured graphing program with myriad options.  Gretl gives you
direct access, via a graphical interface, to a subset of these options and it
tries to choose sensible values for you; it also allows you to take complete
control over graph details if you wish.

With a graph displayed, you can click on the graph window for a pop-up menu
with the following options:

- Save as postscript (save the graph in encapsulated postscript [EPS] format)
- Save as PNG (save in Portable Network Graphics format)
- Save to session as icon (the graph will appear in iconic form when you
  select "Icon view" from the Session menu)
- Zoom (lets you select an area within the graph for closer inspection)
- Print (on the Gnome desktop only: lets you print the graph directly) 
- Copy to clipboard (MS Windows only: lets you paste the graph into
  Windows applications such as MS Word)
- Edit (opens a controller for the plot which lets you adjust various aspects
  of its appearance)
- Close (closes the graph window)

If you know something about gnuplot and wish to get finer control over the
appearance of a graph than is available via the graphical controller ("Edit"
option), you have two further options:

- Once the graph is saved as a session icon, you can right-click on its icon
  for a further pop-up menu.  One of the otions here is "Edit plot commands",
  which opens an editing window with the actual gnuplot commands displayed.
  You can edit these commands and either save them for future processing or
  send them to gnuplot (with the "File/Send to gnuplot" menu item in the plot
  commands editing window).

- Another way to save the plot commands (or to save the displayed plot in
  formats other than EPS or PNG) is to use "Edit" item on a graph's pop-up
  menu to invoke the graphical controller, then click on the "Output to file"
  tab in the controller.  You are then presented with a drop-down menu of
  formats in which to save the graph.

To find out more about gnuplot, see http://ricardo.ecn.wfu.edu/gnuplot.html or
http://www.gnuplot.info.

#
3-D plots
@Graphs
generating 3-D plots

This feature works best if you have gnuplot 3.8 or higher installed.  In that
case you can manipulate the 3-D plot with the mouse (rotate it, and expand or
shrink the axes).

In composing a 3-D plot, note that the Z-axis will be shown as the vertical
axis.  Thus if you have some dependent variable that you think may be
influenced by two independent variables, you should put the dependent variable
on the Z-axis, and the independent variable on the X and Y axes.  

Unlike most other gretl graphs, 3-D plots are controlled by gnuplot rather
than gretl itself.  The gretl graph-editing menu is not available.

#
hccm
@Estimation
Heteroskedasticity Consistent Covariance Matrix

This command runs a regression where the coefficients are estimated via the
standard ols procedure, but the standard errors of the coefficient estimates
are computed in a manner that is robust in the face of heteroskedasticity,
namely using the MacKinnon-White "jackknife" procedure.

#
hilu
@Estimation
Hildreth-Lu model

Computes the estimates of a model using the Hildreth-Lu search procedure (fine
tuned by the CORC procedure).  The error sum of squares of the transformed
model is graphed against the value of rho from -0.99 to 0.99.  The final
transformed regression is performed for the observation range stobs+1 endobs
currently in effect.

#
hsk
@Estimation
Heteroskedasticity-corrected estimates

An OLS regression is run and the residuals are saved.  The logs of the squares
of these residuals then become the dependent variable in an auxiliary
regression, on the right-hand side of which are the original independent
variables plus their squares.  The fitted values from the auxiliary regression
are then used to construct a weight series, and the original model is
re-estimated using weighted least squares.  This final result is reported.

The weight series is formed as 1/sqrt(exp(fit)), where "fit" denotes the
fitted values from the auxiliary regression.

#
label
@Dataset

In this dialog box you can:

* Rename a variable.

* Add or edit a description of the variable: this appears next to the variable
  name in the gretl main window.

* Add or edit the "display name" for the variable.  This string (maximum 19
  characters) is shown in place of the variable name when the variable is
  displayed in a graph.  This for instance you can associate a more
  comprehensible string such as "T-bill rate" with a cryptically named
  variable such as "tb3".

* (In case of a time-series dataset) set the compaction method for the
  variable.  This method will be used if you decide to reduce the frequency of
  the dataset, or if you update the variable by importing from a database
  where the variable is at a higher frequency than in the working dataset.

#
lad
@Estimation

Calculates a regression that minimizes the sum of the absolute deviations of
the observed from the fitted values of the dependent variable.  Coefficient
estimates are derived using the Barrodale-Roberts simplex algorithm; a
warning is printed if the solution is not unique.  Standard errors are
derived using the bootstrap procedure with 500 drawings.  

#
lags
@Transformations

Creates new variables which are lagged values of each of the variables in the
list supplied.  The number of lagged counterparts to each of the listed
variables equals the periodicity of the data.  For example, if the periodicity
is 4 (quarterly data), four lagged terms will be created; if the variable "x"
is in the supplied list, the command creates x_1 = x(t-1), x_2 = x(t-2), x_3 =
x(t-3) and x_4 = x(t-4).

#
ldiff
@Transformations

The first difference of the natural log of each variable in the supplied list
is obtained and the result stored in a new variable with the prefix "ld_".
Thus for instance the new variable ld_x = ln[x(t)] - ln[x(t-1)].

#
logistic
@Estimation
Logistic regression

Carries out an OLS regression using the logistic transformation of the
dependent variable, log(y/(ymax-y)).

The dependent variable must be strictly positive.  If it is a decimal
fraction, between 0 and 1, the default is to use a ymax value (the asymptotic
maximum of the dependent variable) of 1.  If the dependent variable is a
percentage, between 0 and 100, the default ymax value is 100.  You are
presented with a dialog box that allows you to specify a different maximum if
you wish.  The supplied ymax value must be greater than all of the observed
values of the dependent variable.

The fitted values and residuals from the regression are automatically
transformed using

                     y = ymax / (1 + exp(-x))

where x represents either a fitted value or a residual from the OLS regression
using the transformed dependent variable.  The reported values are therefore
comparable with the original dependent variable.

Note that if the dependent variable is binary, you should use the logit
command instead.

#
logit
@Estimation
Logit regression

The dependent variable should be a binary variable.  Maximum likelihood
estimates of the coefficients on indepvars are obtained via iterated least
squares (the EM or Expectation-Maximization method).  As the model is
non-linear the slopes depend on the values of the independent variables: the
reported slopes are evaluated at the means of those variables.  The Chi-square
statistic tests the null hypothesis that all coefficients are zero apart from
the constant.

#
logs
@Transformations

The natural log of each of the variables in the supplied list is obtained and
the result stored in a new variable with the prefix l_ which is "el"
underscore.  Thus for instance the new variable l_x = ln(x).

#
loop
@Programming
repeated commands

Usage:          loop number_of_times
                loop while condition
		loop for i=start..end
Examples:       loop 1000
		loop while essdiff > .00001
		loop for i=1991..2000

This (script) command opens a special mode in which the program accepts
commands to be repeated either a specified number of times, or so long as a
specified condition holds true, or for successive integer values of the
(internal) index variable i.  Within a loop, only 7 commands can be used:
genr, ols, print, sim, smpl, store and summary (store can't be used in a
"while" loop).  With genr and ols it is possible to do quite a lot.  You exit
the mode of entering loop commands with "endloop": at this point the stacked
commands are executed.  Loops cannot be nested.

The ols command gives special output, depending on the sort of loop.  If a
number of times is specified the results from each individual regression are
not printed, but rather you get a printout of (a) the mean value of each
estimated coefficient across all the repetitions, (b) the standard deviation of
those coefficient estimates, (c) the mean value of the estimated standard error
for each coefficient, and (d) the standard deviation of the estimated standard
errors.  This makes sense only if there is some random input at each step.
The command is designed for Monte Carlo analysis.  If a "while" condition is
given, you get a printout of the specified model from the last time round the
loop: this is designed for iterated least squares.

The print command also behaves differently in the context of a "number of
times" loop.  It prints the mean and standard deviation of the variable,
across the repetitions of the loop.  It is intended for use with variables
that have a single value at each iteration, for example the ess from a
regression.  The print command behaves as usual with the other loop
constructions.

The store command (use only one of these per loop, and only in a "number
of times" loop) writes out the values of the specified variables, from
each time round the loop, to the specified file.  Thus it keeps a complete
record of the variables.  This data file can then be read into the program
and analysed.

Example of loop code (Monte Carlo):

   genr x = 100 * uniform()
   loop 100
   genr u = normal()
   genr y = (10*x) + (20*u)
   ols y const x
   genr r2 = $rsq
   print r2
   genr a = coeff(const)
   genr b = coeff(x)
   store foo.gdt a b
   endloop
   
#
lmtest
@Tests
Lagrange Multiplier test

Under this heading fall several hypothesis tests.  What they have in common is
that the test involves the estimation of an auxiliary regression, where the
dependent variable is the residual from some "original" regression.  The
right-hand side variables include those from the original regression, along
with some additional terms.  The test statistic is calculated as (sample size
x Rsquared) from the auxiliary regression: this is distributed as Chi-square
with degrees of freedom equal to the number of additional terms, under the
null hypothesis that the additional terms have no explanatory power over the
residual.  A "large" Chi-squared value (small p-value) suggests that this null
hypothesis should be rejected.

#
markers
@Dataset
Add case markers to data set

This command needs the name of a file containing "case markers", that is,
short identifying strings for the individual observations in the data set (for
example, country or city names or codes).  These marker strings should be no
more than 8 characters long.  The file should contain one marker per line, and
there should be just as many markers as observations in the current dataset.
If these conditions are met and the specified file is found, the case markers
will be added; they will be visible when you choose "Display values" under
gretl's Data menu.

#
meantest
@Tests

Calculates the t statistic for the null hypothesis that the population means
are equal for two selected variables, and shows its p-value.  The command may
be called with or without the assumption that the variances are equal for the
two variables (although this will make a difference to the test statistic only
if there are different numbers of non-missing observations for the two
variables.)

#
missing values
@Dataset

Set a numerical value that will be interpreted as "missing" or "not
applicable", either for a particular data series (under the Variable menu) or
globally for the entire data set (under the Sample menu).  

Gretl has its own internal coding for missing values, but sometimes imported
data may employ a different code.  For example, if a particular series is
coded such that a value of -1 indicates "not applicable", you can select "Set
missing value code" under the Variable menu and type in the value "-1"
(without the quotes).  Gretl will then read the -1s as missing
observations.

#
model table
@Printing

In econometric research it is common to estimate several models with a common
dependent variable -- the models differing in respect of which independent
variables are included, or perhaps in respect of the estimator used.  In this
situation it is convenient to present the regression results in the form of a
table, where each column contains the results (coefficient estimates and
standard errors) for a given model, and each row contains the estimates for a
given variable across the models.

Gretl provides a means of constructing such a table (and copying it in plain
text, LaTeX or Rich Text Format).  Here is how to do it:

1. Estimate a model which you wish to include in the table, and in the model
   display window, under the File menu, select "Save to session as icon" or
   "Save as icon and close".

2. Repeat step 1 for the other models to be included in the table (up to a
   total of six models).

3. When you are done estimating the models, open the icon view of your gretl
   session (by selecting "icon view" under the Session menu in the main gretl
   window, or by clicking the "session icon view" icon on the gretl toolbar).

4. In session icon view, there is an icon labeled "Model table". Decide which
   model you wish to appear in the left-most column of the model table and add
   it to the table, either by dragging its icon onto the Model table icon, or
   by right-clicking on the model icon and selecting "Add to model table" from
   the pop-up menu.

5. Repeat step 4 for the other models you wish to include in the table.  The
   second model selected will appear in the second column from the left, and
   so on.

6. When you are finished composing the model table, display it by
   double-clicking on its icon.  Under the Edit menu in the window which
   appears, you have the option of copying the table to the clipboard in
   various formats.

7. If the ordering of the models in the table is not what you wanted,
   right-click on the model table icon and select "Clear table".  Then go back
   to step 4 above and try again.

#
mpols
@Estimation
  
Computes ordinary least squares estimates using multiple-precision arithmetic.
This command is available only if gretl is configured with support for GMP,
the GNU Multiple Precision library.  Note that the accuracy of the regression
results may be limited by (a) the precision of the data read from file, and
(b) any transformations carried out using the genr command, which operates
using ordinary double-precision floating-point arithmetic.

#
nls
@Estimation

Performs Nonlinear Least Squares (NLS) estimation using a modified version of
the Levenberg-Marquandt algorithm.  You must supply a function specification;
it is recommended that you also supply expressions for the derivatives of this
function with respect to each of the parameters if possible.

Example: Suppose we have a data set with variables C and Y
(e.g. greene11_3.gdt) and we wish to estimate a nonlinear consumption function
of the form

                         C = alpha + beta * Y^gamma

The parameters alpha, beta and gamma must first be added to the dataset and
given initial values.  This can be done using the genr command or via menu
choices.  Appropriate "genr" lines may be typed into the NLS specification
window prior to the function specification.

In the NLS window we type the following lines:

C = alpha + beta * Y^gamma
deriv alpha = 1
deriv beta = Y^gamma
deriv gamma = beta * Y^gamma * log(Y)

The first line specifies the regression function, and the next three lines
supply the derivatives of that function with respect to each of the parameters
in turn.  If the "deriv" lines are not given, a numerical approximation to the
Jacobian is computed.

If the parameters alpha, beta and gamma were not previously declared we could
preface the above lines with something like the following:

genr alpha = 1
genr beta = 1
genr gamma = 1

For further details on NLS estimation please see the gretl manual.

#
nulldata
@Dataset

Establishes a "blank" data set, containing only a constant, with periodicity 1
and the specified number of observations.  This may be used for simulation
purposes: some of the genr commands (e.g. genr uniform(), genr normal(), genr
time) will generate dummy data from scratch to fill out the data set.  The
nulldata command may be useful in conjunction with "loop".

#
ols
@Estimation
Ordinary Least Squares model

Computes ordinary least squares estimates of the coefficients for the
specified model.  Prints the p-values for t- (two-tailed) and F-statistics.  A
p-value below 0.01 indicates significance at the 1 percent level.  Model
selection statistics are also printed.

See /Topics/Estimation/dialog for help on using the model specification dialog
box.

#
omit
@Tests
Omit variables from a model and test for their joint significance

The selected variables are dropped from the previous model and the new model
estimated.  If more than one variable is omitted, the Wald F-statistic for the
omitted variables will be printed along with the pvalue for it (for the OLS
procedure only).  A pvalue below 0.05 means that the coefficients are jointly
significant at the 5 percent level.

#
online databases
@Dataset
Access databases via the internet

gretl is able to access databases at the gretl website, at Wake Forest
University (your computer must be connected to the internet for this to work).

Under the "File, Browse databases" menu, select the item "on database server".
A window should appear, showing a listing of the gretl databases available at
Wake Forest.  (Depending on your location and the speed of your internet
connection, this may take a few seconds.)  Along with the name of the database
and a short description, there will appear a "Local status" entry: this shows
whether you have the database installed locally (on the hard drive of your
computer) and if so, whether or not it is up to date with the version on the
server.

If you have a given database installed locally, and it is up to date, there is
no advantage in accessing it via the server.  But for a database that is not
already installed and up to date, you may wish to get a listing of the data
series: click on "Get series listing".  This brings up a further window, from
which you can display the values of a chosen data series, graph those values,
or import them into gretl's workspace.  These tasks can be accomplished using
the "Series" menu, or via the popup menu that appears when you click the right
mouse button on a given series.  You can also search the listing for a
variable of interest (the "Find" menu item).

If you want faster access to the data, or wish to access the database offline,
then select the line showing the database you want, in the initial database
window, and press the "Install" button.  This will download the database in
compressed format, then uncompress it and install it on your hard drive.
Thereafter you should be able to find it under the "File, Browse databases,
gretl native" menu.

(This feature in gretl depends on other free, open-source software projects:
the zlib data compression library, and the GNU "wget" downloader program, from
which chunks of gretl code are borrowed.)

#
panel
@Dataset
Register panel data structure

The two options here are "stacked time series" and "stacked cross sections".
Gretl must know which way your data are organized if you want to make use of
the "Pooled OLS" model command and its associated panel diagnostics.

Stacked time series means that the blocks in the data file take the form of
time series for each of the cross-sectional units in turn.  For example, the
first 10 rows of data might represent the values of certain variables for 
country A over 10 periods, the next 10 rows the values for country B over the
same 10 periods, and so on.

Stacked cross sections means that the blocks in the data file take the form of
cross sections for each of the time periods in turn.  For example, the first
6 rows of data might represent the values of certain variables for countries A
to F for the year 1970, the next 6 rows the values for the same countries in
1971, and so on.

If you save your data file after setting this attribute, the information will
be recorded in the data file and you won't have to set it again.  

Note that this menu item does not change the structure of your panel data set,
it simply fixes the interpretation of that structure on gretl's part.  If you
want to convert a panel data set currently in stacked cross section form to
stacked time series, use the menu item "Restructure panel".

#
pooled
@Estimation
Pooled OLS estimation

This command is for use with panel data.  To take advantage of it, you should
specify a model without any dummy variables representing cross-sectional
units.  The routine presents estimates for straightforward pooled OLS, which
treats cross-sectional and time-series variation at par.  This model may or
may not be appropriate.  Under the Tests menu in the model window, you will
find an item "panel diagnostics", which tests pooled OLS against the principal
alternatives, the fixed effects and random effects models.

The fixed effects model adds a dummy variable for all but one of the
cross-sectional units, allowing the intercept of the regression to vary across
the units.  An F-test for the joint significance of these dummies is
presented: if the p-value for this test is small, that counts against the null
hypothesis (that the simple pooled model is adequate) and in favor of the
fixed effects model.  

The random effects model, on the other hand, decomposes the residual variance
into two parts, one part specific to the cross-sectional unit or "group" and
the other specific to the particular observation.  (This estimator can be
computed only if the panel is "wide" enough, that is, if the number of
cross-sectional units in the data set exceeds the number of parameters to be
estimated.)  The Breusch-Pagan LM statistic tests the null hypothesis (again,
that the pooled OLS estimator is adequate) against the random effects
alternative.

It is quite possible that the pooled OLS model is rejected against both of the
alternatives, fixed effects and random effects.  How, then, to assess the
relative merits of the two alternative estimators?  The Hausman test (also
reported, provided the random effects model can be estimated) addresses this
issue.  Provided the unit- or group-specific error is uncorrelated with the
independent variables, the random effects estimator is more efficient than the
fixed effects estimator; otherwise the random effects estimator is
inconsistent, in which case the fixed effects estimator is to be preferred.
The null hypothesis for the Hausman test is that the group-specific error is
not so correlated (and therefore the random effects model is preferable).
Thus a low p-value for this test counts against the random effects model and
in favor of fixed effects.  

For a rigorous discussion of this topic, see Greene's Econometric Analysis
(4th edition), chapter 14.

#
probit
@Estimation
Probit regression

The dependent variable should be a binary variable.  Maximum likelihood
estimates of the coefficients on indepvars are obtained via iterated least
squares (the EM or Expectation-Maximization method).  As the model is
non-linear the slopes depend on the values of the independent variables: the
reported slopes are evaluated at the means of those variables.  The Chi-square
statistic tests the null hypothesis that all coefficients are zero apart from
the constant.

#
range-mean
@Graphs
Range-mean graph

This is a simple graph to help in deciding whether a time series, y(t), has
constant variance or not.  We take the full sample t=1,...,T and divide it
into small subsamples of arbitrary size k.  The first subsample is formed by
y(1),...,y(k), the second is y(k+1),...,y(2k), and so on.  For each subsample
we calculate the sample mean and range (= maximum-minimum), and we construct a
graph with the means on the horizontal axis and the ranges on the vertical.
So each subsample is represented by a point in this plane.  If the variance of
the series is constant we would expect the subsample range to be independent
of the subsample mean; if we see the points approximate an upward-sloping line
this suggests the variance of the series is increasing in its mean; and if the
points approximate a downward sloping line this suggests the variance is
decreasing in the mean.

Besides the graph, gretl displays an output window showing the means
and ranges for each subsample, along with the slope coefficient for an OLS
regression of the range on the mean and the p-value for the null hypothesis
that this slope is zero.  If the slope coefficient is significant at the 10
percent significance level then the fitted line from the regression of range
on mean is shown in the graph window.

#
rhodiff
@Transformations
Usage:         rhodiff rho varlist
Example:       rhodiff .65 2 3 4

Creates rho-differenced counterparts of the variables (given by number or by
name) in varlist and adds them to the data set.  Given variable v1 in the
list, rd_v1 = v1(t) - rho*v1(t-1) is created.

#
scatters
@Graphs
Multiple pairwise scatter plots

Draws a set of pairwise scatters of the selected "Y-axis variable" against
each of the selected "X-axis variables" in turn.  Scanning a set of such plots
can be a useful step in exploratory data analysis.  The maximum number of
plots is six; any extra variables in the X-axis list will be ignored.

#
seed
@Programming
Initialize the random number generator

Requires an integer as input.  Sets the seed for the pseudo-random number
generator used by the random uniform and random normal options under the Data,
Add variables menu.  By default the seed is set when the program is started,
using the system time.  If you want to obtain repeatable sequences of
pseudo-random numbers you need to set the seed manually.

#
setobs
@Dataset
Set data frequency and starting observation

Use this command to force the program to interpret the current data set as
time series or panel, when the data have been read in as simple undated
series.  Two parameters are needed: an integer frequency and a starting
observation string (usually a date).

Examples of valid input:

  4 1990.1       Interpret the data as quarterly, starting in 1990, Q1
  12 1978.03     Interpret the data as monthly, starting in March 1978
  20 1.01        Data frequency 20, starting with obs 1.01 (panel data)
  5 72/01/10     Daily data (5-day week), starting January 10, 1972
  7 02/01/10     Daily data (7-day week), starting January 10, 2002

#
sim
@Dataset
Put simulated values into a variable

This command requires the name of a variable (already present in the data set)
into which to put the values, and a list of autoregressive coefficients, which
may be either numerical constants or names of variables.  Optionally, a
starting and ending observation may be given before the variable name --
otherwise the simulation is over the current sample range.

For example, if you put into the simulation
dialog

    1979.2 1983.1 y 0 0.9

this will populate y, from 1979.2 to 1983.1, with values:

    y(t) = 0 + 0.9 * y(t-1)

Similarly

    15 25 y 10 0.8 x

will generate, from obs 15 to 25:

    y(t) = 10 + 0.8 * y(t-1) + x(t) * y(t-2)

The autoregressive coefficients may be prefixed with a minus sign, as in
"y 10 0.8 -x", which generates y(t) = 10 + 0.8 * y(t-1) - x(t) * y(t-2).

#
sampling
@Dataset

Select a sub-sample of the current data set.

If you choose "Sample/Define based on dummy..." you are prompted to select a
dummy (indicator) variable, which must have the values 0 or 1 at each
observation.  The sample will be restricted to observations for which the
dummy's value is 1.

If you choose "Sample/Restrict based on criterion..." you need to supply a
Boolean (logical) expression, of the same sort that you would use to define a
dummy variable.  For example the expression "sqft > 1400" will select only
cases for which the variable sqft has a value greater than 1400.  Conditions
may be concatenated using the logical operators "&" (AND) and "|" (OR), and
may be negated using "!" (NOT).

The menu item "Sample/Drop all obs with missing values" redefines the sample
to exclude all observations for which values of one or more variables are
missing (leaving only complete cases).  

To select observations for which a particular variable has no missing values,
use "Sample/Restrict based on criterion..." and supply the Boolean condition
"!missing(varname)".  

If the observations are named, you can re-sample to exclude a particular
observation using, say, obs!="France" as the Boolean criterion.  The
observation name must be enclosed in double quotes.

One point should be noted about defining a sample based on a dummy variable, a
Boolean expression, or on the missing values criterion: Any "structural"
information in the data header file (regarding the time series or panel nature
of the data) is lost.  You may reimpose structure with "Sample/Set frequency,
startobs...".

For simple re-setting of the sample by specifying a beginning and ending
observation, see "smpl" below.

#
smpl
@Dataset

Reset the sample range by specifying a starting and ending observation
(Sample/Set range...).  Use this mechanism for sub-sampling with time-series
data.  The given starting and ending observations should be in a form
consistent with the frequency of the data, e.g. "1985.1" for quarterly data or
"1996.03" for monthly (March 1996).  

#
spearman
@Statistics

Prints Spearman's rank correlation coefficient for a specified pair of
variables.  The variables do not have to be ranked manually in advance; the
function takes care of this.

The automatic ranking is from largest to smallest (i.e. the largest data value
gets rank 1).  If you need to invert this ranking, create a new variable which
is the negative of the original first.  For example:

  genr altx = -x
  spearman altx y

#
square
@Transformations

Generates new variables which are the squares of the variables in the given
list.  The new variables are named with the prefix "sq_", so for instance the
new variable sq_x = x squared.

#
store
@Dataset

Save a gretl dataset.  There are two options for the format of the saved
data.  

(1) "Standard": the data are saved gretl xml format.
(2) As above, but using gzip compression.  This saves disk space; it may be
    useful for large datasets. 

Note that if you wish to save the values of any scalars generated in a gretl
session (as opposed to data series), you should use the "store" command in the
gretl console window or a gretl script, and specify a list of variables to
save.

#
tsls
@Estimation
Two-Stage Least Squares

This command requires the selection of two lists of variables: the independent
variables to appear in the given model and a set of "instruments".  The latter
comprises the exogenous and/or predetermined variables that may be used as
regressors to derive fitted values for the right-hand side endogenous
variables.

If some of the right-hand side variables for the model are exogenous, they
should be referenced in both lists.

#
var
@Estimation
Vector Autoregression

This command requires specification of:

- the dependent variable for the first equation in the VAR system; 

- the lag order, that is, the number of lags of each variable that should be
  included in the system;

- any "deterministic" terms (e.g. the constant, a time trend, seasonal dummy
  variables and so on); and

- a list of independent variables, lags of which will be included on the
  right-hand side of the equations (note: do not include lagged variables
  in this list -- they will be added automatically).

A separate regression will be run for variable in the system.  Output for each
equation includes F-tests for zero restrictions on all lags of each of the
variables and an F-test for the maximum lag, along with forecast
variance decompositions and impulse response functions.  

The variance decompositions and impulse responses are based on the Cholesky
decomposition of the contemporaneous covariance matrix, and in this context
the order in which the (stochastic) variables are given matters.  The first
variable in the list is assumed to be "most exogenous" within-period.  

#
vartest
@Tests

Calculates the F statistic for the null hypothesis that the population
variances for the two selected variables are equal, and shows its p-value.

#
wls
@Estimation
Weighted Least Squares model

Let "wtvar" denote the variable selected in the "Weight variable" box.  An OLS
regression is run, where the dependent variable is the product of wtvar and
the selected dependent variable and the independent variables are also
multiplied by wtvar.  If wtvar is a dummy variable, this is equivalent to
eliminating all observations with the number zero for wtvar.

